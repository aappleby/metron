#ifndef METRO_BOY_SPU2_H
#define METRO_BOY_SPU2_H
#include "metron/metron_tools.h"

//------------------------------------------------------------------------------

class MetroBoySPU2 {
public:

  //----------------------------------------

  void tock_out() {
    logic<9> l;
    logic<9> r;

    l = 0;
    r = 0;

    if (s1_running_ && s1_env_vol_) {
      logic<1> s1_out = 0;
      switch(s1_duty_) {
        case 0: s1_out = s1_phase_ < 1; break;
        case 1: s1_out = s1_phase_ < 2; break;
        case 2: s1_out = s1_phase_ < 4; break;
        case 3: s1_out = s1_phase_ < 6; break;
      }
      if (mix_l1_ && s1_out) l = l + s1_env_vol_;
      if (mix_r1_ && s1_out) r = r + s1_env_vol_;
    }

    if (s2_running_ && s2_env_vol_) {
      logic<1> s2_out = 0;
      switch(s2_duty_) {
        case 0: s2_out = s2_phase_ < 1; break;
        case 1: s2_out = s2_phase_ < 2; break;
        case 2: s2_out = s2_phase_ < 4; break;
        case 3: s2_out = s2_phase_ < 6; break;
      }
      if (mix_l2_ && s2_out) l = l + s2_env_vol_;
      if (mix_r2_ && s2_out) r = r + s2_env_vol_;
    }

    if (s3_running_ && s3_power_) {
      logic<8> s3_sample = s3_wave_[s3_phase_ >> 1];
      logic<4> s3_out = (s3_phase_ & 1) ? b4(s3_sample, 0) : b4(s3_sample, 4);
      s3_out = s3_out >> s3_volume_shift_;
      if (mix_l3_) l = l + s3_out;
      if (mix_r3_) r = r + s3_out;
    }

    if (s4_running_ && s4_env_vol_) {
      logic<1> s4_out = b1(s4_lfsr_, 15);
      if (mix_l4_ && s4_out) l = l + s4_env_vol_;
      if (mix_r4_ && s4_out) r = r + s4_env_vol_;
    }

    l = l * volume_l_;
    r = r * volume_r_;

    out_l = l;
    out_r = r;
  }

  //----------------------------------------

  void tick(logic<1> reset, logic<16> addr, logic<8> data_in, logic<1> read, logic<1> write) {
    if (reset) {
      spu_clock_old_ = 0;
      data_out_ = 0;

      s1_sweep_shift_ = 0;
      s1_sweep_dir_ = 0;
      s1_sweep_timer_init_ = 0;
      s1_len_timer_init_ = 0;
      s1_duty_ = 0;
      s1_env_timer_init_ = 0;
      s1_env_add_ = 0;
      s1_env_vol_init_ = 0;
      s1_freq_timer_init_ = 0;
      s1_len_en_ = 0;
      s1_trig_ = 0;
      s1_running_ = 0;
      s1_sweep_timer_ = 0;
      s1_sweep_freq_ = 0;
      s1_len_timer_ = 0;
      s1_env_vol_ = 0;
      s1_env_timer_ = 0;
      s1_freq_timer_ = 0;
      s1_phase_ = 0;

      s2_len_timer_init_ = 0;
      s2_duty_ = 0;
      s2_env_timer_init_ = 0;
      s2_env_add_ = 0;
      s2_env_vol_init_ = 0;
      s2_freq_timer_init_ = 0;
      s2_len_en_ = 0;
      s2_trig_ = 0;

      s2_len_timer_ = 0;
      s2_running_ = 0;
      s2_env_timer_ = 0;
      s2_env_vol_ = 0;
      s2_freq_timer_ = 0;
      s2_phase_ = 0;

      s3_power_ = 0;
      s3_len_timer_init_ = 0;
      s3_volume_shift_ = 0;
      s3_freq_timer_init_ = 0;
      s3_len_en_ = 0;
      s3_trig_ = 0;

      s3_running_ = 0;
      s3_len_timer_ = 0;
      s3_freq_timer_ = 0;
      s3_phase_ = 0;

      for (int i = 0; i < 16; i++) {
        s3_wave_[i] = 0;
      }

      s4_len_timer_init_ = 0;
      s4_env_timer_init_ = 0;
      s4_env_add_ = 0;
      s4_env_vol_init_ = 0;
      s4_freq_timer_init_ = 0;
      s4_mode_ = 0;
      s4_shift_ = 0;
      s4_len_en_ = 0;
      s4_trig_ = 0;

      s4_running_ = 0;
      s4_len_timer_ = 0;
      s4_env_timer_ = 0;
      s4_env_vol_ = 0;
      s4_freq_timer_ = 0;
      s4_lfsr_ = 0;

      volume_l_ = 0;
      volume_r_ = 0;

      mix_r1_ = 0;
      mix_r2_ = 0;
      mix_r3_ = 0;
      mix_r4_ = 0;
      mix_l1_ = 0;
      mix_l2_ = 0;
      mix_l3_ = 0;
      mix_l4_ = 0;

      spu_power_ = 0;

    }
    else {
      logic<16> spu_clock_new = spu_clock_old_ + 1;
      logic<16> spu_tick = (~spu_clock_old_) & (spu_clock_new);

      logic<1> sweep_tick  = b1(spu_tick, 12);
      logic<1> length_tick = b1(spu_tick, 11);
      logic<1> env_tick    = b1(spu_tick, 13);

      //----------------------------------------
      // Reg read

      if (read) {
        switch (addr) {
          case 0xFF10: data_out_ = cat(b1(1), s1_sweep_timer_init_, s1_sweep_dir_, s1_sweep_shift_); break;
          case 0xFF11: data_out_ = cat(s1_duty_, s1_len_timer_init_); break;
          case 0xFF12: data_out_ = cat(s1_env_vol_init_, s1_env_add_, s1_env_timer_init_); break;
          case 0xFF13: data_out_ = b8(s1_freq_timer_init_, 0); break;
          case 0xFF14: data_out_ = cat(s1_trig_, s1_len_en_, b3(0b111), b3(s1_freq_timer_init_, 8)); break;

            //----------

          case 0xFF16: data_out_ = cat(s2_duty_, s2_len_timer_init_); break;
          case 0xFF17: data_out_ = cat(s2_env_vol_init_, s2_env_add_, s2_env_timer_init_); break;
          case 0xFF18: data_out_ = b8(s2_freq_timer_init_, 0); break;
          case 0xFF19: data_out_ = cat(s2_trig_, s2_len_en_, b3(0b111), b3(s2_freq_timer_init_, 8)); break;

            //----------

          case 0xFF1A: data_out_ = cat(s3_power_, b7(0b1111111)); break;
          case 0xFF1B: data_out_ = s3_len_timer_init_; break;

          // metron didn't like the block without {}
          case 0xFF1C: {
            switch (s3_volume_shift_) {
              case 0: data_out_ = 0b01000000; break;
              case 1: data_out_ = 0b10000000; break;
              case 2: data_out_ = 0b11000000; break;
              case 4: data_out_ = 0b00000000; break;
            }
            break;
          }
          case 0xFF1D: data_out_ = b8(s3_freq_timer_init_, 0); break;
          case 0xFF1E: data_out_ = cat(s3_trig_, s3_len_en_, b3(0b111), b3(s3_freq_timer_init_, 8)); break;

            //----------

          case 0xFF20: data_out_ = cat(b2(0b11), s4_len_timer_init_); break;
          case 0xFF21: data_out_ = cat(s4_env_vol_init_, s4_env_add_, s4_env_timer_init_); break;
          case 0xFF22: data_out_ = cat(s4_shift_, s4_mode_, s4_freq_timer_init_); break;
          case 0xFF23: data_out_ = cat(s4_trig_, s4_len_en_, b6(0b111111)); break;

            //----------

          case 0xFF24: data_out_ = cat(b1(0), volume_l_, b1(0), volume_r_); break;
          case 0xFF25: data_out_ = cat(mix_l4_, mix_l3_, mix_l2_, mix_l1_, mix_r4_, mix_r3_, mix_r2_, mix_r1_); break;
          case 0xFF26: data_out_ = cat(spu_power_, b7(0)); break;

          // "default: break didn't work?"
          default: { break; }
        }
      }

      //----------
      // s1 clock

      if (s1_freq_timer_ == 0b11111111111) {
        s1_phase_ = s1_phase_ + 1;
        s1_freq_timer_ = s1_sweep_timer_init_ ? s1_sweep_freq_ : s1_freq_timer_init_;
      }
      else {
        s1_freq_timer_ = s1_freq_timer_ + 1;
      }

      //----------
      // s1 length

      if (length_tick && s1_running_ && s1_len_en_) {
        if (s1_len_timer_ == 0b111111) {
          s1_len_timer_ = 0;
          s1_running_ = 0;
        }
        else {
          s1_len_timer_ = s1_len_timer_ + 1;
        }
      }

      //----------
      // s1 sweep

      if (sweep_tick && s1_sweep_timer_init_ && s1_sweep_shift_) {
        if (s1_sweep_timer_) {
          s1_sweep_timer_ = s1_sweep_timer_ - 1;
        }
        else {
          logic<11> delta = s1_sweep_freq_ >> s1_sweep_shift_;
          logic<12> next_freq = s1_sweep_freq_ + (s1_sweep_dir_ ? -delta : +delta);
          if (next_freq > 2047) s1_running_ = 0;
          s1_sweep_timer_ = s1_sweep_timer_init_;
          s1_sweep_freq_ = next_freq;
        }
      }

      //----------
      // s1 env

      if (env_tick && s1_env_timer_init_) {
        if (s1_env_timer_) {
          s1_env_timer_ = s1_env_timer_ - 1;
        }
        else {
          s1_env_timer_ = s1_env_timer_init_;
          if (s1_env_add_) { if (s1_env_vol_ < 15) s1_env_vol_ = s1_env_vol_ + 1; }
          else            { if (s1_env_vol_ >  0) s1_env_vol_ = s1_env_vol_ - 1; }
        }
      }

      //----------
      // s2 clock

      if (s2_freq_timer_ == 0x7FF) {
        s2_phase_ = s2_phase_ + 1;
        s2_freq_timer_ = s2_freq_timer_init_;
      }
      else {
        s2_freq_timer_ = s2_freq_timer_ + 1;
      }

      //----------
      // s2 length

      if (length_tick && s2_running_ && s2_len_en_) {
        if (s2_len_timer_ == 0x3F) {
          s2_len_timer_ = 0;
          s2_running_ = 0;
        }
        else {
          s2_len_timer_ = s2_len_timer_ + 1;
        }
      }

      //----------
      // s2 env

      if (env_tick && s2_env_timer_init_) {
        if (s2_env_timer_) {
          s2_env_timer_ = s2_env_timer_ - 1;
        }
        else {
          s2_env_timer_ = s2_env_timer_init_;
          if (s2_env_add_) { if (s2_env_vol_ < 15) s2_env_vol_ = s2_env_vol_ + 1; }
          else            { if (s2_env_vol_ >  0) s2_env_vol_ = s2_env_vol_ - 1; }
        }
      }

      //----------
      // s3 clock - we run this twice because s3's timer ticks at 2 mhz

      {
        logic<5> next_phase = s3_phase_;
        logic<11> next_timer = s3_freq_timer_;

        if (next_timer == 0x7FF) {
          next_phase = next_phase + 1;
          next_timer = s3_freq_timer_init_;
        }
        else {
          next_timer = next_timer + 1;
        }

        if (next_timer == 0x7FF) {
          next_phase = next_phase + 1;
          next_timer = s3_freq_timer_init_;
        }
        else {
          next_timer = next_timer + 1;
        }

        s3_phase_ = next_phase;
        s3_freq_timer_ = next_timer;
      }

      //----------
      // s3 length

      if (length_tick && s3_running_ && s3_len_en_) {
        if (s3_len_timer_ == 0xFF) {
          s3_len_timer_ = 0;
          s3_running_ = 0;
        }
        else {
          s3_len_timer_ = s3_len_timer_ + 1;
        }
      }

      //----------
      // s4 lfsr

      logic<1> lfsr_clock_old = spu_clock_old_[s4_shift_ + 1];
      logic<1> lfsr_clock_new = spu_clock_new[s4_shift_ + 1];

      if ((lfsr_clock_old == 0) && (lfsr_clock_new == 1)) {
        if (s4_freq_timer_) {
          s4_freq_timer_ = s4_freq_timer_ - 1;
        }
        else {
          logic<1> new_bit = s4_lfsr_[15] ^ s4_lfsr_[14] ^ 1;
          s4_lfsr_ = cat(
            b6(s4_lfsr_, 9),
            s4_mode_ ? new_bit : s4_lfsr_[8],
            b8(s4_lfsr_, 0),
            new_bit);
          s4_freq_timer_ = s4_freq_timer_init_;
        }
      }

      //----------
      // s4 length

      if (length_tick && s4_running_ && s4_len_en_) {
        if (s4_len_timer_ == 0x3F) {
          s4_len_timer_ = 0;
          s4_running_ = 0;
        }
        else {
          s4_len_timer_ = s4_len_timer_ + 1;
        }
      }

      //----------
      // s4 env

      if (env_tick && s4_env_timer_init_) {
        if (s4_env_timer_) {
          s4_env_timer_ = s4_env_timer_ - 1;
        }
        else {
          s4_env_timer_ = s4_env_timer_init_;
          if (s4_env_add_) { if (s4_env_vol_ < 15) s4_env_vol_ = s4_env_vol_ + 1; }
          else            { if (s4_env_vol_ >  0) s4_env_vol_ = s4_env_vol_ - 1; }
        }
      }

      //----------
      // Triggers

      if (s1_trig_ && (s1_env_vol_init_ || s1_env_add_)) {
        s1_running_     = 1;
        s1_len_timer_   = s1_len_timer_init_;
        s1_sweep_timer_ = s1_sweep_timer_init_;
        s1_sweep_freq_  = s1_freq_timer_init_;
        s1_env_vol_     = s1_env_vol_init_;
        s1_env_timer_   = s1_env_timer_init_;
        s1_freq_timer_  = s1_freq_timer_init_;
        s1_phase_       = 0;
        s1_trig_        = 0;
      }

      if (s2_trig_ && (s2_env_vol_init_ || s2_env_add_)) {
        s2_running_    = 1;
        s2_len_timer_  = s2_len_timer_init_;
        s2_env_vol_    = s2_env_vol_init_;
        s2_env_timer_  = s2_env_timer_init_;
        s2_freq_timer_ = s2_freq_timer_init_;
        s2_phase_      = 0;
        s2_trig_       = 0;
      }

      if (s3_trig_) {
        s3_running_    = 1;
        s3_len_timer_  = s3_len_timer_init_;
        s3_freq_timer_ = s3_freq_timer_init_;
        s3_phase_      = 0;
        s3_trig_       = 0;
      }

      if (s4_trig_ && (s4_env_vol_init_ || s4_env_add_)) {
        s4_running_    = 1;
        s4_len_timer_  = s4_len_timer_init_;
        s4_env_vol_    = s4_env_vol_init_;
        s4_env_timer_  = s4_env_timer_init_;
        s4_freq_timer_ = s4_freq_timer_init_;
        s4_lfsr_       = 0;
        s4_trig_       = 0;
      }

      //----------
      // Register writes

      if (write && addr >= 0xFF10 && addr <= 0xFF26) {
        switch (addr) {
          case 0xFF10: {
            s1_sweep_shift_      = b3(data_in, 0);
            s1_sweep_dir_        = b1(data_in, 3);
            s1_sweep_timer_init_ = b3(data_in, 4);
            break;
          }
          case 0xFF11: {
            s1_len_timer_init_ = b6(data_in, 0);
            s1_duty_           = b2(data_in, 6);
            break;
          }
          case 0xFF12: {
            s1_env_timer_init_ = b3(data_in, 0);
            s1_env_add_        = b1(data_in, 3);
            s1_env_vol_init_   = b4(data_in, 4);
            break;
          }
          case 0xFF13: {
            s1_freq_timer_init_ = cat(b3(s1_freq_timer_init_, 8), data_in);
            break;
          }
          case 0xFF14: {
            s1_freq_timer_init_ = cat(b3(data_in, 0), b8(s1_freq_timer_init_, 0));
            s1_len_en_          = b1(data_in, 6);
            s1_trig_            = b1(data_in, 7);
            break;
          }

          //----------

          case 0xFF16: {
            s2_len_timer_init_ = b6(data_in, 0);
            s2_duty_           = b2(data_in, 6);
            break;
          }
          case 0xFF17: {
            s2_env_timer_init_ = b3(data_in, 0);
            s2_env_add_        = b1(data_in, 3);
            s2_env_vol_init_   = b4(data_in, 4);
            break;
          }
          case 0xFF18: {
            s2_freq_timer_init_ = cat(b3(s2_freq_timer_init_, 8), data_in);
            break;
          }
          case 0xFF19: {
            s2_freq_timer_init_ = cat(b3(data_in, 0), b8(s2_freq_timer_init_, 0));
            s2_len_en_          = b1(data_in, 6);
            s2_trig_            = b1(data_in, 7);
            break;
          }

          //----------

          case 0xFF1A: {
            s3_power_ = b1(data_in, 7);
            break;
          }
          case 0xFF1B: {
            s3_len_timer_init_ = b8(data_in, 0);
            break;
          }
          case 0xFF1C: {
            switch (b2(data_in, 5)) {
              case 0: s3_volume_shift_ = 4; break;
              case 1: s3_volume_shift_ = 0; break;
              case 2: s3_volume_shift_ = 1; break;
              case 3: s3_volume_shift_ = 2; break;
            }
            break;
          }
          case 0xFF1D: {
            s3_freq_timer_init_ = cat(b3(s3_freq_timer_init_, 8), data_in);
            break;
          }
          case 0xFF1E: {
            s3_freq_timer_init_ = cat(b3(data_in, 0), b8(s3_freq_timer_init_, 0));
            s3_len_en_          = b1(data_in, 6);
            s3_trig_            = b1(data_in, 7);
            break;
          }

          //----------

          case 0xFF20: {
            s4_len_timer_init_ = b6(data_in, 0);
            break;
          }
          case 0xFF21: {
            s4_env_timer_init_ = b3(data_in, 0);
            s4_env_add_        = b1(data_in, 3);
            s4_env_vol_init_   = b4(data_in, 4);
            break;
          }
          case 0xFF22: {
            s4_freq_timer_init_ = b3(data_in, 0);
            s4_mode_            = b1(data_in, 3);
            s4_shift_           = b4(data_in, 4);
            break;
          }
          case 0xFF23: {
            s4_len_en_ = b1(data_in, 6);
            s4_trig_   = b1(data_in, 7);
            break;
          }

          //----------

          case 0xFF24: {
            volume_r_ = b3(data_in, 0) + 1;
            volume_l_ = b3(data_in, 4) + 1;
            break;
          }
          case 0xFF25: {
            mix_r1_ = b1(data_in, 0);
            mix_r2_ = b1(data_in, 1);
            mix_r3_ = b1(data_in, 2);
            mix_r4_ = b1(data_in, 3);
            mix_l1_ = b1(data_in, 4);
            mix_l2_ = b1(data_in, 5);
            mix_l3_ = b1(data_in, 6);
            mix_l4_ = b1(data_in, 7);
            break;
          }
          case 0xFF26: {
            spu_power_ = b1(data_in, 7);
            break;
          }
          default: {
            break;
          }
        }
      }

      //----------
      // Wavetable writes

      if (write && addr >= 0xFF30 && addr <= 0xFF3F) {
        s3_wave_[addr & 0xF] = data_in;
      }

      spu_clock_old_ = spu_clock_new;
    }
  }

  //----------------------------------------

  logic<9>  out_r; // signals
  logic<9>  out_l; // signals

  //----------------------------------------

private:

  logic<16> spu_clock_old_;
  logic<8>  data_out_;

  // Channel 1

  /*NR10*/ logic<3>  s1_sweep_shift_;
  /*NR10*/ logic<1>  s1_sweep_dir_;
  /*NR10*/ logic<3>  s1_sweep_timer_init_;
  /*NR11*/ logic<6>  s1_len_timer_init_;
  /*NR11*/ logic<2>  s1_duty_;
  /*NR12*/ logic<3>  s1_env_timer_init_;
  /*NR12*/ logic<1>  s1_env_add_;
  /*NR12*/ logic<4>  s1_env_vol_init_;
  /*NR13*/ logic<11> s1_freq_timer_init_;
  /*NR14*/ logic<1>  s1_len_en_;
  /*NR14*/ logic<1>  s1_trig_;

  logic<1>  s1_running_;
  logic<3>  s1_sweep_timer_;
  logic<11> s1_sweep_freq_;
  logic<6>  s1_len_timer_;
  logic<4>  s1_env_vol_;
  logic<3>  s1_env_timer_;
  logic<11> s1_freq_timer_;
  logic<3>  s1_phase_;

  // Channel 2

  /*NR21*/ logic<6>  s2_len_timer_init_;
  /*NR21*/ logic<2>  s2_duty_;
  /*NR22*/ logic<3>  s2_env_timer_init_;
  /*NR22*/ logic<1>  s2_env_add_;
  /*NR22*/ logic<4>  s2_env_vol_init_;
  /*NR23*/ logic<11> s2_freq_timer_init_;
  /*NR24*/ logic<1>  s2_len_en_;
  /*NR24*/ logic<1>  s2_trig_;

  logic<6>  s2_len_timer_;
  logic<1>  s2_running_;
  logic<3>  s2_env_timer_;
  logic<4>  s2_env_vol_;
  logic<11> s2_freq_timer_;
  logic<3>  s2_phase_;

  // Channel 3

  /*NR30*/ logic<1>  s3_power_;
  /*NR31*/ logic<8>  s3_len_timer_init_;
  /*NR32*/ logic<3>  s3_volume_shift_;
  /*NR33*/ logic<11> s3_freq_timer_init_;
  /*NR34*/ logic<1>  s3_len_en_;
  /*NR34*/ logic<1>  s3_trig_;

  logic<1>  s3_running_;
  logic<8>  s3_len_timer_;
  logic<11> s3_freq_timer_;
  logic<5>  s3_phase_;
  logic<8>  s3_wave_[16];

  // Channel 4

  /*NR41*/ logic<6>  s4_len_timer_init_;
  /*NR42*/ logic<3>  s4_env_timer_init_;
  /*NR42*/ logic<1>  s4_env_add_;
  /*NR42*/ logic<4>  s4_env_vol_init_;
  /*NR43*/ logic<3>  s4_freq_timer_init_;
  /*NR43*/ logic<1>  s4_mode_;
  /*NR43*/ logic<4>  s4_shift_;
  /*NR44*/ logic<1>  s4_len_en_;
  /*NR44*/ logic<1>  s4_trig_;

  logic<1>  s4_running_;
  logic<6>  s4_len_timer_;
  logic<3>  s4_env_timer_;
  logic<4>  s4_env_vol_;
  logic<3>  s4_freq_timer_;
  logic<16> s4_lfsr_;

  // SPU Control Registers

  /*NR50*/ logic<4>  volume_l_;
  /*NR50*/ logic<4>  volume_r_;

  /*NR51*/ logic<1>  mix_r1_;
  /*NR51*/ logic<1>  mix_r2_;
  /*NR51*/ logic<1>  mix_r3_;
  /*NR51*/ logic<1>  mix_r4_;
  /*NR51*/ logic<1>  mix_l1_;
  /*NR51*/ logic<1>  mix_l2_;
  /*NR51*/ logic<1>  mix_l3_;
  /*NR51*/ logic<1>  mix_l4_;

  /*NR52*/ logic<1>  spu_power_;

};

#endif // METRO_BOY_SPU2_H
Unfinished port of the Ibex RISC-V core to Metron.
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#ifndef IBEX_ALU_H
#define IBEX_ALU_H
#include "metron/metron_tools.h"
#include "ibex_pkg.h"

/**
 * Arithmetic logic unit
 */
template<ibex_pkg::rv32b_e RV32B> // scope getting cut off enum
class ibex_alu {
public:

private:
  logic<32> operand_a_rev;
  logic<33> operand_b_neg;
public:

  void tock_rev(logic<32> operand_a_i) {
    for (int k = 0; k < 32; k++) {
      operand_a_rev[k] = operand_a_i[31-k];
    }
  }

  ///////////
  // Adder //
  ///////////

private:
  logic<1>  adder_op_a_shift1;
  logic<1>  adder_op_a_shift2;
  logic<1>  adder_op_a_shift3;
  logic<1>  adder_op_b_negate;
  //logic<33> adder_in_a, adder_in_b;
  //logic<32> adder_result;
public:

  void tock1(ibex_pkg::alu_op_e operator_i) {
    using namespace ibex_pkg;

    adder_op_a_shift1 = 0;
    adder_op_a_shift2 = 0;
    adder_op_a_shift3 = 0;
    adder_op_b_negate = 0;

    /*#unique#*/ switch(operator_i) {
      // Adder OPs
      case alu_op_e::ALU_SUB:
        adder_op_b_negate = 1;
        break;

      // Comparator OPs
      case alu_op_e::ALU_EQ:
      case alu_op_e::ALU_NE:
      case alu_op_e::ALU_GE:
      case alu_op_e::ALU_GEU:
      case alu_op_e::ALU_LT:
      case alu_op_e::ALU_LTU:
      case alu_op_e::ALU_SLT:
      case alu_op_e::ALU_SLTU:
        adder_op_b_negate = 1;
        break;

      default:
        break;
    }
  }


  void tick() {
    operand_b_neg = 0;
  }


};

#endif // IBEX_ALU_H
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Compressed instruction decoder
 *
 * Decodes RISC-V compressed instructions into their RV32 equivalent.
 * This module is fully combinatorial, clock and reset are used for
 * assertions only.
 */

#ifndef IBEX_COMPRESSED_DECODER_H
#define IBEX_COMPRESSED_DECODER_H
#include "metron/metron_tools.h"
#include "ibex_pkg.h"

struct ibex_compressed_decoder {
  logic<1>  is_compressed_o;
  logic<1>  illegal_instr_o;
  logic<32> instr_o;

  // valid_i indicates if instr_i is valid and is used for assertions only.
  // The following signal is used to avoid possible lint errors.
  logic<1> unused_valid;
  void tock2(bool rst_n, logic<1> valid_i) {
    unused_valid = valid_i;
  }

  ////////////////////////
  // Compressed decoder //
  ////////////////////////

  void tock(bool rst_n, logic<1> valid_i, logic<32> instr_i) {
    using namespace ibex_pkg;

    // By default, forward incoming instruction, mark it as legal.
    instr_o = instr_i;
    illegal_instr_o = b1(0b0);

    // Check if incoming instruction is compressed.
    switch (b2(instr_i)) {
      // C0
      case 0b00: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.addi4spn -> addi rd', x2, imm
            instr_o = cat(b2(0b0), b4(instr_i, 7), b2(instr_i, 11), instr_i[5],
                       instr_i[6], b2(0b00), b5(0x02), b3(0b000), b2(0b01), b3(instr_i, 2), b7(opcode_e::OPCODE_OP_IMM));
            if (b8(instr_i, 5) == b8(0b0))  illegal_instr_o = b1(0b1);
            break;
          }

          case 0b010: {
            // c.lw -> lw rd', imm(rs1')
            instr_o = cat(b5(0b0), instr_i[5], b3(instr_i, 10), instr_i[6],
                       b2(0b00), b2(0b01), b3(instr_i, 7), b3(0b010), b2(0b01), b3(instr_i, 2), b7(opcode_e::OPCODE_LOAD));
            break;
          }

          case 0b110: {
            // c.sw -> sw rs2', imm(rs1')
            instr_o = cat(b5(0b0), instr_i[5], instr_i[12], b2(0b01), b3(instr_i, 2),
                       b2(0b01), b3(instr_i, 7), b3(0b010), b2(instr_i, 10), instr_i[6],
                       b2(0b00), b7(opcode_e::OPCODE_STORE));
            break;
          }

          case 0b001:
          case 0b011:
          case 0b100:
          case 0b101:
          case 0b111: {
            illegal_instr_o = b1(0b1);
          }

          default: {
            illegal_instr_o = b1(0b1);
          }
        }
        break;
      }

      // C1
      //
      // Register address checks for RV32E are performed in the regular instruction decoder.
      // If this check fails, an illegal instruction exception is triggered and the controller
      // writes the actual faulting instruction to mtval.
      case 0b01: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.addi -> addi rd, rd, nzimm
            // c.nop
            instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2),
                       b5(instr_i, 7), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            break;
          }

          case 0b001: case 0b101: {
            // 001: c.jal -> jal x1, imm
            // 101: c.j   -> jal x0, imm
            instr_o = cat(instr_i[12], instr_i[8], b2(instr_i, 9), instr_i[6],
                          instr_i[7], instr_i[2], instr_i[11], b3(instr_i, 3),
                          dup<9>(instr_i[12]), b4(0b0), ~instr_i[15], b7(opcode_e::OPCODE_JAL));
            break;
          }

          case 0b010: {
            // c.li -> addi rd, x0, nzimm
            // (c.li hints are translated into an addi hint)
            instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2), b5(0b0),
                       b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            break;
          }

          case 0b011: {
            // c.lui -> lui rd, imm
            // (c.lui hints are translated into a lui hint)
            instr_o = cat(dup<15>(instr_i[12]), b5(instr_i, 2), b5(instr_i, 7), b7(opcode_e::OPCODE_LUI));

            if (b5(instr_i, 7) == b5(0x02)) {
              // c.addi16sp -> addi x2, x2, nzimm
              instr_o = cat(dup<3>(instr_i[12]), b2(instr_i, 3), instr_i[5], instr_i[2],
                         instr_i[6], b4(0b0), b5(0x02), b3(0b000), b5(0x02), b7(opcode_e::OPCODE_OP_IMM));
            }

            if (cat(instr_i[12], b5(instr_i, 2)) == b6(0b0)) illegal_instr_o = b1(0b1);
            break;
          }

          case 0b100: {
            switch (b2(instr_i, 10)) {
              case 0b00:
              case 0b01: {
                // 00: c.srli -> srli rd, rd, shamt
                // 01: c.srai -> srai rd, rd, shamt
                // (c.srli/c.srai hints are translated into a srli/srai hint)
                instr_o = cat(b1(0b0), instr_i[10], b5(0b0), b5(instr_i, 2), b2(0b01), b3(instr_i, 7),
                           b3(0b101), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
                if (instr_i[12] == 0b1)  illegal_instr_o = b1(0b1);
                break;
              }

              case 0b10: {
                // c.andi -> andi rd, rd, imm
                instr_o = cat(dup<6>(instr_i[12]), instr_i[12], b5(instr_i, 2), b2(0b01), b3(instr_i, 7),
                           b3(0b111), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
                break;
              }

              case 0b11: {
                switch (cat(instr_i[12], b2(instr_i, 5))) {
                  case 0b000: {
                    // c.sub -> sub rd', rd', rs2'
                    instr_o = cat(b2(0b01), b5(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7),
                               b3(0b000), b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b001: {
                    // c.xor -> xor rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b100),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b010: {
                    // c.or  -> or  rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b110),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b011: {
                    // c.and -> and rd', rd', rs2'
                    instr_o = cat(b7(0b0), b2(0b01), b3(instr_i, 2), b2(0b01), b3(instr_i, 7), b3(0b111),
                               b2(0b01), b3(instr_i, 7), b7(opcode_e::OPCODE_OP));
                    break;
                  }

                  case 0b100:
                  case 0b101:
                  case 0b110:
                  case 0b111: {
                    // 100: c.subw
                    // 101: c.addw
                    illegal_instr_o = b1(0b1);
                    break;
                  }

                  default: {
                    illegal_instr_o = b1(0b1);
                    break;
                  }
                }
                break;
              }

              default: {
                illegal_instr_o = b1(0b1);
                break;
              }
            }
            break;
          }

          case 0b110: case 0b111: {
            // 0: c.beqz -> beq rs1', x0, imm
            // 1: c.bnez -> bne rs1', x0, imm
            instr_o = cat(dup<4>(instr_i[12]), b2(instr_i, 5), instr_i[2], b5(0b0), b2(0b01),
                       b3(instr_i, 7), b2(0b00), instr_i[13], b2(instr_i, 10), b2(instr_i, 3),
                       instr_i[12], b7(opcode_e::OPCODE_BRANCH));
            break;
          }

          default: {
            illegal_instr_o = b1(0b1);
            break;
          }
        }
        break;
      }

      // C2
      //
      // Register address checks for RV32E are performed in the regular instruction decoder.
      // If this check fails, an illegal instruction exception is triggered and the controller
      // writes the actual faulting instruction to mtval.
      case 0b10: {
        switch (b3(instr_i, 13)) {
          case 0b000: {
            // c.slli -> slli rd, rd, shamt
            // (c.ssli hints are translated into a slli hint)
            instr_o = cat(b7(0b0), b5(instr_i, 2), b5(instr_i, 7), b3(0b001), b5(instr_i, 7), b7(opcode_e::OPCODE_OP_IMM));
            if (instr_i[12] == 0b1)  illegal_instr_o = b1(0b1); // reserved for custom extensions
            break;
          }

          case 0b010: {
            // c.lwsp -> lw rd, imm(x2)
            instr_o = cat(b4(0b0), b2(instr_i, 2), instr_i[12], b3(instr_i, 4), b2(0b00), b5(0x02),
                       b3(0b010), b5(instr_i, 7), b7(opcode_e::OPCODE_LOAD));
            if (b5(instr_i, 7) == b5(0b0))  illegal_instr_o = b1(0b1);
            break;
          }

          case 0b100: {
            if (instr_i[12] == 0b0) {
              if (b5(instr_i, 2) != b5(0b0)) {
                // c.mv -> add rd/rs1, x0, rs2
                // (c.mv hints are translated into an add hint)
                instr_o = cat(b7(0b0), b5(instr_i, 2), b5(0b0), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP));
              } else {
                // c.jr -> jalr x0, rd/rs1, 0
                instr_o = cat(b12(0b0), b5(instr_i, 7), b3(0b0), b5(0b0), b7(opcode_e::OPCODE_JALR));
                if (b5(instr_i, 7) == b5(0b0)) illegal_instr_o = b1(0b1);
              }
            } else {
              if (b5(instr_i, 2) != b5(0b0)) {
                // c.add -> add rd, rd, rs2
                // (c.add hints are translated into an add hint)
                instr_o = cat(b7(0b0), b5(instr_i, 2), b5(instr_i, 7), b3(0b0), b5(instr_i, 7), b7(opcode_e::OPCODE_OP));
              } else {
                if (b5(instr_i, 7) == b5(0b0)) {
                  // c.ebreak -> ebreak
                  instr_o = b32(0x00'10'00'73);
                } else {
                  // c.jalr -> jalr x1, rs1, 0
                  instr_o = cat(b12(0b0), b5(instr_i, 7), b3(0b000), b5(0b00001), b7(opcode_e::OPCODE_JALR));
                }
              }
            }
            break;
          }

          case 0b110: {
            // c.swsp -> sw rs2, imm(x2)
            instr_o = cat(b4(0b0), b2(instr_i, 7), instr_i[12], b5(instr_i, 2), b5(0x02), b3(0b010),
                       b3(instr_i, 9), b2(0b00), b7(opcode_e::OPCODE_STORE));
            break;
          }

          case 0b001:
          case 0b011:
          case 0b101:
          case 0b111: {
            illegal_instr_o = b1(0b1);
            break;
          }

          default: {
            illegal_instr_o = b1(0b1);
            break;
          }
        }
        break;
      }

      // Incoming instruction is not compressed.
      case 0b11:; break;

      default: {
        illegal_instr_o = b1(0b1);
      }
    }
  }

  void tock3(logic<32> instr_i) {
    is_compressed_o = (b2(instr_i) != 0b11);
  }
  /*#
  ////////////////
  // Assertions //
  ////////////////

  // The valid_i signal used to gate below assertions must be known.
  `ASSERT_KNOWN(IbexInstrValidKnown, valid_i)

  // Selectors must be known/valid.
  `ASSERT(IbexInstrLSBsKnown, valid_i |->
      !$isunknown(instr_i[1:0]))
  `ASSERT(IbexC0Known1, (valid_i && (instr_i[1:0] == 2'b00)) |->
      !$isunknown(instr_i[15:13]))
  `ASSERT(IbexC1Known1, (valid_i && (instr_i[1:0] == 2'b01)) |->
      !$isunknown(instr_i[15:13]))
  `ASSERT(IbexC1Known2, (valid_i && (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100)) |->
      !$isunknown(instr_i[11:10]))
  `ASSERT(IbexC1Known3, (valid_i &&
      (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100) && (instr_i[11:10] == 2'b11)) |->
      !$isunknown({instr_i[12], instr_i[6:5]}))
  `ASSERT(IbexC2Known1, (valid_i && (instr_i[1:0] == 2'b10)) |->
      !$isunknown(instr_i[15:13]))
   #*/
};

#endif // IBEX_COMPRESSED_DECODER_H
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Slow Multiplier and Division
 *
 * Baugh-Wooley multiplier and Long Division
 */

#ifndef IBEX_MULTDIV_SLOW_H
#define IBEX_MULTDIV_SLOW_H
#include "metron/metron_tools.h"
#include "ibex_pkg.h"

struct ibex_multdiv_slow {

  logic<33> alu_operand_a_o;
  logic<33> alu_operand_b_o;
  logic<34> imd_val_d_o[2];
  logic<2>  imd_val_we_o;
  logic<32> multdiv_result_o;
  logic<1>  valid_o;

  enum class md_fsm_e : logic<3>::BASE {
    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH
  };
  md_fsm_e md_state_q, md_state_d;

  logic<33> accum_window_q, accum_window_d;
  logic<1>  unused_imd_val0;
  logic<2>  unused_imd_val1;

  logic<33> res_adder_l;
  logic<33> res_adder_h;

  logic<5>  multdiv_count_q, multdiv_count_d;
  logic<33> op_b_shift_q, op_b_shift_d;
  logic<33> op_a_shift_q, op_a_shift_d;
  logic<33> op_a_ext, op_b_ext;
  logic<33> one_shift;
  logic<33> op_a_bw_pp, op_a_bw_last_pp;
  logic<32> b_0;
  logic<1>  sign_a, sign_b;
  logic<33> next_quotient;
  logic<32> next_remainder;
  logic<32> op_numerator_q, op_numerator_d;
  logic<1>  is_greater_equal;
  logic<1>  div_change_sign, rem_change_sign;
  logic<1>  div_by_zero_d, div_by_zero_q;
  logic<1>  multdiv_hold;
  logic<1>  multdiv_en;

  void tock4(logic<34> alu_adder_ext_i) {
     // (accum_window_q + op_a_shift_q)
    res_adder_l = b33(alu_adder_ext_i);
     // (accum_window_q + op_a_shift_q)>>1
    res_adder_h = b33(alu_adder_ext_i, 1);
  }

  /////////////////////
  // ALU Operand MUX //
  /////////////////////

  void tock7(logic<34> imd_val_q_i[2]) {
    // Intermediate value register shared with ALU
    imd_val_d_o[0]  = cat(b1(0b0), accum_window_d);
    imd_val_we_o[0] = ~multdiv_hold;
    accum_window_q  = b33(imd_val_q_i[0]);
    unused_imd_val0 = imd_val_q_i[0][33];

    imd_val_d_o[1]  = cat(b2(0b00), op_numerator_d);
    imd_val_we_o[1] = multdiv_en;
    op_numerator_q  = b32(imd_val_q_i[1]);
    unused_imd_val1 = b2(imd_val_q_i[1], 32);
  }

  void tock1(
    logic<1>  mult_en_i,
    logic<1>  div_en_i,
    logic<1>  mult_sel_i,
    logic<1>  div_sel_i,
    ibex_pkg::md_op_e   operator_i,
    logic<2>  signed_mode_i,
    logic<32> op_a_i,
    logic<32> op_b_i,
    logic<34> alu_adder_ext_i,
    logic<32> alu_adder_i,
    logic<1>  equal_to_zero_i,
    logic<1>  data_ind_timing_i,
    logic<34> imd_val_q_i[2],
    logic<1>  multdiv_ready_id_i) {
    using namespace ibex_pkg;
    alu_operand_a_o = accum_window_q;

    switch (operator_i) {
      case md_op_e::MD_OP_MULL: {
        alu_operand_b_o = op_a_bw_pp;
        break;
      }

      case md_op_e::MD_OP_MULH: {
        alu_operand_b_o = (md_state_q == md_fsm_e::MD_LAST) ? op_a_bw_last_pp : op_a_bw_pp;
        break;
      }

      case md_op_e::MD_OP_DIV:
      case md_op_e::MD_OP_REM: {
        switch (md_state_q) {
          case md_fsm_e::MD_IDLE: {
            // 0 - B = 0 iff B == 0
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_b_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_ABS_A: {
            // ABS(A) = 0 - A
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_a_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_ABS_B: {
            // ABS(B) = 0 - B
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~op_b_i, b1(0b1));
            break;
          }
          case md_fsm_e::MD_CHANGE_SIGN: {
            // ABS(Quotient) = 0 - Quotient (or Reminder)
            alu_operand_a_o = cat(b32(0x0), b1(0b1));
            alu_operand_b_o = cat(~b32(accum_window_q), b1(0b1));
            break;
          }
          default: {
            // Division
            alu_operand_a_o = cat(b32(accum_window_q), b1(0b1)); // it contains the remainder
            alu_operand_b_o = cat(~b32(op_b_shift_q), b1(0b1));     // -denominator two's compliment
            break;
         }
        }
        break;
      }
      default: {
        alu_operand_a_o = accum_window_q;
        alu_operand_b_o = cat(~b32(op_b_shift_q), b1(0b1));
        break;
      }
    }
  }

  void tock6(logic<32> op_a_i, logic<32> op_b_i, logic<2>  signed_mode_i) {
    // Multiplier partial product calculation
    b_0             = dup<32>(b1(op_b_shift_q));
    op_a_bw_pp      = cat( ~b1(op_a_shift_q, 32) & b1(op_b_shift_q),  (b32(op_a_shift_q) & b_0) );
    op_a_bw_last_pp = cat(  b1(op_a_shift_q, 32) & b1(op_b_shift_q), ~(b32(op_a_shift_q) & b_0) );

    // Sign extend the input operands
    sign_a   = b1(op_a_i, 31) & b1(signed_mode_i, 0);
    sign_b   = b1(op_b_i, 31) & b1(signed_mode_i, 1);

    op_a_ext = cat(sign_a, op_a_i);
    op_b_ext = cat(sign_b, op_b_i);

    // Divider calculations

    // The adder in the ALU computes Remainder - Divisor. If Remainder - Divisor >= 0,
    // is_greater_equal is true, the next Remainder is the subtraction result and the Quotient
    // multdiv_count_q-th bit is set to 1.
    is_greater_equal = (b1(accum_window_q, 31) == b1(op_b_shift_q, 31)) ?
      ~b1(res_adder_h, 31) : b1(accum_window_q, 31);

    one_shift      = cat( b32(0b0), b1(0b1) ) << multdiv_count_q;

    next_remainder = is_greater_equal ? b32(res_adder_h)         : b32(accum_window_q);
    next_quotient  = is_greater_equal ? op_a_shift_q | one_shift : op_a_shift_q;

    div_change_sign = (sign_a ^ sign_b) & ~div_by_zero_q;
    rem_change_sign = sign_a;
  }

  void tock2(logic<1>  mult_en_i,
    logic<1>  div_en_i,
    logic<1>  mult_sel_i,
    logic<1>  div_sel_i,
    ibex_pkg::md_op_e   operator_i,
    logic<2>  signed_mode_i,
    logic<32> op_a_i,
    logic<32> op_b_i,
    logic<34> alu_adder_ext_i,
    logic<32> alu_adder_i,
    logic<1>  equal_to_zero_i,
    logic<1>  data_ind_timing_i,
    logic<34> imd_val_q_i[2],
    logic<1>  multdiv_ready_id_i) {
    using namespace ibex_pkg;
    multdiv_count_d  = multdiv_count_q;
    accum_window_d   = accum_window_q;
    op_b_shift_d     = op_b_shift_q;
    op_a_shift_d     = op_a_shift_q;
    op_numerator_d   = op_numerator_q;
    md_state_d       = md_state_q;
    multdiv_hold     = b1(0b0);
    div_by_zero_d    = div_by_zero_q;
    if (mult_sel_i || div_sel_i) {
      switch (md_state_q) {
        case md_fsm_e::MD_IDLE : {
          switch (operator_i) {
            case md_op_e::MD_OP_MULL : {
              op_a_shift_d   = op_a_ext << 1;
              accum_window_d = cat(~(op_a_ext[32] & op_b_i[0]),
                                   b32(op_a_ext) & dup<32>(op_b_i[0]));
              op_b_shift_d   = op_b_ext >> 1;
              // Proceed with multiplication by 0/1 in data-independent time mode
              md_state_d     = (!data_ind_timing_i && ((op_b_ext >> 1) == 0)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              op_a_shift_d   = op_a_ext;
              accum_window_d = cat( b1(0b1), ~(op_a_ext[32] & op_b_i[0]),
                                   b31(op_a_ext, 1) & dup<31>(op_b_i[0])  );
              op_b_shift_d   = op_b_ext >> 1;
              md_state_d     = md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_DIV : {
              // Check if the denominator is 0
              // quotient for division by 0 is specified to be -1
              // Note with data-independent time option, the full divide operation will proceed as
              // normal and will naturally return -1
              accum_window_d = dup<33>(b1(0b1));
              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? md_fsm_e::MD_FINISH : md_fsm_e::MD_ABS_A;
              // Record that this is a div by zero to stop the sign change at the end of the
              // division (in data_ind_timing mode).
              div_by_zero_d  = equal_to_zero_i;
              break;
            }
            case md_op_e::MD_OP_REM : {
              // Check if the denominator is 0
              // remainder for division by 0 is specified to be the numerator (operand a)
              // Note with data-independent time option, the full divide operation will proceed as
              // normal and will naturally return operand a
              accum_window_d = op_a_ext;
              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? md_fsm_e::MD_FINISH : md_fsm_e::MD_ABS_A;
              break;
            }
            default: break;
          }
          multdiv_count_d   = b5(31);
          break;
        }

        case md_fsm_e::MD_ABS_A: {
          // quotient
          op_a_shift_d = 0;
          // A abs value
          op_numerator_d = sign_a ? alu_adder_i : op_a_i;
          md_state_d     = md_fsm_e::MD_ABS_B;
          break;
        }

        case md_fsm_e::MD_ABS_B: {
          // remainder
          accum_window_d = cat(b32(0x0), b1(op_numerator_q, 31));
          // B abs value
          op_b_shift_d   = sign_b ? cat(b1(0b0), alu_adder_i) : cat(b1(0b0), op_b_i);
          md_state_d     = md_fsm_e::MD_COMP;
          break;
        }

        case md_fsm_e::MD_COMP: {
          multdiv_count_d = multdiv_count_q - b5(0x1);
          switch (operator_i) {
            case md_op_e::MD_OP_MULL: {
              accum_window_d = res_adder_l;
              op_a_shift_d   = op_a_shift_q << 1;
              op_b_shift_d   = op_b_shift_q >> 1;
              // Multiplication is complete once op_b is zero, unless in data_ind_timing mode where
              // the maximum possible shift-add operations will be completed regardless of op_b
              md_state_d     = ((!data_ind_timing_i && (op_b_shift_d == 0)) ||
                                (multdiv_count_q == b5(1))) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              accum_window_d = res_adder_h;
              op_a_shift_d   = op_a_shift_q;
              op_b_shift_d   = op_b_shift_q >> 1;
              md_state_d     = (multdiv_count_q == b5(1)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            case md_op_e::MD_OP_DIV:
            case md_op_e::MD_OP_REM: {
              accum_window_d = cat(b32(next_remainder), op_numerator_q[multdiv_count_d]);
              op_a_shift_d   = next_quotient;
              md_state_d     = (multdiv_count_q == b5(1)) ? md_fsm_e::MD_LAST : md_fsm_e::MD_COMP;
              break;
            }
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_LAST: {
          switch (operator_i) {
            case md_op_e::MD_OP_MULL: {
              accum_window_d = res_adder_l;

              // Note no state transition will occur if multdiv_hold is set
              md_state_d   = md_fsm_e::MD_IDLE;
              multdiv_hold = ~multdiv_ready_id_i;
              break;
            }
            case md_op_e::MD_OP_MULH: {
              accum_window_d = res_adder_l;
              md_state_d     = md_fsm_e::MD_IDLE;

              // Note no state transition will occur if multdiv_hold is set
              md_state_d   = md_fsm_e::MD_IDLE;
              multdiv_hold = ~multdiv_ready_id_i;
              break;
            }
            case md_op_e::MD_OP_DIV: {
              // this time we save the quotient in accum_window_q since we do not need anymore the
              // remainder
              accum_window_d = next_quotient;
              md_state_d     = md_fsm_e::MD_CHANGE_SIGN;
              break;
            }
            case md_op_e::MD_OP_REM: {
              // this time we do not save the quotient anymore since we need only the remainder
              accum_window_d = cat(b1(0b0), b32(next_remainder));
              md_state_d     = md_fsm_e::MD_CHANGE_SIGN;
              break;
            }
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_CHANGE_SIGN: {
          md_state_d = md_fsm_e::MD_FINISH;
          switch (operator_i) {
            case md_op_e::MD_OP_DIV:
              accum_window_d = div_change_sign ? cat(b1(0b0), alu_adder_i) : accum_window_q;
              break;
            case md_op_e::MD_OP_REM:
              accum_window_d = rem_change_sign ? cat(b1(0b0), alu_adder_i) : accum_window_q;
              break;
            default: break;
          }
          break;
        }

        case md_fsm_e::MD_FINISH : {
          // Note no state transition will occur if multdiv_hold is set
          md_state_d   = md_fsm_e::MD_IDLE;
          multdiv_hold = ~multdiv_ready_id_i;
          break;
        }

        default: {
          md_state_d = md_fsm_e::MD_IDLE;
          break;
        }
      } // md_state_q
    } // (mult_sel_i || div_sel_i)
  }

  //////////////////////////////////////////
  // Mutliplier / Divider state registers //
  //////////////////////////////////////////

  void tock5(logic<1>  mult_en_i, logic<1>  div_en_i) {
    multdiv_en = (mult_en_i | div_en_i) & ~multdiv_hold;
  }

  void tick(bool rst_n) {
    if (!rst_n) {
      multdiv_count_q  = b5(0x0);
      op_b_shift_q     = b33(0x0);
      op_a_shift_q     = b33(0x0);
      md_state_q       = md_fsm_e::MD_IDLE;
      div_by_zero_q    = b1(0b0);
    } else if (multdiv_en) {
      multdiv_count_q  = multdiv_count_d;
      op_b_shift_q     = op_b_shift_d;
      op_a_shift_q     = op_a_shift_d;
      md_state_q       = md_state_d;
      div_by_zero_q    = div_by_zero_d;
    }
  }

  /////////////
  // Outputs //
  /////////////

  void tock3(bool rst_n, ibex_pkg::md_op_e operator_i, logic<1> div_en_i) {
    using namespace ibex_pkg;
    valid_o = (md_state_q == md_fsm_e::MD_FINISH) |
              ((md_state_q == md_fsm_e::MD_LAST) &
              ((operator_i == md_op_e::MD_OP_MULL) |
               (operator_i == md_op_e::MD_OP_MULH)));

    multdiv_result_o = div_en_i ? b32(accum_window_q) : b32(res_adder_l);
  }

/*
  ////////////////
  // Assertions //
  ////////////////

  // State must be valid.
  `ASSERT(IbexMultDivStateValid, md_state_q inside {
      MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH
      }, clk_i, !rst_ni)

`ifdef FORMAL
  `ifdef YOSYS
    `include "formal_tb_frag.svh"
  `endif
`endif
 */
};

#endif // IBEX_MULTDIV_SLOW_H
// Copyright lowRISC contributors.
// Copyright 2017 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#ifndef IBEX_PKG_H
#define IBEX_PKG_H
#include "metron/metron_tools.h"

/**
 * Package with constants used by Ibex
 */
namespace ibex_pkg {

  ////////////////
  // IO Structs //
  ////////////////

  struct crash_dump_t {
    logic<32> current_pc;
    logic<32> next_pc;
    logic<32> last_data_addr;
    logic<32> exception_addr;
  };

  struct core2rf_t {
    logic<1> dummy_instr_id;
    logic<5> raddr_a;
    logic<5> waddr_a;
    logic<1> we_a;
    logic<5> raddr_b;
  };

  /////////////////////
  // Parameter Enums //
  /////////////////////

  enum class regfile_e : int {
    RegFileFF    = 0,
    RegFileFPGA  = 1,
    RegFileLatch = 2
  };

  enum class rv32m_e : int {
    RV32MNone        = 0,
    RV32MSlow        = 1,
    RV32MFast        = 2,
    RV32MSingleCycle = 3
  };

  enum class rv32b_e : int {
    RV32BNone       = 0,
    RV32BBalanced   = 1,
    RV32BOTEarlGrey = 2,
    RV32BFull       = 3
  };

  /////////////
  // Opcodes //
  /////////////

  enum class opcode_e : logic<7>::BASE {
    OPCODE_LOAD     = 0x03,
    OPCODE_MISC_MEM = 0x0f,
    OPCODE_OP_IMM   = 0x13,
    OPCODE_AUIPC    = 0x17,
    OPCODE_STORE    = 0x23,
    OPCODE_OP       = 0x33,
    OPCODE_LUI      = 0x37,
    OPCODE_BRANCH   = 0x63,
    OPCODE_JALR     = 0x67,
    OPCODE_JAL      = 0x6f,
    OPCODE_SYSTEM   = 0x73
  };


  ////////////////////
  // ALU operations //
  ////////////////////

  enum class alu_op_e : logic<7>::BASE {
    // Arithmetics
    ALU_ADD,
    ALU_SUB,

    // Logics
    ALU_XOR,
    ALU_OR,
    ALU_AND,
    // RV32B
    ALU_XNOR,
    ALU_ORN,
    ALU_ANDN,

    // Shifts
    ALU_SRA,
    ALU_SRL,
    ALU_SLL,
    // RV32B
    ALU_SRO,
    ALU_SLO,
    ALU_ROR,
    ALU_ROL,
    ALU_GREV,
    ALU_GORC,
    ALU_SHFL,
    ALU_UNSHFL,
    ALU_XPERM_N,
    ALU_XPERM_B,
    ALU_XPERM_H,

    // Address Calculations
    // RV32B
    ALU_SH1ADD,
    ALU_SH2ADD,
    ALU_SH3ADD,

    // Comparisons
    ALU_LT,
    ALU_LTU,
    ALU_GE,
    ALU_GEU,
    ALU_EQ,
    ALU_NE,
    // RV32B
    ALU_MIN,
    ALU_MINU,
    ALU_MAX,
    ALU_MAXU,

    // Pack
    // RV32B
    ALU_PACK,
    ALU_PACKU,
    ALU_PACKH,

    // Sign-Extend
    // RV32B
    ALU_SEXTB,
    ALU_SEXTH,

    // Bitcounting
    // RV32B
    ALU_CLZ,
    ALU_CTZ,
    ALU_CPOP,

    // Set lower than
    ALU_SLT,
    ALU_SLTU,

    // Ternary Bitmanip Operations
    // RV32B
    ALU_CMOV,
    ALU_CMIX,
    ALU_FSL,
    ALU_FSR,

    // Single-Bit Operations
    // RV32B
    ALU_BSET,
    ALU_BCLR,
    ALU_BINV,
    ALU_BEXT,

    // Bit Compress / Decompress
    // RV32B
    ALU_BCOMPRESS,
    ALU_BDECOMPRESS,

    // Bit Field Place
    // RV32B
    ALU_BFP,

    // Carry-less Multiply
    // RV32B
    ALU_CLMUL,
    ALU_CLMULR,
    ALU_CLMULH,

    // Cyclic Redundancy Check
    ALU_CRC32_B,
    ALU_CRC32C_B,
    ALU_CRC32_H,
    ALU_CRC32C_H,
    ALU_CRC32_W,
    ALU_CRC32C_W
  };

  enum class md_op_e : logic<2>::BASE {
    // Multiplier/divider
    MD_OP_MULL,
    MD_OP_MULH,
    MD_OP_DIV,
    MD_OP_REM
  };


  //////////////////////////////////
  // Control and status registers //
  //////////////////////////////////

  // CSR operations
  enum class csr_op_e : logic<2>::BASE {
    CSR_OP_READ,
    CSR_OP_WRITE,
    CSR_OP_SET,
    CSR_OP_CLEAR
  };

  // Privileged mode
  enum class priv_lvl_e : logic<2>::BASE {
    PRIV_LVL_M = 0b11,
    PRIV_LVL_H = 0b10,
    PRIV_LVL_S = 0b01,
    PRIV_LVL_U = 0b00
  };

  // Constants for the dcsr.xdebugver fields
  enum class x_debug_ver_e : logic<4>::BASE {
    XDEBUGVER_NO     = 0, // no external debug support
    XDEBUGVER_STD    = 4, // external debug according to RISC-V debug spec
    XDEBUGVER_NONSTD = 15 // debug not conforming to RISC-V debug spec
  };

  //////////////
  // WB stage //
  //////////////

  // Type of instruction present in writeback stage
  enum class wb_instr_type_e : logic<2>::BASE {
    WB_INSTR_LOAD,  // Instruction is awaiting load data
    WB_INSTR_STORE, // Instruction is awaiting store response
    WB_INSTR_OTHER  // Instruction doesn't fit into above categories
  };

  //////////////
  // ID stage //
  //////////////

  // Operand a selection
  enum class op_a_sel_e : logic<2>::BASE {
    OP_A_REG_A,
    OP_A_FWD,
    OP_A_CURRPC,
    OP_A_IMM
  };

  // Immediate a selection
  enum class imm_a_sel_e : logic<1>::BASE {
    IMM_A_Z,
    IMM_A_ZERO
  };

  // Operand b selection
  enum class op_b_sel_e : logic<1>::BASE  {
    OP_B_REG_B,
    OP_B_IMM
  };

  // Immediate b selection
  enum class imm_b_sel_e : logic<3>::BASE {
    IMM_B_I,
    IMM_B_S,
    IMM_B_B,
    IMM_B_U,
    IMM_B_J,
    IMM_B_INCR_PC,
    IMM_B_INCR_ADDR
  };

  // Regfile write data selection
  enum class rf_wd_sel_e : logic<1>::BASE  {
    RF_WD_EX,
    RF_WD_CSR
  };

  //////////////
  // IF stage //
  //////////////

  // PC mux selection
  enum class pc_sel_e : logic<3>::BASE {
    PC_BOOT,
    PC_JUMP,
    PC_EXC,
    PC_ERET,
    PC_DRET,
    PC_BP
  };

  // Exception PC mux selection
  enum class exc_pc_sel_e : logic<2>::BASE {
    EXC_PC_EXC,
    EXC_PC_IRQ,
    EXC_PC_DBD,
    EXC_PC_DBG_EXC // Exception while in debug mode
  };

  // Interrupt requests
  struct irqs_t {
    logic<1>  irq_software;
    logic<1>  irq_timer;
    logic<1>  irq_external;
    logic<15> irq_fast; // 15 fast interrupts,
                          // one interrupt is reserved for NMI (not visible through mip/mie)
  };

  // Exception cause
  enum class exc_cause_e : logic<6>::BASE {
    EXC_CAUSE_IRQ_SOFTWARE_M     = 0b100011,
    EXC_CAUSE_IRQ_TIMER_M        = 0b100111,
    EXC_CAUSE_IRQ_EXTERNAL_M     = 0b101011,
    // EXC_CAUSE_IRQ_FAST_0      = 0b110000,
    // EXC_CAUSE_IRQ_FAST_14     = 0b111110,
    EXC_CAUSE_IRQ_NM             = 0b111111, // == EXC_CAUSE_IRQ_FAST_15
    EXC_CAUSE_INSN_ADDR_MISA     = 0b000000,
    EXC_CAUSE_INSTR_ACCESS_FAULT = 0b000001,
    EXC_CAUSE_ILLEGAL_INSN       = 0b000010,
    EXC_CAUSE_BREAKPOINT         = 0b000011,
    EXC_CAUSE_LOAD_ACCESS_FAULT  = 0b000101,
    EXC_CAUSE_STORE_ACCESS_FAULT = 0b000111,
    EXC_CAUSE_ECALL_UMODE        = 0b001000,
    EXC_CAUSE_ECALL_MMODE        = 0b001011
  };

  // Debug cause
  enum class dbg_cause_e : logic<3>::BASE {
    DBG_CAUSE_NONE    = 0x0,
    DBG_CAUSE_EBREAK  = 0x1,
    DBG_CAUSE_TRIGGER = 0x2,
    DBG_CAUSE_HALTREQ = 0x3,
    DBG_CAUSE_STEP    = 0x4
  };

  // ICache constants
  static const unsigned int ADDR_W           = 32;
  static const unsigned int BUS_SIZE         = 32;
  static const unsigned int BUS_BYTES        = BUS_SIZE/8;
  static const unsigned int BUS_W            = clog2(BUS_BYTES);
  static const unsigned int IC_SIZE_BYTES    = 4096;
  static const unsigned int IC_NUM_WAYS      = 2;
  static const unsigned int IC_LINE_SIZE     = 64;
  static const unsigned int IC_LINE_BYTES    = IC_LINE_SIZE/8;
  static const unsigned int IC_LINE_W        = clog2(IC_LINE_BYTES);
  static const unsigned int IC_NUM_LINES     = IC_SIZE_BYTES / IC_NUM_WAYS / IC_LINE_BYTES;
  static const unsigned int IC_LINE_BEATS    = IC_LINE_BYTES / BUS_BYTES;
  static const unsigned int IC_LINE_BEATS_W  = clog2(IC_LINE_BEATS);
  static const unsigned int IC_INDEX_W       = clog2(IC_NUM_LINES);
  static const unsigned int IC_INDEX_HI      = IC_INDEX_W + IC_LINE_W - 1;
  static const unsigned int IC_TAG_SIZE      = ADDR_W - IC_INDEX_W - IC_LINE_W + 1; // 1 valid bit
  static const unsigned int IC_OUTPUT_BEATS  = (BUS_BYTES / 2); // number of halfwords
  // ICache Scrambling Parameters
  static const unsigned int SCRAMBLE_KEY_W   = 128;
  static const unsigned int SCRAMBLE_NONCE_W = 64;

  // PMP constants
  static const unsigned int PMP_MAX_REGIONS      = 16;
  static const unsigned int PMP_CFG_W            = 8;

  // PMP acces type
  static const unsigned int PMP_I  = 0;
  static const unsigned int PMP_I2 = 1;
  static const unsigned int PMP_D  = 2;

  enum class pmp_req_e : logic<2>::BASE {
    PMP_ACC_EXEC    = 0b00,
    PMP_ACC_WRITE   = 0b01,
    PMP_ACC_READ    = 0b10
  };

  // PMP cfg structures
  enum class pmp_cfg_mode_e : logic<2>::BASE {
    PMP_MODE_OFF   = 0b00,
    PMP_MODE_TOR   = 0b01,
    PMP_MODE_NA4   = 0b10,
    PMP_MODE_NAPOT = 0b11
  };

  struct pmp_cfg_t {
    logic<1>       lock;
    pmp_cfg_mode_e mode;
    logic<1>       exec;
    logic<1>       write;
    logic<1>       read;
  };

  // Machine Security Configuration (ePMP)
  struct pmp_mseccfg_t {
    logic<1> rlb;  // Rule Locking Bypass
    logic<1> mmwp; // Machine Mode Whitelist Policy
    logic<1> mml;  // Machine Mode Lockdown
  };

  // CSRs
  enum class csr_num_e : logic<12>::BASE {
    // Machine information
    CSR_MVENDORID = 0xF11,
    CSR_MARCHID   = 0xF12,
    CSR_MIMPID    = 0xF13,
    CSR_MHARTID   = 0xF14,

    // Machine trap setup
    CSR_MSTATUS   = 0x300,
    CSR_MISA      = 0x301,
    CSR_MIE       = 0x304,
    CSR_MTVEC     = 0x305,
    CSR_MCOUNTEREN= 0x306,

    // Machine trap handling
    CSR_MSCRATCH  = 0x340,
    CSR_MEPC      = 0x341,
    CSR_MCAUSE    = 0x342,
    CSR_MTVAL     = 0x343,
    CSR_MIP       = 0x344,

    // Physical memory protection
    CSR_PMPCFG0   = 0x3A0,
    CSR_PMPCFG1   = 0x3A1,
    CSR_PMPCFG2   = 0x3A2,
    CSR_PMPCFG3   = 0x3A3,
    CSR_PMPADDR0  = 0x3B0,
    CSR_PMPADDR1  = 0x3B1,
    CSR_PMPADDR2  = 0x3B2,
    CSR_PMPADDR3  = 0x3B3,
    CSR_PMPADDR4  = 0x3B4,
    CSR_PMPADDR5  = 0x3B5,
    CSR_PMPADDR6  = 0x3B6,
    CSR_PMPADDR7  = 0x3B7,
    CSR_PMPADDR8  = 0x3B8,
    CSR_PMPADDR9  = 0x3B9,
    CSR_PMPADDR10 = 0x3BA,
    CSR_PMPADDR11 = 0x3BB,
    CSR_PMPADDR12 = 0x3BC,
    CSR_PMPADDR13 = 0x3BD,
    CSR_PMPADDR14 = 0x3BE,
    CSR_PMPADDR15 = 0x3BF,

    // ePMP control
    CSR_MSECCFG   = 0x747,
    CSR_MSECCFGH  = 0x757,

    // Debug trigger
    CSR_TSELECT   = 0x7A0,
    CSR_TDATA1    = 0x7A1,
    CSR_TDATA2    = 0x7A2,
    CSR_TDATA3    = 0x7A3,
    CSR_MCONTEXT  = 0x7A8,
    CSR_SCONTEXT  = 0x7AA,

    // Debug/trace
    CSR_DCSR      = 0x7b0,
    CSR_DPC       = 0x7b1,

    // Debug
    CSR_DSCRATCH0 = 0x7b2, // optional
    CSR_DSCRATCH1 = 0x7b3, // optional

    // Machine Counter/Timers
    CSR_MCOUNTINHIBIT  = 0x320,
    CSR_MHPMEVENT3     = 0x323,
    CSR_MHPMEVENT4     = 0x324,
    CSR_MHPMEVENT5     = 0x325,
    CSR_MHPMEVENT6     = 0x326,
    CSR_MHPMEVENT7     = 0x327,
    CSR_MHPMEVENT8     = 0x328,
    CSR_MHPMEVENT9     = 0x329,
    CSR_MHPMEVENT10    = 0x32A,
    CSR_MHPMEVENT11    = 0x32B,
    CSR_MHPMEVENT12    = 0x32C,
    CSR_MHPMEVENT13    = 0x32D,
    CSR_MHPMEVENT14    = 0x32E,
    CSR_MHPMEVENT15    = 0x32F,
    CSR_MHPMEVENT16    = 0x330,
    CSR_MHPMEVENT17    = 0x331,
    CSR_MHPMEVENT18    = 0x332,
    CSR_MHPMEVENT19    = 0x333,
    CSR_MHPMEVENT20    = 0x334,
    CSR_MHPMEVENT21    = 0x335,
    CSR_MHPMEVENT22    = 0x336,
    CSR_MHPMEVENT23    = 0x337,
    CSR_MHPMEVENT24    = 0x338,
    CSR_MHPMEVENT25    = 0x339,
    CSR_MHPMEVENT26    = 0x33A,
    CSR_MHPMEVENT27    = 0x33B,
    CSR_MHPMEVENT28    = 0x33C,
    CSR_MHPMEVENT29    = 0x33D,
    CSR_MHPMEVENT30    = 0x33E,
    CSR_MHPMEVENT31    = 0x33F,
    CSR_MCYCLE         = 0xB00,
    CSR_MINSTRET       = 0xB02,
    CSR_MHPMCOUNTER3   = 0xB03,
    CSR_MHPMCOUNTER4   = 0xB04,
    CSR_MHPMCOUNTER5   = 0xB05,
    CSR_MHPMCOUNTER6   = 0xB06,
    CSR_MHPMCOUNTER7   = 0xB07,
    CSR_MHPMCOUNTER8   = 0xB08,
    CSR_MHPMCOUNTER9   = 0xB09,
    CSR_MHPMCOUNTER10  = 0xB0A,
    CSR_MHPMCOUNTER11  = 0xB0B,
    CSR_MHPMCOUNTER12  = 0xB0C,
    CSR_MHPMCOUNTER13  = 0xB0D,
    CSR_MHPMCOUNTER14  = 0xB0E,
    CSR_MHPMCOUNTER15  = 0xB0F,
    CSR_MHPMCOUNTER16  = 0xB10,
    CSR_MHPMCOUNTER17  = 0xB11,
    CSR_MHPMCOUNTER18  = 0xB12,
    CSR_MHPMCOUNTER19  = 0xB13,
    CSR_MHPMCOUNTER20  = 0xB14,
    CSR_MHPMCOUNTER21  = 0xB15,
    CSR_MHPMCOUNTER22  = 0xB16,
    CSR_MHPMCOUNTER23  = 0xB17,
    CSR_MHPMCOUNTER24  = 0xB18,
    CSR_MHPMCOUNTER25  = 0xB19,
    CSR_MHPMCOUNTER26  = 0xB1A,
    CSR_MHPMCOUNTER27  = 0xB1B,
    CSR_MHPMCOUNTER28  = 0xB1C,
    CSR_MHPMCOUNTER29  = 0xB1D,
    CSR_MHPMCOUNTER30  = 0xB1E,
    CSR_MHPMCOUNTER31  = 0xB1F,
    CSR_MCYCLEH        = 0xB80,
    CSR_MINSTRETH      = 0xB82,
    CSR_MHPMCOUNTER3H  = 0xB83,
    CSR_MHPMCOUNTER4H  = 0xB84,
    CSR_MHPMCOUNTER5H  = 0xB85,
    CSR_MHPMCOUNTER6H  = 0xB86,
    CSR_MHPMCOUNTER7H  = 0xB87,
    CSR_MHPMCOUNTER8H  = 0xB88,
    CSR_MHPMCOUNTER9H  = 0xB89,
    CSR_MHPMCOUNTER10H = 0xB8A,
    CSR_MHPMCOUNTER11H = 0xB8B,
    CSR_MHPMCOUNTER12H = 0xB8C,
    CSR_MHPMCOUNTER13H = 0xB8D,
    CSR_MHPMCOUNTER14H = 0xB8E,
    CSR_MHPMCOUNTER15H = 0xB8F,
    CSR_MHPMCOUNTER16H = 0xB90,
    CSR_MHPMCOUNTER17H = 0xB91,
    CSR_MHPMCOUNTER18H = 0xB92,
    CSR_MHPMCOUNTER19H = 0xB93,
    CSR_MHPMCOUNTER20H = 0xB94,
    CSR_MHPMCOUNTER21H = 0xB95,
    CSR_MHPMCOUNTER22H = 0xB96,
    CSR_MHPMCOUNTER23H = 0xB97,
    CSR_MHPMCOUNTER24H = 0xB98,
    CSR_MHPMCOUNTER25H = 0xB99,
    CSR_MHPMCOUNTER26H = 0xB9A,
    CSR_MHPMCOUNTER27H = 0xB9B,
    CSR_MHPMCOUNTER28H = 0xB9C,
    CSR_MHPMCOUNTER29H = 0xB9D,
    CSR_MHPMCOUNTER30H = 0xB9E,
    CSR_MHPMCOUNTER31H = 0xB9F,
    CSR_CPUCTRL        = 0x7C0,
    CSR_SECURESEED     = 0x7C1
  };

  // CSR pmp-related offsets
  static const logic<12> CSR_OFF_PMP_CFG  = 0x3A0; // pmp_cfg  @ 12'h3a0 - 12'h3a3
  static const logic<12> CSR_OFF_PMP_ADDR = 0x3B0; // pmp_addr @ 12'h3b0 - 12'h3bf

  // CSR status bits
  static const unsigned int CSR_MSTATUS_MIE_BIT      = 3;
  static const unsigned int CSR_MSTATUS_MPIE_BIT     = 7;
  static const unsigned int CSR_MSTATUS_MPP_BIT_LOW  = 11;
  static const unsigned int CSR_MSTATUS_MPP_BIT_HIGH = 12;
  static const unsigned int CSR_MSTATUS_MPRV_BIT     = 17;
  static const unsigned int CSR_MSTATUS_TW_BIT       = 21;

  // CSR machine ISA
  static const logic<2> CSR_MISA_MXL = b2(1); // M-XLEN: XLEN in M-Mode for RV32

  // CSR interrupt pending/enable bits
  static const unsigned int CSR_MSIX_BIT      = 3;
  static const unsigned int CSR_MTIX_BIT      = 7;
  static const unsigned int CSR_MEIX_BIT      = 11;
  static const unsigned int CSR_MFIX_BIT_LOW  = 16;
  static const unsigned int CSR_MFIX_BIT_HIGH = 30;

  // CSR Machine Security Configuration bits
  static const unsigned int CSR_MSECCFG_MML_BIT  = 0;
  static const unsigned int CSR_MSECCFG_MMWP_BIT = 1;
  static const unsigned int CSR_MSECCFG_RLB_BIT  = 2;

  // Vendor ID
  // No JEDEC ID has been allocated to lowRISC so the value is 0 to indicate the field is not
  // implemented
  static const logic<32> CSR_MVENDORID_VALUE  = b32(0b0);

  // Architecture ID
  // Top bit is unset to indicate an open source project. The lower bits are an ID allocated by the
  // RISC-V Foundation. Note this is allocated specifically to Ibex, should significant changes be
  // made a different architecture ID should be supplied.
  static const logic<32> CSR_MARCHID_VALUE = b32(22);

  // Implementation ID
  // 0 indicates this field is not implemeted. Ibex implementors may wish to indicate an RTL/netlist
  // version here using their own unique encoding (e.g. 32 bits of the git hash of the implemented
  // commit).
  static const logic<32> CSR_MIMPID_VALUE = b32(0b0);

  // These LFSR parameters have been generated with
  // $ opentitan/util/design/gen-lfsr-seed.py --width 32 --seed 2480124384 --prefix ""
  static const int LfsrWidth = 32;
  typedef logic<LfsrWidth> lfsr_seed_t;
  typedef logic<LfsrWidth> lfsr_perm_t[clog2(LfsrWidth)];
  static const lfsr_seed_t RndCnstLfsrSeedDefault = b32(0xac533bf4);
  static const lfsr_perm_t RndCnstLfsrPermDefault = { b32(0x78a8daed), b32(0xc04fa438), b32(0x2e958152), b32(0x467fd1b1), b32(0x1e35ecba) };

  // we don't support 128-bit logic<>s in Metron yet
  //parameter logic [SCRAMBLE_KEY_W-1:0]   RndCnstIbexKeyDefault = 128'h14e8cecae3040d5e12286bb3cc113298;
  //parameter logic [SCRAMBLE_NONCE_W-1:0] RndCnstIbexNonceDefault = 64'hf79780bc735f3843;
}

#endif // IBEX_PKG_H
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// N:1 fixed priority arbiter module (index 0 has highest prio)
//
// Verilog parameter
//   N:           Number of request ports
//   DW:          Data width
//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
//
// See also: prim_arbiter_ppc, prim_arbiter_tree

#ifndef PRIM_ARBITER_FIXED_H
#define PRIM_ARBITER_FIXED_H
#include "metron/metron_tools.h"

template<
  int N = 8,
  int DW = 32,

  // Configurations
  // EnDataPort: {0, 1}, if 0, input data will be ignored
  int EnDataPort = 1,

  // Derived parameters
  int IdxW = clog2(N)
>
struct prim_arbiter_fixed {

  logic<N>    gnt_o;
  logic<IdxW> idx_o;

  logic<1>    valid_o;
  logic<DW>   data_o;


  prim_arbiter_fixed() {
  }

  void tick(bool rst_n, logic<N> req_i, logic<DW> data_i[N], logic<1> ready_i) {
  }

  // align to powers of 2 for simplicity
  // a full binary tree with N levels has 2**N + 2**N-1 nodes
  logic<pow2(IdxW + 1) - 1> req_tree;
  logic<pow2(IdxW + 1) - 1> gnt_tree;
  logic<pow2(IdxW + 1) - 1> idx_tree[IdxW];
  logic<pow2(IdxW + 1) - 1> data_tree[DW];

  void tock(bool rst_n, logic<N> req_i, logic<DW> data_i[N], logic<1> ready_i) {
    /*
    for (int level = 0; level < IdxW + 1; level++) {
      //
      // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
      //            \  /         these nodes are the children of the nodes one level below
      // level       Pa      <- "Base0", points to the first node on "level",
      //                         these nodes are the parents of the nodes one level above
      //
      // hence we have the following indices for the Pa, C0, C1 nodes:
      // Pa = 2**level     - 1 + offset       = Base0 + offset
      // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
      // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
      //

      static const int Base0 = pow2(level) - 1;
      static const int Base1 = pow2(level + 1) - 1;

      for (int offset = 0; offset < pow2(level); offset++) {
      }
    }

    // the results can be found at the tree root
    if (EnDataPort) {
      data_o = data_tree[0];
    } else {
      logic<DW> unused_data;
      unused_data = data_tree[0];
      data_o = 1;
    }

    idx_o       = idx_tree[0];
    valid_o     = req_tree[0];

    // this propagates a grant back to the input
    gnt_tree[0] = valid_o & ready_i;
    */
  }

};

#endif // PRIM_ARBITER_FIXED_H
#include "metron/metron_tools.h"

class DPRam {
public:

  logic<16> porta_dout_;
  logic<16> portb_dout_;

  void tick(
    logic<16> porta_addr,
    logic<16> portb_addr,
    logic<1>  portb_write,
    logic<16> portb_data) {

    porta_dout_ = ram_[porta_addr];

    if (portb_write) {
      ram_[portb_addr] = portb_data;
      portb_dout_ = portb_data;
    }
    else {
      portb_dout_ = ram_[portb_addr];
    }
  }

private:
  logic<16> ram_[65536];
};
#include "metron/metron_tools.h"
#include "dpram.h"

class J1 {
public:

  logic<1>  io_rd_;
  logic<1>  io_wr_;
  logic<16> io_addr_;
  logic<16> io_dout_;
  logic<16> io_din;

  enum {
    OP_JUMP = 0b000,
    OP_CJMP = 0b001,
    OP_CALL = 0b010,
    OP_ALU  = 0b011,
  };

  void tock(logic<1> sys_rst_i) {
    logic<5>  _dsp;
    logic<16> _st0;
    logic<1>  _dstkW;
    logic<1>  _rstkW;
    logic<16> _rstkD;
    logic<13> _pc;
    logic<5>  _rsp;

    logic<16> insn;
    logic<16> ramrd;

    insn = dpram.porta_dout_;
    ramrd = dpram.portb_dout_;

    logic<16> dd = sign_extend<16>(b2(insn, 0));
    logic<16> rd = sign_extend<16>(b2(insn, 2));
    logic<1>  op_store = insn[5];

    logic<3> opcode = b3(insn, 13);
    logic<1> is_lit = insn[15];
    logic<16> st1 = dstack_[dsp_];

    logic<4> st0sel;
    switch(b2(insn, 13)) {
      case 0:  st0sel = 0; break;
      case 1:  st0sel = 0; break;
      case 2:  st0sel = 1; break;
      case 3:  st0sel = b4(insn, 8); break;
    }

    // Compute the new value of T.
    logic<16> rst0 = rstack_[rsp_];

    if (is_lit) {
      _st0 = cat(b1(0), b15(insn));
    }
    else {
      switch (st0sel) {
        case 0b0000: _st0 = st0_; break;
        case 0b0001: _st0 = st1; break;
        case 0b0010: _st0 = st0_ + st1; break;
        case 0b0011: _st0 = st0_ & st1; break;
        case 0b0100: _st0 = st0_ | st1; break;
        case 0b0101: _st0 = st0_ ^ st1; break;
        case 0b0110: _st0 = ~st0_; break;
        case 0b0111: _st0 = dup<16>(b1(st1 == st0_)); break;
        case 0b1000: _st0 = dup<16>(b1(signed(st1) < signed(st0_))); break;
        case 0b1001: _st0 = st1 >> b4(st0_); break;
        case 0b1010: _st0 = st0_ - 1; break;
        case 0b1011: _st0 = rst0; break;
        case 0b1100: _st0 = b2(st0_, 14) ? io_din : ramrd; break;
        case 0b1101: _st0 = st1 << b4(st0_); break;
        case 0b1110: _st0 = cat(rsp_, b3(0), dsp_); break;
        case 0b1111: _st0 = dup<16>(b1(st1 < st0_)); break;
        default:     _st0 = DONTCARE; break;
      }
    }

    if (is_lit) {
      _dsp = dsp_ + 1;
      _rsp = rsp_;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = pc_ + 1;
    }
    else if (opcode == OP_JUMP) {
      _dsp = dsp_;
      _rsp = rsp_;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = b13(insn);
    }
    else if (opcode == OP_CJMP) {
      // predicated jump is like DROP
      _dsp = dsp_ - 1;
      _rsp = rsp_;
      _rstkW = 0;
      _rstkD = _pc;
      _pc = st0_ ? b13(pc_ + 1) : b13(insn);
    }
    else if (opcode == OP_CALL) {
      _dsp = dsp_;
      _rsp = rsp_ + 1;
      _rstkW = 1;
      _rstkD = cat(b15(pc_ + 1), b1(0));
      _pc = b13(insn);
    }
    else if (opcode == OP_ALU) {
      _dsp = dsp_ + sign_extend<5>(b2(insn, 0));
      _rsp = rsp_ + sign_extend<5>(b2(insn, 2));
      _rstkW = insn[6];
      _rstkD = st0_;
      _pc = insn[12] ? b13(rst0, 1) : b13(pc_ + 1);
    }


    logic<1> _ramWE = (opcode == OP_ALU) & op_store;

    dpram.tick(
      b16(pc_),                      // porta_addr
      b16(_st0, 1),                 // portb_addr
      _ramWE & (b2(_st0, 14) == 0), // portb_write
      b16(st1));                       // portb_data

    _dstkW = is_lit | ((opcode == OP_ALU) & insn[7]);

    tick(sys_rst_i, _pc, _st0, _dsp, _rsp, _dstkW, _rstkW, _rstkD, insn);
  }

  void tick(
    logic<1> sys_rst_i,
    logic<13> _pc,
    logic<16> _st0,
    logic<5>  _dsp,
    logic<5>  _rsp,
    logic<1> _dstkW,
    logic<1> _rstkW,
    logic<16> _rstkD,
    logic<16> insn
  ) {


    if (sys_rst_i) {
      pc_      = 0;
      st0_     = 0;
      dsp_     = 0;
      rsp_     = 0;
      io_rd_   = 0;
      io_wr_   = 0;
      io_addr_ = 0;
      io_dout_ = 0;
    } else {
      logic<3> opcode = b3(insn, 13);

      io_rd_   = (opcode == OP_ALU && (b4(insn,8) == 0xc));
      io_wr_   = opcode == OP_ALU && insn[5];
      io_addr_ = b16(st0_);
      io_dout_ = dstack_[dsp_];

      if (_dstkW) dstack_[_dsp] = st0_;
      if (_rstkW) rstack_[_rsp] = _rstkD;

      pc_  = _pc;
      st0_ = _st0;
      dsp_ = _dsp;
      rsp_ = _rsp;
    }
  }

private:

  // The RAM
  DPRam dpram;

  // The D and R stacks
  logic<16> dstack_[32];
  logic<16> rstack_[32];

  logic<13> pc_;
  logic<16> st0_;
  logic<5>  dsp_;
  logic<5>  rsp_;

};
#include "metron/metron_tools.h"

// PicoRV32 -- A Small RISC-V (RV32I) Processor Core
//
// Copyright (C) 2015  Claire Xenia Wolf <claire@yosyshq.com>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

// verilator lint_off WIDTH
// verilator lint_off PINMISSING
// verilator lint_off CASEOVERLAP
// verilator lint_off CASEINCOMPLETE

// `timescale 1 ns / 1 ps
// `default_nettype none
// #define DEBUGNETS
// #define DEBUGREGS
// #define DEBUGASM
// #define DEBUG

//#ifdef DEBUG
//  #define debug(debug_command) debug_command
//#else
//  #define debug(debug_command)
//#endif

#ifdef FORMAL
  #define FORMAL_KEEP /*#(* keep *)#*/
  #define assert(assert_expr) assert(assert_expr)
#else
  #ifdef DEBUGNETS
    #define FORMAL_KEEP /*#(* keep *)#*/
  #else
    #define FORMAL_KEEP
  #endif
  #define assert(assert_expr) empty_statement
#endif

// uncomment this for register file in extra module
// #define PICORV32_REGS picorv32_regs

// this macro can be used to check if the verilog files in your
// design are read in the correct order.
#define PICORV32_V


//==============================================================================
// picorv32
//==============================================================================

class picorv32 {
  public:

/*
module picorv32 #(
	parameter [ 0:0] ENABLE_COUNTERS = 1,
	parameter [ 0:0] ENABLE_COUNTERS64 = 1,
	parameter [ 0:0] ENABLE_REGS_16_31 = 1,
	parameter [ 0:0] ENABLE_REGS_DUALPORT = 1,
	parameter [ 0:0] LATCHED_MEM_RDATA = 0,
	parameter [ 0:0] TWO_STAGE_SHIFT = 1,
	parameter [ 0:0] BARREL_SHIFTER = 0,
	parameter [ 0:0] TWO_CYCLE_COMPARE = 0,
	parameter [ 0:0] TWO_CYCLE_ALU = 0,
	parameter [ 0:0] COMPRESSED_ISA = 0,
	parameter [ 0:0] CATCH_MISALIGN = 1,
	parameter [ 0:0] CATCH_ILLINSN = 1,
	parameter [ 0:0] ENABLE_PCPI = 0,
	parameter [ 0:0] ENABLE_MUL = 0,
	parameter [ 0:0] ENABLE_FAST_MUL = 0,
	parameter [ 0:0] ENABLE_DIV = 0,
	parameter [ 0:0] ENABLE_IRQ = 0,
	parameter [ 0:0] ENABLE_IRQ_QREGS = 1,
	parameter [ 0:0] ENABLE_IRQ_TIMER = 1,
	parameter [ 0:0] ENABLE_TRACE = 0,
	parameter [ 0:0] REGS_INIT_ZERO = 0,
	parameter [31:0] MASKED_IRQ = 32'h 0000_0000,
	parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff,
	parameter [31:0] PROGADDR_RESET = 32'h 0000_0000,
	parameter [31:0] PROGADDR_IRQ = 32'h 0000_0010,
	parameter [31:0] STACKADDR = 32'h ffff_ffff
) (
	input clk, resetn,
	output reg trap,

	output reg        mem_valid,
	output reg        mem_instr,
	input             mem_ready,

	output reg [31:0] mem_addr,
	output reg [31:0] mem_wdata,
	output reg [ 3:0] mem_wstrb,
	input      [31:0] mem_rdata,

	// Look-Ahead Interface
	output            mem_la_read,
	output            mem_la_write,
	output     [31:0] mem_la_addr,
	output reg [31:0] mem_la_wdata,
	output reg [ 3:0] mem_la_wstrb,

	// Pico Co-Processor Interface (PCPI)
	output reg        pcpi_valid,
	output reg [31:0] pcpi_insn,
	output     [31:0] pcpi_rs1,
	output     [31:0] pcpi_rs2,
	input             pcpi_wr,
	input      [31:0] pcpi_rd,
	input             pcpi_wait,
	input             pcpi_ready,

	// IRQ Interface
	input      [31:0] irq,
	output reg [31:0] eoi,

`ifdef RISCV_FORMAL
	output reg        rvfi_valid,
	output reg [63:0] rvfi_order,
	output reg [31:0] rvfi_insn,
	output reg        rvfi_trap,
	output reg        rvfi_halt,
	output reg        rvfi_intr,
	output reg [ 1:0] rvfi_mode,
	output reg [ 1:0] rvfi_ixl,
	output reg [ 4:0] rvfi_rs1_addr,
	output reg [ 4:0] rvfi_rs2_addr,
	output reg [31:0] rvfi_rs1_rdata,
	output reg [31:0] rvfi_rs2_rdata,
	output reg [ 4:0] rvfi_rd_addr,
	output reg [31:0] rvfi_rd_wdata,
	output reg [31:0] rvfi_pc_rdata,
	output reg [31:0] rvfi_pc_wdata,
	output reg [31:0] rvfi_mem_addr,
	output reg [ 3:0] rvfi_mem_rmask,
	output reg [ 3:0] rvfi_mem_wmask,
	output reg [31:0] rvfi_mem_rdata,
	output reg [31:0] rvfi_mem_wdata,

	output reg [63:0] rvfi_csr_mcycle_rmask,
	output reg [63:0] rvfi_csr_mcycle_wmask,
	output reg [63:0] rvfi_csr_mcycle_rdata,
	output reg [63:0] rvfi_csr_mcycle_wdata,

	output reg [63:0] rvfi_csr_minstret_rmask,
	output reg [63:0] rvfi_csr_minstret_wmask,
	output reg [63:0] rvfi_csr_minstret_rdata,
	output reg [63:0] rvfi_csr_minstret_wdata,
`endif

	// Trace Interface
	output reg        trace_valid,
	output reg [35:0] trace_data
);
	localparam integer irq_timer = 0;
	localparam integer irq_ebreak = 1;
	localparam integer irq_buserror = 2;

	localparam integer irqregs_offset = ENABLE_REGS_16_31 ? 32 : 16;
	localparam integer regfile_size = (ENABLE_REGS_16_31 ? 32 : 16) + 4*ENABLE_IRQ*ENABLE_IRQ_QREGS;
	localparam integer regindex_bits = (ENABLE_REGS_16_31 ? 5 : 4) + ENABLE_IRQ*ENABLE_IRQ_QREGS;

	localparam WITH_PCPI = ENABLE_PCPI || ENABLE_MUL || ENABLE_FAST_MUL || ENABLE_DIV;

	localparam [35:0] TRACE_BRANCH = {4'b 0001, 32'b 0};
	localparam [35:0] TRACE_ADDR   = {4'b 0010, 32'b 0};
	localparam [35:0] TRACE_IRQ    = {4'b 1000, 32'b 0};

	reg [63:0] count_cycle, count_instr;
	reg [31:0] reg_pc, reg_next_pc, reg_op1, reg_op2, reg_out;
	reg [4:0] reg_sh;

	reg [31:0] next_insn_opcode;
	reg [31:0] dbg_insn_opcode;
	reg [31:0] dbg_insn_addr;

	wire dbg_mem_valid = mem_valid;
	wire dbg_mem_instr = mem_instr;
	wire dbg_mem_ready = mem_ready;
	wire [31:0] dbg_mem_addr  = mem_addr;
	wire [31:0] dbg_mem_wdata = mem_wdata;
	wire [ 3:0] dbg_mem_wstrb = mem_wstrb;
	wire [31:0] dbg_mem_rdata = mem_rdata;

	assign pcpi_rs1 = reg_op1;
	assign pcpi_rs2 = reg_op2;

	wire [31:0] next_pc;

	reg irq_delay;
	reg irq_active;
	reg [31:0] irq_mask;
	reg [31:0] irq_pending;
	reg [31:0] timer;

`ifndef PICORV32_REGS
	reg [31:0] cpuregs [0:regfile_size-1];

	integer i;
	initial begin
		if (REGS_INIT_ZERO) begin
			for (i = 0; i < regfile_size; i = i+1)
				cpuregs[i] = 0;
		end
	end
`endif

	task empty_statement;
		// This task is used by the `assert directive in non-formal mode to
		// avoid empty statement (which are unsupported by plain Verilog syntax).
		begin end
	endtask

`ifdef DEBUGREGS
	wire [31:0] dbg_reg_x0  = 0;
	wire [31:0] dbg_reg_x1  = cpuregs[1];
	wire [31:0] dbg_reg_x2  = cpuregs[2];
	wire [31:0] dbg_reg_x3  = cpuregs[3];
	wire [31:0] dbg_reg_x4  = cpuregs[4];
	wire [31:0] dbg_reg_x5  = cpuregs[5];
	wire [31:0] dbg_reg_x6  = cpuregs[6];
	wire [31:0] dbg_reg_x7  = cpuregs[7];
	wire [31:0] dbg_reg_x8  = cpuregs[8];
	wire [31:0] dbg_reg_x9  = cpuregs[9];
	wire [31:0] dbg_reg_x10 = cpuregs[10];
	wire [31:0] dbg_reg_x11 = cpuregs[11];
	wire [31:0] dbg_reg_x12 = cpuregs[12];
	wire [31:0] dbg_reg_x13 = cpuregs[13];
	wire [31:0] dbg_reg_x14 = cpuregs[14];
	wire [31:0] dbg_reg_x15 = cpuregs[15];
	wire [31:0] dbg_reg_x16 = cpuregs[16];
	wire [31:0] dbg_reg_x17 = cpuregs[17];
	wire [31:0] dbg_reg_x18 = cpuregs[18];
	wire [31:0] dbg_reg_x19 = cpuregs[19];
	wire [31:0] dbg_reg_x20 = cpuregs[20];
	wire [31:0] dbg_reg_x21 = cpuregs[21];
	wire [31:0] dbg_reg_x22 = cpuregs[22];
	wire [31:0] dbg_reg_x23 = cpuregs[23];
	wire [31:0] dbg_reg_x24 = cpuregs[24];
	wire [31:0] dbg_reg_x25 = cpuregs[25];
	wire [31:0] dbg_reg_x26 = cpuregs[26];
	wire [31:0] dbg_reg_x27 = cpuregs[27];
	wire [31:0] dbg_reg_x28 = cpuregs[28];
	wire [31:0] dbg_reg_x29 = cpuregs[29];
	wire [31:0] dbg_reg_x30 = cpuregs[30];
	wire [31:0] dbg_reg_x31 = cpuregs[31];
`endif

	// Internal PCPI Cores

	wire        pcpi_mul_wr;
	wire [31:0] pcpi_mul_rd;
	wire        pcpi_mul_wait;
	wire        pcpi_mul_ready;

	wire        pcpi_div_wr;
	wire [31:0] pcpi_div_rd;
	wire        pcpi_div_wait;
	wire        pcpi_div_ready;

	reg        pcpi_int_wr;
	reg [31:0] pcpi_int_rd;
	reg        pcpi_int_wait;
	reg        pcpi_int_ready;

	generate if (ENABLE_FAST_MUL) begin
		picorv32_pcpi_fast_mul pcpi_mul (
			.clk       (clk            ),
			.resetn    (resetn         ),
			.pcpi_valid(pcpi_valid     ),
			.pcpi_insn (pcpi_insn      ),
			.pcpi_rs1  (pcpi_rs1       ),
			.pcpi_rs2  (pcpi_rs2       ),
			.pcpi_wr   (pcpi_mul_wr    ),
			.pcpi_rd   (pcpi_mul_rd    ),
			.pcpi_wait (pcpi_mul_wait  ),
			.pcpi_ready(pcpi_mul_ready )
		);
	end else if (ENABLE_MUL) begin
		picorv32_pcpi_mul pcpi_mul (
			.clk       (clk            ),
			.resetn    (resetn         ),
			.pcpi_valid(pcpi_valid     ),
			.pcpi_insn (pcpi_insn      ),
			.pcpi_rs1  (pcpi_rs1       ),
			.pcpi_rs2  (pcpi_rs2       ),
			.pcpi_wr   (pcpi_mul_wr    ),
			.pcpi_rd   (pcpi_mul_rd    ),
			.pcpi_wait (pcpi_mul_wait  ),
			.pcpi_ready(pcpi_mul_ready )
		);
	end else begin
		assign pcpi_mul_wr = 0;
		assign pcpi_mul_rd = 32'bx;
		assign pcpi_mul_wait = 0;
		assign pcpi_mul_ready = 0;
	end endgenerate

	generate if (ENABLE_DIV) begin
		picorv32_pcpi_div pcpi_div (
			.clk       (clk            ),
			.resetn    (resetn         ),
			.pcpi_valid(pcpi_valid     ),
			.pcpi_insn (pcpi_insn      ),
			.pcpi_rs1  (pcpi_rs1       ),
			.pcpi_rs2  (pcpi_rs2       ),
			.pcpi_wr   (pcpi_div_wr    ),
			.pcpi_rd   (pcpi_div_rd    ),
			.pcpi_wait (pcpi_div_wait  ),
			.pcpi_ready(pcpi_div_ready )
		);
	end else begin
		assign pcpi_div_wr = 0;
		assign pcpi_div_rd = 32'bx;
		assign pcpi_div_wait = 0;
		assign pcpi_div_ready = 0;
	end endgenerate

	always @* begin
		pcpi_int_wr = 0;
		pcpi_int_rd = 32'bx;
		pcpi_int_wait  = |{ENABLE_PCPI && pcpi_wait,  (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_wait,  ENABLE_DIV && pcpi_div_wait};
		pcpi_int_ready = |{ENABLE_PCPI && pcpi_ready, (ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready, ENABLE_DIV && pcpi_div_ready};

		(* parallel_case *)
		case (1'b1)
			ENABLE_PCPI && pcpi_ready: begin
				pcpi_int_wr = ENABLE_PCPI ? pcpi_wr : 0;
				pcpi_int_rd = ENABLE_PCPI ? pcpi_rd : 0;
			end
			(ENABLE_MUL || ENABLE_FAST_MUL) && pcpi_mul_ready: begin
				pcpi_int_wr = pcpi_mul_wr;
				pcpi_int_rd = pcpi_mul_rd;
			end
			ENABLE_DIV && pcpi_div_ready: begin
				pcpi_int_wr = pcpi_div_wr;
				pcpi_int_rd = pcpi_div_rd;
			end
		endcase
	end


	// Memory Interface

	reg [1:0] mem_state;
	reg [1:0] mem_wordsize;
	reg [31:0] mem_rdata_word;
	reg [31:0] mem_rdata_q;
	reg mem_do_prefetch;
	reg mem_do_rinst;
	reg mem_do_rdata;
	reg mem_do_wdata;

	wire mem_xfer;
	reg mem_la_secondword, mem_la_firstword_reg, last_mem_valid;
	wire mem_la_firstword = COMPRESSED_ISA && (mem_do_prefetch || mem_do_rinst) && next_pc[1] && !mem_la_secondword;
	wire mem_la_firstword_xfer = COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg);

	reg prefetched_high_word;
	reg clear_prefetched_high_word;
	reg [15:0] mem_16bit_buffer;

	wire [31:0] mem_rdata_latched_noshuffle;
	wire [31:0] mem_rdata_latched;

	wire mem_la_use_prefetched_high_word = COMPRESSED_ISA && mem_la_firstword && prefetched_high_word && !clear_prefetched_high_word;
	assign mem_xfer = (mem_valid && mem_ready) || (mem_la_use_prefetched_high_word && mem_do_rinst);

	wire mem_busy = |{mem_do_prefetch, mem_do_rinst, mem_do_rdata, mem_do_wdata};
	wire mem_done = resetn && ((mem_xfer && |mem_state && (mem_do_rinst || mem_do_rdata || mem_do_wdata)) || (&mem_state && mem_do_rinst)) &&
			(!mem_la_firstword || (~&mem_rdata_latched[1:0] && mem_xfer));

	assign mem_la_write = resetn && !mem_state && mem_do_wdata;
	assign mem_la_read = resetn && ((!mem_la_use_prefetched_high_word && !mem_state && (mem_do_rinst || mem_do_prefetch || mem_do_rdata)) ||
			(COMPRESSED_ISA && mem_xfer && (!last_mem_valid ? mem_la_firstword : mem_la_firstword_reg) && !mem_la_secondword && &mem_rdata_latched[1:0]));
	assign mem_la_addr = (mem_do_prefetch || mem_do_rinst) ? {next_pc[31:2] + mem_la_firstword_xfer, 2'b00} : {reg_op1[31:2], 2'b00};

	assign mem_rdata_latched_noshuffle = (mem_xfer || LATCHED_MEM_RDATA) ? mem_rdata : mem_rdata_q;

	assign mem_rdata_latched = COMPRESSED_ISA && mem_la_use_prefetched_high_word ? {16'bx, mem_16bit_buffer} :
			COMPRESSED_ISA && mem_la_secondword ? {mem_rdata_latched_noshuffle[15:0], mem_16bit_buffer} :
			COMPRESSED_ISA && mem_la_firstword ? {16'bx, mem_rdata_latched_noshuffle[31:16]} : mem_rdata_latched_noshuffle;

	always @(posedge clk) begin
		if (!resetn) begin
			mem_la_firstword_reg <= 0;
			last_mem_valid <= 0;
		end else begin
			if (!last_mem_valid)
				mem_la_firstword_reg <= mem_la_firstword;
			last_mem_valid <= mem_valid && !mem_ready;
		end
	end

	always @* begin
		(* full_case *)
		case (mem_wordsize)
			0: begin
				mem_la_wdata = reg_op2;
				mem_la_wstrb = 4'b1111;
				mem_rdata_word = mem_rdata;
			end
			1: begin
				mem_la_wdata = {2{reg_op2[15:0]}};
				mem_la_wstrb = reg_op1[1] ? 4'b1100 : 4'b0011;
				case (reg_op1[1])
					1'b0: mem_rdata_word = {16'b0, mem_rdata[15: 0]};
					1'b1: mem_rdata_word = {16'b0, mem_rdata[31:16]};
				endcase
			end
			2: begin
				mem_la_wdata = {4{reg_op2[7:0]}};
				mem_la_wstrb = 4'b0001 << reg_op1[1:0];
				case (reg_op1[1:0])
					2'b00: mem_rdata_word = {24'b0, mem_rdata[ 7: 0]};
					2'b01: mem_rdata_word = {24'b0, mem_rdata[15: 8]};
					2'b10: mem_rdata_word = {24'b0, mem_rdata[23:16]};
					2'b11: mem_rdata_word = {24'b0, mem_rdata[31:24]};
				endcase
			end
		endcase
	end

	always @(posedge clk) begin
		if (mem_xfer) begin
			mem_rdata_q <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
			next_insn_opcode <= COMPRESSED_ISA ? mem_rdata_latched : mem_rdata;
		end

		if (COMPRESSED_ISA && mem_done && (mem_do_prefetch || mem_do_rinst)) begin
			case (mem_rdata_latched[1:0])
				2'b00: begin // Quadrant 0
					case (mem_rdata_latched[15:13])
						3'b000: begin // C.ADDI4SPN
							mem_rdata_q[14:12] <= 3'b000;
							mem_rdata_q[31:20] <= {2'b0, mem_rdata_latched[10:7], mem_rdata_latched[12:11], mem_rdata_latched[5], mem_rdata_latched[6], 2'b00};
						end
						3'b010: begin // C.LW
							mem_rdata_q[31:20] <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
							mem_rdata_q[14:12] <= 3'b 010;
						end
						3'b 110: begin // C.SW
							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {5'b0, mem_rdata_latched[5], mem_rdata_latched[12:10], mem_rdata_latched[6], 2'b00};
							mem_rdata_q[14:12] <= 3'b 010;
						end
					endcase
				end
				2'b01: begin // Quadrant 1
					case (mem_rdata_latched[15:13])
						3'b 000: begin // C.ADDI
							mem_rdata_q[14:12] <= 3'b000;
							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
						end
						3'b 010: begin // C.LI
							mem_rdata_q[14:12] <= 3'b000;
							mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
						end
						3'b 011: begin
							if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
								mem_rdata_q[14:12] <= 3'b000;
								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[4:3],
										mem_rdata_latched[5], mem_rdata_latched[2], mem_rdata_latched[6], 4'b 0000});
							end else begin // C.LUI
								mem_rdata_q[31:12] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
							end
						end
						3'b100: begin
							if (mem_rdata_latched[11:10] == 2'b00) begin // C.SRLI
								mem_rdata_q[31:25] <= 7'b0000000;
								mem_rdata_q[14:12] <= 3'b 101;
							end
							if (mem_rdata_latched[11:10] == 2'b01) begin // C.SRAI
								mem_rdata_q[31:25] <= 7'b0100000;
								mem_rdata_q[14:12] <= 3'b 101;
							end
							if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
								mem_rdata_q[14:12] <= 3'b111;
								mem_rdata_q[31:20] <= $signed({mem_rdata_latched[12], mem_rdata_latched[6:2]});
							end
							if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
								if (mem_rdata_latched[6:5] == 2'b00) mem_rdata_q[14:12] <= 3'b000;
								if (mem_rdata_latched[6:5] == 2'b01) mem_rdata_q[14:12] <= 3'b100;
								if (mem_rdata_latched[6:5] == 2'b10) mem_rdata_q[14:12] <= 3'b110;
								if (mem_rdata_latched[6:5] == 2'b11) mem_rdata_q[14:12] <= 3'b111;
								mem_rdata_q[31:25] <= mem_rdata_latched[6:5] == 2'b00 ? 7'b0100000 : 7'b0000000;
							end
						end
						3'b 110: begin // C.BEQZ
							mem_rdata_q[14:12] <= 3'b000;
							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
						end
						3'b 111: begin // C.BNEZ
							mem_rdata_q[14:12] <= 3'b001;
							{ mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8] } <=
									$signed({mem_rdata_latched[12], mem_rdata_latched[6:5], mem_rdata_latched[2],
											mem_rdata_latched[11:10], mem_rdata_latched[4:3]});
						end
					endcase
				end
				2'b10: begin // Quadrant 2
					case (mem_rdata_latched[15:13])
						3'b000: begin // C.SLLI
							mem_rdata_q[31:25] <= 7'b0000000;
							mem_rdata_q[14:12] <= 3'b 001;
						end
						3'b010: begin // C.LWSP
							mem_rdata_q[31:20] <= {4'b0, mem_rdata_latched[3:2], mem_rdata_latched[12], mem_rdata_latched[6:4], 2'b00};
							mem_rdata_q[14:12] <= 3'b 010;
						end
						3'b100: begin
							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
								mem_rdata_q[14:12] <= 3'b000;
								mem_rdata_q[31:20] <= 12'b0;
							end
							if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
								mem_rdata_q[14:12] <= 3'b000;
								mem_rdata_q[31:25] <= 7'b0000000;
							end
							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
								mem_rdata_q[14:12] <= 3'b000;
								mem_rdata_q[31:20] <= 12'b0;
							end
							if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
								mem_rdata_q[14:12] <= 3'b000;
								mem_rdata_q[31:25] <= 7'b0000000;
							end
						end
						3'b110: begin // C.SWSP
							{mem_rdata_q[31:25], mem_rdata_q[11:7]} <= {4'b0, mem_rdata_latched[8:7], mem_rdata_latched[12:9], 2'b00};
							mem_rdata_q[14:12] <= 3'b 010;
						end
					endcase
				end
			endcase
		end
	end

	always @(posedge clk) begin
		if (resetn && !trap) begin
			if (mem_do_prefetch || mem_do_rinst || mem_do_rdata)
				`assert(!mem_do_wdata);

			if (mem_do_prefetch || mem_do_rinst)
				`assert(!mem_do_rdata);

			if (mem_do_rdata)
				`assert(!mem_do_prefetch && !mem_do_rinst);

			if (mem_do_wdata)
				`assert(!(mem_do_prefetch || mem_do_rinst || mem_do_rdata));

			if (mem_state == 2 || mem_state == 3)
				`assert(mem_valid || mem_do_prefetch);
		end
	end

	always @(posedge clk) begin
		if (!resetn || trap) begin
			if (!resetn)
				mem_state <= 0;
			if (!resetn || mem_ready)
				mem_valid <= 0;
			mem_la_secondword <= 0;
			prefetched_high_word <= 0;
		end else begin
			if (mem_la_read || mem_la_write) begin
				mem_addr <= mem_la_addr;
				mem_wstrb <= mem_la_wstrb & {4{mem_la_write}};
			end
			if (mem_la_write) begin
				mem_wdata <= mem_la_wdata;
			end
			case (mem_state)
				0: begin
					if (mem_do_prefetch || mem_do_rinst || mem_do_rdata) begin
						mem_valid <= !mem_la_use_prefetched_high_word;
						mem_instr <= mem_do_prefetch || mem_do_rinst;
						mem_wstrb <= 0;
						mem_state <= 1;
					end
					if (mem_do_wdata) begin
						mem_valid <= 1;
						mem_instr <= 0;
						mem_state <= 2;
					end
				end
				1: begin
					`assert(mem_wstrb == 0);
					`assert(mem_do_prefetch || mem_do_rinst || mem_do_rdata);
					`assert(mem_valid == !mem_la_use_prefetched_high_word);
					`assert(mem_instr == (mem_do_prefetch || mem_do_rinst));
					if (mem_xfer) begin
						if (COMPRESSED_ISA && mem_la_read) begin
							mem_valid <= 1;
							mem_la_secondword <= 1;
							if (!mem_la_use_prefetched_high_word)
								mem_16bit_buffer <= mem_rdata[31:16];
						end else begin
							mem_valid <= 0;
							mem_la_secondword <= 0;
							if (COMPRESSED_ISA && !mem_do_rdata) begin
								if (~&mem_rdata[1:0] || mem_la_secondword) begin
									mem_16bit_buffer <= mem_rdata[31:16];
									prefetched_high_word <= 1;
								end else begin
									prefetched_high_word <= 0;
								end
							end
							mem_state <= mem_do_rinst || mem_do_rdata ? 0 : 3;
						end
					end
				end
				2: begin
					`assert(mem_wstrb != 0);
					`assert(mem_do_wdata);
					if (mem_xfer) begin
						mem_valid <= 0;
						mem_state <= 0;
					end
				end
				3: begin
					`assert(mem_wstrb == 0);
					`assert(mem_do_prefetch);
					if (mem_do_rinst) begin
						mem_state <= 0;
					end
				end
			endcase
		end

		if (clear_prefetched_high_word)
			prefetched_high_word <= 0;
	end


	// Instruction Decoder

	reg instr_lui, instr_auipc, instr_jal, instr_jalr;
	reg instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu;
	reg instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw;
	reg instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai;
	reg instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and;
	reg instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_ecall_ebreak, instr_fence;
	reg instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer;
	wire instr_trap;

	reg [regindex_bits-1:0] decoded_rd, decoded_rs1, decoded_rs2;
	reg [31:0] decoded_imm, decoded_imm_j;
	reg decoder_trigger;
	reg decoder_trigger_q;
	reg decoder_pseudo_trigger;
	reg decoder_pseudo_trigger_q;
	reg compressed_instr;

	reg is_lui_auipc_jal;
	reg is_lb_lh_lw_lbu_lhu;
	reg is_slli_srli_srai;
	reg is_jalr_addi_slti_sltiu_xori_ori_andi;
	reg is_sb_sh_sw;
	reg is_sll_srl_sra;
	reg is_lui_auipc_jal_jalr_addi_add_sub;
	reg is_slti_blt_slt;
	reg is_sltiu_bltu_sltu;
	reg is_beq_bne_blt_bge_bltu_bgeu;
	reg is_lbu_lhu_lw;
	reg is_alu_reg_imm;
	reg is_alu_reg_reg;
	reg is_compare;

	assign instr_trap = (CATCH_ILLINSN || WITH_PCPI) && !{instr_lui, instr_auipc, instr_jal, instr_jalr,
			instr_beq, instr_bne, instr_blt, instr_bge, instr_bltu, instr_bgeu,
			instr_lb, instr_lh, instr_lw, instr_lbu, instr_lhu, instr_sb, instr_sh, instr_sw,
			instr_addi, instr_slti, instr_sltiu, instr_xori, instr_ori, instr_andi, instr_slli, instr_srli, instr_srai,
			instr_add, instr_sub, instr_sll, instr_slt, instr_sltu, instr_xor, instr_srl, instr_sra, instr_or, instr_and,
			instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh, instr_fence,
			instr_getq, instr_setq, instr_retirq, instr_maskirq, instr_waitirq, instr_timer};

	wire is_rdcycle_rdcycleh_rdinstr_rdinstrh;
	assign is_rdcycle_rdcycleh_rdinstr_rdinstrh = |{instr_rdcycle, instr_rdcycleh, instr_rdinstr, instr_rdinstrh};

	reg [63:0] new_ascii_instr;
	`FORMAL_KEEP reg [63:0] dbg_ascii_instr;
	`FORMAL_KEEP reg [31:0] dbg_insn_imm;
	`FORMAL_KEEP reg [4:0] dbg_insn_rs1;
	`FORMAL_KEEP reg [4:0] dbg_insn_rs2;
	`FORMAL_KEEP reg [4:0] dbg_insn_rd;
	`FORMAL_KEEP reg [31:0] dbg_rs1val;
	`FORMAL_KEEP reg [31:0] dbg_rs2val;
	`FORMAL_KEEP reg dbg_rs1val_valid;
	`FORMAL_KEEP reg dbg_rs2val_valid;

	always @* begin
		new_ascii_instr = "";

		if (instr_lui)      new_ascii_instr = "lui";
		if (instr_auipc)    new_ascii_instr = "auipc";
		if (instr_jal)      new_ascii_instr = "jal";
		if (instr_jalr)     new_ascii_instr = "jalr";

		if (instr_beq)      new_ascii_instr = "beq";
		if (instr_bne)      new_ascii_instr = "bne";
		if (instr_blt)      new_ascii_instr = "blt";
		if (instr_bge)      new_ascii_instr = "bge";
		if (instr_bltu)     new_ascii_instr = "bltu";
		if (instr_bgeu)     new_ascii_instr = "bgeu";

		if (instr_lb)       new_ascii_instr = "lb";
		if (instr_lh)       new_ascii_instr = "lh";
		if (instr_lw)       new_ascii_instr = "lw";
		if (instr_lbu)      new_ascii_instr = "lbu";
		if (instr_lhu)      new_ascii_instr = "lhu";
		if (instr_sb)       new_ascii_instr = "sb";
		if (instr_sh)       new_ascii_instr = "sh";
		if (instr_sw)       new_ascii_instr = "sw";

		if (instr_addi)     new_ascii_instr = "addi";
		if (instr_slti)     new_ascii_instr = "slti";
		if (instr_sltiu)    new_ascii_instr = "sltiu";
		if (instr_xori)     new_ascii_instr = "xori";
		if (instr_ori)      new_ascii_instr = "ori";
		if (instr_andi)     new_ascii_instr = "andi";
		if (instr_slli)     new_ascii_instr = "slli";
		if (instr_srli)     new_ascii_instr = "srli";
		if (instr_srai)     new_ascii_instr = "srai";

		if (instr_add)      new_ascii_instr = "add";
		if (instr_sub)      new_ascii_instr = "sub";
		if (instr_sll)      new_ascii_instr = "sll";
		if (instr_slt)      new_ascii_instr = "slt";
		if (instr_sltu)     new_ascii_instr = "sltu";
		if (instr_xor)      new_ascii_instr = "xor";
		if (instr_srl)      new_ascii_instr = "srl";
		if (instr_sra)      new_ascii_instr = "sra";
		if (instr_or)       new_ascii_instr = "or";
		if (instr_and)      new_ascii_instr = "and";

		if (instr_rdcycle)  new_ascii_instr = "rdcycle";
		if (instr_rdcycleh) new_ascii_instr = "rdcycleh";
		if (instr_rdinstr)  new_ascii_instr = "rdinstr";
		if (instr_rdinstrh) new_ascii_instr = "rdinstrh";
		if (instr_fence)    new_ascii_instr = "fence";

		if (instr_getq)     new_ascii_instr = "getq";
		if (instr_setq)     new_ascii_instr = "setq";
		if (instr_retirq)   new_ascii_instr = "retirq";
		if (instr_maskirq)  new_ascii_instr = "maskirq";
		if (instr_waitirq)  new_ascii_instr = "waitirq";
		if (instr_timer)    new_ascii_instr = "timer";
	end

	reg [63:0] q_ascii_instr;
	reg [31:0] q_insn_imm;
	reg [31:0] q_insn_opcode;
	reg [4:0] q_insn_rs1;
	reg [4:0] q_insn_rs2;
	reg [4:0] q_insn_rd;
	reg dbg_next;

	wire launch_next_insn;
	reg dbg_valid_insn;

	reg [63:0] cached_ascii_instr;
	reg [31:0] cached_insn_imm;
	reg [31:0] cached_insn_opcode;
	reg [4:0] cached_insn_rs1;
	reg [4:0] cached_insn_rs2;
	reg [4:0] cached_insn_rd;

	always @(posedge clk) begin
		q_ascii_instr <= dbg_ascii_instr;
		q_insn_imm <= dbg_insn_imm;
		q_insn_opcode <= dbg_insn_opcode;
		q_insn_rs1 <= dbg_insn_rs1;
		q_insn_rs2 <= dbg_insn_rs2;
		q_insn_rd <= dbg_insn_rd;
		dbg_next <= launch_next_insn;

		if (!resetn || trap)
			dbg_valid_insn <= 0;
		else if (launch_next_insn)
			dbg_valid_insn <= 1;

		if (decoder_trigger_q) begin
			cached_ascii_instr <= new_ascii_instr;
			cached_insn_imm <= decoded_imm;
			if (&next_insn_opcode[1:0])
				cached_insn_opcode <= next_insn_opcode;
			else
				cached_insn_opcode <= {16'b0, next_insn_opcode[15:0]};
			cached_insn_rs1 <= decoded_rs1;
			cached_insn_rs2 <= decoded_rs2;
			cached_insn_rd <= decoded_rd;
		end

		if (launch_next_insn) begin
			dbg_insn_addr <= next_pc;
		end
	end

	always @* begin
		dbg_ascii_instr = q_ascii_instr;
		dbg_insn_imm = q_insn_imm;
		dbg_insn_opcode = q_insn_opcode;
		dbg_insn_rs1 = q_insn_rs1;
		dbg_insn_rs2 = q_insn_rs2;
		dbg_insn_rd = q_insn_rd;

		if (dbg_next) begin
			if (decoder_pseudo_trigger_q) begin
				dbg_ascii_instr = cached_ascii_instr;
				dbg_insn_imm = cached_insn_imm;
				dbg_insn_opcode = cached_insn_opcode;
				dbg_insn_rs1 = cached_insn_rs1;
				dbg_insn_rs2 = cached_insn_rs2;
				dbg_insn_rd = cached_insn_rd;
			end else begin
				dbg_ascii_instr = new_ascii_instr;
				if (&next_insn_opcode[1:0])
					dbg_insn_opcode = next_insn_opcode;
				else
					dbg_insn_opcode = {16'b0, next_insn_opcode[15:0]};
				dbg_insn_imm = decoded_imm;
				dbg_insn_rs1 = decoded_rs1;
				dbg_insn_rs2 = decoded_rs2;
				dbg_insn_rd = decoded_rd;
			end
		end
	end

`ifdef DEBUGASM
	always @(posedge clk) begin
		if (dbg_next) begin
			$display("debugasm %x %x %s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "*");
		end
	end
`endif

`ifdef DEBUG
	always @(posedge clk) begin
		if (dbg_next) begin
			if (&dbg_insn_opcode[1:0])
				$display("DECODE: 0x%08x 0x%08x %-0s", dbg_insn_addr, dbg_insn_opcode, dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
			else
				$display("DECODE: 0x%08x     0x%04x %-0s", dbg_insn_addr, dbg_insn_opcode[15:0], dbg_ascii_instr ? dbg_ascii_instr : "UNKNOWN");
		end
	end
`endif

	always @(posedge clk) begin
		is_lui_auipc_jal <= |{instr_lui, instr_auipc, instr_jal};
		is_lui_auipc_jal_jalr_addi_add_sub <= |{instr_lui, instr_auipc, instr_jal, instr_jalr, instr_addi, instr_add, instr_sub};
		is_slti_blt_slt <= |{instr_slti, instr_blt, instr_slt};
		is_sltiu_bltu_sltu <= |{instr_sltiu, instr_bltu, instr_sltu};
		is_lbu_lhu_lw <= |{instr_lbu, instr_lhu, instr_lw};
		is_compare <= |{is_beq_bne_blt_bge_bltu_bgeu, instr_slti, instr_slt, instr_sltiu, instr_sltu};

		if (mem_do_rinst && mem_done) begin
			instr_lui     <= mem_rdata_latched[6:0] == 7'b0110111;
			instr_auipc   <= mem_rdata_latched[6:0] == 7'b0010111;
			instr_jal     <= mem_rdata_latched[6:0] == 7'b1101111;
			instr_jalr    <= mem_rdata_latched[6:0] == 7'b1100111 && mem_rdata_latched[14:12] == 3'b000;
			instr_retirq  <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ;
			instr_waitirq <= mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000100 && ENABLE_IRQ;

			is_beq_bne_blt_bge_bltu_bgeu <= mem_rdata_latched[6:0] == 7'b1100011;
			is_lb_lh_lw_lbu_lhu          <= mem_rdata_latched[6:0] == 7'b0000011;
			is_sb_sh_sw                  <= mem_rdata_latched[6:0] == 7'b0100011;
			is_alu_reg_imm               <= mem_rdata_latched[6:0] == 7'b0010011;
			is_alu_reg_reg               <= mem_rdata_latched[6:0] == 7'b0110011;

			{ decoded_imm_j[31:20], decoded_imm_j[10:1], decoded_imm_j[11], decoded_imm_j[19:12], decoded_imm_j[0] } <= $signed({mem_rdata_latched[31:12], 1'b0});

			decoded_rd <= mem_rdata_latched[11:7];
			decoded_rs1 <= mem_rdata_latched[19:15];
			decoded_rs2 <= mem_rdata_latched[24:20];

			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS)
				decoded_rs1[regindex_bits-1] <= 1; // instr_getq

			if (mem_rdata_latched[6:0] == 7'b0001011 && mem_rdata_latched[31:25] == 7'b0000010 && ENABLE_IRQ)
				decoded_rs1 <= ENABLE_IRQ_QREGS ? irqregs_offset : 3; // instr_retirq

			compressed_instr <= 0;
			if (COMPRESSED_ISA && mem_rdata_latched[1:0] != 2'b11) begin
				compressed_instr <= 1;
				decoded_rd <= 0;
				decoded_rs1 <= 0;
				decoded_rs2 <= 0;

				{ decoded_imm_j[31:11], decoded_imm_j[4], decoded_imm_j[9:8], decoded_imm_j[10], decoded_imm_j[6],
          decoded_imm_j[7], decoded_imm_j[3:1], decoded_imm_j[5], decoded_imm_j[0] } <= $signed({mem_rdata_latched[12:2], 1'b0});

				case (mem_rdata_latched[1:0])
					2'b00: begin // Quadrant 0
						case (mem_rdata_latched[15:13])
							3'b000: begin // C.ADDI4SPN
								is_alu_reg_imm <= |mem_rdata_latched[12:5];
								decoded_rs1 <= 2;
								decoded_rd <= 8 + mem_rdata_latched[4:2];
							end
							3'b010: begin // C.LW
								is_lb_lh_lw_lbu_lhu <= 1;
								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
								decoded_rd <= 8 + mem_rdata_latched[4:2];
							end
							3'b110: begin // C.SW
								is_sb_sh_sw <= 1;
								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
								decoded_rs2 <= 8 + mem_rdata_latched[4:2];
							end
						endcase
					end
					2'b01: begin // Quadrant 1
						case (mem_rdata_latched[15:13])
							3'b000: begin // C.NOP / C.ADDI
								is_alu_reg_imm <= 1;
								decoded_rd <= mem_rdata_latched[11:7];
								decoded_rs1 <= mem_rdata_latched[11:7];
							end
							3'b001: begin // C.JAL
								instr_jal <= 1;
								decoded_rd <= 1;
							end
							3'b 010: begin // C.LI
								is_alu_reg_imm <= 1;
								decoded_rd <= mem_rdata_latched[11:7];
								decoded_rs1 <= 0;
							end
							3'b 011: begin
								if (mem_rdata_latched[12] || mem_rdata_latched[6:2]) begin
									if (mem_rdata_latched[11:7] == 2) begin // C.ADDI16SP
										is_alu_reg_imm <= 1;
										decoded_rd <= mem_rdata_latched[11:7];
										decoded_rs1 <= mem_rdata_latched[11:7];
									end else begin // C.LUI
										instr_lui <= 1;
										decoded_rd <= mem_rdata_latched[11:7];
										decoded_rs1 <= 0;
									end
								end
							end
							3'b100: begin
								if (!mem_rdata_latched[11] && !mem_rdata_latched[12]) begin // C.SRLI, C.SRAI
									is_alu_reg_imm <= 1;
									decoded_rd <= 8 + mem_rdata_latched[9:7];
									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
								end
								if (mem_rdata_latched[11:10] == 2'b10) begin // C.ANDI
									is_alu_reg_imm <= 1;
									decoded_rd <= 8 + mem_rdata_latched[9:7];
									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
								end
								if (mem_rdata_latched[12:10] == 3'b011) begin // C.SUB, C.XOR, C.OR, C.AND
									is_alu_reg_reg <= 1;
									decoded_rd <= 8 + mem_rdata_latched[9:7];
									decoded_rs1 <= 8 + mem_rdata_latched[9:7];
									decoded_rs2 <= 8 + mem_rdata_latched[4:2];
								end
							end
							3'b101: begin // C.J
								instr_jal <= 1;
							end
							3'b110: begin // C.BEQZ
								is_beq_bne_blt_bge_bltu_bgeu <= 1;
								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
								decoded_rs2 <= 0;
							end
							3'b111: begin // C.BNEZ
								is_beq_bne_blt_bge_bltu_bgeu <= 1;
								decoded_rs1 <= 8 + mem_rdata_latched[9:7];
								decoded_rs2 <= 0;
							end
						endcase
					end
					2'b10: begin // Quadrant 2
						case (mem_rdata_latched[15:13])
							3'b000: begin // C.SLLI
								if (!mem_rdata_latched[12]) begin
									is_alu_reg_imm <= 1;
									decoded_rd <= mem_rdata_latched[11:7];
									decoded_rs1 <= mem_rdata_latched[11:7];
									decoded_rs2 <= {mem_rdata_latched[12], mem_rdata_latched[6:2]};
								end
							end
							3'b010: begin // C.LWSP
								if (mem_rdata_latched[11:7]) begin
									is_lb_lh_lw_lbu_lhu <= 1;
									decoded_rd <= mem_rdata_latched[11:7];
									decoded_rs1 <= 2;
								end
							end
							3'b100: begin
								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JR
									instr_jalr <= 1;
									decoded_rd <= 0;
									decoded_rs1 <= mem_rdata_latched[11:7];
								end
								if (mem_rdata_latched[12] == 0 && mem_rdata_latched[6:2] != 0) begin // C.MV
									is_alu_reg_reg <= 1;
									decoded_rd <= mem_rdata_latched[11:7];
									decoded_rs1 <= 0;
									decoded_rs2 <= mem_rdata_latched[6:2];
								end
								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[11:7] != 0 && mem_rdata_latched[6:2] == 0) begin // C.JALR
									instr_jalr <= 1;
									decoded_rd <= 1;
									decoded_rs1 <= mem_rdata_latched[11:7];
								end
								if (mem_rdata_latched[12] != 0 && mem_rdata_latched[6:2] != 0) begin // C.ADD
									is_alu_reg_reg <= 1;
									decoded_rd <= mem_rdata_latched[11:7];
									decoded_rs1 <= mem_rdata_latched[11:7];
									decoded_rs2 <= mem_rdata_latched[6:2];
								end
							end
							3'b110: begin // C.SWSP
								is_sb_sh_sw <= 1;
								decoded_rs1 <= 2;
								decoded_rs2 <= mem_rdata_latched[6:2];
							end
						endcase
					end
				endcase
			end
		end

		if (decoder_trigger && !decoder_pseudo_trigger) begin
			pcpi_insn <= WITH_PCPI ? mem_rdata_q : 'bx;

			instr_beq   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b000;
			instr_bne   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b001;
			instr_blt   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b100;
			instr_bge   <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b101;
			instr_bltu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b110;
			instr_bgeu  <= is_beq_bne_blt_bge_bltu_bgeu && mem_rdata_q[14:12] == 3'b111;

			instr_lb    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b000;
			instr_lh    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b001;
			instr_lw    <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b010;
			instr_lbu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b100;
			instr_lhu   <= is_lb_lh_lw_lbu_lhu && mem_rdata_q[14:12] == 3'b101;

			instr_sb    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b000;
			instr_sh    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b001;
			instr_sw    <= is_sb_sh_sw && mem_rdata_q[14:12] == 3'b010;

			instr_addi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b000;
			instr_slti  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b010;
			instr_sltiu <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b011;
			instr_xori  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b100;
			instr_ori   <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b110;
			instr_andi  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b111;

			instr_slli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
			instr_srli  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
			instr_srai  <= is_alu_reg_imm && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;

			instr_add   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0000000;
			instr_sub   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b000 && mem_rdata_q[31:25] == 7'b0100000;
			instr_sll   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000;
			instr_slt   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b010 && mem_rdata_q[31:25] == 7'b0000000;
			instr_sltu  <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b011 && mem_rdata_q[31:25] == 7'b0000000;
			instr_xor   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b100 && mem_rdata_q[31:25] == 7'b0000000;
			instr_srl   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000;
			instr_sra   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000;
			instr_or    <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b110 && mem_rdata_q[31:25] == 7'b0000000;
			instr_and   <= is_alu_reg_reg && mem_rdata_q[14:12] == 3'b111 && mem_rdata_q[31:25] == 7'b0000000;

			instr_rdcycle  <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000000000010) ||
			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000000100000010)) && ENABLE_COUNTERS;
			instr_rdcycleh <= ((mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000000000010) ||
			                   (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000000100000010)) && ENABLE_COUNTERS && ENABLE_COUNTERS64;
			instr_rdinstr  <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11000000001000000010) && ENABLE_COUNTERS;
			instr_rdinstrh <=  (mem_rdata_q[6:0] == 7'b1110011 && mem_rdata_q[31:12] == 'b11001000001000000010) && ENABLE_COUNTERS && ENABLE_COUNTERS64;

			instr_ecall_ebreak <= ((mem_rdata_q[6:0] == 7'b1110011 && !mem_rdata_q[31:21] && !mem_rdata_q[19:7]) ||
					(COMPRESSED_ISA && mem_rdata_q[15:0] == 16'h9002));
			instr_fence <= (mem_rdata_q[6:0] == 7'b0001111 && !mem_rdata_q[14:12]);

			instr_getq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000000 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
			instr_setq    <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000001 && ENABLE_IRQ && ENABLE_IRQ_QREGS;
			instr_maskirq <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000011 && ENABLE_IRQ;
			instr_timer   <= mem_rdata_q[6:0] == 7'b0001011 && mem_rdata_q[31:25] == 7'b0000101 && ENABLE_IRQ && ENABLE_IRQ_TIMER;

			is_slli_srli_srai <= is_alu_reg_imm && |{
				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
			};

			is_jalr_addi_slti_sltiu_xori_ori_andi <= instr_jalr || is_alu_reg_imm && |{
				mem_rdata_q[14:12] == 3'b000,
				mem_rdata_q[14:12] == 3'b010,
				mem_rdata_q[14:12] == 3'b011,
				mem_rdata_q[14:12] == 3'b100,
				mem_rdata_q[14:12] == 3'b110,
				mem_rdata_q[14:12] == 3'b111
			};

			is_sll_srl_sra <= is_alu_reg_reg && |{
				mem_rdata_q[14:12] == 3'b001 && mem_rdata_q[31:25] == 7'b0000000,
				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0000000,
				mem_rdata_q[14:12] == 3'b101 && mem_rdata_q[31:25] == 7'b0100000
			};

			is_lui_auipc_jal_jalr_addi_add_sub <= 0;
			is_compare <= 0;

			(* parallel_case *)
			case (1'b1)
				instr_jal:
					decoded_imm <= decoded_imm_j;
				|{instr_lui, instr_auipc}:
					decoded_imm <= mem_rdata_q[31:12] << 12;
				|{instr_jalr, is_lb_lh_lw_lbu_lhu, is_alu_reg_imm}:
					decoded_imm <= $signed(mem_rdata_q[31:20]);
				is_beq_bne_blt_bge_bltu_bgeu:
					decoded_imm <= $signed({mem_rdata_q[31], mem_rdata_q[7], mem_rdata_q[30:25], mem_rdata_q[11:8], 1'b0});
				is_sb_sh_sw:
					decoded_imm <= $signed({mem_rdata_q[31:25], mem_rdata_q[11:7]});
				default:
					decoded_imm <= 1'bx;
			endcase
		end

		if (!resetn) begin
			is_beq_bne_blt_bge_bltu_bgeu <= 0;
			is_compare <= 0;

			instr_beq   <= 0;
			instr_bne   <= 0;
			instr_blt   <= 0;
			instr_bge   <= 0;
			instr_bltu  <= 0;
			instr_bgeu  <= 0;

			instr_addi  <= 0;
			instr_slti  <= 0;
			instr_sltiu <= 0;
			instr_xori  <= 0;
			instr_ori   <= 0;
			instr_andi  <= 0;

			instr_add   <= 0;
			instr_sub   <= 0;
			instr_sll   <= 0;
			instr_slt   <= 0;
			instr_sltu  <= 0;
			instr_xor   <= 0;
			instr_srl   <= 0;
			instr_sra   <= 0;
			instr_or    <= 0;
			instr_and   <= 0;

			instr_fence <= 0;
		end
	end


	// Main State Machine

	localparam cpu_state_trap   = 8'b10000000;
	localparam cpu_state_fetch  = 8'b01000000;
	localparam cpu_state_ld_rs1 = 8'b00100000;
	localparam cpu_state_ld_rs2 = 8'b00010000;
	localparam cpu_state_exec   = 8'b00001000;
	localparam cpu_state_shift  = 8'b00000100;
	localparam cpu_state_stmem  = 8'b00000010;
	localparam cpu_state_ldmem  = 8'b00000001;

	reg [7:0] cpu_state;
	reg [1:0] irq_state;

	`FORMAL_KEEP reg [127:0] dbg_ascii_state;

	always @* begin
		dbg_ascii_state = "";
		if (cpu_state == cpu_state_trap)   dbg_ascii_state = "trap";
		if (cpu_state == cpu_state_fetch)  dbg_ascii_state = "fetch";
		if (cpu_state == cpu_state_ld_rs1) dbg_ascii_state = "ld_rs1";
		if (cpu_state == cpu_state_ld_rs2) dbg_ascii_state = "ld_rs2";
		if (cpu_state == cpu_state_exec)   dbg_ascii_state = "exec";
		if (cpu_state == cpu_state_shift)  dbg_ascii_state = "shift";
		if (cpu_state == cpu_state_stmem)  dbg_ascii_state = "stmem";
		if (cpu_state == cpu_state_ldmem)  dbg_ascii_state = "ldmem";
	end

	reg set_mem_do_rinst;
	reg set_mem_do_rdata;
	reg set_mem_do_wdata;

	reg latched_store;
	reg latched_stalu;
	reg latched_branch;
	reg latched_compr;
	reg latched_trace;
	reg latched_is_lu;
	reg latched_is_lh;
	reg latched_is_lb;
	reg [regindex_bits-1:0] latched_rd;

	reg [31:0] current_pc;
	assign next_pc = latched_store && latched_branch ? reg_out & ~1 : reg_next_pc;

	reg [3:0] pcpi_timeout_counter;
	reg pcpi_timeout;

	reg [31:0] next_irq_pending;
	reg do_waitirq;

	reg [31:0] alu_out, alu_out_q;
	reg alu_out_0, alu_out_0_q;
	reg alu_wait, alu_wait_2;

	reg [31:0] alu_add_sub;
	reg [31:0] alu_shl, alu_shr;
	reg alu_eq, alu_ltu, alu_lts;

	generate if (TWO_CYCLE_ALU) begin
		always @(posedge clk) begin
			alu_add_sub <= instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
			alu_eq <= reg_op1 == reg_op2;
			alu_lts <= $signed(reg_op1) < $signed(reg_op2);
			alu_ltu <= reg_op1 < reg_op2;
			alu_shl <= reg_op1 << reg_op2[4:0];
			alu_shr <= $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
		end
	end else begin
		always @* begin
			alu_add_sub = instr_sub ? reg_op1 - reg_op2 : reg_op1 + reg_op2;
			alu_eq = reg_op1 == reg_op2;
			alu_lts = $signed(reg_op1) < $signed(reg_op2);
			alu_ltu = reg_op1 < reg_op2;
			alu_shl = reg_op1 << reg_op2[4:0];
			alu_shr = $signed({instr_sra || instr_srai ? reg_op1[31] : 1'b0, reg_op1}) >>> reg_op2[4:0];
		end
	end endgenerate

	always @* begin
		alu_out_0 = 'bx;
		(* parallel_case, full_case *)
		case (1'b1)
			instr_beq:
				alu_out_0 = alu_eq;
			instr_bne:
				alu_out_0 = !alu_eq;
			instr_bge:
				alu_out_0 = !alu_lts;
			instr_bgeu:
				alu_out_0 = !alu_ltu;
			is_slti_blt_slt && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
				alu_out_0 = alu_lts;
			is_sltiu_bltu_sltu && (!TWO_CYCLE_COMPARE || !{instr_beq,instr_bne,instr_bge,instr_bgeu}):
				alu_out_0 = alu_ltu;
		endcase

		alu_out = 'bx;
		(* parallel_case, full_case *)
		case (1'b1)
			is_lui_auipc_jal_jalr_addi_add_sub:
				alu_out = alu_add_sub;
			is_compare:
				alu_out = alu_out_0;
			instr_xori || instr_xor:
				alu_out = reg_op1 ^ reg_op2;
			instr_ori || instr_or:
				alu_out = reg_op1 | reg_op2;
			instr_andi || instr_and:
				alu_out = reg_op1 & reg_op2;
			BARREL_SHIFTER && (instr_sll || instr_slli):
				alu_out = alu_shl;
			BARREL_SHIFTER && (instr_srl || instr_srli || instr_sra || instr_srai):
				alu_out = alu_shr;
		endcase

`ifdef RISCV_FORMAL_BLACKBOX_ALU
		alu_out_0 = $anyseq;
		alu_out = $anyseq;
`endif
	end

	reg clear_prefetched_high_word_q;
	always @(posedge clk) clear_prefetched_high_word_q <= clear_prefetched_high_word;

	always @* begin
		clear_prefetched_high_word = clear_prefetched_high_word_q;
		if (!prefetched_high_word)
			clear_prefetched_high_word = 0;
		if (latched_branch || irq_state || !resetn)
			clear_prefetched_high_word = COMPRESSED_ISA;
	end

	reg cpuregs_write;
	reg [31:0] cpuregs_wrdata;
	reg [31:0] cpuregs_rs1;
	reg [31:0] cpuregs_rs2;
	reg [regindex_bits-1:0] decoded_rs;

	always @* begin
		cpuregs_write = 0;
		cpuregs_wrdata = 'bx;

		if (cpu_state == cpu_state_fetch) begin
			(* parallel_case *)
			case (1'b1)
				latched_branch: begin
					cpuregs_wrdata = reg_pc + (latched_compr ? 2 : 4);
					cpuregs_write = 1;
				end
				latched_store && !latched_branch: begin
					cpuregs_wrdata = latched_stalu ? alu_out_q : reg_out;
					cpuregs_write = 1;
				end
				ENABLE_IRQ && irq_state[0]: begin
					cpuregs_wrdata = reg_next_pc | latched_compr;
					cpuregs_write = 1;
				end
				ENABLE_IRQ && irq_state[1]: begin
					cpuregs_wrdata = irq_pending & ~irq_mask;
					cpuregs_write = 1;
				end
			endcase
		end
	end

`ifndef PICORV32_REGS
	always @(posedge clk) begin
		if (resetn && cpuregs_write && latched_rd)
`ifdef PICORV32_TESTBUG_001
			cpuregs[latched_rd ^ 1] <= cpuregs_wrdata;
`elsif PICORV32_TESTBUG_002
			cpuregs[latched_rd] <= cpuregs_wrdata ^ 1;
`else
			cpuregs[latched_rd] <= cpuregs_wrdata;
`endif
	end

	always @* begin
		decoded_rs = 'bx;
		if (ENABLE_REGS_DUALPORT) begin
`ifndef RISCV_FORMAL_BLACKBOX_REGS
			cpuregs_rs1 = decoded_rs1 ? cpuregs[decoded_rs1] : 0;
			cpuregs_rs2 = decoded_rs2 ? cpuregs[decoded_rs2] : 0;
`else
			cpuregs_rs1 = decoded_rs1 ? $anyseq : 0;
			cpuregs_rs2 = decoded_rs2 ? $anyseq : 0;
`endif
		end else begin
			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
`ifndef RISCV_FORMAL_BLACKBOX_REGS
			cpuregs_rs1 = decoded_rs ? cpuregs[decoded_rs] : 0;
`else
			cpuregs_rs1 = decoded_rs ? $anyseq : 0;
`endif
			cpuregs_rs2 = cpuregs_rs1;
		end
	end
`else
	wire[31:0] cpuregs_rdata1;
	wire[31:0] cpuregs_rdata2;

	wire [5:0] cpuregs_waddr = latched_rd;
	wire [5:0] cpuregs_raddr1 = ENABLE_REGS_DUALPORT ? decoded_rs1 : decoded_rs;
	wire [5:0] cpuregs_raddr2 = ENABLE_REGS_DUALPORT ? decoded_rs2 : 0;

	`PICORV32_REGS cpuregs (
		.clk(clk),
		.wen(resetn && cpuregs_write && latched_rd),
		.waddr(cpuregs_waddr),
		.raddr1(cpuregs_raddr1),
		.raddr2(cpuregs_raddr2),
		.wdata(cpuregs_wrdata),
		.rdata1(cpuregs_rdata1),
		.rdata2(cpuregs_rdata2)
	);

	always @* begin
		decoded_rs = 'bx;
		if (ENABLE_REGS_DUALPORT) begin
			cpuregs_rs1 = decoded_rs1 ? cpuregs_rdata1 : 0;
			cpuregs_rs2 = decoded_rs2 ? cpuregs_rdata2 : 0;
		end else begin
			decoded_rs = (cpu_state == cpu_state_ld_rs2) ? decoded_rs2 : decoded_rs1;
			cpuregs_rs1 = decoded_rs ? cpuregs_rdata1 : 0;
			cpuregs_rs2 = cpuregs_rs1;
		end
	end
`endif

	assign launch_next_insn = cpu_state == cpu_state_fetch && decoder_trigger && (!ENABLE_IRQ || irq_delay || irq_active || !(irq_pending & ~irq_mask));

	always @(posedge clk) begin
		trap <= 0;
		reg_sh <= 'bx;
		reg_out <= 'bx;
		set_mem_do_rinst = 0;
		set_mem_do_rdata = 0;
		set_mem_do_wdata = 0;

		alu_out_0_q <= alu_out_0;
		alu_out_q <= alu_out;

		alu_wait <= 0;
		alu_wait_2 <= 0;

		if (launch_next_insn) begin
			dbg_rs1val <= 'bx;
			dbg_rs2val <= 'bx;
			dbg_rs1val_valid <= 0;
			dbg_rs2val_valid <= 0;
		end

		if (WITH_PCPI && CATCH_ILLINSN) begin
			if (resetn && pcpi_valid && !pcpi_int_wait) begin
				if (pcpi_timeout_counter)
					pcpi_timeout_counter <= pcpi_timeout_counter - 1;
			end else
				pcpi_timeout_counter <= ~0;
			pcpi_timeout <= !pcpi_timeout_counter;
		end

		if (ENABLE_COUNTERS) begin
			count_cycle <= resetn ? count_cycle + 1 : 0;
			if (!ENABLE_COUNTERS64) count_cycle[63:32] <= 0;
		end else begin
			count_cycle <= 'bx;
			count_instr <= 'bx;
		end

		next_irq_pending = ENABLE_IRQ ? irq_pending & LATCHED_IRQ : 'bx;

		if (ENABLE_IRQ && ENABLE_IRQ_TIMER && timer) begin
			timer <= timer - 1;
		end

		decoder_trigger <= mem_do_rinst && mem_done;
		decoder_trigger_q <= decoder_trigger;
		decoder_pseudo_trigger <= 0;
		decoder_pseudo_trigger_q <= decoder_pseudo_trigger;
		do_waitirq <= 0;

		trace_valid <= 0;

		if (!ENABLE_TRACE)
			trace_data <= 'bx;

		if (!resetn) begin
			reg_pc <= PROGADDR_RESET;
			reg_next_pc <= PROGADDR_RESET;
			if (ENABLE_COUNTERS)
				count_instr <= 0;
			latched_store <= 0;
			latched_stalu <= 0;
			latched_branch <= 0;
			latched_trace <= 0;
			latched_is_lu <= 0;
			latched_is_lh <= 0;
			latched_is_lb <= 0;
			pcpi_valid <= 0;
			pcpi_timeout <= 0;
			irq_active <= 0;
			irq_delay <= 0;
			irq_mask <= ~0;
			next_irq_pending = 0;
			irq_state <= 0;
			eoi <= 0;
			timer <= 0;
			if (~STACKADDR) begin
				latched_store <= 1;
				latched_rd <= 2;
				reg_out <= STACKADDR;
			end
			cpu_state <= cpu_state_fetch;
		end else
		(* parallel_case, full_case *)
		case (cpu_state)
			cpu_state_trap: begin
				trap <= 1;
			end

			cpu_state_fetch: begin
				mem_do_rinst <= !decoder_trigger && !do_waitirq;
				mem_wordsize <= 0;

				current_pc = reg_next_pc;

				(* parallel_case *)
				case (1'b1)
					latched_branch: begin
						current_pc = latched_store ? (latched_stalu ? alu_out_q : reg_out) & ~1 : reg_next_pc;
						`debug($display("ST_RD:  %2d 0x%08x, BRANCH 0x%08x", latched_rd, reg_pc + (latched_compr ? 2 : 4), current_pc);)
					end
					latched_store && !latched_branch: begin
						`debug($display("ST_RD:  %2d 0x%08x", latched_rd, latched_stalu ? alu_out_q : reg_out);)
					end
					ENABLE_IRQ && irq_state[0]: begin
						current_pc = PROGADDR_IRQ;
						irq_active <= 1;
						mem_do_rinst <= 1;
					end
					ENABLE_IRQ && irq_state[1]: begin
						eoi <= irq_pending & ~irq_mask;
						next_irq_pending = next_irq_pending & irq_mask;
					end
				endcase

				if (ENABLE_TRACE && latched_trace) begin
					latched_trace <= 0;
					trace_valid <= 1;
					if (latched_branch)
						trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_BRANCH | (current_pc & 32'hfffffffe);
					else
						trace_data <= (irq_active ? TRACE_IRQ : 0) | (latched_stalu ? alu_out_q : reg_out);
				end

				reg_pc <= current_pc;
				reg_next_pc <= current_pc;

				latched_store <= 0;
				latched_stalu <= 0;
				latched_branch <= 0;
				latched_is_lu <= 0;
				latched_is_lh <= 0;
				latched_is_lb <= 0;
				latched_rd <= decoded_rd;
				latched_compr <= compressed_instr;

				if (ENABLE_IRQ && ((decoder_trigger && !irq_active && !irq_delay && |(irq_pending & ~irq_mask)) || irq_state)) begin
					irq_state <=
						irq_state == 2'b00 ? 2'b01 :
						irq_state == 2'b01 ? 2'b10 : 2'b00;
					latched_compr <= latched_compr;
					if (ENABLE_IRQ_QREGS)
						latched_rd <= irqregs_offset | irq_state[0];
					else
						latched_rd <= irq_state[0] ? 4 : 3;
				end else
				if (ENABLE_IRQ && (decoder_trigger || do_waitirq) && instr_waitirq) begin
					if (irq_pending) begin
						latched_store <= 1;
						reg_out <= irq_pending;
						reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
						mem_do_rinst <= 1;
					end else
						do_waitirq <= 1;
				end else
				if (decoder_trigger) begin
					`debug($display("-- %-0t", $time);)
					irq_delay <= irq_active;
					reg_next_pc <= current_pc + (compressed_instr ? 2 : 4);
					if (ENABLE_TRACE)
						latched_trace <= 1;
					if (ENABLE_COUNTERS) begin
						count_instr <= count_instr + 1;
						if (!ENABLE_COUNTERS64) count_instr[63:32] <= 0;
					end
					if (instr_jal) begin
						mem_do_rinst <= 1;
						reg_next_pc <= current_pc + decoded_imm_j;
						latched_branch <= 1;
					end else begin
						mem_do_rinst <= 0;
						mem_do_prefetch <= !instr_jalr && !instr_retirq;
						cpu_state <= cpu_state_ld_rs1;
					end
				end
			end

			cpu_state_ld_rs1: begin
				reg_op1 <= 'bx;
				reg_op2 <= 'bx;

				(* parallel_case *)
				case (1'b1)
					(CATCH_ILLINSN || WITH_PCPI) && instr_trap: begin
						if (WITH_PCPI) begin
							`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
							reg_op1 <= cpuregs_rs1;
							dbg_rs1val <= cpuregs_rs1;
							dbg_rs1val_valid <= 1;
							if (ENABLE_REGS_DUALPORT) begin
								pcpi_valid <= 1;
								`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
								reg_sh <= cpuregs_rs2;
								reg_op2 <= cpuregs_rs2;
								dbg_rs2val <= cpuregs_rs2;
								dbg_rs2val_valid <= 1;
								if (pcpi_int_ready) begin
									mem_do_rinst <= 1;
									pcpi_valid <= 0;
									reg_out <= pcpi_int_rd;
									latched_store <= pcpi_int_wr;
									cpu_state <= cpu_state_fetch;
								end else
								if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
									pcpi_valid <= 0;
									`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
									if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
										next_irq_pending[irq_ebreak] = 1;
										cpu_state <= cpu_state_fetch;
									end else
										cpu_state <= cpu_state_trap;
								end
							end else begin
								cpu_state <= cpu_state_ld_rs2;
							end
						end else begin
							`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
								next_irq_pending[irq_ebreak] = 1;
								cpu_state <= cpu_state_fetch;
							end else
								cpu_state <= cpu_state_trap;
						end
					end
					ENABLE_COUNTERS && is_rdcycle_rdcycleh_rdinstr_rdinstrh: begin
						(* parallel_case, full_case *)
						case (1'b1)
							instr_rdcycle:
								reg_out <= count_cycle[31:0];
							instr_rdcycleh && ENABLE_COUNTERS64:
								reg_out <= count_cycle[63:32];
							instr_rdinstr:
								reg_out <= count_instr[31:0];
							instr_rdinstrh && ENABLE_COUNTERS64:
								reg_out <= count_instr[63:32];
						endcase
						latched_store <= 1;
						cpu_state <= cpu_state_fetch;
					end
					is_lui_auipc_jal: begin
						reg_op1 <= instr_lui ? 0 : reg_pc;
						reg_op2 <= decoded_imm;
						if (TWO_CYCLE_ALU)
							alu_wait <= 1;
						else
							mem_do_rinst <= mem_do_prefetch;
						cpu_state <= cpu_state_exec;
					end
					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_getq: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_out <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						latched_store <= 1;
						cpu_state <= cpu_state_fetch;
					end
					ENABLE_IRQ && ENABLE_IRQ_QREGS && instr_setq: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_out <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						latched_rd <= latched_rd | irqregs_offset;
						latched_store <= 1;
						cpu_state <= cpu_state_fetch;
					end
					ENABLE_IRQ && instr_retirq: begin
						eoi <= 0;
						irq_active <= 0;
						latched_branch <= 1;
						latched_store <= 1;
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_out <= CATCH_MISALIGN ? (cpuregs_rs1 & 32'h fffffffe) : cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						cpu_state <= cpu_state_fetch;
					end
					ENABLE_IRQ && instr_maskirq: begin
						latched_store <= 1;
						reg_out <= irq_mask;
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						irq_mask <= cpuregs_rs1 | MASKED_IRQ;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						cpu_state <= cpu_state_fetch;
					end
					ENABLE_IRQ && ENABLE_IRQ_TIMER && instr_timer: begin
						latched_store <= 1;
						reg_out <= timer;
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						timer <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						cpu_state <= cpu_state_fetch;
					end
					is_lb_lh_lw_lbu_lhu && !instr_trap: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_op1 <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						cpu_state <= cpu_state_ldmem;
						mem_do_rinst <= 1;
					end
					is_slli_srli_srai && !BARREL_SHIFTER: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_op1 <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						reg_sh <= decoded_rs2;
						cpu_state <= cpu_state_shift;
					end
					is_jalr_addi_slti_sltiu_xori_ori_andi, is_slli_srli_srai && BARREL_SHIFTER: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_op1 <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						reg_op2 <= is_slli_srli_srai && BARREL_SHIFTER ? decoded_rs2 : decoded_imm;
						if (TWO_CYCLE_ALU)
							alu_wait <= 1;
						else
							mem_do_rinst <= mem_do_prefetch;
						cpu_state <= cpu_state_exec;
					end
					default: begin
						`debug($display("LD_RS1: %2d 0x%08x", decoded_rs1, cpuregs_rs1);)
						reg_op1 <= cpuregs_rs1;
						dbg_rs1val <= cpuregs_rs1;
						dbg_rs1val_valid <= 1;
						if (ENABLE_REGS_DUALPORT) begin
							`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
							reg_sh <= cpuregs_rs2;
							reg_op2 <= cpuregs_rs2;
							dbg_rs2val <= cpuregs_rs2;
							dbg_rs2val_valid <= 1;
							(* parallel_case *)
							case (1'b1)
								is_sb_sh_sw: begin
									cpu_state <= cpu_state_stmem;
									mem_do_rinst <= 1;
								end
								is_sll_srl_sra && !BARREL_SHIFTER: begin
									cpu_state <= cpu_state_shift;
								end
								default: begin
									if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
										alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
										alu_wait <= 1;
									end else
										mem_do_rinst <= mem_do_prefetch;
									cpu_state <= cpu_state_exec;
								end
							endcase
						end else
							cpu_state <= cpu_state_ld_rs2;
					end
				endcase
			end

			cpu_state_ld_rs2: begin
				`debug($display("LD_RS2: %2d 0x%08x", decoded_rs2, cpuregs_rs2);)
				reg_sh <= cpuregs_rs2;
				reg_op2 <= cpuregs_rs2;
				dbg_rs2val <= cpuregs_rs2;
				dbg_rs2val_valid <= 1;

				(* parallel_case *)
				case (1'b1)
					WITH_PCPI && instr_trap: begin
						pcpi_valid <= 1;
						if (pcpi_int_ready) begin
							mem_do_rinst <= 1;
							pcpi_valid <= 0;
							reg_out <= pcpi_int_rd;
							latched_store <= pcpi_int_wr;
							cpu_state <= cpu_state_fetch;
						end else
						if (CATCH_ILLINSN && (pcpi_timeout || instr_ecall_ebreak)) begin
							pcpi_valid <= 0;
							`debug($display("EBREAK OR UNSUPPORTED INSN AT 0x%08x", reg_pc);)
							if (ENABLE_IRQ && !irq_mask[irq_ebreak] && !irq_active) begin
								next_irq_pending[irq_ebreak] = 1;
								cpu_state <= cpu_state_fetch;
							end else
								cpu_state <= cpu_state_trap;
						end
					end
					is_sb_sh_sw: begin
						cpu_state <= cpu_state_stmem;
						mem_do_rinst <= 1;
					end
					is_sll_srl_sra && !BARREL_SHIFTER: begin
						cpu_state <= cpu_state_shift;
					end
					default: begin
						if (TWO_CYCLE_ALU || (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu)) begin
							alu_wait_2 <= TWO_CYCLE_ALU && (TWO_CYCLE_COMPARE && is_beq_bne_blt_bge_bltu_bgeu);
							alu_wait <= 1;
						end else
							mem_do_rinst <= mem_do_prefetch;
						cpu_state <= cpu_state_exec;
					end
				endcase
			end

			cpu_state_exec: begin
				reg_out <= reg_pc + decoded_imm;
				if ((TWO_CYCLE_ALU || TWO_CYCLE_COMPARE) && (alu_wait || alu_wait_2)) begin
					mem_do_rinst <= mem_do_prefetch && !alu_wait_2;
					alu_wait <= alu_wait_2;
				end else
				if (is_beq_bne_blt_bge_bltu_bgeu) begin
					latched_rd <= 0;
					latched_store <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
					latched_branch <= TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0;
					if (mem_done)
						cpu_state <= cpu_state_fetch;
					if (TWO_CYCLE_COMPARE ? alu_out_0_q : alu_out_0) begin
						decoder_trigger <= 0;
						set_mem_do_rinst = 1;
					end
				end else begin
					latched_branch <= instr_jalr;
					latched_store <= 1;
					latched_stalu <= 1;
					cpu_state <= cpu_state_fetch;
				end
			end

			cpu_state_shift: begin
				latched_store <= 1;
				if (reg_sh == 0) begin
					reg_out <= reg_op1;
					mem_do_rinst <= mem_do_prefetch;
					cpu_state <= cpu_state_fetch;
				end else if (TWO_STAGE_SHIFT && reg_sh >= 4) begin
					(* parallel_case, full_case *)
					case (1'b1)
						instr_slli || instr_sll: reg_op1 <= reg_op1 << 4;
						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 4;
						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 4;
					endcase
					reg_sh <= reg_sh - 4;
				end else begin
					(* parallel_case, full_case *)
					case (1'b1)
						instr_slli || instr_sll: reg_op1 <= reg_op1 << 1;
						instr_srli || instr_srl: reg_op1 <= reg_op1 >> 1;
						instr_srai || instr_sra: reg_op1 <= $signed(reg_op1) >>> 1;
					endcase
					reg_sh <= reg_sh - 1;
				end
			end

			cpu_state_stmem: begin
				if (ENABLE_TRACE)
					reg_out <= reg_op2;
				if (!mem_do_prefetch || mem_done) begin
					if (!mem_do_wdata) begin
						(* parallel_case, full_case *)
						case (1'b1)
							instr_sb: mem_wordsize <= 2;
							instr_sh: mem_wordsize <= 1;
							instr_sw: mem_wordsize <= 0;
						endcase
						if (ENABLE_TRACE) begin
							trace_valid <= 1;
							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
						end
						reg_op1 <= reg_op1 + decoded_imm;
						set_mem_do_wdata = 1;
					end
					if (!mem_do_prefetch && mem_done) begin
						cpu_state <= cpu_state_fetch;
						decoder_trigger <= 1;
						decoder_pseudo_trigger <= 1;
					end
				end
			end

			cpu_state_ldmem: begin
				latched_store <= 1;
				if (!mem_do_prefetch || mem_done) begin
					if (!mem_do_rdata) begin
						(* parallel_case, full_case *)
						case (1'b1)
							instr_lb || instr_lbu: mem_wordsize <= 2;
							instr_lh || instr_lhu: mem_wordsize <= 1;
							instr_lw: mem_wordsize <= 0;
						endcase
						latched_is_lu <= is_lbu_lhu_lw;
						latched_is_lh <= instr_lh;
						latched_is_lb <= instr_lb;
						if (ENABLE_TRACE) begin
							trace_valid <= 1;
							trace_data <= (irq_active ? TRACE_IRQ : 0) | TRACE_ADDR | ((reg_op1 + decoded_imm) & 32'hffffffff);
						end
						reg_op1 <= reg_op1 + decoded_imm;
						set_mem_do_rdata = 1;
					end
					if (!mem_do_prefetch && mem_done) begin
						(* parallel_case, full_case *)
						case (1'b1)
							latched_is_lu: reg_out <= mem_rdata_word;
							latched_is_lh: reg_out <= $signed(mem_rdata_word[15:0]);
							latched_is_lb: reg_out <= $signed(mem_rdata_word[7:0]);
						endcase
						decoder_trigger <= 1;
						decoder_pseudo_trigger <= 1;
						cpu_state <= cpu_state_fetch;
					end
				end
			end
		endcase

		if (ENABLE_IRQ) begin
			next_irq_pending = next_irq_pending | irq;
			if(ENABLE_IRQ_TIMER && timer)
				if (timer - 1 == 0)
					next_irq_pending[irq_timer] = 1;
		end

		if (CATCH_MISALIGN && resetn && (mem_do_rdata || mem_do_wdata)) begin
			if (mem_wordsize == 0 && reg_op1[1:0] != 0) begin
				`debug($display("MISALIGNED WORD: 0x%08x", reg_op1);)
				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
					next_irq_pending[irq_buserror] = 1;
				end else
					cpu_state <= cpu_state_trap;
			end
			if (mem_wordsize == 1 && reg_op1[0] != 0) begin
				`debug($display("MISALIGNED HALFWORD: 0x%08x", reg_op1);)
				if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
					next_irq_pending[irq_buserror] = 1;
				end else
					cpu_state <= cpu_state_trap;
			end
		end
		if (CATCH_MISALIGN && resetn && mem_do_rinst && (COMPRESSED_ISA ? reg_pc[0] : |reg_pc[1:0])) begin
			`debug($display("MISALIGNED INSTRUCTION: 0x%08x", reg_pc);)
			if (ENABLE_IRQ && !irq_mask[irq_buserror] && !irq_active) begin
				next_irq_pending[irq_buserror] = 1;
			end else
				cpu_state <= cpu_state_trap;
		end
		if (!CATCH_ILLINSN && decoder_trigger_q && !decoder_pseudo_trigger_q && instr_ecall_ebreak) begin
			cpu_state <= cpu_state_trap;
		end

		if (!resetn || mem_done) begin
			mem_do_prefetch <= 0;
			mem_do_rinst <= 0;
			mem_do_rdata <= 0;
			mem_do_wdata <= 0;
		end

		if (set_mem_do_rinst)
			mem_do_rinst <= 1;
		if (set_mem_do_rdata)
			mem_do_rdata <= 1;
		if (set_mem_do_wdata)
			mem_do_wdata <= 1;

		irq_pending <= next_irq_pending & ~MASKED_IRQ;

		if (!CATCH_MISALIGN) begin
			if (COMPRESSED_ISA) begin
				reg_pc[0] <= 0;
				reg_next_pc[0] <= 0;
			end else begin
				reg_pc[1:0] <= 0;
				reg_next_pc[1:0] <= 0;
			end
		end
		current_pc = 'bx;
	end

`ifdef RISCV_FORMAL
	reg dbg_irq_call;
	reg dbg_irq_enter;
	reg [31:0] dbg_irq_ret;
	always @(posedge clk) begin
		rvfi_valid <= resetn && (launch_next_insn || trap) && dbg_valid_insn;
		rvfi_order <= resetn ? rvfi_order + rvfi_valid : 0;

		rvfi_insn <= dbg_insn_opcode;
		rvfi_rs1_addr <= dbg_rs1val_valid ? dbg_insn_rs1 : 0;
		rvfi_rs2_addr <= dbg_rs2val_valid ? dbg_insn_rs2 : 0;
		rvfi_pc_rdata <= dbg_insn_addr;
		rvfi_rs1_rdata <= dbg_rs1val_valid ? dbg_rs1val : 0;
		rvfi_rs2_rdata <= dbg_rs2val_valid ? dbg_rs2val : 0;
		rvfi_trap <= trap;
		rvfi_halt <= trap;
		rvfi_intr <= dbg_irq_enter;
		rvfi_mode <= 3;
		rvfi_ixl <= 1;

		if (!resetn) begin
			dbg_irq_call <= 0;
			dbg_irq_enter <= 0;
		end else
		if (rvfi_valid) begin
			dbg_irq_call <= 0;
			dbg_irq_enter <= dbg_irq_call;
		end else
		if (irq_state == 1) begin
			dbg_irq_call <= 1;
			dbg_irq_ret <= next_pc;
		end

		if (!resetn) begin
			rvfi_rd_addr <= 0;
			rvfi_rd_wdata <= 0;
		end else
		if (cpuregs_write && !irq_state) begin
`ifdef PICORV32_TESTBUG_003
			rvfi_rd_addr <= latched_rd ^ 1;
`else
			rvfi_rd_addr <= latched_rd;
`endif
`ifdef PICORV32_TESTBUG_004
			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata ^ 1 : 0;
`else
			rvfi_rd_wdata <= latched_rd ? cpuregs_wrdata : 0;
`endif
		end else
		if (rvfi_valid) begin
			rvfi_rd_addr <= 0;
			rvfi_rd_wdata <= 0;
		end

		casez (dbg_insn_opcode)
			32'b 0000000_?????_000??_???_?????_0001011: begin // getq
				rvfi_rs1_addr <= 0;
				rvfi_rs1_rdata <= 0;
			end
			32'b 0000001_?????_?????_???_000??_0001011: begin // setq
				rvfi_rd_addr <= 0;
				rvfi_rd_wdata <= 0;
			end
			32'b 0000010_?????_00000_???_00000_0001011: begin // retirq
				rvfi_rs1_addr <= 0;
				rvfi_rs1_rdata <= 0;
			end
		endcase

		if (!dbg_irq_call) begin
			if (dbg_mem_instr) begin
				rvfi_mem_addr <= 0;
				rvfi_mem_rmask <= 0;
				rvfi_mem_wmask <= 0;
				rvfi_mem_rdata <= 0;
				rvfi_mem_wdata <= 0;
			end else
			if (dbg_mem_valid && dbg_mem_ready) begin
				rvfi_mem_addr <= dbg_mem_addr;
				rvfi_mem_rmask <= dbg_mem_wstrb ? 0 : ~0;
				rvfi_mem_wmask <= dbg_mem_wstrb;
				rvfi_mem_rdata <= dbg_mem_rdata;
				rvfi_mem_wdata <= dbg_mem_wdata;
			end
		end
	end

	always @* begin
`ifdef PICORV32_TESTBUG_005
		rvfi_pc_wdata = (dbg_irq_call ? dbg_irq_ret : dbg_insn_addr) ^ 4;
`else
		rvfi_pc_wdata = dbg_irq_call ? dbg_irq_ret : dbg_insn_addr;
`endif

		rvfi_csr_mcycle_rmask = 0;
		rvfi_csr_mcycle_wmask = 0;
		rvfi_csr_mcycle_rdata = 0;
		rvfi_csr_mcycle_wdata = 0;

		rvfi_csr_minstret_rmask = 0;
		rvfi_csr_minstret_wmask = 0;
		rvfi_csr_minstret_rdata = 0;
		rvfi_csr_minstret_wdata = 0;

		if (rvfi_valid && rvfi_insn[6:0] == 7'b 1110011 && rvfi_insn[13:12] == 3'b010) begin
			if (rvfi_insn[31:20] == 12'h C00) begin
				rvfi_csr_mcycle_rmask = 64'h 0000_0000_FFFF_FFFF;
				rvfi_csr_mcycle_rdata = {32'h 0000_0000, rvfi_rd_wdata};
			end
			if (rvfi_insn[31:20] == 12'h C80) begin
				rvfi_csr_mcycle_rmask = 64'h FFFF_FFFF_0000_0000;
				rvfi_csr_mcycle_rdata = {rvfi_rd_wdata, 32'h 0000_0000};
			end
			if (rvfi_insn[31:20] == 12'h C02) begin
				rvfi_csr_minstret_rmask = 64'h 0000_0000_FFFF_FFFF;
				rvfi_csr_minstret_rdata = {32'h 0000_0000, rvfi_rd_wdata};
			end
			if (rvfi_insn[31:20] == 12'h C82) begin
				rvfi_csr_minstret_rmask = 64'h FFFF_FFFF_0000_0000;
				rvfi_csr_minstret_rdata = {rvfi_rd_wdata, 32'h 0000_0000};
			end
		end
	end
`endif

	// Formal Verification
`ifdef FORMAL
	reg [3:0] last_mem_nowait;
	always @(posedge clk)
		last_mem_nowait <= {last_mem_nowait, mem_ready || !mem_valid};

	// stall the memory interface for max 4 cycles
	restrict property (|last_mem_nowait || mem_ready || !mem_valid);

	// resetn low in first cycle, after that resetn high
	restrict property (resetn != $initstate);

	// this just makes it much easier to read traces. uncomment as needed.
	// assume property (mem_valid || !mem_ready);

	reg ok;
	always @* begin
		if (resetn) begin
			// instruction fetches are read-only
			if (mem_valid && mem_instr)
				assert (mem_wstrb == 0);

			// cpu_state must be valid
			ok = 0;
			if (cpu_state == cpu_state_trap)   ok = 1;
			if (cpu_state == cpu_state_fetch)  ok = 1;
			if (cpu_state == cpu_state_ld_rs1) ok = 1;
			if (cpu_state == cpu_state_ld_rs2) ok = !ENABLE_REGS_DUALPORT;
			if (cpu_state == cpu_state_exec)   ok = 1;
			if (cpu_state == cpu_state_shift)  ok = 1;
			if (cpu_state == cpu_state_stmem)  ok = 1;
			if (cpu_state == cpu_state_ldmem)  ok = 1;
			assert (ok);
		end
	end

	reg last_mem_la_read = 0;
	reg last_mem_la_write = 0;
	reg [31:0] last_mem_la_addr;
	reg [31:0] last_mem_la_wdata;
	reg [3:0] last_mem_la_wstrb = 0;

	always @(posedge clk) begin
		last_mem_la_read <= mem_la_read;
		last_mem_la_write <= mem_la_write;
		last_mem_la_addr <= mem_la_addr;
		last_mem_la_wdata <= mem_la_wdata;
		last_mem_la_wstrb <= mem_la_wstrb;

		if (last_mem_la_read) begin
			assert(mem_valid);
			assert(mem_addr == last_mem_la_addr);
			assert(mem_wstrb == 0);
		end
		if (last_mem_la_write) begin
			assert(mem_valid);
			assert(mem_addr == last_mem_la_addr);
			assert(mem_wdata == last_mem_la_wdata);
			assert(mem_wstrb == last_mem_la_wstrb);
		end
		if (mem_la_read || mem_la_write) begin
			assert(!mem_valid || mem_ready);
		end
	end
`endif
endmodule
*/
};























// This is a simple example implementation of PICORV32_REGS.
// Use the PICORV32_REGS mechanism if you want to use custom
// memory resources to implement the processor register file.
// Note that your implementation must match the requirements of
// the PicoRV32 configuration. (e.g. QREGS, etc)

class picorv32_regs {
public:

  void tick (
    logic<1>  wen,
    logic<6>  waddr,
    logic<6>  raddr1,
    logic<6>  raddr2,
    logic<32> wdata) {

    if (wen) regs[b5(~waddr)] = wdata;
    rdata1 = regs[b5(~raddr1)];
    rdata2 = regs[b5(~raddr2)];
  }

  logic<32> get_rdata1() { return rdata1; }
  logic<32> get_rdata2() { return rdata2; }

private:

  logic<32> rdata1;
  logic<32> rdata2;
  logic<32> regs[31];
};











































//==============================================================================
// picorv32_pcpi_mul
//==============================================================================

/*
module picorv32_pcpi_mul #(
	parameter STEPS_AT_ONCE = 1,
	parameter CARRY_CHAIN = 4
) (
	input clk, resetn,

	input             pcpi_valid,
	input      [31:0] pcpi_insn,
	input      [31:0] pcpi_rs1,
	input      [31:0] pcpi_rs2,
	output reg        pcpi_wr,
	output reg [31:0] pcpi_rd,
	output reg        pcpi_wait,
	output reg        pcpi_ready
);
	reg instr_mul, instr_mulh, instr_mulhsu, instr_mulhu;
	wire instr_any_mul = |{instr_mul, instr_mulh, instr_mulhsu, instr_mulhu};
	wire instr_any_mulh = |{instr_mulh, instr_mulhsu, instr_mulhu};
	wire instr_rs1_signed = |{instr_mulh, instr_mulhsu};
	wire instr_rs2_signed = |{instr_mulh};

	reg pcpi_wait_q;
	wire mul_start = pcpi_wait && !pcpi_wait_q;

	always @(posedge clk) begin
		instr_mul <= 0;
		instr_mulh <= 0;
		instr_mulhsu <= 0;
		instr_mulhu <= 0;

		if (resetn && pcpi_valid && pcpi_insn[6:0] == 7'b0110011 && pcpi_insn[31:25] == 7'b0000001) begin
			case (pcpi_insn[14:12])
				3'b000: instr_mul <= 1;
				3'b001: instr_mulh <= 1;
				3'b010: instr_mulhsu <= 1;
				3'b011: instr_mulhu <= 1;
			endcase
		end

		pcpi_wait <= instr_any_mul;
		pcpi_wait_q <= pcpi_wait;
	end

	reg [63:0] rs1, rs2, rd, rdx;
	reg [63:0] next_rs1, next_rs2, this_rs2;
	reg [63:0] next_rd, next_rdx, next_rdt;
	reg [6:0] mul_counter;
	reg mul_waiting;
	reg mul_finish;
	integer i, j;

	// carry save accumulator
	always @* begin
		next_rd = rd;
		next_rdx = rdx;
		next_rs1 = rs1;
		next_rs2 = rs2;

		for (i = 0; i < STEPS_AT_ONCE; i=i+1) begin
			this_rs2 = next_rs1[0] ? next_rs2 : 0;
			if (CARRY_CHAIN == 0) begin
				next_rdt = next_rd ^ next_rdx ^ this_rs2;
				next_rdx = ((next_rd & next_rdx) | (next_rd & this_rs2) | (next_rdx & this_rs2)) << 1;
				next_rd = next_rdt;
			end else begin
				next_rdt = 0;
				for (j = 0; j < 64; j = j + CARRY_CHAIN)
					{next_rdt[j+CARRY_CHAIN-1], next_rd[j +: CARRY_CHAIN]} =
							next_rd[j +: CARRY_CHAIN] + next_rdx[j +: CARRY_CHAIN] + this_rs2[j +: CARRY_CHAIN];
				next_rdx = next_rdt << 1;
			end
			next_rs1 = next_rs1 >> 1;
			next_rs2 = next_rs2 << 1;
		end
	end

	always @(posedge clk) begin
		mul_finish <= 0;
		if (!resetn) begin
			mul_waiting <= 1;
		end else
		if (mul_waiting) begin
			if (instr_rs1_signed)
				rs1 <= $signed(pcpi_rs1);
			else
				rs1 <= $unsigned(pcpi_rs1);

			if (instr_rs2_signed)
				rs2 <= $signed(pcpi_rs2);
			else
				rs2 <= $unsigned(pcpi_rs2);

			rd <= 0;
			rdx <= 0;
			mul_counter <= (instr_any_mulh ? 63 - STEPS_AT_ONCE : 31 - STEPS_AT_ONCE);
			mul_waiting <= !mul_start;
		end else begin
			rd <= next_rd;
			rdx <= next_rdx;
			rs1 <= next_rs1;
			rs2 <= next_rs2;

			mul_counter <= mul_counter - STEPS_AT_ONCE;
			if (mul_counter[6]) begin
				mul_finish <= 1;
				mul_waiting <= 1;
			end
		end
	end

	always @(posedge clk) begin
		pcpi_wr <= 0;
		pcpi_ready <= 0;
		if (mul_finish && resetn) begin
			pcpi_wr <= 1;
			pcpi_ready <= 1;
			pcpi_rd <= instr_any_mulh ? rd >> 32 : rd;
		end
	end
endmodule

module picorv32_pcpi_fast_mul #(
	parameter EXTRA_MUL_FFS = 0,
	parameter EXTRA_INSN_FFS = 0,
	parameter MUL_CLKGATE = 0
) (
	input clk, resetn,

	input             pcpi_valid,
	input      [31:0] pcpi_insn,
	input      [31:0] pcpi_rs1,
	input      [31:0] pcpi_rs2,
	output            pcpi_wr,
	output     [31:0] pcpi_rd,
	output            pcpi_wait,
	output            pcpi_ready
);
	reg instr_mul, instr_mulh, instr_mulhsu, instr_mulhu;
	wire instr_any_mul = |{instr_mul, instr_mulh, instr_mulhsu, instr_mulhu};
	wire instr_any_mulh = |{instr_mulh, instr_mulhsu, instr_mulhu};
	wire instr_rs1_signed = |{instr_mulh, instr_mulhsu};
	wire instr_rs2_signed = |{instr_mulh};

	reg shift_out;
	reg [3:0] active;
	reg [32:0] rs1, rs2, rs1_q, rs2_q;
	reg [63:0] rd, rd_q;

	wire pcpi_insn_valid = pcpi_valid && pcpi_insn[6:0] == 7'b0110011 && pcpi_insn[31:25] == 7'b0000001;
	reg pcpi_insn_valid_q;

	always @* begin
		instr_mul = 0;
		instr_mulh = 0;
		instr_mulhsu = 0;
		instr_mulhu = 0;

		if (resetn && (EXTRA_INSN_FFS ? pcpi_insn_valid_q : pcpi_insn_valid)) begin
			case (pcpi_insn[14:12])
				3'b000: instr_mul = 1;
				3'b001: instr_mulh = 1;
				3'b010: instr_mulhsu = 1;
				3'b011: instr_mulhu = 1;
			endcase
		end
	end

	always @(posedge clk) begin
		pcpi_insn_valid_q <= pcpi_insn_valid;
		if (!MUL_CLKGATE || active[0]) begin
			rs1_q <= rs1;
			rs2_q <= rs2;
		end
		if (!MUL_CLKGATE || active[1]) begin
			rd <= $signed(EXTRA_MUL_FFS ? rs1_q : rs1) * $signed(EXTRA_MUL_FFS ? rs2_q : rs2);
		end
		if (!MUL_CLKGATE || active[2]) begin
			rd_q <= rd;
		end
	end

	always @(posedge clk) begin
		if (instr_any_mul && !(EXTRA_MUL_FFS ? active[3:0] : active[1:0])) begin
			if (instr_rs1_signed)
				rs1 <= $signed(pcpi_rs1);
			else
				rs1 <= $unsigned(pcpi_rs1);

			if (instr_rs2_signed)
				rs2 <= $signed(pcpi_rs2);
			else
				rs2 <= $unsigned(pcpi_rs2);
			active[0] <= 1;
		end else begin
			active[0] <= 0;
		end

		active[3:1] <= active;
		shift_out <= instr_any_mulh;

		if (!resetn)
			active <= 0;
	end

	assign pcpi_wr = active[EXTRA_MUL_FFS ? 3 : 1];
	assign pcpi_wait = 0;
	assign pcpi_ready = active[EXTRA_MUL_FFS ? 3 : 1];
`ifdef RISCV_FORMAL_ALTOPS
	assign pcpi_rd =
			instr_mul    ? (pcpi_rs1 + pcpi_rs2) ^ 32'h5876063e :
			instr_mulh   ? (pcpi_rs1 + pcpi_rs2) ^ 32'hf6583fb7 :
			instr_mulhsu ? (pcpi_rs1 - pcpi_rs2) ^ 32'hecfbe137 :
			instr_mulhu  ? (pcpi_rs1 + pcpi_rs2) ^ 32'h949ce5e8 : 1'bx;
`else
	assign pcpi_rd = shift_out ? (EXTRA_MUL_FFS ? rd_q : rd) >> 32 : (EXTRA_MUL_FFS ? rd_q : rd);
`endif
endmodule
*/








































//==============================================================================
// picorv32_pcpi_div
//==============================================================================

/*
module picorv32_pcpi_div (
	input clk, resetn,

	input             pcpi_valid,
	input      [31:0] pcpi_insn,
	input      [31:0] pcpi_rs1,
	input      [31:0] pcpi_rs2,
	output reg        pcpi_wr,
	output reg [31:0] pcpi_rd,
	output reg        pcpi_wait,
	output reg        pcpi_ready
);
	reg instr_div, instr_divu, instr_rem, instr_remu;
	wire instr_any_div_rem = |{instr_div, instr_divu, instr_rem, instr_remu};

	reg pcpi_wait_q;
	wire start = pcpi_wait && !pcpi_wait_q;

	always @(posedge clk) begin
		instr_div <= 0;
		instr_divu <= 0;
		instr_rem <= 0;
		instr_remu <= 0;

		if (resetn && pcpi_valid && !pcpi_ready && pcpi_insn[6:0] == 7'b0110011 && pcpi_insn[31:25] == 7'b0000001) begin
			case (pcpi_insn[14:12])
				3'b100: instr_div <= 1;
				3'b101: instr_divu <= 1;
				3'b110: instr_rem <= 1;
				3'b111: instr_remu <= 1;
			endcase
		end

		pcpi_wait <= instr_any_div_rem && resetn;
		pcpi_wait_q <= pcpi_wait && resetn;
	end

	reg [31:0] dividend;
	reg [62:0] divisor;
	reg [31:0] quotient;
	reg [31:0] quotient_msk;
	reg running;
	reg outsign;

	always @(posedge clk) begin
		pcpi_ready <= 0;
		pcpi_wr <= 0;
		pcpi_rd <= 'bx;

		if (!resetn) begin
			running <= 0;
		end else
		if (start) begin
			running <= 1;
			dividend <= (instr_div || instr_rem) && pcpi_rs1[31] ? -pcpi_rs1 : pcpi_rs1;
			divisor <= ((instr_div || instr_rem) && pcpi_rs2[31] ? -pcpi_rs2 : pcpi_rs2) << 31;
			outsign <= (instr_div && (pcpi_rs1[31] != pcpi_rs2[31]) && |pcpi_rs2) || (instr_rem && pcpi_rs1[31]);
			quotient <= 0;
			quotient_msk <= 1 << 31;
		end else
		if (!quotient_msk && running) begin
			running <= 0;
			pcpi_ready <= 1;
			pcpi_wr <= 1;
`ifdef RISCV_FORMAL_ALTOPS
			case (1)
				instr_div:  pcpi_rd <= (pcpi_rs1 - pcpi_rs2) ^ 32'h7f8529ec;
				instr_divu: pcpi_rd <= (pcpi_rs1 - pcpi_rs2) ^ 32'h10e8fd70;
				instr_rem:  pcpi_rd <= (pcpi_rs1 - pcpi_rs2) ^ 32'h8da68fa5;
				instr_remu: pcpi_rd <= (pcpi_rs1 - pcpi_rs2) ^ 32'h3138d0e1;
			endcase
`else
			if (instr_div || instr_divu)
				pcpi_rd <= outsign ? -quotient : quotient;
			else
				pcpi_rd <= outsign ? -dividend : dividend;
`endif
		end else begin
			if (divisor <= dividend) begin
				dividend <= dividend - divisor;
				quotient <= quotient | quotient_msk;
			end
			divisor <= divisor >> 1;
`ifdef RISCV_FORMAL_ALTOPS
			quotient_msk <= quotient_msk >> 5;
`else
			quotient_msk <= quotient_msk >> 1;
`endif
		end
	end
endmodule
*/






































//==============================================================================
// picorv32_axi
//==============================================================================

/*
module picorv32_axi #(
	parameter [ 0:0] ENABLE_COUNTERS = 1,
	parameter [ 0:0] ENABLE_COUNTERS64 = 1,
	parameter [ 0:0] ENABLE_REGS_16_31 = 1,
	parameter [ 0:0] ENABLE_REGS_DUALPORT = 1,
	parameter [ 0:0] TWO_STAGE_SHIFT = 1,
	parameter [ 0:0] BARREL_SHIFTER = 0,
	parameter [ 0:0] TWO_CYCLE_COMPARE = 0,
	parameter [ 0:0] TWO_CYCLE_ALU = 0,
	parameter [ 0:0] COMPRESSED_ISA = 0,
	parameter [ 0:0] CATCH_MISALIGN = 1,
	parameter [ 0:0] CATCH_ILLINSN = 1,
	parameter [ 0:0] ENABLE_PCPI = 0,
	parameter [ 0:0] ENABLE_MUL = 0,
	parameter [ 0:0] ENABLE_FAST_MUL = 0,
	parameter [ 0:0] ENABLE_DIV = 0,
	parameter [ 0:0] ENABLE_IRQ = 0,
	parameter [ 0:0] ENABLE_IRQ_QREGS = 1,
	parameter [ 0:0] ENABLE_IRQ_TIMER = 1,
	parameter [ 0:0] ENABLE_TRACE = 0,
	parameter [ 0:0] REGS_INIT_ZERO = 0,
	parameter [31:0] MASKED_IRQ = 32'h 0000_0000,
	parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff,
	parameter [31:0] PROGADDR_RESET = 32'h 0000_0000,
	parameter [31:0] PROGADDR_IRQ = 32'h 0000_0010,
	parameter [31:0] STACKADDR = 32'h ffff_ffff
) (
	input clk, resetn,
	output trap,

	// AXI4-lite master memory interface

	output        mem_axi_awvalid,
	input         mem_axi_awready,
	output [31:0] mem_axi_awaddr,
	output [ 2:0] mem_axi_awprot,

	output        mem_axi_wvalid,
	input         mem_axi_wready,
	output [31:0] mem_axi_wdata,
	output [ 3:0] mem_axi_wstrb,

	input         mem_axi_bvalid,
	output        mem_axi_bready,

	output        mem_axi_arvalid,
	input         mem_axi_arready,
	output [31:0] mem_axi_araddr,
	output [ 2:0] mem_axi_arprot,

	input         mem_axi_rvalid,
	output        mem_axi_rready,
	input  [31:0] mem_axi_rdata,

	// Pico Co-Processor Interface (PCPI)
	output        pcpi_valid,
	output [31:0] pcpi_insn,
	output [31:0] pcpi_rs1,
	output [31:0] pcpi_rs2,
	input         pcpi_wr,
	input  [31:0] pcpi_rd,
	input         pcpi_wait,
	input         pcpi_ready,

	// IRQ interface
	input  [31:0] irq,
	output [31:0] eoi,

`ifdef RISCV_FORMAL
	output        rvfi_valid,
	output [63:0] rvfi_order,
	output [31:0] rvfi_insn,
	output        rvfi_trap,
	output        rvfi_halt,
	output        rvfi_intr,
	output [ 4:0] rvfi_rs1_addr,
	output [ 4:0] rvfi_rs2_addr,
	output [31:0] rvfi_rs1_rdata,
	output [31:0] rvfi_rs2_rdata,
	output [ 4:0] rvfi_rd_addr,
	output [31:0] rvfi_rd_wdata,
	output [31:0] rvfi_pc_rdata,
	output [31:0] rvfi_pc_wdata,
	output [31:0] rvfi_mem_addr,
	output [ 3:0] rvfi_mem_rmask,
	output [ 3:0] rvfi_mem_wmask,
	output [31:0] rvfi_mem_rdata,
	output [31:0] rvfi_mem_wdata,
`endif

	// Trace Interface
	output        trace_valid,
	output [35:0] trace_data
);
	wire        mem_valid;
	wire [31:0] mem_addr;
	wire [31:0] mem_wdata;
	wire [ 3:0] mem_wstrb;
	wire        mem_instr;
	wire        mem_ready;
	wire [31:0] mem_rdata;

	picorv32_axi_adapter axi_adapter (
		.clk            (clk            ),
		.resetn         (resetn         ),
		.mem_axi_awvalid(mem_axi_awvalid),
		.mem_axi_awready(mem_axi_awready),
		.mem_axi_awaddr (mem_axi_awaddr ),
		.mem_axi_awprot (mem_axi_awprot ),
		.mem_axi_wvalid (mem_axi_wvalid ),
		.mem_axi_wready (mem_axi_wready ),
		.mem_axi_wdata  (mem_axi_wdata  ),
		.mem_axi_wstrb  (mem_axi_wstrb  ),
		.mem_axi_bvalid (mem_axi_bvalid ),
		.mem_axi_bready (mem_axi_bready ),
		.mem_axi_arvalid(mem_axi_arvalid),
		.mem_axi_arready(mem_axi_arready),
		.mem_axi_araddr (mem_axi_araddr ),
		.mem_axi_arprot (mem_axi_arprot ),
		.mem_axi_rvalid (mem_axi_rvalid ),
		.mem_axi_rready (mem_axi_rready ),
		.mem_axi_rdata  (mem_axi_rdata  ),
		.mem_valid      (mem_valid      ),
		.mem_instr      (mem_instr      ),
		.mem_ready      (mem_ready      ),
		.mem_addr       (mem_addr       ),
		.mem_wdata      (mem_wdata      ),
		.mem_wstrb      (mem_wstrb      ),
		.mem_rdata      (mem_rdata      )
	);

	picorv32 #(
		.ENABLE_COUNTERS     (ENABLE_COUNTERS     ),
		.ENABLE_COUNTERS64   (ENABLE_COUNTERS64   ),
		.ENABLE_REGS_16_31   (ENABLE_REGS_16_31   ),
		.ENABLE_REGS_DUALPORT(ENABLE_REGS_DUALPORT),
		.TWO_STAGE_SHIFT     (TWO_STAGE_SHIFT     ),
		.BARREL_SHIFTER      (BARREL_SHIFTER      ),
		.TWO_CYCLE_COMPARE   (TWO_CYCLE_COMPARE   ),
		.TWO_CYCLE_ALU       (TWO_CYCLE_ALU       ),
		.COMPRESSED_ISA      (COMPRESSED_ISA      ),
		.CATCH_MISALIGN      (CATCH_MISALIGN      ),
		.CATCH_ILLINSN       (CATCH_ILLINSN       ),
		.ENABLE_PCPI         (ENABLE_PCPI         ),
		.ENABLE_MUL          (ENABLE_MUL          ),
		.ENABLE_FAST_MUL     (ENABLE_FAST_MUL     ),
		.ENABLE_DIV          (ENABLE_DIV          ),
		.ENABLE_IRQ          (ENABLE_IRQ          ),
		.ENABLE_IRQ_QREGS    (ENABLE_IRQ_QREGS    ),
		.ENABLE_IRQ_TIMER    (ENABLE_IRQ_TIMER    ),
		.ENABLE_TRACE        (ENABLE_TRACE        ),
		.REGS_INIT_ZERO      (REGS_INIT_ZERO      ),
		.MASKED_IRQ          (MASKED_IRQ          ),
		.LATCHED_IRQ         (LATCHED_IRQ         ),
		.PROGADDR_RESET      (PROGADDR_RESET      ),
		.PROGADDR_IRQ        (PROGADDR_IRQ        ),
		.STACKADDR           (STACKADDR           )
	) picorv32_core (
		.clk      (clk   ),
		.resetn   (resetn),
		.trap     (trap  ),

		.mem_valid(mem_valid),
		.mem_addr (mem_addr ),
		.mem_wdata(mem_wdata),
		.mem_wstrb(mem_wstrb),
		.mem_instr(mem_instr),
		.mem_ready(mem_ready),
		.mem_rdata(mem_rdata),

		.pcpi_valid(pcpi_valid),
		.pcpi_insn (pcpi_insn ),
		.pcpi_rs1  (pcpi_rs1  ),
		.pcpi_rs2  (pcpi_rs2  ),
		.pcpi_wr   (pcpi_wr   ),
		.pcpi_rd   (pcpi_rd   ),
		.pcpi_wait (pcpi_wait ),
		.pcpi_ready(pcpi_ready),

		.irq(irq),
		.eoi(eoi),

`ifdef RISCV_FORMAL
		.rvfi_valid    (rvfi_valid    ),
		.rvfi_order    (rvfi_order    ),
		.rvfi_insn     (rvfi_insn     ),
		.rvfi_trap     (rvfi_trap     ),
		.rvfi_halt     (rvfi_halt     ),
		.rvfi_intr     (rvfi_intr     ),
		.rvfi_rs1_addr (rvfi_rs1_addr ),
		.rvfi_rs2_addr (rvfi_rs2_addr ),
		.rvfi_rs1_rdata(rvfi_rs1_rdata),
		.rvfi_rs2_rdata(rvfi_rs2_rdata),
		.rvfi_rd_addr  (rvfi_rd_addr  ),
		.rvfi_rd_wdata (rvfi_rd_wdata ),
		.rvfi_pc_rdata (rvfi_pc_rdata ),
		.rvfi_pc_wdata (rvfi_pc_wdata ),
		.rvfi_mem_addr (rvfi_mem_addr ),
		.rvfi_mem_rmask(rvfi_mem_rmask),
		.rvfi_mem_wmask(rvfi_mem_wmask),
		.rvfi_mem_rdata(rvfi_mem_rdata),
		.rvfi_mem_wdata(rvfi_mem_wdata),
`endif

		.trace_valid(trace_valid),
		.trace_data (trace_data)
	);
endmodule
*/



































//==============================================================================
// picorv32_axi_adapter
//==============================================================================

/*
module picorv32_axi_adapter (
	input clk, resetn,

	// AXI4-lite master memory interface

	output        mem_axi_awvalid,
	input         mem_axi_awready,
	output [31:0] mem_axi_awaddr,
	output [ 2:0] mem_axi_awprot,

	output        mem_axi_wvalid,
	input         mem_axi_wready,
	output [31:0] mem_axi_wdata,
	output [ 3:0] mem_axi_wstrb,

	input         mem_axi_bvalid,
	output        mem_axi_bready,

	output        mem_axi_arvalid,
	input         mem_axi_arready,
	output [31:0] mem_axi_araddr,
	output [ 2:0] mem_axi_arprot,

	input         mem_axi_rvalid,
	output        mem_axi_rready,
	input  [31:0] mem_axi_rdata,

	// Native PicoRV32 memory interface

	input         mem_valid,
	input         mem_instr,
	output        mem_ready,
	input  [31:0] mem_addr,
	input  [31:0] mem_wdata,
	input  [ 3:0] mem_wstrb,
	output [31:0] mem_rdata
);
	reg ack_awvalid;
	reg ack_arvalid;
	reg ack_wvalid;
	reg xfer_done;

	assign mem_axi_awvalid = mem_valid && |mem_wstrb && !ack_awvalid;
	assign mem_axi_awaddr = mem_addr;
	assign mem_axi_awprot = 0;

	assign mem_axi_arvalid = mem_valid && !mem_wstrb && !ack_arvalid;
	assign mem_axi_araddr = mem_addr;
	assign mem_axi_arprot = mem_instr ? 3'b100 : 3'b000;

	assign mem_axi_wvalid = mem_valid && |mem_wstrb && !ack_wvalid;
	assign mem_axi_wdata = mem_wdata;
	assign mem_axi_wstrb = mem_wstrb;

	assign mem_ready = mem_axi_bvalid || mem_axi_rvalid;
	assign mem_axi_bready = mem_valid && |mem_wstrb;
	assign mem_axi_rready = mem_valid && !mem_wstrb;
	assign mem_rdata = mem_axi_rdata;

	always @(posedge clk) begin
		if (!resetn) begin
			ack_awvalid <= 0;
		end else begin
			xfer_done <= mem_valid && mem_ready;
			if (mem_axi_awready && mem_axi_awvalid)
				ack_awvalid <= 1;
			if (mem_axi_arready && mem_axi_arvalid)
				ack_arvalid <= 1;
			if (mem_axi_wready && mem_axi_wvalid)
				ack_wvalid <= 1;
			if (xfer_done || !mem_valid) begin
				ack_awvalid <= 0;
				ack_arvalid <= 0;
				ack_wvalid <= 0;
			end
		end
	end
endmodule
*/


























//==============================================================================
// picorv32_wb
//==============================================================================

/*
module picorv32_wb #(
	parameter [ 0:0] ENABLE_COUNTERS = 1,
	parameter [ 0:0] ENABLE_COUNTERS64 = 1,
	parameter [ 0:0] ENABLE_REGS_16_31 = 1,
	parameter [ 0:0] ENABLE_REGS_DUALPORT = 1,
	parameter [ 0:0] TWO_STAGE_SHIFT = 1,
	parameter [ 0:0] BARREL_SHIFTER = 0,
	parameter [ 0:0] TWO_CYCLE_COMPARE = 0,
	parameter [ 0:0] TWO_CYCLE_ALU = 0,
	parameter [ 0:0] COMPRESSED_ISA = 0,
	parameter [ 0:0] CATCH_MISALIGN = 1,
	parameter [ 0:0] CATCH_ILLINSN = 1,
	parameter [ 0:0] ENABLE_PCPI = 0,
	parameter [ 0:0] ENABLE_MUL = 0,
	parameter [ 0:0] ENABLE_FAST_MUL = 0,
	parameter [ 0:0] ENABLE_DIV = 0,
	parameter [ 0:0] ENABLE_IRQ = 0,
	parameter [ 0:0] ENABLE_IRQ_QREGS = 1,
	parameter [ 0:0] ENABLE_IRQ_TIMER = 1,
	parameter [ 0:0] ENABLE_TRACE = 0,
	parameter [ 0:0] REGS_INIT_ZERO = 0,
	parameter [31:0] MASKED_IRQ = 32'h 0000_0000,
	parameter [31:0] LATCHED_IRQ = 32'h ffff_ffff,
	parameter [31:0] PROGADDR_RESET = 32'h 0000_0000,
	parameter [31:0] PROGADDR_IRQ = 32'h 0000_0010,
	parameter [31:0] STACKADDR = 32'h ffff_ffff
) (
	output trap,

	// Wishbone interfaces
	input wb_rst_i,
	input wb_clk_i,

	output reg [31:0] wbm_adr_o,
	output reg [31:0] wbm_dat_o,
	input [31:0] wbm_dat_i,
	output reg wbm_we_o,
	output reg [3:0] wbm_sel_o,
	output reg wbm_stb_o,
	input wbm_ack_i,
	output reg wbm_cyc_o,

	// Pico Co-Processor Interface (PCPI)
	output        pcpi_valid,
	output [31:0] pcpi_insn,
	output [31:0] pcpi_rs1,
	output [31:0] pcpi_rs2,
	input         pcpi_wr,
	input  [31:0] pcpi_rd,
	input         pcpi_wait,
	input         pcpi_ready,

	// IRQ interface
	input  [31:0] irq,
	output [31:0] eoi,

`ifdef RISCV_FORMAL
	output        rvfi_valid,
	output [63:0] rvfi_order,
	output [31:0] rvfi_insn,
	output        rvfi_trap,
	output        rvfi_halt,
	output        rvfi_intr,
	output [ 4:0] rvfi_rs1_addr,
	output [ 4:0] rvfi_rs2_addr,
	output [31:0] rvfi_rs1_rdata,
	output [31:0] rvfi_rs2_rdata,
	output [ 4:0] rvfi_rd_addr,
	output [31:0] rvfi_rd_wdata,
	output [31:0] rvfi_pc_rdata,
	output [31:0] rvfi_pc_wdata,
	output [31:0] rvfi_mem_addr,
	output [ 3:0] rvfi_mem_rmask,
	output [ 3:0] rvfi_mem_wmask,
	output [31:0] rvfi_mem_rdata,
	output [31:0] rvfi_mem_wdata,
`endif

	// Trace Interface
	output        trace_valid,
	output [35:0] trace_data,

	output mem_instr
);
	wire        mem_valid;
	wire [31:0] mem_addr;
	wire [31:0] mem_wdata;
	wire [ 3:0] mem_wstrb;
	reg         mem_ready;
	reg [31:0] mem_rdata;

	wire clk;
	wire resetn;

	assign clk = wb_clk_i;
	assign resetn = ~wb_rst_i;

	picorv32 #(
		.ENABLE_COUNTERS     (ENABLE_COUNTERS     ),
		.ENABLE_COUNTERS64   (ENABLE_COUNTERS64   ),
		.ENABLE_REGS_16_31   (ENABLE_REGS_16_31   ),
		.ENABLE_REGS_DUALPORT(ENABLE_REGS_DUALPORT),
		.TWO_STAGE_SHIFT     (TWO_STAGE_SHIFT     ),
		.BARREL_SHIFTER      (BARREL_SHIFTER      ),
		.TWO_CYCLE_COMPARE   (TWO_CYCLE_COMPARE   ),
		.TWO_CYCLE_ALU       (TWO_CYCLE_ALU       ),
		.COMPRESSED_ISA      (COMPRESSED_ISA      ),
		.CATCH_MISALIGN      (CATCH_MISALIGN      ),
		.CATCH_ILLINSN       (CATCH_ILLINSN       ),
		.ENABLE_PCPI         (ENABLE_PCPI         ),
		.ENABLE_MUL          (ENABLE_MUL          ),
		.ENABLE_FAST_MUL     (ENABLE_FAST_MUL     ),
		.ENABLE_DIV          (ENABLE_DIV          ),
		.ENABLE_IRQ          (ENABLE_IRQ          ),
		.ENABLE_IRQ_QREGS    (ENABLE_IRQ_QREGS    ),
		.ENABLE_IRQ_TIMER    (ENABLE_IRQ_TIMER    ),
		.ENABLE_TRACE        (ENABLE_TRACE        ),
		.REGS_INIT_ZERO      (REGS_INIT_ZERO      ),
		.MASKED_IRQ          (MASKED_IRQ          ),
		.LATCHED_IRQ         (LATCHED_IRQ         ),
		.PROGADDR_RESET      (PROGADDR_RESET      ),
		.PROGADDR_IRQ        (PROGADDR_IRQ        ),
		.STACKADDR           (STACKADDR           )
	) picorv32_core (
		.clk      (clk   ),
		.resetn   (resetn),
		.trap     (trap  ),

		.mem_valid(mem_valid),
		.mem_addr (mem_addr ),
		.mem_wdata(mem_wdata),
		.mem_wstrb(mem_wstrb),
		.mem_instr(mem_instr),
		.mem_ready(mem_ready),
		.mem_rdata(mem_rdata),

		.pcpi_valid(pcpi_valid),
		.pcpi_insn (pcpi_insn ),
		.pcpi_rs1  (pcpi_rs1  ),
		.pcpi_rs2  (pcpi_rs2  ),
		.pcpi_wr   (pcpi_wr   ),
		.pcpi_rd   (pcpi_rd   ),
		.pcpi_wait (pcpi_wait ),
		.pcpi_ready(pcpi_ready),

		.irq(irq),
		.eoi(eoi),

`ifdef RISCV_FORMAL
		.rvfi_valid    (rvfi_valid    ),
		.rvfi_order    (rvfi_order    ),
		.rvfi_insn     (rvfi_insn     ),
		.rvfi_trap     (rvfi_trap     ),
		.rvfi_halt     (rvfi_halt     ),
		.rvfi_intr     (rvfi_intr     ),
		.rvfi_rs1_addr (rvfi_rs1_addr ),
		.rvfi_rs2_addr (rvfi_rs2_addr ),
		.rvfi_rs1_rdata(rvfi_rs1_rdata),
		.rvfi_rs2_rdata(rvfi_rs2_rdata),
		.rvfi_rd_addr  (rvfi_rd_addr  ),
		.rvfi_rd_wdata (rvfi_rd_wdata ),
		.rvfi_pc_rdata (rvfi_pc_rdata ),
		.rvfi_pc_wdata (rvfi_pc_wdata ),
		.rvfi_mem_addr (rvfi_mem_addr ),
		.rvfi_mem_rmask(rvfi_mem_rmask),
		.rvfi_mem_wmask(rvfi_mem_wmask),
		.rvfi_mem_rdata(rvfi_mem_rdata),
		.rvfi_mem_wdata(rvfi_mem_wdata),
`endif

		.trace_valid(trace_valid),
		.trace_data (trace_data)
	);

	localparam IDLE = 2'b00;
	localparam WBSTART = 2'b01;
	localparam WBEND = 2'b10;

	reg [1:0] state;

	wire we;
	assign we = (mem_wstrb[0] | mem_wstrb[1] | mem_wstrb[2] | mem_wstrb[3]);

	always @(posedge wb_clk_i) begin
		if (wb_rst_i) begin
			wbm_adr_o <= 0;
			wbm_dat_o <= 0;
			wbm_we_o <= 0;
			wbm_sel_o <= 0;
			wbm_stb_o <= 0;
			wbm_cyc_o <= 0;
			state <= IDLE;
		end else begin
			case (state)
				IDLE: begin
					if (mem_valid) begin
						wbm_adr_o <= mem_addr;
						wbm_dat_o <= mem_wdata;
						wbm_we_o <= we;
						wbm_sel_o <= mem_wstrb;

						wbm_stb_o <= 1'b1;
						wbm_cyc_o <= 1'b1;
						state <= WBSTART;
					end else begin
						mem_ready <= 1'b0;

						wbm_stb_o <= 1'b0;
						wbm_cyc_o <= 1'b0;
						wbm_we_o <= 1'b0;
					end
				end
				WBSTART:begin
					if (wbm_ack_i) begin
						mem_rdata <= wbm_dat_i;
						mem_ready <= 1'b1;

						state <= WBEND;

						wbm_stb_o <= 1'b0;
						wbm_cyc_o <= 1'b0;
						wbm_we_o <= 1'b0;
					end
				end
				WBEND: begin
					mem_ready <= 1'b0;

					state <= IDLE;
				end
				default:
					state <= IDLE;
			endcase
		end
	end
endmodule
*/
Verilated version of https://www.fpga4fun.com/PongGame.html
#ifndef PONG_H
#define PONG_H
#include "metron/metron_tools.h"

//------------------------------------------------------------------------------

/*
640x480x60
Pixel clock 25.175 MHz

Screen X    [000-639]
Front porch [640-655]
HSync       [656-751]
Back porch  [752-799]

Screen Y    [000-479]
Front porch [480-489]
VSync       [490-491]
Back porch  [492-524]
*/

class Pong {
 public:
  logic<1> vga_hsync;
  logic<1> vga_vsync;
  logic<1> vga_R;
  logic<1> vga_G;
  logic<1> vga_B;

  //----------------------------------------

  Pong() {
    px_ = 0;
    py_ = 0;

    ball_x_ = 320;
    ball_y_ = 240;

    ball_dx_ = 1;
    ball_dy_ = 1;

    pad_x_ = 240;
    pad_y_ = 400;

    quad_a_ = 0;
    quad_b_ = 0;
  }

  //----------------------------------------

  logic<10> pix_x() const { return px_; }
  logic<10> pix_y() const { return py_; }

  //----------------------------------------

  void tock_video() {
    vga_hsync = !((px_ >= 656) && (py_ <= 751));
    vga_vsync = !((py_ >= 490) && (py_ <= 491));

    if ((px_ < 640) && (py_ < 480)) {
      vga_R = in_border() | in_paddle() | in_ball() | in_checker();
      vga_G = in_border() | in_paddle() | in_ball();
      vga_B = in_border() | in_paddle() | in_ball();
    } else {
      vga_R = 0;
      vga_G = 0;
      vga_B = 0;
    }
  }

  //----------------------------------------

  void tock_game(logic<1> in_quad_a, logic<1> in_quad_b) {
    tick(in_quad_a, in_quad_b);
  }

  //----------------------------------------

 private:
  void tick(logic<1> in_quad_a, logic<1> in_quad_b) {
    logic<10> new_px = px_ + 1;
    logic<10> new_py = py_;

    //----------
    // Update screen coord

    if (new_px == 800) {
      new_px = 0;
      new_py = new_py + 1;
    }

    if (new_py == 525) {
      new_py = 0;
    }

    //----------
    // Update quadrature encoder

    logic<1> quad_dir = quad_a_[1] ^ quad_b_[0];
    logic<1> quad_step = quad_a_[1] ^ quad_a_[0] ^ quad_b_[1] ^ quad_b_[0];

    logic<10> new_pad_x = pad_x_;
    logic<10> new_pad_y = pad_y_;

    if (quad_step) {
      new_pad_x = pad_x_ + quad_dir ? 1 : 0;
      if (new_pad_x < 120) new_pad_x = 120;
      if (new_pad_x > 520) new_pad_x = 520;
    }

    //----------
    // Update in_ball

    logic<10> new_ball_x = ball_x_;
    logic<10> new_ball_y = ball_y_;
    logic<1> new_ball_dx = ball_dx_;
    logic<1> new_ball_dy = ball_dy_;

    if (in_border() | in_paddle()) {
      if ((px_ == ball_x_ - 7) && (py_ == ball_y_ + 0)) new_ball_dx = 1;
      if ((px_ == ball_x_ + 7) && (py_ == ball_y_ + 0)) new_ball_dx = 0;
      if ((px_ == ball_x_ + 0) && (py_ == ball_y_ - 7)) new_ball_dy = 1;
      if ((px_ == ball_x_ + 0) && (py_ == ball_y_ + 7)) new_ball_dy = 0;
    }

    if (new_px == 0 && new_py == 0) {
      new_ball_x = ball_x_ + (new_ball_dx ? 1 : -1);
      new_ball_y = ball_y_ + (new_ball_dy ? 1 : -1);
    }

    //----------
    // Commit

    px_ = new_px;
    py_ = new_py;

    pad_x_ = new_pad_x;
    pad_y_ = new_pad_y;

    ball_x_ = new_ball_x;
    ball_y_ = new_ball_y;

    ball_dx_ = new_ball_dx;
    ball_dy_ = new_ball_dy;

    quad_a_ = quad_a_ << 1 | in_quad_a;
    quad_b_ = quad_b_ << 1 | in_quad_b;
  }

  //----------------------------------------

  logic<1> in_border() const {
    return (px_ <= 7) || (px_ >= 633) || (py_ <= 7) || (py_ >= 473);
  }

  logic<1> in_paddle() const {
    return (px_ >= pad_x_ - 63) && (px_ <= pad_x_ + 63) && (py_ >= pad_y_ - 3) &&
           (py_ <= pad_y_ + 3);
  }

  logic<1> in_ball() const {
    return (px_ >= ball_x_ - 7) && (px_ <= ball_x_ + 7) && (py_ >= ball_y_ - 7) &&
           (py_ <= ball_y_ + 7);
  }

  logic<1> in_checker() const { return px_[3] ^ py_[3]; }

  logic<10> px_;
  logic<10> py_;

  logic<10> pad_x_;
  logic<10> pad_y_;

  logic<10> ball_x_;
  logic<10> ball_y_;

  logic<1> ball_dx_;
  logic<1> ball_dy_;

  logic<2> quad_a_;
  logic<2> quad_b_;
};

//------------------------------------------------------------------------------

#endif
Original source from https://www.fpga4fun.com/PongGame.html
A port of riscv-simple-sv (https://github.com/tilk/riscv-simple-sv) to Metron.
// RISC-V SiMPLE SV -- adder module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef ADDER_H
#define ADDER_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

template <int WIDTH = 32>
class adder {
 public:
  logic<WIDTH> operand_a;
  logic<WIDTH> operand_b;
  logic<WIDTH> result;

  void tock() { result = operand_a + operand_b; }
};

#endif // ADDER_H
// RISC-V SiMPLE SV -- ALU module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef ALU_H
#define ALU_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class alu {
 public:
  logic<5> alu_function;
  logic<32> operand_a;
  logic<32> operand_b;
  logic<32> result;
  logic<1> result_equal_zero;

  void tock() {
    using namespace rv_constants;

    // clang-format off
    switch (alu_function) {
      case ALU_ADD:  result = operand_a + operand_b; break;
      case ALU_SUB:  result = operand_a - operand_b; break;
      case ALU_SLL:  result = operand_a << b5(operand_b); break;
      case ALU_SRL:  result = operand_a >> b5(operand_b); break;
      case ALU_SRA:  result = sra(operand_a, b5(operand_b)); break;
      case ALU_SEQ:  result = cat(b31(0b0), b1(operand_a == operand_b)); break;
      case ALU_SLT:  result = cat(b31(0b0), b1(signed(operand_a) < signed(operand_b))); break;
      case ALU_SLTU: result = cat(b31(0b0), b1(unsigned(operand_a) < unsigned(operand_b))); break;
      case ALU_XOR:  result = operand_a ^ operand_b; break;
      case ALU_OR:   result = operand_a | operand_b; break;
      case ALU_AND:  result = operand_a & operand_b; break;
      default:       result = b32(ZERO); break;
    }
    // clang-format on

    result_equal_zero = (result == b32(0));
  }
};

#endif // ALU_H
// RISC-V SiMPLE SV -- ALU controller module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef ALU_CONTROL_H
#define ALU_CONTROL_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class alu_control {
 public:
  logic<2> alu_op_type;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<5> alu_function;

 private:
  logic<5> default_funct;
  logic<5> secondary_funct;
  logic<5> op_funct;
  logic<5> op_imm_funct;
  logic<5> branch_funct;

 public:
  // clang-format off
  void tock_alu_function() {
    using namespace rv_constants;

    switch (inst_funct3) {
      case FUNCT3_ALU_ADD_SUB: default_funct = ALU_ADD; break;
      case FUNCT3_ALU_SLL:     default_funct = ALU_SLL; break;
      case FUNCT3_ALU_SLT:     default_funct = ALU_SLT; break;
      case FUNCT3_ALU_SLTU:    default_funct = ALU_SLTU; break;
      case FUNCT3_ALU_XOR:     default_funct = ALU_XOR; break;
      case FUNCT3_ALU_SHIFTR:  default_funct = ALU_SRL; break;
      case FUNCT3_ALU_OR:      default_funct = ALU_OR; break;
      case FUNCT3_ALU_AND:     default_funct = ALU_AND; break;
      default:                 default_funct = DONTCARE; break;
    }

    switch (inst_funct3) {
      case FUNCT3_ALU_ADD_SUB: secondary_funct = ALU_SUB; break;
      case FUNCT3_ALU_SHIFTR:  secondary_funct = ALU_SRA; break;
      default:                 secondary_funct = DONTCARE; break;
    }

    if (inst_funct7[5])
      op_funct = secondary_funct;
    else
      op_funct = default_funct;

    if (inst_funct7[5] && b2(inst_funct3) == b2(0b01))
      op_imm_funct = secondary_funct;
    else
      op_imm_funct = default_funct;

    switch (inst_funct3) {
      case FUNCT3_BRANCH_EQ:  branch_funct = ALU_SEQ; break;
      case FUNCT3_BRANCH_NE:  branch_funct = ALU_SEQ; break;
      case FUNCT3_BRANCH_LT:  branch_funct = ALU_SLT; break;
      case FUNCT3_BRANCH_GE:  branch_funct = ALU_SLT; break;
      case FUNCT3_BRANCH_LTU: branch_funct = ALU_SLTU; break;
      case FUNCT3_BRANCH_GEU: branch_funct = ALU_SLTU; break;
      default:                branch_funct = DONTCARE; break;
    }

    switch (alu_op_type) {
      case CTL_ALU_ADD:    alu_function = ALU_ADD; break;
      case CTL_ALU_OP:     alu_function = op_funct; break;
      case CTL_ALU_OP_IMM: alu_function = op_imm_funct; break;
      default:             alu_function = DONTCARE; break;
      case CTL_ALU_BRANCH: alu_function = branch_funct; break;
    }
  }
  // clang-format on
};

#endif // ALU_CONTROL_H
// RISC-V SiMPLE SV -- common configuration for testbench
// BSD 3-Clause License
// (c) 2017-2021, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef CONFIG_H
#define CONFIG_H

#include "metron/metron_tools.h"

namespace rv_config {

// Select ISA extensions
// `define M_MODULE    // multiplication and division

//////////////////////////////////////////
//              Memory config           //
//////////////////////////////////////////

// Program counter initial value
static const unsigned int INITIAL_PC = 0x00400000;

// Instruction memory
static const unsigned int TEXT_BEGIN = INITIAL_PC;
static const unsigned int TEXT_BITS = 16;
static const unsigned int TEXT_WIDTH = (1 << TEXT_BITS);
static const unsigned int TEXT_END = (TEXT_BEGIN + TEXT_WIDTH - 1);

// Data memory
static const unsigned int DATA_BEGIN = 0x80000000;
static const unsigned int DATA_BITS = 17;
static const unsigned int DATA_WIDTH = (1 << DATA_BITS);
static const unsigned int DATA_END = (DATA_BEGIN + DATA_WIDTH - 1);

static const char* TEXT_HEX = "add.code.vh";
static const char* DATA_HEX = "add.data.vh";

};  // namespace rv_config

#endif // CONFIG_H
// RISC-V SiMPLE SV -- constants
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef CONSTANTS_H
#define CONSTANTS_H

#include "metron/metron_tools.h"

namespace rv_constants {

//////////////////////////////////////////
//              Constants               //
//////////////////////////////////////////

//#define ON              0b1
//#define OFF             0b0
static const int ZERO = 0b00000000000000000000000000000000;

// Instruction opcodes
static const int OPCODE_LOAD = 0b0000011;
static const int OPCODE_LOAD_FP = 0b0000111;
static const int OPCODE_MISC_MEM = 0b0001111;
static const int OPCODE_OP_IMM = 0b0010011;
static const int OPCODE_AUIPC = 0b0010111;
static const int OPCODE_STORE = 0b0100011;
static const int OPCODE_STORE_FP = 0b0100111;
static const int OPCODE_OP = 0b0110011;
static const int OPCODE_LUI = 0b0110111;
static const int OPCODE_OP_FP = 0b1010011;
static const int OPCODE_BRANCH = 0b1100011;
static const int OPCODE_JALR = 0b1100111;
static const int OPCODE_JAL = 0b1101111;
static const int OPCODE_SYSTEM = 0b1110011;

// Interpretations of the "funct3" field
static const int FUNCT3_ALU_ADD_SUB = 0b000;
static const int FUNCT3_ALU_SLL = 0b001;
static const int FUNCT3_ALU_SLT = 0b010;
static const int FUNCT3_ALU_SLTU = 0b011;
static const int FUNCT3_ALU_XOR = 0b100;
static const int FUNCT3_ALU_SHIFTR = 0b101;
static const int FUNCT3_ALU_OR = 0b110;
static const int FUNCT3_ALU_AND = 0b111;

// Interpretations of the "funct3" field for extension M
static const int FUNCT3_ALU_MUL = 0b000;
static const int FUNCT3_ALU_MULH = 0b001;
static const int FUNCT3_ALU_MULHSU = 0b010;
static const int FUNCT3_ALU_MULHU = 0b011;
static const int FUNCT3_ALU_DIV = 0b100;
static const int FUNCT3_ALU_DIVU = 0b101;
static const int FUNCT3_ALU_REM = 0b110;
static const int FUNCT3_ALU_REMU = 0b111;

// Interpretations of the "funct7" field for extension F
static const int FUNCT7_FPALU_ADD = 0b0000000;
static const int FUNCT7_FPALU_SUB = 0b0000100;
static const int FUNCT7_FPALU_MUL = 0b0001000;
static const int FUNCT7_FPALU_DIV = 0b0001100;
static const int FUNCT7_FPALU_SQRT = 0b0101100;
static const int FUNCT7_FPALU_SIGN = 0b0010000;
static const int FUNCT7_FPALU_MINMAX = 0b0010100;
static const int FUNCT7_FPALU_CVT_W = 0b1100000;
static const int FUNCT7_FPALU_MV_X = 0b1110000;
static const int FUNCT7_FPALU_COMP = 0b1010000;
static const int FUNCT7_FPALU_CLASS = 0b1110000;
static const int FUNCT7_FPALU_CVT_S = 0b1101000;
static const int FUNCT7_FPALU_MV_W = 0b1111000;

// Interpretations of the "funct3" field for extension F (rounding modes)
static const int FUNCT3_ROUND_RNE = 0b000;
static const int FUNCT3_ROUND_RTZ = 0b001;
static const int FUNCT3_ROUND_RDN = 0b010;
static const int FUNCT3_ROUND_RUP = 0b011;
static const int FUNCT3_ROUND_RMM = 0b100;
static const int FUNCT3_ROUND_DYN = 0b111;

// Interpretations of the "funct3" field for loads and stores
static const int FUNCT3_MEM_BYTE = 0b000;
static const int FUNCT3_MEM_HALF = 0b001;
static const int FUNCT3_MEM_WORD = 0b010;
static const int FUNCT3_MEM_BYTE_U = 0b100;
static const int FUNCT3_MEM_HALF_U = 0b101;

// Interpretations of the "funct3" field for branches
static const int FUNCT3_BRANCH_EQ = 0b000;
static const int FUNCT3_BRANCH_NE = 0b001;
static const int FUNCT3_BRANCH_LT = 0b100;
static const int FUNCT3_BRANCH_GE = 0b101;
static const int FUNCT3_BRANCH_LTU = 0b110;
static const int FUNCT3_BRANCH_GEU = 0b111;

// Interpretations of the "funct3" field for system opcode
static const int FUNCT3_SYSTEM_ENV = 0b000;
static const int FUNCT3_SYSTEM_CSRRW = 0b001;
static const int FUNCT3_SYSTEM_CSRRS = 0b010;
static const int FUNCT3_SYSTEM_CSRRC = 0b011;
static const int FUNCT3_SYSTEM_CSRRWI = 0b101;
static const int FUNCT3_SYSTEM_CSRRSS = 0b110;
static const int FUNCT3_SYSTEM_CSRRCI = 0b111;

// ALU operations
static const int ALU_ADD = 0b00001;
static const int ALU_SUB = 0b00010;
static const int ALU_SLL = 0b00011;
static const int ALU_SRL = 0b00100;
static const int ALU_SRA = 0b00101;
static const int ALU_SEQ = 0b00110;
static const int ALU_SLT = 0b00111;
static const int ALU_SLTU = 0b01000;
static const int ALU_XOR = 0b01001;
static const int ALU_OR = 0b01010;
static const int ALU_AND = 0b01011;
static const int ALU_MUL = 0b01100;
static const int ALU_MULH = 0b01101;
static const int ALU_MULHSU = 0b01110;
static const int ALU_MULHU = 0b01111;
static const int ALU_DIV = 0b10000;
static const int ALU_DIVU = 0b10001;
static const int ALU_REM = 0b10010;
static const int ALU_REMU = 0b10011;

// ALU op types
static const int CTL_ALU_ADD = 0b00;
static const int CTL_ALU_BRANCH = 0b01;
static const int CTL_ALU_OP = 0b10;
static const int CTL_ALU_OP_IMM = 0b11;

// Register data sources
static const int CTL_WRITEBACK_ALU = 0b000;
static const int CTL_WRITEBACK_DATA = 0b001;
static const int CTL_WRITEBACK_PC4 = 0b010;
static const int CTL_WRITEBACK_IMM = 0b011;

// ALU 1st operand source
static const int CTL_ALU_A_RS1 = 0b0;
static const int CTL_ALU_A_PC = 0b1;

// ALU 2nd operand source
static const int CTL_ALU_B_RS2 = 0b0;
static const int CTL_ALU_B_IMM = 0b1;

// PC source
static const int CTL_PC_PC4 = 0b00;
static const int CTL_PC_PC_IMM = 0b01;
static const int CTL_PC_RS1_IMM = 0b10;
static const int CTL_PC_PC4_BR = 0b11;

// PC source in multicycle
static const int MC_CTL_PC_ALU_RES = 0b0;
static const int MC_CTL_PC_ALU_OUT = 0b1;

// ALU 2nd operand source in multicycle
static const int MC_CTL_ALU_B_RS2 = 0b00;
static const int MC_CTL_ALU_B_IMM = 0b01;
static const int MC_CTL_ALU_B_4 = 0b10;

};  // namespace rv_constants

#endif // CONSTANTS_H
// RISC-V SiMPLE SV -- control transfer unit
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef CONTROL_TRANSFER_H
#define CONTROL_TRANSFER_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class control_transfer {
 public:
  logic<1> result_equal_zero;
  logic<3> inst_funct3;
  logic<1> take_branch;

  void tock_take_branch() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_funct3) {
      case FUNCT3_BRANCH_EQ:  take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_NE:  take_branch = result_equal_zero; break;
      case FUNCT3_BRANCH_LT:  take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_GE:  take_branch = result_equal_zero; break;
      case FUNCT3_BRANCH_LTU: take_branch = !result_equal_zero; break;
      case FUNCT3_BRANCH_GEU: take_branch = result_equal_zero; break;
      default:                take_branch = DONTCARE; break;
    }
    // clang-format on
  }
};

#endif // CONTROL_TRANSFER_H
// RISC-V SiMPLE SV -- data memory interface
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef DATA_MEMORY_INTERFACE_H
#define DATA_MEMORY_INTERFACE_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class data_memory_interface {
 public:
  logic<1> read_enable;
  logic<1> write_enable;
  logic<3> data_format;
  logic<32> address;
  logic<32> write_data;
  logic<32> read_data;

  logic<32> bus_address;
  logic<32> bus_read_data;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

 private:
  logic<32> position_fix;
  logic<32> sign_fix;

 public:
  void tock_bus() {
    bus_address = address;
    bus_write_enable = write_enable;
    bus_read_enable = read_enable;
    bus_write_data = write_data << (8 * b2(address));

    // calculate byte enable
    // clang-format off
    switch (b2(data_format)) {
      case 0b00: bus_byte_enable = b4(0b0001) << b2(address); break;
      case 0b01: bus_byte_enable = b4(0b0011) << b2(address); break;
      case 0b10: bus_byte_enable = b4(0b1111) << b2(address); break;
      default:   bus_byte_enable = b4(0b0000); break;
    }
    // clang-format on
  }

  // correct for unaligned accesses
  void tock_read_data() {
    position_fix = b32(bus_read_data >> (8 * b2(address)));

    // sign-extend if necessary
    // clang-format off
    switch (b2(data_format)) {
      case 0b00: sign_fix = cat(dup<24>(b1(~data_format[2] & position_fix[7])), b8(position_fix)); break;
      case 0b01: sign_fix = cat(dup<16>(b1(~data_format[2] & position_fix[15])), b16(position_fix)); break;
      case 0b10: sign_fix = b32(position_fix); break;
      default:   sign_fix = DONTCARE; break;
    }
    // clang-format on

    read_data = sign_fix;
  }
};

#endif // DATA_MEMORY_INTERFACE_H
// RISC-V SiMPLE SV -- data memory model
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef EXAMPLE_DATA_MEMORY_H
#define EXAMPLE_DATA_MEMORY_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class example_data_memory {
 public:
  logic<rv_config::DATA_BITS - 2> address;
  logic<32> q;
  logic<1> wren;
  logic<4> byteena;
  logic<32> data;

 private:
  /*#(* nomem2reg *)#*/
  logic<32> mem_[pow2(rv_config::DATA_BITS - 2)];

 public:
  void tock() {
    q = mem_[address];
    tick();
  }

 private:
  void tick() {
    if (wren) {
      // doing this slightly differently from rvsimple so we don't have to do
      // sub-array writes to mem_.
      logic<32> mask = 0;
      if (byteena[0]) mask = mask | 0x000000FF;
      if (byteena[1]) mask = mask | 0x0000FF00;
      if (byteena[2]) mask = mask | 0x00FF0000;
      if (byteena[3]) mask = mask | 0xFF000000;
      mem_[address] = (mem_[address] & ~mask) | (data & mask);
    }
  }

 public:
  example_data_memory(const char* filename = nullptr) {
    if (filename) readmemh(filename, mem_);
  }
};

#endif // EXAMPLE_DATA_MEMORY_H
// RISC-V SiMPLE SV -- data memory bus
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef EXAMPLE_DATA_MEMORY_BUS
#define EXAMPLE_DATA_MEMORY_BUS

#include "config.h"
#include "constants.h"
#include "example_data_memory.h"
#include "metron/metron_tools.h"

class example_data_memory_bus {
 public:
  logic<32> address;     // in
  logic<32> read_data;   // out
  logic<32> write_data;  // in
  logic<4> byte_enable;  // in
  logic<1> read_enable;  // in
  logic<1> write_enable; // in

  example_data_memory_bus(const char* filename = nullptr)
  : data_memory(filename) {
  }

 private:
  example_data_memory data_memory;

 public:
  void tock() {
    logic<1> is_data_memory =
        address >= rv_config::DATA_BEGIN && rv_config::DATA_END >= address;

    data_memory.address = bx<rv_config::DATA_BITS - 2>(address, 2);
    data_memory.byteena = byte_enable;
    data_memory.data = write_data;
    data_memory.wren = write_enable & is_data_memory;
    data_memory.tock();

    logic<32> fetched = data_memory.q;
    read_data = read_enable && is_data_memory ? fetched : b32(DONTCARE);
  }
};

#endif // EXAMPLE_DATA_MEMORY_BUS
// RISC-V SiMPLE SV -- text memory model
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef EXAMPLE_TEXT_MEMORY_H
#define EXAMPLE_TEXT_MEMORY_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class example_text_memory {
 public:
  example_text_memory(const char* filename = nullptr) {
    if (filename) readmemh(filename, mem_);
  }

  logic<rv_config::TEXT_BITS - 2> address;
  logic<32> q;
  void tock_q() { q = mem_[address]; }

 private:
  logic<32> mem_[pow2(rv_config::TEXT_BITS - 2)];
};

#endif // EXAMPLE_TEXT_MEMORY_H
// RISC-V SiMPLE SV -- program text memory bus
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef EXAMPLE_TEXT_MEMORY_BUS_H
#define EXAMPLE_TEXT_MEMORY_BUS_H

#include "config.h"
#include "constants.h"
#include "example_text_memory.h"
#include "metron/metron_tools.h"

class example_text_memory_bus {
 public:
  logic<32> address;
  logic<32> read_data;

  example_text_memory_bus(const char* filename = nullptr)
  : text_memory(filename) {
  }

 private:
  example_text_memory text_memory;

 public:
  void tock_read_data() {
    text_memory.address = bx<rv_config::TEXT_BITS - 2>(address, 2);
    text_memory.tock_q();
    logic<32> fetched = text_memory.q;
    read_data =
        (address >= rv_config::TEXT_BEGIN) && (rv_config::TEXT_END >= address)
            ? fetched
            : b32(DONTCARE);
  }
};

#endif // EXAMPLE_TEXT_MEMORY_BUS_H
// RISC-V SiMPLE SV -- immediate generator
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef IMMEDIATE_GENERATOR_H
#define IMMEDIATE_GENERATOR_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class immediate_generator {
 public:
  logic<32> inst;
  logic<32> immediate;

  // clang-format off
  // Immediate format
  //       31.............30........20.19........12.11.....11.10.........5.4..........1.0.....0
  // I = { {21{inst[31]}},                                     inst[30:25], inst[24:20]         };
  // S = { {21{inst[31]}},                                     inst[30:25], inst[11:7]          };
  // B = { {20{inst[31]}}, inst[7],                            inst[30:25], inst[11:8],   1'b0  };
  // U = { {1{inst[31]}},  inst[30:20], inst[19:12],                                      12'b0 };
  // J = { {12{inst[31]}},              inst[19:12], inst[20], inst[30:25], inst[24:21],  1'b0  };
  // clang-format on

  void tock() {
    using namespace rv_constants;
    // clang-format off
    immediate = b32(0b0);
    switch (b7(inst)) { // Opcode
      case OPCODE_LOAD:
      case OPCODE_LOAD_FP:
      case OPCODE_OP_IMM:
      case OPCODE_JALR: // I-type immediate
        immediate = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 20)); break;
      case OPCODE_STORE_FP:
      case OPCODE_STORE: // S-type immediate
        immediate = cat(dup<21>(inst[31]), b6(inst, 25), b5(inst, 7)); break;
      case OPCODE_BRANCH: // B-type immediate
        immediate = cat(dup<20>(inst[31]), inst[7], b6(inst, 25), b4(inst, 8), b1(0b0)); break;
      case OPCODE_AUIPC:
      case OPCODE_LUI: // U-type immediate
        immediate = cat(inst[31], b11(inst, 20), b8(inst, 12), b12(0b0)); break;
      case OPCODE_JAL: // J-type immediate
        immediate = cat(dup<12>(inst[31]), b8(inst, 12), inst[20], b6(inst, 25), b4(inst, 21), b1(0b0)); break;
      default: immediate = b32(0b0); break;
    }
    // clang-format on
  }
};

#endif // IMMEDIATE_GENERATOR_H
// RISC-V SiMPLE SV -- instruction decoder
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef INSTRUCTION_DECODER_H
#define INSTRUCTION_DECODER_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class instruction_decoder {
 public:
  logic<32> inst;
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<5> inst_rd;
  logic<5> inst_rs1;
  logic<5> inst_rs2;

  void tock() {
    inst_opcode = b7(inst, 0);
    inst_funct3 = b3(inst, 12);
    inst_funct7 = b7(inst, 25);
    inst_rd = b5(inst, 7);
    inst_rs1 = b5(inst, 15);
    inst_rs2 = b5(inst, 20);
  }
};

#endif // INSTRUCTION_DECODER_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef MULTIPLEXER2_H
#define MULTIPLEXER2_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

template <int WIDTH = 32>
class multiplexer2 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<1> sel;
  logic<WIDTH> out;

  void tock() {
    switch (sel) {
      case 0:
        out = in0;
        break;
      case 1:
        out = in1;
        break;
      default:
        out = DONTCARE;
        break;
    }
  }
};

#endif // MULTIPLEXER2_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef MULTIPLEXER4_H
#define MULTIPLEXER4_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

template <int WIDTH = 32>
class multiplexer4 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<WIDTH> in2;
  logic<WIDTH> in3;
  logic<2> sel;
  logic<WIDTH> out;

  void tock() {
    switch (sel) {
      case 0:
        out = in0;
        break;
      case 1:
        out = in1;
        break;
      case 2:
        out = in2;
        break;
      case 3:
        out = in3;
        break;
      default:
        out = DONTCARE;
        break;
    }
  }
};

#endif // MULTIPLEXER4_H
// RISC-V SiMPLE SV -- multiplexer module
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef MULTIPLEXER8_H
#define MULTIPLEXER8_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

template <int WIDTH = 32>
class multiplexer8 {
 public:
  logic<WIDTH> in0;
  logic<WIDTH> in1;
  logic<WIDTH> in2;
  logic<WIDTH> in3;
  logic<WIDTH> in4;
  logic<WIDTH> in5;
  logic<WIDTH> in6;
  logic<WIDTH> in7;
  logic<3> sel;
  logic<WIDTH> out;

  void tock() {
    // clang-format off
    switch (sel) {
      case 0:  out = in0; break;
      case 1:  out = in1; break;
      case 2:  out = in2; break;
      case 3:  out = in3; break;
      case 4:  out = in4; break;
      case 5:  out = in5; break;
      case 6:  out = in6; break;
      case 7:  out = in7; break;
      default: out = DONTCARE; break;
    }
    // clang-format on
  }
};

#endif // MULTIPLEXER8_H
// RISC-V SiMPLE SV -- register file
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef REGFILE_H
#define REGFILE_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class regfile {
 public:
  logic<1> write_enable;
  logic<5> rd_address;
  logic<5> rs1_address;
  logic<5> rs2_address;
  logic<32> rd_data;
  logic<32> rs1_data;
  logic<32> rs2_data;

 private:
  // 32 registers of 32-bit width
  logic<32> register_[32];

 public:
  // Read ports for rs1 and rs1
  void tock1() {
    rs1_data = register_[rs1_address];
    rs2_data = register_[rs2_address];
  }

  // Register x0 is always 0
  regfile() { register_[0] = b32(0b0); }

  void tock() { tick(); }

 private:
  // Write port for rd
  void tick() {
    if (write_enable)
      if (rd_address != b5(0b0)) register_[rd_address] = rd_data;
  }
};

#endif // REGFILE_H
// RISC-V SiMPLE SV -- generic register
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef REGISTER_H
#define REGISTER_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

template <int WIDTH = 32, int INITIAL = 0>
class single_register {
 public:
  logic<1> reset;
  logic<1> write_enable;
  logic<WIDTH> next;
  logic<WIDTH> value_;

  single_register() { value_ = INITIAL; }

  void tock() { tick(); }

 private:
  void tick() {
    if (reset)
      value_ = INITIAL;
    else if (write_enable)
      value_ = next;
  }
};

#endif // REGISTER_H
// RISC-V SiMPLE SV -- Single-cycle RISC-V core
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef RISCV_CORE_H
#define RISCV_CORE_H

#include "config.h"
#include "constants.h"
#include "data_memory_interface.h"
#include "metron/metron_tools.h"
#include "singlecycle_ctlpath.h"
#include "singlecycle_datapath.h"

class riscv_core {
 public:
  logic<1> reset;
  logic<32> bus_address;
  logic<32> bus_read_data;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

  logic<32> inst;
  logic<32> pc;

  void tock_pc() {
    datapath.tock_pc();
    pc = datapath.pc;
  }

  void tock_execute() {
    datapath.inst = inst;
    datapath.tock_instruction_decoder();
    datapath.tock_immediate_generator();

    ctlpath.inst_opcode = datapath.inst_opcode;
    ctlpath.inst_funct3 = datapath.inst_funct3;
    ctlpath.inst_funct7 = datapath.inst_funct7;

    ctlpath.tock_alu_function();
    ctlpath.tock_alu_operand_select();

    datapath.alu_function = ctlpath.alu_function;
    datapath.alu_operand_a_select = ctlpath.alu_operand_a_select;
    datapath.alu_operand_b_select = ctlpath.alu_operand_b_select;

    datapath.tock_reg_read();
    datapath.tock_mux_operand_a();
    datapath.tock_mux_operand_b();
    datapath.tock_alu();

    ctlpath.tock_data_mem_enable();
    datapath.tock_data_mem_write_data();
    dmem.read_enable = ctlpath.data_mem_read_enable;
    dmem.write_enable = ctlpath.data_mem_write_enable;
    dmem.data_format = datapath.inst_funct3;
    dmem.address = datapath.data_mem_address;
    dmem.write_data = datapath.data_mem_write_data;
    dmem.tock_bus();

    ctlpath.alu_result_equal_zero = datapath.alu_result_equal_zero;
    ctlpath.tock_pc_write_enable();
    ctlpath.tock_regfile_write_enable();
    ctlpath.tock_reg_writeback_select();
    ctlpath.tock_next_pc_select();

    //----------

    bus_address = dmem.bus_address;
    bus_write_data = dmem.bus_write_data;
    bus_byte_enable = dmem.bus_byte_enable;
    bus_read_enable = dmem.bus_read_enable;
    bus_write_enable = dmem.bus_write_enable;
  }

  void tock_writeback() {
    dmem.bus_read_data = bus_read_data;
    dmem.tock_read_data();

    datapath.next_pc_select = ctlpath.next_pc_select;
    datapath.tock_adder_pc_plus_4();
    datapath.tock_adder_pc_plus_immediate();
    datapath.tock_mux_next_pc_select();

    datapath.reset = reset;
    datapath.pc_write_enable = ctlpath.pc_write_enable;
    datapath.tock_program_counter();

    datapath.reg_writeback_select = ctlpath.reg_writeback_select;
    datapath.data_mem_read_data = dmem.read_data;
    datapath.tock_mux_reg_writeback();

    datapath.regfile_write_enable = ctlpath.regfile_write_enable;
    datapath.tock_reg_writeback();
  }

  //----------------------------------------

 private:
  singlecycle_datapath datapath;
  singlecycle_ctlpath ctlpath;
  data_memory_interface dmem;
};

#endif // RISCV_CORE_H
// RISC-V SiMPLE SV -- single-cycle controller
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef SINGLECYCLE_CONTROL_H
#define SINGLECYCLE_CONTROL_H

#include "config.h"
#include "constants.h"
#include "metron/metron_tools.h"

class singlecycle_control {
 public:
  logic<7> inst_opcode;
  logic<1> take_branch;
  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<2> alu_op_type;
  logic<1> data_mem_read_enable;
  logic<1> data_mem_write_enable;
  logic<3> reg_writeback_select;
  logic<2> next_pc_select;

  void tock_next_pc_select() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_opcode) {
      case OPCODE_BRANCH: next_pc_select = take_branch ? CTL_PC_PC_IMM : CTL_PC_PC4; break;
      case OPCODE_JALR:   next_pc_select = CTL_PC_RS1_IMM; break;
      case OPCODE_JAL:    next_pc_select = CTL_PC_PC_IMM; break;
      default:            next_pc_select = CTL_PC_PC4; break;
    }
    // clang-format on
  }

  void tock_pc_write_enable() { pc_write_enable = 0b1; }

  void tock_regfile_write_enable() {
    using namespace rv_constants;
    // clang-format off
    switch (inst_opcode) {
      case OPCODE_MISC_MEM: regfile_write_enable = 0; break;
      case OPCODE_STORE:    regfile_write_enable = 0; break;
      case OPCODE_BRANCH:   regfile_write_enable = 0; break;
      case OPCODE_LOAD:     regfile_write_enable = 1; break;
      case OPCODE_OP_IMM:   regfile_write_enable = 1; break;
      case OPCODE_AUIPC:    regfile_write_enable = 1; break;
      case OPCODE_OP:       regfile_write_enable = 1; break;
      case OPCODE_LUI:      regfile_write_enable = 1; break;
      case OPCODE_JALR:     regfile_write_enable = 1; break;
      case OPCODE_JAL:      regfile_write_enable = 1; break;
      default:              regfile_write_enable = DONTCARE; break;
    }
    // clang-format on
  }

  void tock_alu_operand_a_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_operand_a_select = CTL_ALU_A_PC; break;
      case OPCODE_JAL:      alu_operand_a_select = CTL_ALU_A_PC; break;

      case OPCODE_OP:       alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_LUI:      alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_BRANCH:   alu_operand_a_select = CTL_ALU_A_RS1; break;

      case OPCODE_LOAD:     alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_STORE:    alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_OP_IMM:   alu_operand_a_select = CTL_ALU_A_RS1; break;
      case OPCODE_JALR:     alu_operand_a_select = CTL_ALU_A_RS1; break;
      default:              alu_operand_a_select = DONTCARE; break;
    }
    // clang-format on
  }

  void tock_alu_operand_b_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_JAL:      alu_operand_b_select = CTL_ALU_B_IMM; break;

      case OPCODE_OP:       alu_operand_b_select = CTL_ALU_B_RS2; break;
      case OPCODE_LUI:      alu_operand_b_select = CTL_ALU_B_RS2; break;
      case OPCODE_BRANCH:   alu_operand_b_select = CTL_ALU_B_RS2; break;

      case OPCODE_LOAD:     alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_STORE:    alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_OP_IMM:   alu_operand_b_select = CTL_ALU_B_IMM; break;
      case OPCODE_JALR:     alu_operand_b_select = CTL_ALU_B_IMM; break;
      default:              alu_operand_b_select = DONTCARE; break;
    }
    // clang-format on
  }

  void tock_alu_op_type() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_AUIPC:    alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_JAL:      alu_op_type = CTL_ALU_ADD; break;

      case OPCODE_OP:       alu_op_type = CTL_ALU_OP; break;
      case OPCODE_BRANCH:   alu_op_type = CTL_ALU_BRANCH; break;

      case OPCODE_LOAD:     alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_STORE:    alu_op_type = CTL_ALU_ADD; break;
      case OPCODE_OP_IMM:   alu_op_type = CTL_ALU_OP_IMM; break;
      case OPCODE_JALR:     alu_op_type = CTL_ALU_ADD; break;
      default:              alu_op_type = DONTCARE; break;
    }
    // clang-format on
  }

  void tock_data_mem_read_enable() {
    using namespace rv_constants;
    data_mem_read_enable = inst_opcode == OPCODE_LOAD;
  }

  void tock_data_mem_write_enable() {
    using namespace rv_constants;
    data_mem_write_enable = inst_opcode == OPCODE_STORE;
  }

  void tock_reg_writeback_select() {
    using namespace rv_constants;

    // clang-format off
    switch (inst_opcode) {
      case OPCODE_OP_IMM:   reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_AUIPC:    reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_OP:       reg_writeback_select = CTL_WRITEBACK_ALU; break;
      case OPCODE_LUI:      reg_writeback_select = CTL_WRITEBACK_IMM; break;
      case OPCODE_JALR:     reg_writeback_select = CTL_WRITEBACK_PC4; break;
      case OPCODE_JAL:      reg_writeback_select = CTL_WRITEBACK_PC4; break;
      case OPCODE_LOAD:     reg_writeback_select = CTL_WRITEBACK_DATA; break;
      default:              reg_writeback_select = DONTCARE; break;
    }
    // clang-format on
  }
};

#endif // SINGLECYCLE_CONTROL_H
// RISC-V SiMPLE SV -- control path
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef SINGLECYCLE_CTLPATH_H
#define SINGLECYCLE_CTLPATH_H

#include "alu_control.h"
#include "config.h"
#include "constants.h"
#include "control_transfer.h"
#include "metron/metron_tools.h"
#include "singlecycle_control.h"

class singlecycle_ctlpath {
 public:
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<1> alu_result_equal_zero;

  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<1> data_mem_read_enable;
  logic<1> data_mem_write_enable;
  logic<3> reg_writeback_select;
  logic<5> alu_function;
  logic<2> next_pc_select;

  void tock_alu_function() {
    control.inst_opcode = inst_opcode;
    control.tock_alu_op_type();
    alu_ctrl.alu_op_type = control.alu_op_type;
    alu_ctrl.inst_funct3 = inst_funct3;
    alu_ctrl.inst_funct7 = inst_funct7;
    alu_ctrl.tock_alu_function();
    alu_function = alu_ctrl.alu_function;
  }

  void tock_alu_operand_select() {
    control.tock_alu_operand_a_select();
    control.tock_alu_operand_b_select();
    alu_operand_a_select = control.alu_operand_a_select;
    alu_operand_b_select = control.alu_operand_b_select;
  }

  void tock_data_mem_enable() {
    control.tock_data_mem_read_enable();
    control.tock_data_mem_write_enable();
    data_mem_read_enable = control.data_mem_read_enable;
    data_mem_write_enable = control.data_mem_write_enable;
  }

  void tock_pc_write_enable() {
    control.tock_pc_write_enable();
    pc_write_enable = control.pc_write_enable;
  }

  void tock_regfile_write_enable() {
    control.tock_regfile_write_enable();
    regfile_write_enable = control.regfile_write_enable;
  }

  void tock_reg_writeback_select() {
    control.tock_reg_writeback_select();
    reg_writeback_select = control.reg_writeback_select;
  }

  void tock_next_pc_select() {
    transfer.result_equal_zero = alu_result_equal_zero;
    transfer.inst_funct3 = inst_funct3;
    transfer.tock_take_branch();
    control.take_branch = transfer.take_branch;
    control.tock_next_pc_select();
    next_pc_select = control.next_pc_select;
  }

  //----------------------------------------

 private:
  singlecycle_control control;
  control_transfer transfer;
  alu_control alu_ctrl;
};

#endif // SINGLECYCLE_CTLPATH_H
// RISC-V SiMPLE SV -- single-cycle data path
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef SINGLECYCLE_DATAPATH_H
#define SINGLECYCLE_DATAPATH_H

#include "adder.h"
#include "alu.h"
#include "config.h"
#include "constants.h"
#include "immediate_generator.h"
#include "instruction_decoder.h"
#include "metron/metron_tools.h"
#include "multiplexer2.h"
#include "multiplexer4.h"
#include "multiplexer8.h"
#include "regfile.h"
#include "register.h"

class singlecycle_datapath {
 public:
  logic<1> reset;
  logic<32> data_mem_read_data;
  logic<32> data_mem_address;
  logic<32> data_mem_write_data;

  logic<32> inst;
  logic<32> pc;
  logic<7> inst_opcode;
  logic<3> inst_funct3;
  logic<7> inst_funct7;
  logic<1> alu_result_equal_zero;

  // control signals
  logic<1> pc_write_enable;
  logic<1> regfile_write_enable;
  logic<1> alu_operand_a_select;
  logic<1> alu_operand_b_select;
  logic<3> reg_writeback_select;
  logic<2> next_pc_select;
  logic<5> alu_function;

 private:
  logic<32> rs1_data;
  logic<32> rs2_data;

  logic<5> inst_rd;
  logic<5> inst_rs1;
  logic<5> inst_rs2;

 public:
  //----------------------------------------

  void tock_pc() { pc = program_counter.value_; }

  //----------------------------------------

  void tock_instruction_decoder() {
    idec.inst = inst;
    idec.tock();

    inst_opcode = idec.inst_opcode;
    inst_funct3 = idec.inst_funct3;
    inst_funct7 = idec.inst_funct7;
    inst_rd = idec.inst_rd;
    inst_rs1 = idec.inst_rs1;
    inst_rs2 = idec.inst_rs2;
  }

  //----------------------------------------

  void tock_immediate_generator() {
    igen.inst = inst;
    igen.tock();
  }

  //----------------------------------------

  void tock_reg_read() {
    regs.rd_address = idec.inst_rd;
    regs.rs1_address = idec.inst_rs1;
    regs.rs2_address = idec.inst_rs2;
    regs.tock1();
    rs1_data = regs.rs1_data;
    rs2_data = regs.rs2_data;
  }

  void tock_mux_operand_a() {
    mux_operand_a.sel = alu_operand_a_select;
    mux_operand_a.in0 = regs.rs1_data;
    mux_operand_a.in1 = program_counter.value_;
    mux_operand_a.tock();
  }

  void tock_mux_operand_b() {
    mux_operand_b.sel = alu_operand_b_select;
    mux_operand_b.in0 = regs.rs2_data;
    mux_operand_b.in1 = igen.immediate;
    mux_operand_b.tock();
  }

  void tock_alu() {
    alu_core.alu_function = alu_function;
    alu_core.operand_a = mux_operand_a.out;
    alu_core.operand_b = mux_operand_b.out;
    alu_core.tock();
    alu_result_equal_zero = alu_core.result_equal_zero;
  }

  void tock_adder_pc_plus_4() {
    adder_pc_plus_4.operand_a = b32(0x00000004);
    adder_pc_plus_4.operand_b = program_counter.value_;
    adder_pc_plus_4.tock();
  }

  void tock_adder_pc_plus_immediate() {
    adder_pc_plus_immediate.operand_a = program_counter.value_;
    adder_pc_plus_immediate.operand_b = igen.immediate;
    adder_pc_plus_immediate.tock();
  }

  void tock_data_mem_write_data() {
    data_mem_address = alu_core.result;
    data_mem_write_data = regs.rs2_data;
  }

  void tock_mux_next_pc_select() {
    mux_next_pc_select.sel = next_pc_select;
    mux_next_pc_select.in0 = adder_pc_plus_4.result;
    mux_next_pc_select.in1 = adder_pc_plus_immediate.result;
    mux_next_pc_select.in2 = cat(b31(alu_core.result, 1), b1(0b0));
    mux_next_pc_select.in3 = b32(0b0);
    mux_next_pc_select.tock();
  }

  void tock_program_counter() {
    program_counter.reset = reset;
    program_counter.write_enable = pc_write_enable;
    program_counter.next = mux_next_pc_select.out;
    program_counter.tock();
  }

  void tock_mux_reg_writeback() {
    mux_reg_writeback.sel = reg_writeback_select;
    mux_reg_writeback.in0 = alu_core.result;
    mux_reg_writeback.in1 = data_mem_read_data;
    mux_reg_writeback.in2 = adder_pc_plus_4.result;
    mux_reg_writeback.in3 = igen.immediate;
    mux_reg_writeback.in4 = b32(0b0);
    mux_reg_writeback.in5 = b32(0b0);
    mux_reg_writeback.in6 = b32(0b0);
    mux_reg_writeback.in7 = b32(0b0);
    mux_reg_writeback.tock();
  }

  void tock_reg_writeback() {
    regs.write_enable = regfile_write_enable;
    regs.rd_data = mux_reg_writeback.out;
    regs.tock();
  }

  //----------------------------------------

 private:
  adder<32> adder_pc_plus_4;
  adder<32> adder_pc_plus_immediate;
  alu alu_core;
  multiplexer4<32> mux_next_pc_select;
  multiplexer2<32> mux_operand_a;
  multiplexer2<32> mux_operand_b;
  multiplexer8<32> mux_reg_writeback;
  single_register<32, rv_config::INITIAL_PC> program_counter;
  regfile regs;
  instruction_decoder idec;
  immediate_generator igen;
};

#endif // SINGLECYCLE_DATAPATH_H
// RISC-V SiMPLE SV -- Toplevel
// BSD 3-Clause License
// (c) 2017-2019, Arthur Matos, Marcus Vinicius Lamar, Universidade de Braslia,
//                Marek Materzok, University of Wrocaw

#ifndef TOPLEVEL_H
#define TOPLEVEL_H

#include "config.h"
#include "constants.h"
#include "example_data_memory_bus.h"
#include "example_text_memory_bus.h"
#include "metron/metron_tools.h"
#include "riscv_core.h"

class toplevel {
 public:
  logic<1> reset;
  logic<32> bus_read_data;
  logic<32> bus_address;
  logic<32> bus_write_data;
  logic<4> bus_byte_enable;
  logic<1> bus_read_enable;
  logic<1> bus_write_enable;

  logic<32> inst;
  logic<32> pc;

  toplevel(const char* text_filename = nullptr, const char* data_filename = nullptr)
  : text_memory_bus(text_filename),
    data_memory_bus(data_filename)
  {
  }

  //----------------------------------------

  void tock(int bogus_param) {
    core.reset = reset;
    core.tock_pc();

    text_memory_bus.address = core.pc;
    text_memory_bus.tock_read_data();

    core.inst = text_memory_bus.read_data;
    core.tock_execute();

    data_memory_bus.address = core.bus_address;
    data_memory_bus.read_enable = core.bus_read_enable;
    data_memory_bus.write_enable = core.bus_write_enable;
    data_memory_bus.byte_enable = core.bus_byte_enable;
    data_memory_bus.write_data = core.bus_write_data;
    data_memory_bus.tock();

    core.bus_read_data = data_memory_bus.read_data;
    core.tock_writeback();

    //----------

    bus_read_data = data_memory_bus.read_data;
    bus_address = core.bus_address;
    bus_write_data = core.bus_write_data;
    bus_byte_enable = core.bus_byte_enable;
    bus_read_enable = core.bus_read_enable;
    bus_write_enable = core.bus_write_enable;
    inst = text_memory_bus.read_data;
    pc = core.pc;
  }

  //----------------------------------------

 private:
  riscv_core core;

  example_text_memory_bus text_memory_bus;
  example_data_memory_bus data_memory_bus;
};

#endif // TOPLEVEL_H
#include "metron/metron_tools.h"

// We need to support very basic preprocessor macros or else dealing with mixed
// languages will be a huge pain in the butt.

#ifdef METRON_SV

module Module2(input logic clock);
  logic[7:0] counter;

  always @(posedge clock) begin
    counter <= counter + 1;
  end
endmodule

#else

class Module {
};

#endif
class Adder {
public:
  int add(int a, int b) {
    return a + b;
  }
};

//----------

class Adder2 {
public:
  int a;
  int b;
  int sum;

  void add() {
    sum = a + b;
  }
};
#include "metron/metron_tools.h"

class Module {
  // Private only so we don't spam our port list for this example
private:

  // Logic types can be indexed like arrays that return individual bits.
  logic<1> extract_bit_four(logic<16> a) {
    return a[4];
  }

  // bN(x, offset) is shorthand for bx<N>(x, offset) which extracts a slice
  // of the bits in a field. Slices that overflow the source will be padded
  // with 0.
  logic<3> extract_three_bits_starting_at_bit_four(logic<16> a) {
    return b3(a, 4);
  }

  // Logic types can be concatenated together, and the result's bit width will
  // be the sum of the bit widths of the arguments.
  logic<3> concatenate(logic<1> a, logic<1> b, logic<1> c) {
    return cat(a, b, c);
  }

  // Logic types can be duplicated, which is equivalent to cat(x, x, x...). The
  // result's bit width will be the product of the argument width and the dup
  // count.
  logic<9> duplicate_three_times(logic<3> a) {
    return dup<3>(a);
  }
};
#include "metron/metron_tools.h"

//------------------------------------------------------------------------------

class Blockram {
public:
  Blockram() {
    readmemh("blockram.hex", memory_, 0, 255);
  }

  logic<8> get_data() const {
    return data_out_;
  }

  void tick(logic<8> address, logic<1> write, logic<8> data_in) {
    if (write) {
      memory_[address] = data_in;
      data_out_ = data_in;
    }
    else {
      data_out_ = memory_[address];
    }
  }

private:
  logic<8> memory_[256];
  logic<8> data_out_;
};
#include "metron/metron_tools.h"
#include "blockram.h"

//------------------------------------------------------------------------------

class Checksum {
public:

  int get_checksum() const {
    return sum_;
  }

  int get_done() const {
    return cursor_ == 256;
  }

  void tock(int reset) {
    logic<8> data = ram.get_data();
    ram.tick(cursor_, 0, 0);
    tick(reset, data);
  }

private:

  void tick(int reset, logic<8> data) {
    if (reset) {
      cursor_ = 0;
      sum_ = 0;
    }
    else {
      if (cursor_ < 256) {
        cursor_ = cursor_ + 1;
        sum_ = sum_ + data;
      }
    }
  }

  int cursor_;
  int sum_;
  Blockram ram;
};

//------------------------------------------------------------------------------
// If "sum" does not have an underscore suffix, it is a signal and "add" will
// be converted to an always_comb block.
class Adder1 {
public:
  int sum;
  void add(int a, int b) {
    sum = a + b;
  }
};

// If "sum" does have an underscore suffix, it is a register and "add" will
// be converted to an always_ff block.
class Adder2 {
public:
  int sum_;
  void add(int a, int b) {
    sum_ = a + b;
  }
};
// A very basic counter in plain C++, converted to Verilog using Metron.

class Counter {
public:
  int count_;
  void update() {
    count_++;
  }
};
// FIXME this example is outdated

// If we try to update mutually-dependent fields in one function, we'll hit an
// error. Uncomment to see the error.

/*
class Module1 {
public:
  int a;
  int b;

  void update() {
    a = b + 1;
    b = a + 1;
  }
};
*/

// This module declares "update_a" first.
class Module2 {
public:
  int a_;
  int b;

  void update_a() {
    a_ = b + 1;
  }

  void update_b() {
    b = a_ + 1;
  }
};

// This module declares "update_b" first.
class Module3 {
public:
  int a;
  int b_;

  void update_a() {
    a = b_ + 1;
  }

  void update_b() {
    b_ = a + 1;
  }
};

// This module uses temporaries to update both A and B in a single function
class Module4 {
public:
  int a_;
  int b_;

  void update() {
    int old_a = a_;
    int old_b = b_;
    a_ = old_b + 1;
    b_ = old_a + 1;
  }
};
class ModuleWithFunction {
public:

  // Tock methods can call pure functions.
  int get_signal1(int x) {
    return reg1_ + my_func(x);
  }

  // Tick methods can call pure functions.
  void update_reg() {
    reg1_ = my_func(reg1_);
  }

private:
  int reg1_;

  // This function is called elsewhere in the module, so it would not be
  // added to the port list even if it were public.
  int my_func(int x) const {
    return x + 17;
  }

  // This function would appear in the port list if it were public.
  // Uncomment the line below to see the difference.
//public:
  int my_func2(int x) const {
    return x + 17;
  }
};

//----------------------------------------

class ModuleWithTask {
public:
  int reg1_;
  int reg2_;

  // The top-level tick method will become an always_ff.
  void tick1() {
    reg1_ = reg1_ + 1;
    tick2();
  }

  // Tick methods called by other tick methods will become tasks.
  void tick2() {
    reg2_ = reg2_ + 1;
  }
};
class NonBlockingAssignment {
public:
  int count_;
  void update() {
    count_ = count_ + 1;
    int dummy = count_;
  }
};
#include "adder.h"
#include "counter.h"

class ModuleWithSubmodules {
public:
  int result;

  void update() {
    // The field "my_counter.count" is a register, which means we can only read
    // it _before_ it is written. Uncomment this line to see the error if we
    // call update() on the counter before we send its value to the adder.
    // my_counter.update();

    // Each branch of our if() can call my_adder.add, but we can only have one
    // call to it total per code path.
    if (1) {
      result = my_adder.add(my_counter.count_, 7);
    }
    else {
      result = my_adder.add(23, my_counter.count_);
    }

    // If we try to call it a second time, Metron will generate an error.
    // int result2 = my_adder.add(3, 4);

    // The counter's update() method is a tick, but the method we're currently
    // in is a tock. This cross-module, cross-tick/tock call is OK.
    my_counter.update();
  }

private:
  // Metron will generate and bind variables to our submodules during
  // conversion so that we can "call" methods in them.
  Adder my_adder;
  Counter my_counter;
};
#include "metron/metron_tools.h"

namespace MyPackage {
  static const int ADDER_WIDTH = 17;
  static const int INCREMENT_VAL = 3;
};

template<int width = 32>
class AdjustableAdder {
public:
  logic<width> add(logic<width> a, logic<width> b) {
    return a + b;
  }
};

class Module {
  public:
  logic<MyPackage::ADDER_WIDTH> increment(logic<MyPackage::ADDER_WIDTH> x) {
    return x + MyPackage::INCREMENT_VAL;
  }

private:
  AdjustableAdder<MyPackage::ADDER_WIDTH> my_adder;
};
class Tutorial2 {
public:

  int get_thing() {
    return 1;
  }
};
// Tutorial 3

class Module {
public:
};
// Tutorial 4

class Module {
public:
};
// Tutorial 5

class Module {
public:
};
#include "metron/metron_tools.h"

/*
640x480x60
Pixel clock 25.175 MHz

Screen X    [000-639]
Front porch [640-655]
HSync-      [656-751]
Back porch  [752-799]

Screen Y    [000-479]
Front porch [480-489]
VSync-      [490-491]
Back porch  [492-524]
*/

class VGAOut {
 public:
  logic<1> vga_hsync;
  logic<1> vga_vsync;
  logic<1> vga_R;
  logic<1> vga_G;
  logic<1> vga_B;

  logic<1> in_border() const {
    return (px_ <= 7) || (px_ >= 633) || (py_ <= 7) || (py_ >= 473);
  }

  logic<1> in_checker() const {
    return px_[3] ^ py_[3];
  }

  void update_video() {
    vga_hsync = !((px_ >= 656) && (px_ <= 751));
    vga_vsync = !((py_ >= 490) && (py_ <= 491));

    if ((px_ < 640) && (py_ < 480)) {
      vga_R = in_border() | in_checker();
      vga_G = in_border();
      vga_B = in_border();
    } else {
      vga_R = 0;
      vga_G = 0;
      vga_B = 0;
    }
  }

  void update_counters() {
    logic<10> new_px = px_ + 1;
    logic<10> new_py = py_;

    if (new_px == 800) {
      new_px = 0;
      new_py = new_py + 1;
    }

    if (new_py == 525) {
      new_py = 0;
    }

    px_ = new_px;
    py_ = new_py;
  }

private:
  logic<10> px_;
  logic<10> py_;
};
A simple UART-based testbench for Metron that exercises translation to
SystemVerilog, simulation via Icarus, translation back to C via Verilator,
synthesis via Yosys, place+route via NextPNR, and uploading to a Lattice ICE40
fpga via Icestorm.
#ifndef UART_HELLO_H
#define UART_HELLO_H

#include "metron/metron_tools.h"

//==============================================================================

template <int repeat_msg = 0>
class uart_hello {
public:
  uart_hello() {
    readmemh("examples/uart/message.hex", memory_, 0, 511);
    state_ = 0;
    cursor_ = 0;
  }

  // The byte of data we want transmitted is always the one at the cursor.
  logic<8> get_data() const {
    return memory_[cursor_];
  }

  // True if we want to transmit a byte
  logic<1> get_request() const {
    return state_ == SEND;
  }

  // True if we've transmitted the whole message.
  logic<1> get_done() const {
    return state_ == DONE;
  }

  void tick(
    logic<1> reset,          // Top-level reset signal.
    logic<1> clear_to_send,  // True if the transmitter can accept an input byte
    logic<1> idle)           // True if the transmitter is idle
  {
    // In reset we're always in WAIT state with the message cursor set to
    // the start of the message buffer.
    if (reset) {
      state_ = WAIT;
      cursor_ = 0;
    }
    else {
      // If we're waiting for the transmitter to be free and it's told us that
      // it's idle, go to SEND state.
      if (state_ == WAIT && idle) {
        state_ = SEND;
      }

      // If we're currently sending a message and the transmitter is ready to
      // accept another byte,
      else if (state_ == SEND && clear_to_send) {
        // either go to DONE state if we're about to send the last character of
        // the message
        if (cursor_ == message_len - 1) {
          state_ = DONE;
        }

        // or just advance the message cursor.
        else {
          cursor_ = cursor_ + 1;
        }
      }

      // If we've finished transmitting, reset the message cursor and either go
      // back to WAIT state if we want to re-transmit or just stay in DONE
      // otherwise.
      else if (state_ == DONE) {
        cursor_ = 0;
        if (repeat_msg) state_ = WAIT;
      }
    }
  }

private:
  static const int message_len = 512;
  static const int cursor_bits = clog2(message_len);

  static const int WAIT = 0; // Waiting for the transmitter to be free
  static const int SEND = 1; // Sending the message buffer
  static const int DONE = 2; // Message buffer sent
  logic<2> state_;            // One of the above states

  logic<8> memory_[512];      // The buffer preloaded with our message
  logic<cursor_bits> cursor_; // Index into the message buffer of the _next_ character to transmit
};

//==============================================================================

#endif // UART_HELLO_H
#ifndef UART_RX_H
#define UART_RX_H

#include "metron/metron_tools.h"

//==============================================================================

template <int cycles_per_bit = 4>
class uart_rx {
public:

  uart_rx() {
    bit_delay_ = 0;
    bit_count_ = 0;
    data_out_ = 0;
    checksum_ = 0;
  }

  // Our output is valid once we've received 8 bits.
  logic<1> get_valid() const {
    return bit_count_ == 8;
  }

  // The most recent data byte received.
  logic<8> get_data_out() const {
    return data_out_;
  }

  // The checksum of all bytes received so far.
  logic<32> get_checksum() const {
    return checksum_;
  }

  void tick(
    logic<1> reset,  // Top-level reset signal
    logic<1> serial) // Serial input from the transmitter
  {
    if (reset) {
      bit_delay_ = bit_delay_max;
      bit_count_ = bit_count_max;
      data_out_ = 0;
      checksum_ = 0;
    }
    else {

      // If we're waiting for the next bit to arrive, keep waiting until our
      // bit delay counter runs out.
      if (bit_delay_ < bit_delay_max) {
        bit_delay_ = bit_delay_ + 1;
      }

      // We're done waiting for a bit. If we have bits left to receive, shift
      // them into the top of the output register.
      else if (bit_count_ < bit_count_max) {
        logic<8> new_output = (serial << 7) | (data_out_ >> 1);

        // If that was the last data bit, add the finished byte to our checksum.
        if (bit_count_ == 7) {
          checksum_ = checksum_ + new_output;
        }

        // Move to the next bit and reset our delay counter.
        bit_delay_ = 0;
        bit_count_ = bit_count_ + 1;
        data_out_ = new_output;
      }

      // We're not waiting for a bit and we finished receiving the previous
      // byte. Wait for the serial line to go low, which signals the start of
      // the next byte.
      else if (serial == 0) {
        bit_delay_ = 0;
        bit_count_ = 0;
      }
    }
  }

 private:
  // We wait for cycles_per_bit cycles
  static const int bit_delay_width = clog2(cycles_per_bit);
  static const int bit_delay_max = cycles_per_bit - 1;
  logic<bit_delay_width> bit_delay_;

  // Our serial data format is 8n1, which is short for "one start bit, 8 data
  // bits, no parity bit, one stop bit". If bit_count_ == 1, we're only waiting
  // on the stop bit.
  static const int bit_count_max = 9;
  static const int bit_count_width = clog2(bit_count_max);
  logic<bit_count_width> bit_count_;

  // The received byte
  logic<8> data_out_;

  // The checksum of all bytes received so far.
  logic<32> checksum_;
};

//==============================================================================

#endif // UART_RX_H
#ifndef UART_TOP_H
#define UART_TOP_H

#include "metron/metron_tools.h"
#include "uart_hello.h"
#include "uart_rx.h"
#include "uart_tx.h"

//==============================================================================

template <int cycles_per_bit = 3, int repeat_msg = 0>
class uart_top {
public:

  // The actual bit of data currently on the transmitter's output
  logic<1> get_serial() const {
    return tx_.get_serial();
  }

  // Returns true if the receiver has a byte in its buffer
  logic<1> get_valid() const {
    return rx_.get_valid();
  }

  // The next byte of data from the receiver
  logic<8> get_data_out() const {
    return rx_.get_data_out();
  }

  // True if the client has sent its message and the transmitter has finished
  // transmitting it.
  logic<1> get_done() const {
    return hello_.get_done() && tx_.get_idle();
  }

  // Checksum of all the bytes received
  logic<32> get_checksum() const {
    return rx_.get_checksum();
  }

  void tock(logic<1> reset) {
    // Grab signals from our submodules before we tick them.
    logic<8> data = hello_.get_data();
    logic<1> request = hello_.get_request();

    logic<1> serial = tx_.get_serial();
    logic<1> clear_to_send = tx_.get_clear_to_send();
    logic<1> idle = tx_.get_idle();

    // Tick all submodules.
    hello_.tick(reset, clear_to_send, idle);
    tx_.tick(reset, data, request);
    rx_.tick(reset, serial);
  }

  //----------------------------------------
private:
  // Our UART client that transmits our "hello world" test message
  uart_hello<repeat_msg>  hello_;
  // The UART transmitter
  uart_tx<cycles_per_bit> tx_;
  // The UART receiver
  uart_rx<cycles_per_bit> rx_;
};

//==============================================================================

#endif // UART_TOP_H
#ifndef UART_TX_H
#define UART_TX_H

#include "metron/metron_tools.h"

//==============================================================================

template <int cycles_per_bit = 4>
class uart_tx {
public:
  uart_tx() {
    bit_delay_ = bit_delay_max;
    bit_count_ = bit_count_max;
    output_buffer_ = 0;
  }

  // The actual bit of data we're sending to the serial port.
  logic<1> get_serial() const {
    return output_buffer_ & 1;
  }

  // True if the transmitter is ready to accept another byte.
  logic<1> get_clear_to_send() const {
    return ((bit_count_ == bit_count_done) && (bit_delay_ == bit_delay_max)) ||
           (bit_count_ > bit_count_done);
  }

  // True if the transmitter has sent the message plus the extra stop bits.
  logic<1> get_idle() const {
    return (bit_count_ == bit_count_max) && (bit_delay_ == bit_delay_max);
  }

  void tick(logic<1> reset, logic<8> send_data, logic<1> send_request) {
    if (reset) {
      bit_delay_ = bit_delay_max;
      bit_count_ = bit_count_max;
      output_buffer_ = 0x1FF;
    }

    else {
      // If we've just sent a bit, wait for the delay to expire before sending
      // another.
      if (bit_delay_ < bit_delay_max) {
        bit_delay_ = bit_delay_ + 1;
      }

      // The bit delay is done. If we have more bits to send, shift our output
      // buffer over and append a stop bit.
      else if (bit_count_ < bit_count_done) {
        bit_delay_ = 0;
        bit_count_ = bit_count_ + 1;
        output_buffer_ = (output_buffer_ >> 1) | 0x100;
      }

      // If we don't have any more bits to send, check for a new send request.
      else if (send_request) {
        bit_delay_ = 0;
        bit_count_ = 0;
        // We shift the new byte left by one so that the low 0 bit in the output
        // buffer serves as the start bit for the next byte.
        output_buffer_ = send_data << 1;
      }

      // If there was no send request, keep sending extra stop bits until we've
      // sent enough.
      else if (bit_count_ < bit_count_max) {
        bit_delay_ = 0;
        bit_count_ = bit_count_ + 1;
      }
    }
  }

private:

  // We wait {cycles_per_bit} cycles between sending bits.
  static const int bit_delay_width = clog2(cycles_per_bit);
  static const int bit_delay_max   = cycles_per_bit - 1;
  logic<bit_delay_width> bit_delay_;

  // We send 1 start bit, 8 data bits, and 1 stop bit per byte = 10 bits per
  // byte total. We also send 7 additional stop bits between messages to
  // guarantee that the receiver can resynchronize with our start bit.

  static const int bit_count_done  = 10;
  static const int extra_stop_bits = 7;
  static const int bit_count_width = clog2(10 + extra_stop_bits);
  static const int bit_count_max   = bit_count_done + extra_stop_bits;
  logic<bit_count_width> bit_count_;

  // Our output buffer is 9 (not 8) bits wide so that the low bit can serve as
  // our start bit.
  logic<9> output_buffer_;
};

//==============================================================================

#endif // UART_TX_H
Tests in this directory are designed to run the Metron simulation in lockstep
with the Verilator simulation.
#include "metron/metron_tools.h"

class Module {
public:
  Module() {
    counter_ = 0;
  }

  logic<1> done() {
    return counter_ >= 100;
  }

  logic<32> result() {
    return counter_;
  }

  void tock() {
    tick();
  }

private:

  void tick() {
    counter_ = counter_ + 1;
  }

  logic<32> counter_;

};
#include "metron/metron_tools.h"

// All the combos of tasks/funcs should work from ticks and tocks.

class Module {
public:
  Module() {
    my_reg_ = 0;
    counter_ = 0;
  }

  logic<32> my_sig;

  logic<1> done() {
    return counter_ > 1000;
  }

  logic<32> result() {
    return my_reg_;
  }

  void tock() {
    my_sig = private_func2(171) + 7;
    tick();
  }

private:

  logic<32> private_func2(logic<8> x) {
    return my_reg_ + private_func(51);
  }

  void tick() {
    private_task(private_func(33));
    counter_ = counter_ + 1;
  }

  void private_task(logic<32> x) {
    my_reg_ = my_reg_ - private_func(17);
  }

  logic<32> private_func(logic<32> y) {
    return (my_reg_ >> 3) + y;
  }

  logic<32> my_reg_;
  logic<32> counter_;
};
#include "metron/metron_tools.h"

class Module {
public:
  Module() {
    counter_ = 0;
    lfsr_ = 0xDEADBEEF;
  }

  logic<1> done() {
    return counter_ >= 100;
  }

  logic<32> result() {
    return lfsr_;
  }

  void tock() {
    tick();
  }

private:

  void tick() {
    counter_ = counter_ + 1;
    logic<1> next_bit = lfsr_[31] ^ lfsr_[21] ^ lfsr_[1] ^ lfsr_[0];
    lfsr_ = cat(lfsr_, next_bit);
  }

  logic<32> counter_;
  logic<32> lfsr_;

};
#include "metron/metron_tools.h"

// Force a mismatch between the Metron and Verilator sims so we can ensure that
// we catch them.

class Module {
public:
  Module() {
    counter_ = 0;
  }

  logic<1> done() {
    return counter_ >= 7;
  }

  logic<32> result() {
    logic<32> c = counter_;
    /*#
    c = c + 1;
    #*/
    return c;
  }

  void tock() {
    tick();
  }

private:

  void tick() {
    counter_ = counter_ + 1;
  }

  logic<32> counter_;

};
#include "metron/metron_tools.h"

// Intentionally-failing test that should trigger the lockstep test timeout

class Module {
public:
  Module() {
    counter_ = 0;
  }

  logic<1> done() {
    return counter_ >= 0xFFFF0000;
  }

  logic<32> result() {
    return counter_;
  }

  void tock() {
    tick();
  }

private:

  void tick() {
    counter_ = counter_ + 1;
  }

  logic<32> counter_;

};
All the header files in this directory should _not_ be convertible to
SystemVerilog. They should fail for one or more reasons, and the reason texts
are stored in the header file tagged with "//X".
#include "metron/metron_tools.h"

// Registers that are read after they're written should fail.

// X Context reg had invalid state after trace

class Module {
 public:
  void tock() { tick(); }

 private:
  void tick() {
    logic<1> x = reg_;
    reg_ = 1;
    logic<1> y = reg_;
  }

  logic<1> reg_;
};
#include "metron/metron_tools.h"

// Signals that are written after they're read should fail.

// X Context sig had invalid state after trace

class Module {
 public:
  void tock() {
    sig = 1;
    logic<1> x = sig;
    sig = 0;
  }

  logic<1> sig;
};
#include "metron/metron_tools.h"

// X Context sig1 had invalid state after trace

class Module {
 public:
  void tock1() { sig1 = sig2; }

  void tock2() { sig2 = sig1; }

 private:
  logic<8> sig1;
  logic<8> sig2;
};
#include "metron/metron_tools.h"

// The tracer should catch it if we forget a break.
// X Case statement in tock does not end with break

class Module {
 public:
  logic<8> tock(logic<8> in) {
    logic<8> result;
    switch (in) {
      case 0:
      case 1:
      case 2:
        result = 10;
        break;
      case 3: {
        result = 20;
        /*break;*/
      }
      default:
        result = 30;
        break;
    }

    return result;
  }
};
#include "metron/metron_tools.h"

// A method that writes both a signal and a register should fail

class Module {
 public:

  void update(logic<1> in) {
    sig = reg_ + in;
    reg_ = sig + in;
  }

  logic<1> sig;
  logic<1> reg_;
};
#include "metron/metron_tools.h"

// If statements whose sub-blocks contain submodule calls _must_ use {}.

// X If branches that contain component calls must use {}.

class Submod {
 public:
  int my_sig;
  void tock() {
    my_sig = 1;
  }
};

class Module {
 public:

  int my_sig;

  void tock() {
    if (1)
      submod.tock();
    else
      submod.tock();
    my_sig = submod.my_sig;
  }

  Submod submod;
};
#include "metron/metron_tools.h"

// The tracer should catch it if we add a redundant break and it's in a block.

// X Case statement in tock does not end with break

class Module {
 public:
  logic<8> tock(logic<8> in) {
    logic<8> result;
    switch (in) {
      case 0: {
        result = 10;
        break;
        result = 10;
        break;
      }
      default:
        result = 30;
        break;
    }

    return result;
  }
};
#include "metron/metron_tools.h"

// If for some reason you put a return in the middle of a block, we should catch
// it.

// X Method tock has non-terminal return

class Module {
 public:
  logic<8> tock() {
    logic<8> a = 10;
    logic<8> b = 2;
    logic<8> c;

    c = a + b;
    return c;
    c = b + b;
  }
};
#include "metron/metron_tools.h"

// A submod function can only produce one value per cycle. Trying to use it
// twice should be an error.

// X Context tock_add_one had invalid state after trace

class Submod {
 public:
  logic<8> tock_add_one(logic<8> a) const { return a + 1; }
};

class Module {
 public:
  void tock() {
    b = submod.tock_add_one(b);
    c = submod.tock_add_one(c);
  }

 private:
  logic<8> b;
  logic<8> c;
  Submod submod;
};
#include "metron/metron_tools.h"

// Tock functions can't have more than a single return at the end.

// X Method tock has non-terminal return

class Module {
 public:
  int tock(int data) {
    if (data > 10) {
      return 12;
    }
    return 11;
  }
};
#include "metron/metron_tools.h"

// Tick methods are not allowed to have a return value.
// X Tick method Module.tick is not allowed to have a return value.

class Module {
 public:
  logic<2> tick() {
    my_reg_ = my_reg_ + 1;
    return 8;
  }

 private:
  logic<2> my_reg_;
};
#include "metron/metron_tools.h"

// These ticks are invalid 'cause there's no valid order.

class Module {
public:

  void update_a() {
    a_ = b_ + 1;
  }

  void update_b() {
    b_ = a_ + 1;
  }

  logic<32> a_;
  logic<32> b_;
};
#include "metron/metron_tools.h"

// These tocks are invalid 'cause there's no valid order.

class Module {
public:

  void update_a() {
    a = b + 1;
  }

  void update_b() {
    b = a + 1;
  }

  logic<32> a;
  logic<32> b;
};
#include "metron/metron_tools.h"

// If a module calls a submod's functions in the "wrong" order, we should catch
// it.

#include "metron/metron_tools.h"

class Submod {
public:

  void tick1() { y_ = y_ + z_; }
  void tick2() { z_ = z_ + 1; }

private:
  int y_;
  int z_;
};

class Module {
public:

  void tock() {
    x.tick2();
    x.tick1();
  }

  Submod x;
};
*.v
tests/metron/generated/all_func_types.sv: tests/metron/pass/all_func_types.h
tests/metron/generated/basic_constructor.sv: tests/metron/pass/basic_constructor.h
tests/metron/generated/basic_function.sv: tests/metron/pass/basic_function.h
tests/metron/generated/basic_increment.sv: tests/metron/pass/basic_increment.h
tests/metron/generated/basic_inputs.sv: tests/metron/pass/basic_inputs.h
tests/metron/generated/basic_literals.sv: tests/metron/pass/basic_literals.h
tests/metron/generated/basic_localparam.sv: tests/metron/pass/basic_localparam.h
tests/metron/generated/basic_output.sv: tests/metron/pass/basic_output.h
tests/metron/generated/basic_param.sv: tests/metron/pass/basic_param.h
tests/metron/generated/basic_public_reg.sv: tests/metron/pass/basic_public_reg.h
tests/metron/generated/basic_public_sig.sv: tests/metron/pass/basic_public_sig.h
tests/metron/generated/basic_reg_rww.sv: tests/metron/pass/basic_reg_rww.h
tests/metron/generated/basic_sig_wwr.sv: tests/metron/pass/basic_sig_wwr.h
tests/metron/generated/basic_submod.sv: tests/metron/pass/basic_submod.h
tests/metron/generated/basic_submod_param.sv: tests/metron/pass/basic_submod_param.h
tests/metron/generated/basic_submod_public_reg.sv: tests/metron/pass/basic_submod_public_reg.h
tests/metron/generated/basic_switch.sv: tests/metron/pass/basic_switch.h
tests/metron/generated/basic_task.sv: tests/metron/pass/basic_task.h
tests/metron/generated/basic_template.sv: tests/metron/pass/basic_template.h
tests/metron/generated/bit_casts.sv: tests/metron/pass/bit_casts.h
tests/metron/generated/bit_concat.sv: tests/metron/pass/bit_concat.h
tests/metron/generated/bit_dup.sv: tests/metron/pass/bit_dup.h
tests/metron/generated/bitfields.sv: tests/metron/pass/bitfields.h
tests/metron/generated/both_tock_and_tick_use_tasks_and_funcs.sv: tests/metron/pass/both_tock_and_tick_use_tasks_and_funcs.h
tests/metron/generated/builtins.sv: tests/metron/pass/builtins.h
tests/metron/generated/call_tick_from_tock.sv: tests/metron/pass/call_tick_from_tock.h
tests/metron/generated/case_with_fallthrough.sv: tests/metron/pass/case_with_fallthrough.h
tests/metron/generated/constructor_arg_passing.sv: tests/metron/pass/constructor_arg_passing.h
tests/metron/generated/constructor_args.sv: tests/metron/pass/constructor_args.h
tests/metron/generated/counter.sv: tests/metron/pass/counter.h
tests/metron/generated/defines.sv: tests/metron/pass/defines.h
tests/metron/generated/dontcare.sv: tests/metron/pass/dontcare.h
tests/metron/generated/enum_simple.sv: tests/metron/pass/enum_simple.h
tests/metron/generated/for_loops.sv: tests/metron/pass/for_loops.h
tests/metron/generated/good_order.sv: tests/metron/pass/good_order.h
tests/metron/generated/if_with_compound.sv: tests/metron/pass/if_with_compound.h
tests/metron/generated/include_guards.sv: tests/metron/pass/include_guards.h
tests/metron/generated/include_test_module.sv: tests/metron/pass/include_test_module.h \
 tests/metron/pass/include_test_submod.h
tests/metron/generated/include_test_submod.sv: tests/metron/pass/include_test_submod.h
tests/metron/generated/init_chain.sv: tests/metron/pass/init_chain.h
tests/metron/generated/initialize_struct_to_zero.sv: tests/metron/pass/initialize_struct_to_zero.h
tests/metron/generated/input_signals.sv: tests/metron/pass/input_signals.h
tests/metron/generated/local_localparam.sv: tests/metron/pass/local_localparam.h
tests/metron/generated/magic_comments.sv: tests/metron/pass/magic_comments.h
tests/metron/generated/matching_port_and_arg_names.sv: tests/metron/pass/matching_port_and_arg_names.h
tests/metron/generated/minimal.sv: tests/metron/pass/minimal.h
tests/metron/generated/multi_tick.sv: tests/metron/pass/multi_tick.h
tests/metron/generated/namespaces.sv: tests/metron/pass/namespaces.h
tests/metron/generated/nested_structs.sv: tests/metron/pass/nested_structs.h
tests/metron/generated/nested_submod_calls.sv: tests/metron/pass/nested_submod_calls.h
tests/metron/generated/noconvert.sv: tests/metron/pass/noconvert.h
tests/metron/generated/nonblocking_assign_to_struct_union.sv: tests/metron/pass/nonblocking_assign_to_struct_union.h
tests/metron/generated/oneliners.sv: tests/metron/pass/oneliners.h
tests/metron/generated/plus_equals.sv: tests/metron/pass/plus_equals.h
tests/metron/generated/preproc.sv: tests/metron/pass/preproc.h
tests/metron/generated/private_getter.sv: tests/metron/pass/private_getter.h
tests/metron/generated/self_reference.sv: tests/metron/pass/self_reference.h
tests/metron/generated/slice.sv: tests/metron/pass/slice.h
tests/metron/generated/structs.sv: tests/metron/pass/structs.h
tests/metron/generated/structs_as_args.sv: tests/metron/pass/structs_as_args.h
tests/metron/generated/structs_as_ports.sv: tests/metron/pass/structs_as_ports.h
tests/metron/generated/submod_bindings.sv: tests/metron/pass/submod_bindings.h
tests/metron/generated/tock_task.sv: tests/metron/pass/tock_task.h
tests/metron/generated/trivial_adder.sv: tests/metron/pass/trivial_adder.h
tests/metron/generated/unions.sv: tests/metron/pass/unions.h
tests/metron/generated/utf8-mod.bom.sv: tests/metron/pass/utf8-mod.bom.h
tests/metron/generated/utf8-mod.sv: tests/metron/pass/utf8-mod.h
All the header files in this directory _should_ be convertible to SystemVerilog.
#include "metron/metron_tools.h"

class Module {
public:


  /*
  // but why would you do this?
  void func_no_params_no_return() {
  }

  // or this?
  void func_params_no_return(int x) {
  }
  */

  int func_no_params_return() {
    return 1;
  }

  int func_params_return(int x) {
    return x + 1;
  }

  int my_sig1;
  void tock_no_params() {
    my_sig1 = 12;
    int x = my_sig1;
  }

  int my_sig3;
  void tock_params(int x) {
    my_sig3 = 12 + x;
    int y = my_sig3;
  }

  int my_sig5a;
  void tock_calls_funcs1(int x) {
    my_sig5a = 12 + my_func5(x);
  }

  int my_sig5b;
  void tock_calls_funcs2(int x) {
    my_sig5b = 2 + my_func5(x - 7);
  }

private:
  int my_func5(int x) {
    return x + 1;
  }
public:

  int my_sig6a;
  void tock_calls_tock(int x) {
    my_sig6a = 12;
    tock_called_by_tock(my_sig6a);
  }

private:
  int my_sig6b;
  void tock_called_by_tock(int x) {
    my_sig6b = x;
  }
public:

  //----------

  int my_reg1_;
  void tick_no_params() {
    my_reg1_ = my_reg1_ + 1;
    tick_called_by_tick(func_called_by_tick(1));
  }

  int my_reg2_;
  void tick_params(int x) {
    my_reg2_ = my_reg2_ + x;
  }

private:
  int my_reg3_;
  void tick_called_by_tick(int x) {
    my_reg3_ = my_reg3_ + x;
  }

  int func_called_by_tick(int x) {
    return x + 7;
  }

public:

  int my_sig6c;
  void tock_calls_private_tick() {
    my_sig6c = 17;
    tick_private(my_sig6c);
  }

private:
  int my_reg4_;
  void tick_private(int x) {
    my_reg4_ = my_reg4_ + x;
  }


};
#include "metron/metron_tools.h"

// Modules can use constructors to initialize state

class Module {
public:

  Module() {
    my_reg_ = 7;
  }

  logic<8> get_reg() {
    return my_reg_;
  }

private:

  logic<8> my_reg_;
};

/*#
`ifdef IVERILOG
module Test;
  logic clock;
  logic[7:0] tock;
  Module mod(.clock(clock), .tock(tock));
  initial begin
    if (tock != 7) $display("FAIL");
  end
endmodule
`endif
#*/
#include "metron/metron_tools.h"

// Methods that don't write anything should become functions.

class Module {
public:

  void tick() {
    my_reg_ = my_reg_ + some_func();
  }

  logic<8> some_func() const {
    return 3;
  }

  logic<8> my_reg_;
};
#include "metron/metron_tools.h"

// Increment/decrement should be translated into equivalent Verilog, but they
// do _not_ return the old/new value.

class Module {
public:

  void tick() {
    my_reg1_++;
    ++my_reg2_;
    my_reg3_--;
    --my_reg4_;
  }

  int my_reg1_;
  int my_reg2_;
  int my_reg3_;
  int my_reg4_;
};
#include "metron/metron_tools.h"

// Tick inputs should become input ports.

// clang-format off
class Module {
 public:

  void tock(logic<7> my_input) {
    tick(my_input);
  }

 private:

  void tick(logic<7> my_input) {
    my_reg_ = my_reg_ + my_input;
  }

  logic<7> my_reg_;
};
// clang-format on
#include "metron/metron_tools.h"

// Number literals
// don't forget the ' spacers

class Module {
public:

  int test1() {
    logic<32> a = 0b0;
    logic<32> b = 0b00;
    logic<32> c = 0b000;
    logic<32> d = 0b0000;
    logic<32> e = 0b00000;
    logic<32> f = 0b000000;
    logic<32> g = 0b0000000;
    logic<32> h = 0b00000000;
    return 0;
  }

  int test2() {
    logic<32> a = 0b0;
    logic<32> b = 0b0'0;
    logic<32> c = 0b0'00;
    logic<32> d = 0b00'00;
    logic<32> e = 0b00'000;
    logic<32> f = 0b0'000'00;
    logic<32> g = 0b000'0000;
    logic<32> h = 0b0'0'0'0'0'0'0'0;
    return 0;
  }

};
#include "metron/metron_tools.h"

// Static const members become SV localparams

class Module {
public:

  void tock() {
    tick();
  }

private:

  static const int my_val = 7;

  void tick() {
    my_reg_ = my_reg_ + my_val;
  }

  logic<7> my_reg_;
};
#include "metron/metron_tools.h"

// Getter methods should turn into outputs.

class Module {
public:

  logic<7> get_reg() const {
    return my_reg_;
  }

  void tock() {
    tick();
  }


private:

  void tick() {
    my_reg_ = my_reg_ + 1;
  }

  logic<7> my_reg_;
};
#include "metron/metron_tools.h"

// Template parameters become SV module parameters.

template<int SOME_CONSTANT = 7>
class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    my_reg_ = my_reg_ + SOME_CONSTANT;
  }

  logic<7> my_reg_;
};
#include "metron/metron_tools.h"

// Public register member variables get moved to the output port list.

class Module {
public:

  void tick() {
    my_reg_ = my_reg_ + 1;
  }

  logic<1> my_reg_;
};
#include "metron/metron_tools.h"

// Public signal member variables get moved to the output port list.

class Module {
public:

  void tock() {
    my_sig = 1;
  }

  logic<1> my_sig;
};
#include "metron/metron_tools.h"

// Writing a register multiple times in the same function is OK.

class Module {
public:

  void tick() {
    logic<1> temp = my_reg_;
    my_reg_ = 0;
    my_reg_ = 1;
  }

  logic<1> my_reg_;
};
#include "metron/metron_tools.h"

// Writing a register multiple times in the same function is OK.

class Module {
public:

  void tock() {
    my_sig = 0;
    my_sig = 1;
    logic<1> temp = my_sig;
  }

  logic<1> my_sig;
};
#include "metron/metron_tools.h"

// Modules can contain other modules.

class Submod {
public:

  void tock(int x) {
    tick(x);
  }

private:

  void tick(int x) {
    sub_reg_ = sub_reg_ + x;
  }

  logic<8> sub_reg_;
};

class Module {
public:

  void tock(int x) {
    submod.tock(x);
  }

  Submod submod;
};
#include "metron/metron_tools.h"

// We can instantiated templated classes as submodules.

template<int SOME_CONSTANT = 6>
class Submod {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    sub_reg_ = sub_reg_ + SOME_CONSTANT;
  }

  logic<8> sub_reg_;
};

class Module {
public:

  void tock() {
    submod.tock();
  }

  Submod<99> submod;
};
#include "metron/metron_tools.h"

// We can instantiated templated classes as submodules.

class Submod {
public:

  void tock() {
    tick();
  }

  logic<8> sub_reg_;

private:

  void tick() {
    sub_reg_ = sub_reg_ + 1;
  }

};

class Module {
public:

  logic<8> get_submodreg() const {
    return submod.sub_reg_;
  }

  void tock() {
    submod.tock();
  }

  Submod submod;
};
#include "metron/metron_tools.h"

// Simple switch statements are OK.

class Module {
public:

  void tock(logic<2> selector) {
    tick(selector);
  }

private:

  void tick(logic<2> selector) {
    switch(selector) {
      case 0: // comment
        my_reg_ = 17; break;
      case 1:  // comment
        my_reg_ = 22; break;
      case 2: my_reg_ = 30; break;
      case 3: // fallthrough
      case 4:
      case 5:
      case 6: my_reg_ = 72; break;
    }
  }

  logic<8> my_reg_;
};
#include "metron/metron_tools.h"

// Private non-const methods should turn into SV tasks.

class Module {
public:

  void tock() {
    tick();
  }

private:

  void tick() {
    my_reg_ = my_reg_ + my_reg2_ + 3;
    some_task2();
  }

  void some_task2() {
    my_reg2_ = my_reg2_ + 3;
  }

  logic<8> my_reg_;
  logic<8> my_reg2_;
};
#include "metron/metron_tools.h"

// Templates can be used for module parameters

template<int WIDTH = 123, int HEIGHT = 456>
class Submod {
public:

  void tock(logic<WIDTH> dx, logic<HEIGHT> dy) {
    my_width = bx<WIDTH>(100) + dx;
    my_height = bx<HEIGHT>(200) + dy;
  }

  logic<WIDTH> my_width;
  logic<HEIGHT> my_height;
};

class Module {
public:

  logic<20> tock_ret;
  void tock() {
    submod.tock(1, 2);
    tock_ret = submod.my_width + submod.my_height;
  }

  Submod<10,11> submod;
};
#include "metron/metron_tools.h"

// Logics can be casted to various sizes via bN() or bx<N>()

class Module {
public:

  int test_bN() {
    logic<64> src = 0x1234567812345678;
    logic<64> dst64 = b64(src);
    logic<63> dst63 = b63(src);
    logic<62> dst62 = b62(src);
    logic<61> dst61 = b61(src);
    logic<60> dst60 = b60(src);

    logic<59> dst59 = b59(src);
    logic<58> dst58 = b58(src);
    logic<57> dst57 = b57(src);
    logic<56> dst56 = b56(src);
    logic<55> dst55 = b55(src);
    logic<54> dst54 = b54(src);
    logic<53> dst53 = b53(src);
    logic<52> dst52 = b52(src);
    logic<51> dst51 = b51(src);
    logic<50> dst50 = b50(src);

    logic<49> dst49 = b49(src);
    logic<48> dst48 = b48(src);
    logic<47> dst47 = b47(src);
    logic<46> dst46 = b46(src);
    logic<45> dst45 = b45(src);
    logic<44> dst44 = b44(src);
    logic<43> dst43 = b43(src);
    logic<42> dst42 = b42(src);
    logic<41> dst41 = b41(src);
    logic<40> dst40 = b40(src);

    logic<39> dst39 = b39(src);
    logic<38> dst38 = b38(src);
    logic<37> dst37 = b37(src);
    logic<36> dst36 = b36(src);
    logic<35> dst35 = b35(src);
    logic<34> dst34 = b34(src);
    logic<33> dst33 = b33(src);
    logic<32> dst32 = b32(src);
    logic<31> dst31 = b31(src);
    logic<30> dst30 = b30(src);

    logic<29> dst29 = b29(src);
    logic<28> dst28 = b28(src);
    logic<27> dst27 = b27(src);
    logic<26> dst26 = b26(src);
    logic<25> dst25 = b25(src);
    logic<24> dst24 = b24(src);
    logic<23> dst23 = b23(src);
    logic<22> dst22 = b22(src);
    logic<21> dst21 = b21(src);
    logic<20> dst20 = b20(src);

    logic<19> dst19 = b19(src);
    logic<18> dst18 = b18(src);
    logic<17> dst17 = b17(src);
    logic<16> dst16 = b16(src);
    logic<15> dst15 = b15(src);
    logic<14> dst14 = b14(src);
    logic<13> dst13 = b13(src);
    logic<12> dst12 = b12(src);
    logic<11> dst11 = b11(src);
    logic<10> dst10 = b10(src);

    logic<9> dst9 = b9(src);
    logic<8> dst8 = b8(src);
    logic<7> dst7 = b7(src);
    logic<6> dst6 = b6(src);
    logic<5> dst5 = b5(src);
    logic<4> dst4 = b4(src);
    logic<3> dst3 = b3(src);
    logic<2> dst2 = b2(src);
    logic<1> dst1 = b1(src);
    return 0;
  }

  int test_bx_const() {
    logic<64> src = 0x1234567812345678;
    logic<63> dst63 = bx<63>(src);
    logic<62> dst62 = bx<62>(src);
    logic<61> dst61 = bx<61>(src);
    logic<60> dst60 = bx<60>(src);

    logic<59> dst59 = bx<59>(src);
    logic<58> dst58 = bx<58>(src);
    logic<57> dst57 = bx<57>(src);
    logic<56> dst56 = bx<56>(src);
    logic<55> dst55 = bx<55>(src);
    logic<54> dst54 = bx<54>(src);
    logic<53> dst53 = bx<53>(src);
    logic<52> dst52 = bx<52>(src);
    logic<51> dst51 = bx<51>(src);
    logic<50> dst50 = bx<50>(src);

    logic<49> dst49 = bx<49>(src);
    logic<48> dst48 = bx<48>(src);
    logic<47> dst47 = bx<47>(src);
    logic<46> dst46 = bx<46>(src);
    logic<45> dst45 = bx<45>(src);
    logic<44> dst44 = bx<44>(src);
    logic<43> dst43 = bx<43>(src);
    logic<42> dst42 = bx<42>(src);
    logic<41> dst41 = bx<41>(src);
    logic<40> dst40 = bx<40>(src);

    logic<39> dst39 = bx<39>(src);
    logic<38> dst38 = bx<38>(src);
    logic<37> dst37 = bx<37>(src);
    logic<36> dst36 = bx<36>(src);
    logic<35> dst35 = bx<35>(src);
    logic<34> dst34 = bx<34>(src);
    logic<33> dst33 = bx<33>(src);
    logic<32> dst32 = bx<32>(src);
    logic<31> dst31 = bx<31>(src);
    logic<30> dst30 = bx<30>(src);

    logic<29> dst29 = bx<29>(src);
    logic<28> dst28 = bx<28>(src);
    logic<27> dst27 = bx<27>(src);
    logic<26> dst26 = bx<26>(src);
    logic<25> dst25 = bx<25>(src);
    logic<24> dst24 = bx<24>(src);
    logic<23> dst23 = bx<23>(src);
    logic<22> dst22 = bx<22>(src);
    logic<21> dst21 = bx<21>(src);
    logic<20> dst20 = bx<20>(src);

    logic<19> dst19 = bx<19>(src);
    logic<18> dst18 = bx<18>(src);
    logic<17> dst17 = bx<17>(src);
    logic<16> dst16 = bx<16>(src);
    logic<15> dst15 = bx<15>(src);
    logic<14> dst14 = bx<14>(src);
    logic<13> dst13 = bx<13>(src);
    logic<12> dst12 = bx<12>(src);
    logic<11> dst11 = bx<11>(src);
    logic<10> dst10 = bx<10>(src);

    logic<9> dst9 = bx<9>(src);
    logic<8> dst8 = bx<8>(src);
    logic<7> dst7 = bx<7>(src);
    logic<6> dst6 = bx<6>(src);
    logic<5> dst5 = bx<5>(src);
    logic<4> dst4 = bx<4>(src);
    logic<3> dst3 = bx<3>(src);
    logic<2> dst2 = bx<2>(src);
    logic<1> dst1 = bx<1>(src);
    return 0;
  }

  int test_bN_offset() {
    logic<64> src = 0x1234567812345678;

    logic<8> dst0 = b8(src, 0);
    logic<8> dst1 = b8(src, 1);
    logic<8> dst2 = b8(src, 2);
    logic<8> dst3 = b8(src, 3);
    logic<8> dst4 = b8(src, 4);
    logic<8> dst5 = b8(src, 5);
    logic<8> dst6 = b8(src, 6);
    logic<8> dst7 = b8(src, 7);
    logic<8> dst8 = b8(src, 8);
    logic<8> dst9 = b8(src, 9);
    return 0;
  }

  static const int some_size1 = 64;
  static const int some_size2 = 8;

  int test_bx_param() {
    logic<some_size1> a = 10;
    logic<some_size2> b = bx<some_size2>(a);

    logic<some_size2> b0 = bx<some_size2>(a, 0);
    logic<some_size2> b1 = bx<some_size2>(a, 1);
    logic<some_size2> b2 = bx<some_size2>(a, 2);
    logic<some_size2> b3 = bx<some_size2>(a, 3);
    logic<some_size2> b4 = bx<some_size2>(a, 4);
    logic<some_size2> b5 = bx<some_size2>(a, 5);
    logic<some_size2> b6 = bx<some_size2>(a, 6);
    logic<some_size2> b7 = bx<some_size2>(a, 7);
    logic<some_size2> b8 = bx<some_size2>(a, 8);
    logic<some_size2> b9 = bx<some_size2>(a, 9);

    return 0;
  }


  int test2() {
    logic<32> a = 0xDEADBEEF;

    logic<1> b = b1(a, 3); //static bit extract with literal offset, width 1
    logic<7> c = b7(a, 3); //static bit extract with literal offset, width N

    logic<1> e = b1(a, some_size1); //static bit extract with variable offset, width 1
    logic<7> f = b7(a, some_size2); //static bit extract with variable offset, width N

    return 0;
  }



};
#include "metron/metron_tools.h"

// Concatenating logics should produce logics with correct <N>

class Module {
public:

  Module() {
    write("Hello World?\n");
  }

  logic<6> sig1;
  logic<6> sig2;

  void tock1() {
    logic<1> a = 1;
    logic<2> b = 2;
    logic<3> c = 3;

    sig1 = cat(a, b, c);
  }

  void tock2() {
    logic<8> a = 1;
    logic<8> b = 2;
    logic<8> c = 3;

    sig2 = cat(b1(a), b2(b), b3(c));
  }
};
#include "metron/metron_tools.h"

class Module {
public:

  int test_dup1() {
    logic<1> a1 = 0b1;
    logic<1> b1 = dup<1>(a1);
    return 0;
  }

  int test_dup4() {
    logic<1>  a1 = 0b1;
    logic<4>  b1 = dup<4>(a1);

    logic<2>  a2 = 0b01;
    logic<8>  b2 = dup<4>(a2);

    logic<3>  a3 = 0b001;
    logic<12> b3 = dup<4>(a3);

    logic<4>  a4 = 0b0001;
    logic<16> b4 = dup<4>(a4);

    logic<5>  a5 = 0b00001;
    logic<20> b5 = dup<4>(a5);

    logic<6>  a6 = 0b000001;
    logic<24> b6 = dup<4>(a6);

    logic<7>  a7 = 0b0000001;
    logic<28> b7 = dup<4>(a7);

    logic<8>  a8 = 0b00000001;
    logic<32> b8 = dup<4>(a8);
    return 0;
  }
};
#include "metron/metron_tools.h"

// C structs with bit-size annotations become arrays of sized logic<>s.

struct rv32_rtype {
  uint32_t op  : 7;
  uint32_t rd  : 5;
  uint32_t f3  : 3;
  uint32_t rs1 : 5;
  uint32_t rs2 : 5;
  uint32_t f7  : 7;
};

struct rv32_itype {
  uint32_t op : 7;
  uint32_t rd : 5;
  uint32_t f3 : 3;
  uint32_t rs1 : 5;
  uint32_t imm_11_0 : 12;
};

struct rv32_stype {
  uint32_t op : 7;
  uint32_t imm_4_0 : 5;
  uint32_t f3 : 3;
  uint32_t rs1 : 5;
  uint32_t rs2 : 5;
  uint32_t imm_11_5 : 7;
};

struct rv32_btype {
  uint32_t op : 7;
  uint32_t imm_11 : 1;
  uint32_t imm_4_1 : 4;
  uint32_t f3 : 3;
  uint32_t rs1 : 5;
  uint32_t rs2 : 5;
  uint32_t imm_10_5 : 6;
  uint32_t imm_12 : 1;
};

struct rv32_utype {
  uint32_t op : 7;
  uint32_t rd : 5;
  uint32_t imm_31_12 : 20;
};

struct rv32_jtype {
  uint32_t op : 7;
  uint32_t rd : 5;
  uint32_t imm_19_12 : 8;
  uint32_t imm_11 : 1;
  uint32_t imm_10_1 : 10;
  uint32_t imm_20: 1;
};

union rv32_insn {
  logic<32> raw;
  rv32_rtype r;
  rv32_itype i;
  rv32_stype s;
  rv32_btype b;
  rv32_utype u;
  rv32_jtype j;
};

class Module {
  public:

  void tock(logic<32> x) {
    blah.raw = x;
  }

  rv32_insn blah;
};
#include "metron/metron_tools.h"

// All the combos of tasks/funcs should work from ticks and tocks.

// Yosys bug - fails to parse if we pass constants between the functions
// https://github.com/YosysHQ/yosys/issues/3327

class Module {
public:

  logic<8> my_sig;

  void tock(int z) {
    public_task(public_func(z));
    tick(z);
  }

  void public_task(logic<8> x) {
    my_sig = x + 7;
  }

  logic<8> public_func(logic<8> x) {
    return my_reg1_ + private_func(x);
  }

private:

  void tick(int w) {
    private_task(private_func(w));
    my_reg2_ = my_reg2_ + 1;
  }

  void private_task(logic<8> x) {
    my_reg1_ = my_reg1_ + private_func(x);
  }

  logic<8> private_func(logic<8> y) {
    return my_reg1_ + y;
  }

  logic<8> my_reg1_;
  logic<8> my_reg2_;
};
#include "metron/metron_tools.h"

// Make sure our built-in functions translate.

class Module {
public:

  int sig;

  void tock() {
    logic<8> src = 100;
    logic<8> a = signed(src);
    logic<8> b = unsigned(src);
    logic<8> e = sign_extend<8>(b2(src));
    logic<8> c = clog2(100);
    logic<8> d = pow2(4);
    sig = 1;
  }

};
#include "metron/metron_tools.h"

// Calling tick() from tock() in the same module should work and should
// generate bindings for the tick() call.

class Module {
public:

  void tock(logic<8> val) {
    tick(val);
  }

private:

  void tick(logic<8> val) {
    my_reg_ = my_reg_ + val;
  }

  logic<8> my_reg_;

};
#include "metron/metron_tools.h"

// Case statements are allowed to have fallthrough, though the SV syntax is
// a bit different.

class Module {
public:

  logic<8> tock_result;
  void tock() {
    switch(my_reg_) {
      case 0: // can we stick comments in here?
      case 1:
      case 2:
        tock_result = 10;
        break;
      case 3: {
        tock_result = 20;
        break;
      }
      default:
        tock_result = 30;
        break;
    }

    tick(tock_result);
  }

private:

  void tick(logic<8> inc) {
    my_reg_ = my_reg_ + inc;
  }

  logic<8> my_reg_;
};
#include "metron/metron_tools.h"

// We should be able to pass constructor arguments to submodules.

//----------------------------------------

template<int data_len = 1024, int blarp = 0>
class Module {
public:

  Module(const char* filename = nullptr) {
    if (filename) readmemh(filename, data_);
  }

  void tock(logic<10> new_addr) {
    addr = new_addr;
    tick();
  }

  logic<8> get_data() {
    return out_;
  }

private:
  void tick() {
    out_ = data_[addr];
  }

  logic<10> addr;
  logic<8> data_[data_len];
  logic<8> out_;
};

//----------------------------------------

class Top {
public:
  Top() : submod("examples/uart/message.hex"), derp(7) {
  }

  void tock(logic<10> addr) {
    submod.tock(addr);
  }

  void tick() {
    //mod.tick();
  }

  Module<7777, 8383> submod;
  logic<10> derp;
};

//----------------------------------------
#include "metron/metron_tools.h"

// We should be able to handle constructor args.

template<int data_len = 1024, int blarp = 7>
class Module {
public:

  Module(const char* filename = "examples/uart/message.hex") {
    readmemh(filename, data_);
  }

  void tock(logic<10> addr_) {
    addr = addr_;
  }

  void tick() {
    out_ = data_[addr];
  }

  logic<8> get_data() {
    return out_;
  }

private:
  logic<10> addr;
  logic<8> data_[data_len];
  logic<8> out_;
};
#include "metron/metron_tools.h"

// Members whose names have trailing underscores are states.
// Members without trailing underscores are signals.
// We should not require any other special annotations on our modules.

class Module {
public:

  Module() {
    counter_ = 0;
  }

  logic<1> get_even() {
    return is_even;
  }

  void tock(logic<32> inc) {
    is_even = (counter_ & 1) == 0;
    update(inc);
  }

  void update(logic<32> inc) {
    update2(inc);
  }

  void update2(logic<32> inc) {
    counter_ = counter_ + inc;
  }

  logic<32> get_counter() {
    return counter_;
  }

private:

  logic<1>  is_even;
  logic<32> counter_;
};
#include "metron/metron_tools.h"

// Basic #defines should work as long as their contents are simultaneously
// valid C++ and SV

#define MY_CONSTANT1 10
#define MY_CONSTANT2 20
#define MY_OTHER_CONSTANT (MY_CONSTANT1 + MY_CONSTANT2 + 7)

class Module {
public:

  logic<8> test() {
    return MY_OTHER_CONSTANT;
  }

};
#include "metron/metron_tools.h"

// DONTCARE gets translated to 'x
// bN(DONTCARE) gets translated to N'bx

class Module {
public:

  logic<8> test1() {
    return DONTCARE;
  }

  logic<8> test2() {
    return b8(DONTCARE);
  }

  logic<8> test3() {
    return bx<8>(DONTCARE);
  }
};
#include "metron/metron_tools.h"

// Most kinds of C++ enum declarations should work.

// bad
// enum { FOO, BAR, BAZ };
// typedef enum logic[1:0] { FOO=70, BAR=71, BAZ=72 } blem;
// typedef enum { FOO, BAR=0, BAZ=1 } blem;

// good
// OK enum { FOO, BAR, BAZ } blem;
// enum { FOO=0, BAR=1, BAZ=2 } blem;
// typedef enum { FOO, BAR, BAZ } blem;
// typedef enum { FOO=0, BAR=1, BAZ=2 } blem;
// typedef enum logic[1:0] { FOO, BAR, BAZ } blem;
// typedef enum logic[1:0] { FOO=0, BAR=1, BAZ=2 } blem;

// enum struct {} ? same as enum class

enum top_level_enum {
  A0,
  B0,
  C0
};

// clang-format off
class Module {
 public:
  enum simple_enum1 { A1, /* random comment */ B1, C1 };
  enum simple_enum2 { A2 = 0b01, B2 = 0x02, C2 = 3 };

  enum { A3, B3, C3 } anon_enum_field1;
  enum { A4 = 0b01, B4 = 0x02, C4 = 3 } anon_enum_field2;

  enum class enum_class1 { A5, B5, C5 };
  enum class enum_class2 { A6 = 0b01, B6 = 0x02, C6 = 3 };

  enum class typed_enum : int { A7 = 0b01, B7 = 0x02, C7 = 3 };
  enum class sized_enum : logic<8>::BASE { A8 = 0b01, B8 = 0x02, C8 = 3 };

  int test1() {
    simple_enum1 e1 = A1;
    simple_enum2 e2 = B2;
    anon_enum_field1 = C3;
    anon_enum_field2 = A4;
    enum_class1 ec1 = enum_class1::B5;
    enum_class2 ec2 = enum_class2::C6;
    typed_enum te1 = typed_enum::A7;
    sized_enum se1 = sized_enum::B8;
    return 1;
  }
};
// clang-format on
#include "metron/metron_tools.h"

class Module {
  public:

  // decl in for
  int loop1() {
    int x = 0;
    for (int i = 0; i < 10; i++) {
      x = x + i;
    }
    return x;
  }

  // decl outside of for
  int loop2() {
    int x = 0;
    int i;
    for (i = 0; i < 10; i++) {
      x = x + i;
    }
    return x;
  }
};
#include "metron/metron_tools.h"

class Module {
public:

  void tock() {
    my_sig = my_reg_;
    tick();
  }

private:

  void tick() {
    my_reg_ = 1;
  }

  logic<1> my_sig;
  logic<1> my_reg_;
};
#include "metron/metron_tools.h"

// If statements whose sub-blocks contain submodule calls _must_ use {}.

class Submod {
public:
  void tock(logic<8> arg) {
    tick(arg);
  }
private:
  void tick(logic<8> arg) {
    my_reg_ = my_reg_ + arg;
  }

  logic<8> my_reg_;
};


class Module {
public:

  void tock() {
    if (1) {
      submod.tock(72);
    }
    else {
      submod.tock(36);
    }
  }

  Submod submod;
};
// Preprocessor macros generally won't work, but include guards should be OK.

#ifndef INCLUDE_GUARDS_H
#define INCLUDE_GUARDS_H

class Module {
public:
  int blah() {
    return 7;
  }
};

#endif
// Metron should be able to handle #included submodules.

#include "include_test_submod.h"

class Module {
public:

  void tick(int x) {
    submod.tick(x);
  }

private:
  Submod submod;
};
// Metron should be able to handle #included submodules.

#include "metron/metron_tools.h"

class Submod {
public:

  void tick(int x) {
    y_ += x;
  }

private:
  int y_;
};
#include "metron/metron_tools.h"

// I don't know why you would want to do this, but it should work.

class Module {
public:
  Module() {
    init1();
  }

  void tock() {
    tick();
  }

private:

  void tick() {
    reg1_ = reg1_ + 1;
    reg2_ = reg2_ + 1;
    reg3_ = reg3_ + 1;
    reg4_ = reg4_ + 1;
    reg5_ = reg5_ + 1;
  }

  logic<8> reg1_;
  logic<8> reg2_;
  logic<8> reg3_;
  logic<8> reg4_;
  logic<8> reg5_;

  void init1() {
    reg1_ = 1;
    init2();
  }

  void init2() {
    reg2_ = 2;
    init3();
  }

  void init3() {
    reg3_ = 3;
    init4();
  }

  void init4() {
    reg4_ = 4;
    init5();
  }

  void init5() {
    reg5_ = 5;
  }

};
#include "metron/metron_tools.h"

// Zero-initializing structs should work for convenience.

struct MyStruct1 {
  logic<8> field;
};

class Module {
public:

  MyStruct1 my_struct1;
  void tock() {
    // FIXME fix this later glarghbh
    //my_struct1 = {0};
    my_struct1.field = 0;
  }
};
#include "metron/metron_tools.h"

// Public fields that are read by the module but never written become input
// ports.

class Submod {
public:

  logic<8> i_signal;
  logic<8> o_signal;
  logic<8> o_reg_;

  logic<8> tock_ret;
  void tock(logic<8> i_param) {
    o_signal = i_signal + i_param;
    tick();
    tock_ret = o_signal + 7;
  }

private:

  void tick() {
    o_reg_ = o_reg_ + o_signal;
  }
};

class Module {
public:

  void tock() {
    submod.i_signal = 12;
    submod.tock(13);
    my_sig = submod.tock_ret + 3;
    tick();
  }

  logic<8> my_reg_;

private:

  void tick() {
    my_reg_ = my_reg_ + my_sig - 2;
  }

  logic<8> my_sig;

  Submod submod;
};
#include "metron/metron_tools.h"

class Module {
public:

  logic<8> func() {
    static const int thing1 = 1;
    const int thing2 = 2;
    return thing1 + thing2;
  }

};
#include "metron/metron_tools.h"

// Comments surrounded by / * # <something # * / get unwrapped and dropped
// directly in the output file.

class Module {
public:

  void tick() {
    my_reg_ = my_reg_ + 1;
  }

/*#
  always @(posedge clock) begin
    //$display("Hello World!\n");
  end
#*/

  int my_reg_;
};
#include "metron/metron_tools.h"

// Port and function arg names can collide, the latter is disambiguated by its
// function name.

class Module {
public:

  int input_val;
  int output1;
  int output2;

  void tock1() {
    output1 = input_val + 7;
  }

  void tock2(int input_val) {
    output2 = input_val + 8;
  }
};
// Comments at start of file should be preserved

#include "metron/metron_tools.h"

// Empty module should pass.

class Module {
};

// Comments at end of file should be preserved
#include "metron/metron_tools.h"

// Multiple tick methods are OK as long as they're all called by tock()

class Module {
public:

  logic<8> tock_result;
  void tock() {
    tock_result = my_reg1_ + my_reg2_;
    tick1();
    tick2();
  }

private:

  void tick1() {
    my_reg1_ = 0;
  }

  void tick2() {
    my_reg2_ = 1;
  }

  logic<8> my_reg1_;
  logic<8> my_reg2_;
};
#include "metron/metron_tools.h"

// Namespaces turn into packages.
// "using" doesn't work in methods right now :/

namespace MyPackage {
  static const int foo = 3;
};

class Module {
public:

  int my_sig;
  int my_reg_;

  int tock_ret;
  void tock() {
    my_sig = MyPackage::foo + 1;
    tock_ret = my_sig;
  }

  void tick() {
    my_reg_ = my_reg_ + MyPackage::foo;
  }
};
#include "metron/metron_tools.h"

struct InnerStruct {
  logic<8> a;
  logic<8> b;
  logic<8> c;
};

struct OuterStruct {
  InnerStruct x;
  InnerStruct y;
  InnerStruct z;
};

class Module {
public:

  OuterStruct r;
  OuterStruct s_;

  void tock_func1() {
    r.x.a = 1;
    r.x.b = 2;
    r.x.c = 3;
  }

  void tick_func2() {
    s_.y.a = 4;
    s_.y.b = 5;
    s_.y.c = 6;
  }

  void tick_func3() {
    s_.z.a = 7;
    s_.z.b = 8;
    s_.z.c = 9;
  }
};
#include "metron/metron_tools.h"

// Nesting submod calls should put all the nested input bindings above the call.

class Submod1 {
public:
  logic<8> add_one(logic<8> a) const {
    return a + 1;
  }
};

class Submod2 {
public:
  logic<8> add_two(logic<8> a) const {
    return a + 1;
  }
};

class Module {
public:

  logic<8> tock_ret;
  void tock(logic<8> old_counter) {
    // Two bindings should end up here.
    logic<8> new_counter = submod1.add_one(submod2.add_two(old_counter));
    tock_ret = new_counter;
  }

private:

  Submod1 submod1;
  Submod2 submod2;
};
#include "metron/metron_tools.h"

class Module {
  public:

  logic<1> foo() {
    /* metron_noconvert */ int x;
    return 0;
  }

  /* metron_noconvert */ void akdslfkajsf(const char* skdfjlskdjf);
  /* metron_noconvert */ size_t size_bytes();
  /* metron_noconvert */ void debug_dump() { printf("Hello World %d\n", 1234); }
};
#include "metron/metron_tools.h"

// Structs exist in both C++ and Verilog

struct MyStruct1 {
  logic<8> a;
  logic<8> b;
};

union MyUnion1 {
  logic<8> a;
  logic<8> b;
};

class Module {
public:

  void tick() {
    my_struct_.a = my_struct_.b + 1;
    my_union_.a = my_union_.b + 1;
  }

private:

  MyStruct1 my_struct_;
  MyUnion1 my_union_;

};
#include "metron/metron_tools.h"

// Cramming various statements into one line should not break anything.

class Module {
public:

  logic<8> test() { logic<8> a = 1; a = a + 7; return a; }

  void tick() { if (my_reg_ & 1) my_reg_ = my_reg_ - 7; }

  logic<8> my_reg_;

};
class Metron {
public:

  int my_sig;

  // Divide and mod work, but make Yosys extremely slow to synth

  void tock() {
    int x = 7;
    x += 13;
    x  -= 13;
    x   *= 13;
    x +=   13;
    x -=  13;
    x *= 13;
    my_sig = x;
  }

  int my_reg1_;
  int my_reg2_;
  int my_reg3_;
  int my_reg4_;
  int my_reg5_;
  int my_reg6_;

  void tick() {
    my_reg1_ += 22;
    my_reg2_  -= 22;
    my_reg3_   *= 22;
    my_reg4_ +=   22;
    my_reg5_ -=  22;
    my_reg6_ *= 22;
  }
};
#include "metron/metron_tools.h"

// We need to support very basic preprocessor macros or else dealing with mixed
// languages will be a huge pain in the butt.

/*
#ifdef METRON_SV

//module Submod();
//endmodule

#else

#endif

#endif


#ifndef METRON_SV

#else

#endif


#ifdef METRON_CPP

#else

#endif
*/

class Module {
};
#include "metron/metron_tools.h"

// Private getter methods are OK

class Module {
public:

  int my_sig;

  int tock_ret;
  void tock() {
    my_sig = my_getter();
    tock_ret = my_sig;
  }

private:

  int my_getter() const {
    return 12;
  }

};
#include "metron/metron_tools.h"

// A module should be able to have a noconvert-tagged method that returns a
// pointer to its type

class Module {
public:
  /* metron_noconvert */ Module* get_this();
};
#include "metron/metron_tools.h"

// Using slice<>() to write to sub-sections of a variable should work.
// FIXME This can break tracing....

class test_slice {
public:

  void tick(logic<8> addr, logic<4> mask, logic<32> wdata) {
    if (mask[0]) slice<8,  0>(ram_[addr]) = b8(wdata,  0);
    if (mask[1]) slice<8,  8>(ram_[addr]) = b8(wdata,  8);
    if (mask[2]) slice<8, 16>(ram_[addr]) = b8(wdata, 16);
    if (mask[3]) slice<8, 24>(ram_[addr]) = b8(wdata, 24);
  }

private:
  logic<32> ram_[256];
};
#include "metron/metron_tools.h"

// Structs exist in both C++ and Verilog

struct MyStruct1 {
  logic<8> a;
};

class Module {
public:

  MyStruct1 my_struct1;

  MyStruct1 get_something() {
    return my_struct1;
  }

  logic<8> tock_ret;
  void tock() {
    my_struct1.a = 1;

    // FIXME does not work in yosys
    //return extract_field(my_struct1);
    tock_ret = 16;
  }

private:

  logic<8> extract_field(MyStruct1 m) {
    return m.a;
  }

};
#include "metron/metron_tools.h"

// Passing structs to functions that turn into always_comb or always_ff
// should prepend the function name to the struct name.

//------------------------------------------------------------------------------

struct tilelink_a {
  logic<32> a_data;
};

class block_ram {
public:

  logic<32> unshell(tilelink_a tla) {
    return tla.a_data;
  }

  void tick(tilelink_a tla) {
    data_ = tla.a_data;
  }

  logic<32> data_;
};

//------------------------------------------------------------------------------
#include "metron/metron_tools.h"

// Structs can be used as input/output ports to submodules.
// ...but they have to be public member variables because Yosys...

namespace TL {
  static const int PutFullData = 0;
  static const int PutPartialData = 1;
  static const int Get = 4;
  static const int AccessAck = 0;
  static const int AccessAckData = 1;
};

struct tilelink_a {
  logic<3>  a_opcode;
  logic<32> a_address;
  logic<4>  a_mask;
  logic<32> a_data;
  logic<1>  a_valid;
};

struct tilelink_d {
  logic<3>  d_opcode;
  logic<32> d_data;
  logic<1>  d_valid;
};

//------------------------------------------------------------------------------

class TilelinkDevice {
public:

  TilelinkDevice() {
    test_reg_ = 0;
    oe_ = 0;
  }

  tilelink_d tld;
  tilelink_a tla;

  void tock() {
    if (oe_) {
      tld.d_opcode = TL::AccessAckData;
      tld.d_data   = test_reg_;
      tld.d_valid  = 1;
    }
    else {
      tld.d_opcode = TL::AccessAckData;
      tld.d_data   = DONTCARE;
      tld.d_valid  = 0;
    }
  }

  void tick() {
    if (tla.a_address == 0x1234) {
      if (tla.a_opcode == TL::PutFullData && tla.a_valid) {
        logic<32> mask = cat(
          dup<8>(tla.a_mask[0]),
          dup<8>(tla.a_mask[1]),
          dup<8>(tla.a_mask[2]),
          dup<8>(tla.a_mask[3]));
        test_reg_ = (test_reg_ & ~mask) | (tla.a_data & mask);
        oe_ = 0;
      } else if (tla.a_opcode == TL::Get) {
        oe_ = 1;
      }
    }
  }

private:
  logic<32> test_reg_;
  logic<1>  oe_;
};

//------------------------------------------------------------------------------

class TilelinkCPU {
public:

  tilelink_a tla;
  tilelink_d tld;

  TilelinkCPU() {
    addr_ = 0x1234;
    data_ = 0x4321;
  }

  void tock() {
    if (data_ & 1) {
      tla.a_opcode  = TL::Get;
      tla.a_address = addr_;
      tla.a_mask    = 0b1111;
      tla.a_data    = DONTCARE;
      tla.a_valid   = 1;
    } else {
      tla.a_opcode  = TL::PutFullData;
      tla.a_address = addr_;
      tla.a_mask    = 0b1111;
      tla.a_data    = 0xDEADBEEF;
      tla.a_valid   = 1;
    }
  }

  void tick() {
    if (tld.d_opcode == TL::AccessAckData && tld.d_valid) {
      data_ = tld.d_data;
    }
  }

private:
  logic<32> addr_;
  logic<32> data_;
};

//------------------------------------------------------------------------------

class Top {
public:
  void tock() {
    cpu.tock();
    dev.tock();

    cpu.tld = dev.tld;
    dev.tla = cpu.tla;

    cpu.tick();
    dev.tick();
  }

  TilelinkCPU cpu;
  TilelinkDevice dev;
};

//------------------------------------------------------------------------------
#include "metron/metron_tools.h"

// Submodule bindings should be placed immediately before the statement
// containing the call

class Submod {
public:

  logic<8> sum_a(logic<8> a1, logic<8> a2) const { return a1 + a2; }
  logic<8> sum_b(logic<8> b1, logic<8> b2) const { return b1 + b2; }
};

class Module {
public:

  logic<8> tock_bindings_ret;
  void tock_bindings() {
    logic<8> result;
    // Submod bindings should _not_ end up here.

    {
      // Only sum_a's bindings should be here.
      if (submod.sum_a(1, 2)) {
        // Only sum_b's bindings should be here.
        result = submod.sum_b(3,4);
      }
      else {
        // Only sum_b's bindings should be here.
        result = submod.sum_b(5,6);
      }
    }

    tock_bindings_ret = result;
  }

  Submod submod;
};
#include "metron/metron_tools.h"

// Tocks should be able to call private tasks and functions

class Module {
public:

  logic<8> my_signal;

  int tock_ret;
  void tock() {
    set_signal(get_number());
    tock_ret = set_signal_ret;
  }

private:

  logic<8> get_number() const {
    return 7;
  }

  int set_signal_ret;
  void set_signal(logic<8> number) {
    my_signal = number;
    set_signal_ret = my_signal;
  }

};
#include "metron/metron_tools.h"

// Trivial adder just for example.

class Adder {
public:

  logic<8> add(logic<8> a, logic<8> b) {
    return a + b;
  }

};
#include "metron/metron_tools.h"

union my_union {
  logic<32> a;
  logic<32> b;
};

class Module {
public:

  void tock(logic<32> x, logic<32> y) {
    blah.a = x;
    blah.b = y;
  }

  my_union blah;
};
#include "metron/metron_tools.h"

// UTF-8 text files with a byte order mark should be supported.

// From https://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html:

/*
Runes:

             

  (Old English, which transcribed into Latin reads 'He cwaeth that he
  bude thaem lande northweardum with tha Westsae.' and means 'He said
  that he lived in the northern land near the Western Sea.')
*/

class Module {
public:

  Module() {
    my_reg_ = 7;
  }

  logic<8> get_reg() {
    return my_reg_;
  }

private:

  logic<8> my_reg_;
};
#include "metron/metron_tools.h"

// UTF-8 text files with a byte order mark should be supported.

// From https://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html:

/*
Runes:

             

  (Old English, which transcribed into Latin reads 'He cwaeth that he
  bude thaem lande northweardum with tha Westsae.' and means 'He said
  that he lived in the northern land near the Western Sea.')
*/

class Module {
public:

  Module() {
    my_reg_ = 7;
  }

  logic<8> get_reg() {
    return my_reg_;
  }

private:

  logic<8> my_reg_;
};
*.vh
Copyright (c) 2012-2015, The Regents of the University of California (Regents).
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the Regents nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
Tests from https://github.com/riscv/riscv-tests/tree/master/isa/rv32ui
# See LICENSE for license details.

#*****************************************************************************
# add.S
#-----------------------------------------------------------------------------
#
# Test add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  add, 0x00000002, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  add, 0x0000000a, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  add, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  add, 0xffffffff80000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  add, 0xffffffff7fff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  add, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  add, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, add, 0x0000000080007ffe, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, add, 0xffffffff80007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, add, 0x000000007fff7fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, add, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, add, 0x0000000000000000, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, add, 0xfffffffffffffffe, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, add, 0x0000000080000000, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, add, 24, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, add, 25, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, add, 26, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, add, 24, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, add, 25, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, add, 26, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, add, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, add, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, add, 26, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, add, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, add, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, add, 26, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, add, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, add, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, add, 26, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, add, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, add, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, add, 26, 15, 11 );

  TEST_RR_ZEROSRC1( 35, add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, add, 32, 32 );
  TEST_RR_ZEROSRC12( 37, add, 0 );
  TEST_RR_ZERODEST( 38, add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 00000113 002081B3 00000E93 00200E13 4DD19663 00100093
@00000007 00100113 002081B3 00200E93 00300E13 4BD19A63 00300093 00700113
@0000000E 002081B3 00A00E93 00400E13 49D19E63 00000093 FFFF8137 002081B3
@00000015 FFFF8EB7 00500E13 49D19263 800000B7 00000113 002081B3 80000EB7
@0000001C 00600E13 47D19663 800000B7 FFFF8137 002081B3 7FFF8EB7 00700E13
@00000023 45D19A63 00000093 00008137 FFF10113 002081B3 00008EB7 FFFE8E93
@0000002A 00800E13 43D19A63 800000B7 FFF08093 00000113 002081B3 80000EB7
@00000031 FFFE8E93 00900E13 41D19A63 800000B7 FFF08093 00008137 FFF10113
@00000038 002081B3 80008EB7 FFEE8E93 00A00E13 3FD19863 800000B7 00008137
@0000003F FFF10113 002081B3 80008EB7 FFFE8E93 00B00E13 3DD19863 800000B7
@00000046 FFF08093 FFFF8137 002081B3 7FFF8EB7 FFFE8E93 00C00E13 3BD19863
@0000004D 00000093 FFF00113 002081B3 FFF00E93 00D00E13 39D19C63 FFF00093
@00000054 00100113 002081B3 00000E93 00E00E13 39D19063 FFF00093 FFF00113
@0000005B 002081B3 FFE00E93 00F00E13 37D19463 00100093 80000137 FFF10113
@00000062 002081B3 80000EB7 01000E13 35D19663 00D00093 00B00113 002080B3
@00000069 01800E93 01100E13 33D09A63 00E00093 00B00113 00208133 01900E93
@00000070 01200E13 31D11E63 00D00093 001080B3 01A00E93 01300E13 31D09463
@00000077 00000213 00D00093 00B00113 002081B3 00018313 00120213 00200293
@0000007E FE5214E3 01800E93 01400E13 2DD31E63 00000213 00E00093 00B00113
@00000085 002081B3 00000013 00018313 00120213 00200293 FE5212E3 01900E93
@0000008C 01500E13 2BD31663 00000213 00F00093 00B00113 002081B3 00000013
@00000093 00000013 00018313 00120213 00200293 FE5210E3 01A00E93 01600E13
@0000009A 27D31C63 00000213 00D00093 00B00113 002081B3 00120213 00200293
@000000A1 FE5216E3 01800E93 01700E13 25D19863 00000213 00E00093 00B00113
@000000A8 00000013 002081B3 00120213 00200293 FE5214E3 01900E93 01800E13
@000000AF 23D19263 00000213 00F00093 00B00113 00000013 00000013 002081B3
@000000B6 00120213 00200293 FE5212E3 01A00E93 01900E13 1FD19A63 00000213
@000000BD 00D00093 00000013 00B00113 002081B3 00120213 00200293 FE5214E3
@000000C4 01800E93 01A00E13 1DD19463 00000213 00E00093 00000013 00B00113
@000000CB 00000013 002081B3 00120213 00200293 FE5212E3 01900E93 01B00E13
@000000D2 19D19C63 00000213 00F00093 00000013 00000013 00B00113 002081B3
@000000D9 00120213 00200293 FE5212E3 01A00E93 01C00E13 17D19463 00000213
@000000E0 00B00113 00D00093 002081B3 00120213 00200293 FE5216E3 01800E93
@000000E7 01D00E13 15D19063 00000213 00B00113 00E00093 00000013 002081B3
@000000EE 00120213 00200293 FE5214E3 01900E93 01E00E13 11D19A63 00000213
@000000F5 00B00113 00F00093 00000013 00000013 002081B3 00120213 00200293
@000000FC FE5212E3 01A00E93 01F00E13 0FD19263 00000213 00B00113 00000013
@00000103 00D00093 002081B3 00120213 00200293 FE5214E3 01800E93 02000E13
@0000010A 0BD19C63 00000213 00B00113 00000013 00E00093 00000013 002081B3
@00000111 00120213 00200293 FE5212E3 01900E93 02100E13 09D19463 00000213
@00000118 00B00113 00000013 00000013 00F00093 002081B3 00120213 00200293
@0000011F FE5212E3 01A00E93 02200E13 05D19C63 00F00093 00100133 00F00E93
@00000126 02300E13 05D11263 02000093 00008133 02000E93 02400E13 03D11863
@0000012D 000000B3 00000E93 02500E13 03D09063 01000093 01E00113 00208033
@00000134 00000E93 02600E13 01D01463 01C01A63 FF000513 00000593 00B52023
@0000013B FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# addi.S
#-----------------------------------------------------------------------------
#
# Test addi instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  addi, 0x00000000, 0x00000000, 0x000 );
  TEST_IMM_OP( 3,  addi, 0x00000002, 0x00000001, 0x001 );
  TEST_IMM_OP( 4,  addi, 0x0000000a, 0x00000003, 0x007 );

  TEST_IMM_OP( 5,  addi, 0xfffffffffffff800, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 6,  addi, 0xffffffff80000000, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 7,  addi, 0xffffffff7ffff800, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 8,  addi, 0x00000000000007ff, 0x00000000, 0x7ff );
  TEST_IMM_OP( 9,  addi, 0x000000007fffffff, 0x7fffffff, 0x000 );
  TEST_IMM_OP( 10, addi, 0x00000000800007fe, 0x7fffffff, 0x7ff );

  TEST_IMM_OP( 11, addi, 0xffffffff800007ff, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 12, addi, 0x000000007ffff7ff, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 13, addi, 0xffffffffffffffff, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 14, addi, 0x0000000000000000, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 15, addi, 0xfffffffffffffffe, 0xffffffffffffffff, 0xfff );

  TEST_IMM_OP( 16, addi, 0x0000000080000000, 0x7fffffff, 0x001 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, addi, 24, 13, 11 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, addi, 24, 13, 11 );
  TEST_IMM_DEST_BYPASS( 19, 1, addi, 23, 13, 10 );
  TEST_IMM_DEST_BYPASS( 20, 2, addi, 22, 13,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, addi, 24, 13, 11 );
  TEST_IMM_SRC1_BYPASS( 22, 1, addi, 23, 13, 10 );
  TEST_IMM_SRC1_BYPASS( 23, 2, addi, 22, 13,  9 );

  TEST_IMM_ZEROSRC1( 24, addi, 32, 32 );
  TEST_IMM_ZERODEST( 25, addi, 33, 50 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 00008193 00000E93 00200E13 27D19C63 00100093 00108193
@00000007 00200E93 00300E13 27D19263 00300093 00708193 00A00E93 00400E13
@0000000E 25D19863 00000093 80008193 80000E93 00500E13 23D19E63 800000B7
@00000015 00008193 80000EB7 00600E13 23D19463 800000B7 80008193 80000EB7
@0000001C 800E8E93 00700E13 21D19863 00000093 7FF08193 7FF00E93 00800E13
@00000023 1FD19E63 800000B7 FFF08093 00008193 80000EB7 FFFE8E93 00900E13
@0000002A 1FD19063 800000B7 FFF08093 7FF08193 80000EB7 7FEE8E93 00A00E13
@00000031 1DD19263 800000B7 7FF08193 80000EB7 7FFE8E93 00B00E13 1BD19663
@00000038 800000B7 FFF08093 80008193 7FFFFEB7 7FFE8E93 00C00E13 19D19863
@0000003F 00000093 FFF08193 FFF00E93 00D00E13 17D19E63 FFF00093 00108193
@00000046 00000E93 00E00E13 17D19463 FFF00093 FFF08193 FFE00E93 00F00E13
@0000004D 15D19A63 800000B7 FFF08093 00108193 80000EB7 01000E13 13D19E63
@00000054 00D00093 00B08093 01800E93 01100E13 13D09463 00000213 00D00093
@0000005B 00B08193 00018313 00120213 00200293 FE5216E3 01800E93 01200E13
@00000062 11D31063 00000213 00D00093 00A08193 00000013 00018313 00120213
@00000069 00200293 FE5214E3 01700E93 01300E13 0DD31A63 00000213 00D00093
@00000070 00908193 00000013 00000013 00018313 00120213 00200293 FE5212E3
@00000077 01600E93 01400E13 0BD31263 00000213 00D00093 00B08193 00120213
@0000007E 00200293 FE5218E3 01800E93 01500E13 09D19063 00000213 00D00093
@00000085 00000013 00A08193 00120213 00200293 FE5216E3 01700E93 01600E13
@0000008C 05D19C63 00000213 00D00093 00000013 00000013 00908193 00120213
@00000093 00200293 FE5214E3 01600E93 01700E13 03D19663 02000093 02000E93
@0000009A 01800E13 01D09E63 02100093 03208013 00000E93 01900E13 01D01463
@000000A1 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@000000A8 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# and.S
#-----------------------------------------------------------------------------
#
# Test and instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, and, 0xf000f000, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_EQ_DEST( 8, and, 0xff00ff00, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, and, 0, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, and, 0, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, and, 0 );
  TEST_RR_ZERODEST( 27, and, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF0100B7 F0008093 0F0F1137 F0F10113 0020F1B3 0F001EB7 F00E8E93
@00000007 00200E13 49D19C63 0FF010B7 FF008093 F0F0F137 0F010113 0020F1B3
@0000000E 00F00EB7 0F0E8E93 00300E13 47D19A63 00FF00B7 0FF08093 0F0F1137
@00000015 F0F10113 0020F1B3 000F0EB7 00FE8E93 00400E13 45D19863 F00FF0B7
@0000001C 00F08093 F0F0F137 0F010113 0020F1B3 F000FEB7 00500E13 43D19863
@00000023 FF0100B7 F0008093 0F0F1137 F0F10113 0020F0B3 0F001EB7 F00E8E93
@0000002A 00600E13 41D09663 0FF010B7 FF008093 F0F0F137 0F010113 0020F133
@00000031 00F00EB7 0F0E8E93 00700E13 3FD11463 FF0100B7 F0008093 0010F0B3
@00000038 FF010EB7 F00E8E93 00800E13 3DD09663 00000213 FF0100B7 F0008093
@0000003F 0F0F1137 F0F10113 0020F1B3 00018313 00120213 00200293 FE5210E3
@00000046 0F001EB7 F00E8E93 00900E13 39D31A63 00000213 0FF010B7 FF008093
@0000004D F0F0F137 0F010113 0020F1B3 00000013 00018313 00120213 00200293
@00000054 FC521EE3 00F00EB7 0F0E8E93 00A00E13 35D31C63 00000213 00FF00B7
@0000005B 0FF08093 0F0F1137 F0F10113 0020F1B3 00000013 00000013 00018313
@00000062 00120213 00200293 FC521CE3 000F0EB7 00FE8E93 00B00E13 31D31C63
@00000069 00000213 FF0100B7 F0008093 0F0F1137 F0F10113 0020F1B3 00120213
@00000070 00200293 FE5212E3 0F001EB7 F00E8E93 00C00E13 2FD19263 00000213
@00000077 0FF010B7 FF008093 F0F0F137 0F010113 00000013 0020F1B3 00120213
@0000007E 00200293 FE5210E3 00F00EB7 0F0E8E93 00D00E13 2BD19663 00000213
@00000085 00FF00B7 0FF08093 0F0F1137 F0F10113 00000013 00000013 0020F1B3
@0000008C 00120213 00200293 FC521EE3 000F0EB7 00FE8E93 00E00E13 27D19863
@00000093 00000213 FF0100B7 F0008093 00000013 0F0F1137 F0F10113 0020F1B3
@0000009A 00120213 00200293 FE5210E3 0F001EB7 F00E8E93 00F00E13 23D19C63
@000000A1 00000213 0FF010B7 FF008093 00000013 F0F0F137 0F010113 00000013
@000000A8 0020F1B3 00120213 00200293 FC521EE3 00F00EB7 0F0E8E93 01000E13
@000000AF 1FD19E63 00000213 00FF00B7 0FF08093 00000013 00000013 0F0F1137
@000000B6 F0F10113 0020F1B3 00120213 00200293 FC521EE3 000F0EB7 00FE8E93
@000000BD 01100E13 1DD19063 00000213 0F0F1137 F0F10113 FF0100B7 F0008093
@000000C4 0020F1B3 00120213 00200293 FE5212E3 0F001EB7 F00E8E93 01200E13
@000000CB 19D19663 00000213 F0F0F137 0F010113 0FF010B7 FF008093 00000013
@000000D2 0020F1B3 00120213 00200293 FE5210E3 00F00EB7 0F0E8E93 01300E13
@000000D9 15D19A63 00000213 0F0F1137 F0F10113 00FF00B7 0FF08093 00000013
@000000E0 00000013 0020F1B3 00120213 00200293 FC521EE3 000F0EB7 00FE8E93
@000000E7 01400E13 11D19C63 00000213 0F0F1137 F0F10113 00000013 FF0100B7
@000000EE F0008093 0020F1B3 00120213 00200293 FE5210E3 0F001EB7 F00E8E93
@000000F5 01500E13 0FD19063 00000213 F0F0F137 0F010113 00000013 0FF010B7
@000000FC FF008093 00000013 0020F1B3 00120213 00200293 FC521EE3 00F00EB7
@00000103 0F0E8E93 01600E13 0BD19263 00000213 0F0F1137 F0F10113 00000013
@0000010A 00000013 00FF00B7 0FF08093 0020F1B3 00120213 00200293 FC521EE3
@00000111 000F0EB7 00FE8E93 01700E13 07D19463 FF0100B7 F0008093 00107133
@00000118 00000E93 01800E13 05D11863 00FF00B7 0FF08093 0000F133 00000E93
@0000011F 01900E13 03D11C63 000070B3 00000E93 01A00E13 03D09463 111110B7
@00000126 11108093 22222137 22210113 0020F033 00000E93 01B00E13 01D01463
@0000012D 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@00000134 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# andi.S
#-----------------------------------------------------------------------------
#
# Test andi instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, andi, 0xff00ff00, 0xff00ff00, 0xf0f );
  TEST_IMM_OP( 3, andi, 0x000000f0, 0x0ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, andi, 0x0000000f, 0x00ff00ff, 0x70f );
  TEST_IMM_OP( 5, andi, 0x00000000, 0xf00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, andi, 0x00000000, 0xff00ff00, 0x0f0 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, andi, 0x00000700, 0x0ff00ff0, 0x70f );
  TEST_IMM_DEST_BYPASS( 8,  1, andi, 0x000000f0, 0x00ff00ff, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 9,  2, andi, 0xf00ff00f, 0xf00ff00f, 0xf0f );

  TEST_IMM_SRC1_BYPASS( 10, 0, andi, 0x00000700, 0x0ff00ff0, 0x70f );
  TEST_IMM_SRC1_BYPASS( 11, 1, andi, 0x000000f0, 0x00ff00ff, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 12, 2, andi, 0x0000000f, 0xf00ff00f, 0x70f );

  TEST_IMM_ZEROSRC1( 13, andi, 0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, andi, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF0100B7 F0008093 F0F0F193 FF010EB7 F00E8E93 00200E13 1BD19463
@00000007 0FF010B7 FF008093 0F00F193 0F000E93 00300E13 19D19863 00FF00B7
@0000000E 0FF08093 70F0F193 00F00E93 00400E13 17D19C63 F00FF0B7 00F08093
@00000015 0F00F193 00000E93 00500E13 17D19063 FF0100B7 F0008093 0F00F093
@0000001C 00000E93 00600E13 15D09463 00000213 0FF010B7 FF008093 70F0F193
@00000023 00018313 00120213 00200293 FE5214E3 70000E93 00700E13 11D31E63
@0000002A 00000213 00FF00B7 0FF08093 0F00F193 00000013 00018313 00120213
@00000031 00200293 FE5212E3 0F000E93 00800E13 0FD31663 00000213 F00FF0B7
@00000038 00F08093 F0F0F193 00000013 00000013 00018313 00120213 00200293
@0000003F FE5210E3 F00FFEB7 00FE8E93 00900E13 0BD31A63 00000213 0FF010B7
@00000046 FF008093 70F0F193 00120213 00200293 FE5216E3 70000E93 00A00E13
@0000004D 09D19663 00000213 00FF00B7 0FF08093 00000013 0F00F193 00120213
@00000054 00200293 FE5214E3 0F000E93 00B00E13 07D19063 00000213 F00FF0B7
@0000005B 00F08093 00000013 00000013 70F0F193 00120213 00200293 FE5212E3
@00000062 00F00E93 00C00E13 03D19863 0F007093 00000E93 00D00E13 03D09063
@00000069 00FF00B7 0FF08093 70F0F013 00000E93 00E00E13 01D01463 01C01A63
@00000070 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@00000077 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# auipc.S
#-----------------------------------------------------------------------------
#
# Test auipc instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 10000, \
    .align 3; \
    lla a0, 1f + 10000; \
    jal a1, 1f; \
    1: sub a0, a0, a1; \
  )

  TEST_CASE(3, a0, -10000, \
    .align 3; \
    lla a0, 1f - 10000; \
    jal a1, 1f; \
    1: sub a0, a0, a1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00002517 71C50513 004005EF 40B50533 00002EB7 710E8E93 00200E13
@00000007 03D51463 FFFFE517 8FC50513 004005EF 40B50533 FFFFEEB7 8F0E8E93
@0000000E 00300E13 01D51463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@00000015 FF000513 00100593 00B52023 FF5FF06F 00000000
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# simple.S
#-----------------------------------------------------------------------------
#
# This is the most basic self checking test. If your simulator does not
# pass thiss then there is little chance that it will pass any of the
# more complicated self checking tests.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  li t0, 1000000

1:
  la t1, tdat

  lw t2, 0(t1)
  xori t3, t2, 1234
  sll t4, t2, 7
  sub t5, t3, t2
  sw t5, 0(t1)

  add t0, t0, -1
  bnez t0, 1b

RVTEST_PASS

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0xdeadbeef
tdat2:  .word 0xdeadbeef
tdat3:  .word 0xdeadbeef
tdat4:  .word 0xdeadbeef
tdat5:  .word 0xdeadbeef
tdat6:  .word 0xdeadbeef
tdat7:  .word 0xdeadbeef
tdat8:  .word 0xdeadbeef
tdat9:  .word 0xdeadbeef
tdat10: .word 0xdeadbeef

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 000F42B7 24028293 7FC00317 FF830313 00032383 4D23CE13 00739E93
@00000007 407E0F33 01E32023 FFF28293 FE0290E3 FF000513 00100593 00B52023
@0000000E FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF
@00000007 DEADBEEF DEADBEEF DEADBEEF
# See LICENSE for license details.

#*****************************************************************************
# beq.S
#-----------------------------------------------------------------------------
#
# Test beq instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, beq,  0,  0 );
  TEST_BR2_OP_TAKEN( 3, beq,  1,  1 );
  TEST_BR2_OP_TAKEN( 4, beq, -1, -1 );

  TEST_BR2_OP_NOTTAKEN( 5, beq,  0,  1 );
  TEST_BR2_OP_NOTTAKEN( 6, beq,  1,  0 );
  TEST_BR2_OP_NOTTAKEN( 7, beq, -1,  1 );
  TEST_BR2_OP_NOTTAKEN( 8, beq,  1, -1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, beq, 0, -1 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, beq, 0, -1 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    beq x0, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00000113 00208663 2BC01863 01C01663 FE208EE3
@00000007 2BC01263 00300E13 00100093 00100113 00208663 29C01863 01C01663
@0000000E FE208EE3 29C01263 00400E13 FFF00093 FFF00113 00208663 27C01863
@00000015 01C01663 FE208EE3 27C01263 00500E13 00000093 00100113 00208463
@0000001C 01C01463 25C01663 FE208EE3 00600E13 00100093 00000113 00208463
@00000023 01C01463 23C01863 FE208EE3 00700E13 FFF00093 00100113 00208463
@0000002A 01C01463 21C01A63 FE208EE3 00800E13 00100093 FFF00113 00208463
@00000031 01C01463 1FC01C63 FE208EE3 00900E13 00000213 00000093 FFF00113
@00000038 1E208063 00120213 00200293 FE5216E3 00A00E13 00000213 00000093
@0000003F FFF00113 00000013 1A208E63 00120213 00200293 FE5214E3 00B00E13
@00000046 00000213 00000093 FFF00113 00000013 00000013 18208A63 00120213
@0000004D 00200293 FE5212E3 00C00E13 00000213 00000093 00000013 FFF00113
@00000054 16208863 00120213 00200293 FE5214E3 00D00E13 00000213 00000093
@0000005B 00000013 FFF00113 00000013 14208463 00120213 00200293 FE5212E3
@00000062 00E00E13 00000213 00000093 00000013 00000013 FFF00113 12208063
@00000069 00120213 00200293 FE5212E3 00F00E13 00000213 00000093 FFF00113
@00000070 10208063 00120213 00200293 FE5216E3 01000E13 00000213 00000093
@00000077 FFF00113 00000013 0C208E63 00120213 00200293 FE5214E3 01100E13
@0000007E 00000213 00000093 FFF00113 00000013 00000013 0A208A63 00120213
@00000085 00200293 FE5212E3 01200E13 00000213 00000093 00000013 FFF00113
@0000008C 08208863 00120213 00200293 FE5214E3 01300E13 00000213 00000093
@00000093 00000013 FFF00113 00000013 06208463 00120213 00200293 FE5212E3
@0000009A 01400E13 00000213 00000093 00000013 00000013 FFF00113 04208063
@000000A1 00120213 00200293 FE5212E3 00100093 00000A63 00108093 00108093
@000000A8 00108093 00108093 00108093 00108093 00300E93 01500E13 01D09463
@000000AF 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@000000B6 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# bge.S
#-----------------------------------------------------------------------------
#
# Test bge instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bge,  0,  0 );
  TEST_BR2_OP_TAKEN( 3, bge,  1,  1 );
  TEST_BR2_OP_TAKEN( 4, bge, -1, -1 );
  TEST_BR2_OP_TAKEN( 5, bge,  1,  0 );
  TEST_BR2_OP_TAKEN( 6, bge,  1, -1 );
  TEST_BR2_OP_TAKEN( 7, bge, -1, -2 );

  TEST_BR2_OP_NOTTAKEN(  8, bge,  0,  1 );
  TEST_BR2_OP_NOTTAKEN(  9, bge, -1,  1 );
  TEST_BR2_OP_NOTTAKEN( 10, bge, -2, -1 );
  TEST_BR2_OP_NOTTAKEN( 11, bge, -2,  1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 12, 0, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 13, 0, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 14, 0, 2, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 15, 1, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 16, 1, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 17, 2, 0, bge, -1, 0 );

  TEST_BR2_SRC12_BYPASS( 18, 0, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 19, 0, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 20, 0, 2, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 21, 1, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 22, 1, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 23, 2, 0, bge, -1, 0 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 24, x1, 3, \
    li  x1, 1; \
    bge x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00000113 0020D663 31C01863 01C01663 FE20DEE3
@00000007 31C01263 00300E13 00100093 00100113 0020D663 2FC01863 01C01663
@0000000E FE20DEE3 2FC01263 00400E13 FFF00093 FFF00113 0020D663 2DC01863
@00000015 01C01663 FE20DEE3 2DC01263 00500E13 00100093 00000113 0020D663
@0000001C 2BC01863 01C01663 FE20DEE3 2BC01263 00600E13 00100093 FFF00113
@00000023 0020D663 29C01863 01C01663 FE20DEE3 29C01263 00700E13 FFF00093
@0000002A FFE00113 0020D663 27C01863 01C01663 FE20DEE3 27C01263 00800E13
@00000031 00000093 00100113 0020D463 01C01463 25C01663 FE20DEE3 00900E13
@00000038 FFF00093 00100113 0020D463 01C01463 23C01863 FE20DEE3 00A00E13
@0000003F FFE00093 FFF00113 0020D463 01C01463 21C01A63 FE20DEE3 00B00E13
@00000046 FFE00093 00100113 0020D463 01C01463 1FC01C63 FE20DEE3 00C00E13
@0000004D 00000213 FFF00093 00000113 1E20D063 00120213 00200293 FE5216E3
@00000054 00D00E13 00000213 FFF00093 00000113 00000013 1A20DE63 00120213
@0000005B 00200293 FE5214E3 00E00E13 00000213 FFF00093 00000113 00000013
@00000062 00000013 1820DA63 00120213 00200293 FE5212E3 00F00E13 00000213
@00000069 FFF00093 00000013 00000113 1620D863 00120213 00200293 FE5214E3
@00000070 01000E13 00000213 FFF00093 00000013 00000113 00000013 1420D463
@00000077 00120213 00200293 FE5212E3 01100E13 00000213 FFF00093 00000013
@0000007E 00000013 00000113 1220D063 00120213 00200293 FE5212E3 01200E13
@00000085 00000213 FFF00093 00000113 1020D063 00120213 00200293 FE5216E3
@0000008C 01300E13 00000213 FFF00093 00000113 00000013 0C20DE63 00120213
@00000093 00200293 FE5214E3 01400E13 00000213 FFF00093 00000113 00000013
@0000009A 00000013 0A20DA63 00120213 00200293 FE5212E3 01500E13 00000213
@000000A1 FFF00093 00000013 00000113 0820D863 00120213 00200293 FE5214E3
@000000A8 01600E13 00000213 FFF00093 00000013 00000113 00000013 0620D463
@000000AF 00120213 00200293 FE5212E3 01700E13 00000213 FFF00093 00000013
@000000B6 00000013 00000113 0420D063 00120213 00200293 FE5212E3 00100093
@000000BD 0000DA63 00108093 00108093 00108093 00108093 00108093 00108093
@000000C4 00300E93 01800E13 01D09463 01C01A63 FF000513 00000593 00B52023
@000000CB FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# bgeu.S
#-----------------------------------------------------------------------------
#
# Test bgeu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bgeu, 0x00000000, 0x00000000 );
  TEST_BR2_OP_TAKEN( 3, bgeu, 0x00000001, 0x00000001 );
  TEST_BR2_OP_TAKEN( 4, bgeu, 0xffffffff, 0xffffffff );
  TEST_BR2_OP_TAKEN( 5, bgeu, 0x00000001, 0x00000000 );
  TEST_BR2_OP_TAKEN( 6, bgeu, 0xffffffff, 0xfffffffe );
  TEST_BR2_OP_TAKEN( 7, bgeu, 0xffffffff, 0x00000000 );

  TEST_BR2_OP_NOTTAKEN(  8, bgeu, 0x00000000, 0x00000001 );
  TEST_BR2_OP_NOTTAKEN(  9, bgeu, 0xfffffffe, 0xffffffff );
  TEST_BR2_OP_NOTTAKEN( 10, bgeu, 0x00000000, 0xffffffff );
  TEST_BR2_OP_NOTTAKEN( 11, bgeu, 0x7fffffff, 0x80000000 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 12, 0, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 13, 0, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 14, 0, 2, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 15, 1, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 16, 1, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 17, 2, 0, bgeu, 0xefffffff, 0xf0000000 );

  TEST_BR2_SRC12_BYPASS( 18, 0, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 19, 0, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 20, 0, 2, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 21, 1, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 22, 1, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 23, 2, 0, bgeu, 0xefffffff, 0xf0000000 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 24, x1, 3, \
    li  x1, 1; \
    bgeu x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00000113 0020F663 35C01263 01C01663 FE20FEE3
@00000007 33C01C63 00300E13 00100093 00100113 0020F663 33C01263 01C01663
@0000000E FE20FEE3 31C01C63 00400E13 FFF00093 FFF00113 0020F663 31C01263
@00000015 01C01663 FE20FEE3 2FC01C63 00500E13 00100093 00000113 0020F663
@0000001C 2FC01263 01C01663 FE20FEE3 2DC01C63 00600E13 FFF00093 FFE00113
@00000023 0020F663 2DC01263 01C01663 FE20FEE3 2BC01C63 00700E13 FFF00093
@0000002A 00000113 0020F663 2BC01263 01C01663 FE20FEE3 29C01C63 00800E13
@00000031 00000093 00100113 0020F463 01C01463 29C01063 FE20FEE3 00900E13
@00000038 FFE00093 FFF00113 0020F463 01C01463 27C01263 FE20FEE3 00A00E13
@0000003F 00000093 FFF00113 0020F463 01C01463 25C01463 FE20FEE3 00B00E13
@00000046 800000B7 FFF08093 80000137 0020F463 01C01463 23C01463 FE20FEE3
@0000004D 00C00E13 00000213 F00000B7 FFF08093 F0000137 2020F663 00120213
@00000054 00200293 FE5214E3 00D00E13 00000213 F00000B7 FFF08093 F0000137
@0000005B 00000013 1E20F263 00120213 00200293 FE5212E3 00E00E13 00000213
@00000062 F00000B7 FFF08093 F0000137 00000013 00000013 1A20FC63 00120213
@00000069 00200293 FE5210E3 00F00E13 00000213 F00000B7 FFF08093 00000013
@00000070 F0000137 1820F863 00120213 00200293 FE5212E3 01000E13 00000213
@00000077 F00000B7 FFF08093 00000013 F0000137 00000013 1620F263 00120213
@0000007E 00200293 FE5210E3 01100E13 00000213 F00000B7 FFF08093 00000013
@00000085 00000013 F0000137 1220FC63 00120213 00200293 FE5210E3 01200E13
@0000008C 00000213 F00000B7 FFF08093 F0000137 1020FA63 00120213 00200293
@00000093 FE5214E3 01300E13 00000213 F00000B7 FFF08093 F0000137 00000013
@0000009A 0E20F663 00120213 00200293 FE5212E3 01400E13 00000213 F00000B7
@000000A1 FFF08093 F0000137 00000013 00000013 0C20F063 00120213 00200293
@000000A8 FE5210E3 01500E13 00000213 F00000B7 FFF08093 00000013 F0000137
@000000AF 0820FC63 00120213 00200293 FE5212E3 01600E13 00000213 F00000B7
@000000B6 FFF08093 00000013 F0000137 00000013 0620F663 00120213 00200293
@000000BD FE5210E3 01700E13 00000213 F00000B7 FFF08093 00000013 00000013
@000000C4 F0000137 0420F063 00120213 00200293 FE5210E3 00100093 0000FA63
@000000CB 00108093 00108093 00108093 00108093 00108093 00108093 00300E93
@000000D2 01800E13 01D09463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@000000D9 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# blt.S
#-----------------------------------------------------------------------------
#
# Test blt instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, blt,  0,  1 );
  TEST_BR2_OP_TAKEN( 3, blt, -1,  1 );
  TEST_BR2_OP_TAKEN( 4, blt, -2, -1 );

  TEST_BR2_OP_NOTTAKEN( 5, blt,  1,  0 );
  TEST_BR2_OP_NOTTAKEN( 6, blt,  1, -1 );
  TEST_BR2_OP_NOTTAKEN( 7, blt, -1, -2 );
  TEST_BR2_OP_NOTTAKEN( 8, blt,  1, -2 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, blt, 0, -1 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, blt, 0, -1 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    blt x0, x1, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00100113 0020C663 2BC01863 01C01663 FE20CEE3
@00000007 2BC01263 00300E13 FFF00093 00100113 0020C663 29C01863 01C01663
@0000000E FE20CEE3 29C01263 00400E13 FFE00093 FFF00113 0020C663 27C01863
@00000015 01C01663 FE20CEE3 27C01263 00500E13 00100093 00000113 0020C463
@0000001C 01C01463 25C01663 FE20CEE3 00600E13 00100093 FFF00113 0020C463
@00000023 01C01463 23C01863 FE20CEE3 00700E13 FFF00093 FFE00113 0020C463
@0000002A 01C01463 21C01A63 FE20CEE3 00800E13 00100093 FFE00113 0020C463
@00000031 01C01463 1FC01C63 FE20CEE3 00900E13 00000213 00000093 FFF00113
@00000038 1E20C063 00120213 00200293 FE5216E3 00A00E13 00000213 00000093
@0000003F FFF00113 00000013 1A20CE63 00120213 00200293 FE5214E3 00B00E13
@00000046 00000213 00000093 FFF00113 00000013 00000013 1820CA63 00120213
@0000004D 00200293 FE5212E3 00C00E13 00000213 00000093 00000013 FFF00113
@00000054 1620C863 00120213 00200293 FE5214E3 00D00E13 00000213 00000093
@0000005B 00000013 FFF00113 00000013 1420C463 00120213 00200293 FE5212E3
@00000062 00E00E13 00000213 00000093 00000013 00000013 FFF00113 1220C063
@00000069 00120213 00200293 FE5212E3 00F00E13 00000213 00000093 FFF00113
@00000070 1020C063 00120213 00200293 FE5216E3 01000E13 00000213 00000093
@00000077 FFF00113 00000013 0C20CE63 00120213 00200293 FE5214E3 01100E13
@0000007E 00000213 00000093 FFF00113 00000013 00000013 0A20CA63 00120213
@00000085 00200293 FE5212E3 01200E13 00000213 00000093 00000013 FFF00113
@0000008C 0820C863 00120213 00200293 FE5214E3 01300E13 00000213 00000093
@00000093 00000013 FFF00113 00000013 0620C463 00120213 00200293 FE5212E3
@0000009A 01400E13 00000213 00000093 00000013 00000013 FFF00113 0420C063
@000000A1 00120213 00200293 FE5212E3 00100093 00104A63 00108093 00108093
@000000A8 00108093 00108093 00108093 00108093 00300E93 01500E13 01D09463
@000000AF 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@000000B6 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# bltu.S
#-----------------------------------------------------------------------------
#
# Test bltu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bltu, 0x00000000, 0x00000001 );
  TEST_BR2_OP_TAKEN( 3, bltu, 0xfffffffe, 0xffffffff );
  TEST_BR2_OP_TAKEN( 4, bltu, 0x00000000, 0xffffffff );

  TEST_BR2_OP_NOTTAKEN( 5, bltu, 0x00000001, 0x00000000 );
  TEST_BR2_OP_NOTTAKEN( 6, bltu, 0xffffffff, 0xfffffffe );
  TEST_BR2_OP_NOTTAKEN( 7, bltu, 0xffffffff, 0x00000000 );
  TEST_BR2_OP_NOTTAKEN( 8, bltu, 0x80000000, 0x7fffffff );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, bltu, 0xf0000000, 0xefffffff );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, bltu, 0xf0000000, 0xefffffff );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    bltu x0, x1, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00100113 0020E663 2FC01263 01C01663 FE20EEE3
@00000007 2DC01C63 00300E13 FFE00093 FFF00113 0020E663 2DC01263 01C01663
@0000000E FE20EEE3 2BC01C63 00400E13 00000093 FFF00113 0020E663 2BC01263
@00000015 01C01663 FE20EEE3 29C01C63 00500E13 00100093 00000113 0020E463
@0000001C 01C01463 29C01063 FE20EEE3 00600E13 FFF00093 FFE00113 0020E463
@00000023 01C01463 27C01263 FE20EEE3 00700E13 FFF00093 00000113 0020E463
@0000002A 01C01463 25C01463 FE20EEE3 00800E13 800000B7 80000137 FFF10113
@00000031 0020E463 01C01463 23C01463 FE20EEE3 00900E13 00000213 F00000B7
@00000038 F0000137 FFF10113 2020E663 00120213 00200293 FE5214E3 00A00E13
@0000003F 00000213 F00000B7 F0000137 FFF10113 00000013 1E20E263 00120213
@00000046 00200293 FE5212E3 00B00E13 00000213 F00000B7 F0000137 FFF10113
@0000004D 00000013 00000013 1A20EC63 00120213 00200293 FE5210E3 00C00E13
@00000054 00000213 F00000B7 00000013 F0000137 FFF10113 1820E863 00120213
@0000005B 00200293 FE5212E3 00D00E13 00000213 F00000B7 00000013 F0000137
@00000062 FFF10113 00000013 1620E263 00120213 00200293 FE5210E3 00E00E13
@00000069 00000213 F00000B7 00000013 00000013 F0000137 FFF10113 1220EC63
@00000070 00120213 00200293 FE5210E3 00F00E13 00000213 F00000B7 F0000137
@00000077 FFF10113 1020EA63 00120213 00200293 FE5214E3 01000E13 00000213
@0000007E F00000B7 F0000137 FFF10113 00000013 0E20E663 00120213 00200293
@00000085 FE5212E3 01100E13 00000213 F00000B7 F0000137 FFF10113 00000013
@0000008C 00000013 0C20E063 00120213 00200293 FE5210E3 01200E13 00000213
@00000093 F00000B7 00000013 F0000137 FFF10113 0820EC63 00120213 00200293
@0000009A FE5212E3 01300E13 00000213 F00000B7 00000013 F0000137 FFF10113
@000000A1 00000013 0620E663 00120213 00200293 FE5210E3 01400E13 00000213
@000000A8 F00000B7 00000013 00000013 F0000137 FFF10113 0420E063 00120213
@000000AF 00200293 FE5210E3 00100093 00106A63 00108093 00108093 00108093
@000000B6 00108093 00108093 00108093 00300E93 01500E13 01D09463 01C01A63
@000000BD FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@000000C4 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# bne.S
#-----------------------------------------------------------------------------
#
# Test bne instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bne,  0,  1 );
  TEST_BR2_OP_TAKEN( 3, bne,  1,  0 );
  TEST_BR2_OP_TAKEN( 4, bne, -1,  1 );
  TEST_BR2_OP_TAKEN( 5, bne,  1, -1 );

  TEST_BR2_OP_NOTTAKEN( 6, bne,  0,  0 );
  TEST_BR2_OP_NOTTAKEN( 7, bne,  1,  1 );
  TEST_BR2_OP_NOTTAKEN( 8, bne, -1, -1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, bne, 0, 0 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, bne, 0, 0 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    bne x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 00100113 00209663 2BC01A63 01C01663 FE209EE3
@00000007 2BC01463 00300E13 00100093 00000113 00209663 29C01A63 01C01663
@0000000E FE209EE3 29C01463 00400E13 FFF00093 00100113 00209663 27C01A63
@00000015 01C01663 FE209EE3 27C01463 00500E13 00100093 FFF00113 00209663
@0000001C 25C01A63 01C01663 FE209EE3 25C01463 00600E13 00000093 00000113
@00000023 00209463 01C01463 23C01863 FE209EE3 00700E13 00100093 00100113
@0000002A 00209463 01C01463 21C01A63 FE209EE3 00800E13 FFF00093 FFF00113
@00000031 00209463 01C01463 1FC01C63 FE209EE3 00900E13 00000213 00000093
@00000038 00000113 1E209063 00120213 00200293 FE5216E3 00A00E13 00000213
@0000003F 00000093 00000113 00000013 1A209E63 00120213 00200293 FE5214E3
@00000046 00B00E13 00000213 00000093 00000113 00000013 00000013 18209A63
@0000004D 00120213 00200293 FE5212E3 00C00E13 00000213 00000093 00000013
@00000054 00000113 16209863 00120213 00200293 FE5214E3 00D00E13 00000213
@0000005B 00000093 00000013 00000113 00000013 14209463 00120213 00200293
@00000062 FE5212E3 00E00E13 00000213 00000093 00000013 00000013 00000113
@00000069 12209063 00120213 00200293 FE5212E3 00F00E13 00000213 00000093
@00000070 00000113 10209063 00120213 00200293 FE5216E3 01000E13 00000213
@00000077 00000093 00000113 00000013 0C209E63 00120213 00200293 FE5214E3
@0000007E 01100E13 00000213 00000093 00000113 00000013 00000013 0A209A63
@00000085 00120213 00200293 FE5212E3 01200E13 00000213 00000093 00000013
@0000008C 00000113 08209863 00120213 00200293 FE5214E3 01300E13 00000213
@00000093 00000093 00000013 00000113 00000013 06209463 00120213 00200293
@0000009A FE5212E3 01400E13 00000213 00000093 00000013 00000013 00000113
@000000A1 04209063 00120213 00200293 FE5212E3 00100093 00009A63 00108093
@000000A8 00108093 00108093 00108093 00108093 00108093 00300E93 01500E13
@000000AF 01D09463 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513
@000000B6 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# jal.S
#-----------------------------------------------------------------------------
#
# Test jal instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Test 2: Basic test
  #-------------------------------------------------------------

test_2:
  li  TESTNUM, 2
  li  ra, 0

  jal x4, target_2
linkaddr_2:
  nop
  nop

  j fail

target_2:
  la  x2, linkaddr_2
  bne x2, x4, fail

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 3, ra, 3, \
    li  ra, 1; \
    jal x0, 1f; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
1:  addi ra, ra, 1; \
    addi ra, ra, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000093 0100026F 00000013 00000013 0400006F 00000117
@00000007 FF410113 02411A63 00100093 0140006F 00108093 00108093 00108093
@0000000E 00108093 00108093 00108093 00300E93 00300E13 01D09463 01C01A63
@00000015 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@0000001C FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# jalr.S
#-----------------------------------------------------------------------------
#
# Test jalr instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Test 2: Basic test
  #-------------------------------------------------------------

test_2:
  li  TESTNUM, 2
  li  t0, 0
  la  t1, target_2

  jalr t0, t1, 0
linkaddr_2:
  j fail

target_2:
  la  t1, linkaddr_2
  bne t0, t1, fail

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_JALR_SRC1_BYPASS( 4, 0, jalr );
  TEST_JALR_SRC1_BYPASS( 5, 1, jalr );
  TEST_JALR_SRC1_BYPASS( 6, 2, jalr );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  .option push
  .align 2
  .option norvc
  TEST_CASE( 7, t0, 4, \
    li  t0, 1; \
    la  t1, 1f; \
    jr  t1, -4; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
1:  addi t0, t0, 1; \
    addi t0, t0, 1; \
  )
  .option pop

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00200E13 00000293 00000317 01030313 000302E7 0C00006F 00000317
@00000007 FFC30313 0A629A63 00400E13 00000213 00000317 01030313 000309E7
@0000000E 09C01E63 00120213 00200293 FE5214E3 00500E13 00000213 00000317
@00000015 01430313 00000013 000309E7 07C01A63 00120213 00200293 FE5212E3
@0000001C 00600E13 00000213 00000317 01830313 00000013 00000013 000309E7
@00000023 05C01463 00120213 00200293 FE5210E3 00100293 00000317 01C30313
@0000002A FFC30067 00128293 00128293 00128293 00128293 00128293 00128293
@00000031 00400E93 00700E13 01D29463 01C01A63 FF000513 00000593 00B52023
@00000038 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# lb.S
#-----------------------------------------------------------------------------
#
# Test lb instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lb, 0xffffffffffffffff, 0,  tdat );
  TEST_LD_OP( 3, lb, 0x0000000000000000, 1,  tdat );
  TEST_LD_OP( 4, lb, 0xfffffffffffffff0, 2,  tdat );
  TEST_LD_OP( 5, lb, 0x000000000000000f, 3, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lb, 0xffffffffffffffff, -3, tdat4 );
  TEST_LD_OP( 7, lb, 0x0000000000000000, -2,  tdat4 );
  TEST_LD_OP( 8, lb, 0xfffffffffffffff0, -1,  tdat4 );
  TEST_LD_OP( 9, lb, 0x000000000000000f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0xffffffffffffffff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lb x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x0000000000000000, \
    la  x1, tdat; \
    addi x1, x1, -6; \
    lb x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lb, 0xfffffffffffffff0, 1, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lb, 0x000000000000000f, 1, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lb, 0x0000000000000000, 1, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lb, 0xfffffffffffffff0, 1, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lb, 0x000000000000000f, 1, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lb, 0x0000000000000000, 1, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lb  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lb  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xff
tdat2:  .byte 0x00
tdat3:  .byte 0xf0
tdat4:  .byte 0x0f

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 00008183 FFF00E93 00200E13 23D19C63 7FC00097
@00000007 FE808093 00108183 00000E93 00300E13 23D19063 7FC00097 FD008093
@0000000E 00208183 FF000E93 00400E13 21D19463 7FC00097 FB808093 00308183
@00000015 00F00E93 00500E13 1FD19863 7FC00097 FA308093 FFD08183 FFF00E93
@0000001C 00600E13 1DD19C63 7FC00097 F8B08093 FFE08183 00000E93 00700E13
@00000023 1DD19063 7FC00097 F7308093 FFF08183 FF000E93 00800E13 1BD19463
@0000002A 7FC00097 F5B08093 00008183 00F00E93 00900E13 19D19863 7FC00097
@00000031 F4008093 FE008093 02008283 FFF00E93 00A00E13 17D29A63 7FC00097
@00000038 F2408093 FFA08093 00708283 00000E93 00B00E13 15D29C63 00C00E13
@0000003F 00000213 7FC00097 F0108093 00108183 00018313 FF000E93 13D31C63
@00000046 00120213 00200293 FE5210E3 00D00E13 00000213 7FC00097 ED608093
@0000004D 00108183 00000013 00018313 00F00E93 11D31463 00120213 00200293
@00000054 FC521EE3 00E00E13 00000213 7FC00097 EA408093 00108183 00000013
@0000005B 00000013 00018313 00000E93 0DD31A63 00120213 00200293 FC521CE3
@00000062 00F00E13 00000213 7FC00097 E7108093 00108183 FF000E93 0BD19663
@00000069 00120213 00200293 FE5212E3 01000E13 00000213 7FC00097 E4A08093
@00000070 00000013 00108183 00F00E93 09D19063 00120213 00200293 FE5210E3
@00000077 01100E13 00000213 7FC00097 E1C08093 00000013 00000013 00108183
@0000007E 00000E93 05D19863 00120213 00200293 FC521EE3 7FC00297 DF428293
@00000085 00028103 00200113 00200E93 01200E13 03D11463 7FC00297 DD828293
@0000008C 00028103 00000013 00200113 00200E93 01300E13 01D11463 01C01A63
@00000093 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@0000009A FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 0FF000FF 00000000
# See LICENSE for license details.

#*****************************************************************************
# lbu.S
#-----------------------------------------------------------------------------
#
# Test lbu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lbu, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lbu, 0x0000000000000000, 1,  tdat );
  TEST_LD_OP( 4, lbu, 0x00000000000000f0, 2,  tdat );
  TEST_LD_OP( 5, lbu, 0x000000000000000f, 3, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lbu, 0x00000000000000ff, -3, tdat4 );
  TEST_LD_OP( 7, lbu, 0x0000000000000000, -2,  tdat4 );
  TEST_LD_OP( 8, lbu, 0x00000000000000f0, -1,  tdat4 );
  TEST_LD_OP( 9, lbu, 0x000000000000000f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lbu x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x0000000000000000, \
    la  x1, tdat; \
    addi x1, x1, -6; \
    lbu x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lbu, 0x00000000000000f0, 1, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lbu, 0x000000000000000f, 1, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lbu, 0x0000000000000000, 1, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lbu, 0x00000000000000f0, 1, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lbu, 0x000000000000000f, 1, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lbu, 0x0000000000000000, 1, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lbu  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lbu  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xff
tdat2:  .byte 0x00
tdat3:  .byte 0xf0
tdat4:  .byte 0x0f

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 0000C183 0FF00E93 00200E13 23D19C63 7FC00097
@00000007 FE808093 0010C183 00000E93 00300E13 23D19063 7FC00097 FD008093
@0000000E 0020C183 0F000E93 00400E13 21D19463 7FC00097 FB808093 0030C183
@00000015 00F00E93 00500E13 1FD19863 7FC00097 FA308093 FFD0C183 0FF00E93
@0000001C 00600E13 1DD19C63 7FC00097 F8B08093 FFE0C183 00000E93 00700E13
@00000023 1DD19063 7FC00097 F7308093 FFF0C183 0F000E93 00800E13 1BD19463
@0000002A 7FC00097 F5B08093 0000C183 00F00E93 00900E13 19D19863 7FC00097
@00000031 F4008093 FE008093 0200C283 0FF00E93 00A00E13 17D29A63 7FC00097
@00000038 F2408093 FFA08093 0070C283 00000E93 00B00E13 15D29C63 00C00E13
@0000003F 00000213 7FC00097 F0108093 0010C183 00018313 0F000E93 13D31C63
@00000046 00120213 00200293 FE5210E3 00D00E13 00000213 7FC00097 ED608093
@0000004D 0010C183 00000013 00018313 00F00E93 11D31463 00120213 00200293
@00000054 FC521EE3 00E00E13 00000213 7FC00097 EA408093 0010C183 00000013
@0000005B 00000013 00018313 00000E93 0DD31A63 00120213 00200293 FC521CE3
@00000062 00F00E13 00000213 7FC00097 E7108093 0010C183 0F000E93 0BD19663
@00000069 00120213 00200293 FE5212E3 01000E13 00000213 7FC00097 E4A08093
@00000070 00000013 0010C183 00F00E93 09D19063 00120213 00200293 FE5210E3
@00000077 01100E13 00000213 7FC00097 E1C08093 00000013 00000013 0010C183
@0000007E 00000E93 05D19863 00120213 00200293 FC521EE3 7FC00297 DF428293
@00000085 0002C103 00200113 00200E93 01200E13 03D11463 7FC00297 DD828293
@0000008C 0002C103 00000013 00200113 00200E93 01300E13 01D11463 01C01A63
@00000093 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@0000009A FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 0FF000FF 00000000
# See LICENSE for license details.

#*****************************************************************************
# lh.S
#-----------------------------------------------------------------------------
#
# Test lh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lh, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lh, 0xffffffffffffff00, 2,  tdat );
  TEST_LD_OP( 4, lh, 0x0000000000000ff0, 4,  tdat );
  TEST_LD_OP( 5, lh, 0xfffffffffffff00f, 6, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lh, 0x00000000000000ff, -6,  tdat4 );
  TEST_LD_OP( 7, lh, 0xffffffffffffff00, -4,  tdat4 );
  TEST_LD_OP( 8, lh, 0x0000000000000ff0, -2,  tdat4 );
  TEST_LD_OP( 9, lh, 0xfffffffffffff00f,  0, tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lh x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffffffff00, \
    la  x1, tdat; \
    addi x1, x1, -5; \
    lh x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lh, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lh, 0xfffffffffffff00f, 2, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lh, 0xffffffffffffff00, 2, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lh, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lh, 0xfffffffffffff00f, 2, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lh, 0xffffffffffffff00, 2, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lh  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lh  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0x00ff
tdat2:  .half 0xff00
tdat3:  .half 0x0ff0
tdat4:  .half 0xf00f

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 00009183 0FF00E93 00200E13 25D19C63 7FC00097
@00000007 FE808093 00209183 F0000E93 00300E13 25D19063 7FC00097 FD008093
@0000000E 00409183 00001EB7 FF0E8E93 00400E13 23D19263 7FC00097 FB408093
@00000015 00609183 FFFFFEB7 00FE8E93 00500E13 21D19463 7FC00097 F9E08093
@0000001C FFA09183 0FF00E93 00600E13 1FD19863 7FC00097 F8608093 FFC09183
@00000023 F0000E93 00700E13 1DD19C63 7FC00097 F6E08093 FFE09183 00001EB7
@0000002A FF0E8E93 00800E13 1BD19E63 7FC00097 F5208093 00009183 FFFFFEB7
@00000031 00FE8E93 00900E13 1BD19063 7FC00097 F3008093 FE008093 02009283
@00000038 0FF00E93 00A00E13 19D29263 7FC00097 F1408093 FFB08093 00709283
@0000003F F0000E93 00B00E13 17D29463 00C00E13 00000213 7FC00097 EF208093
@00000046 00209183 00018313 00001EB7 FF0E8E93 15D31263 00120213 00200293
@0000004D FC521EE3 00D00E13 00000213 7FC00097 EC408093 00209183 00000013
@00000054 00018313 FFFFFEB7 00FE8E93 11D31863 00120213 00200293 FC521CE3
@0000005B 00E00E13 00000213 7FC00097 E8C08093 00209183 00000013 00000013
@00000062 00018313 F0000E93 0DD31E63 00120213 00200293 FC521CE3 00F00E13
@00000069 00000213 7FC00097 E5A08093 00209183 00001EB7 FF0E8E93 0BD19863
@00000070 00120213 00200293 FE5210E3 01000E13 00000213 7FC00097 E3008093
@00000077 00000013 00209183 FFFFFEB7 00FE8E93 09D19063 00120213 00200293
@0000007E FC521EE3 01100E13 00000213 7FC00097 DFC08093 00000013 00000013
@00000085 00209183 F0000E93 05D19863 00120213 00200293 FC521EE3 7FC00297
@0000008C DD428293 00029103 00200113 00200E93 01200E13 03D11463 7FC00297
@00000093 DB828293 00029103 00000013 00200113 00200E93 01300E13 01D11463
@0000009A 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@000000A1 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 FF0000FF F00F0FF0
# See LICENSE for license details.

#*****************************************************************************
# lhu.S
#-----------------------------------------------------------------------------
#
# Test lhu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lhu, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lhu, 0x000000000000ff00, 2,  tdat );
  TEST_LD_OP( 4, lhu, 0x0000000000000ff0, 4,  tdat );
  TEST_LD_OP( 5, lhu, 0x000000000000f00f, 6, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lhu, 0x00000000000000ff, -6,  tdat4 );
  TEST_LD_OP( 7, lhu, 0x000000000000ff00, -4,  tdat4 );
  TEST_LD_OP( 8, lhu, 0x0000000000000ff0, -2,  tdat4 );
  TEST_LD_OP( 9, lhu, 0x000000000000f00f,  0, tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lhu x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x000000000000ff00, \
    la  x1, tdat; \
    addi x1, x1, -5; \
    lhu x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lhu, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lhu, 0x000000000000f00f, 2, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lhu, 0x000000000000ff00, 2, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lhu, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lhu, 0x000000000000f00f, 2, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lhu, 0x000000000000ff00, 2, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lhu  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lhu  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0x00ff
tdat2:  .half 0xff00
tdat3:  .half 0x0ff0
tdat4:  .half 0xf00f

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 0000D183 0FF00E93 00200E13 27D19663 7FC00097
@00000007 FE808093 0020D183 00010EB7 F00E8E93 00300E13 25D19863 7FC00097
@0000000E FCC08093 0040D183 00001EB7 FF0E8E93 00400E13 23D19A63 7FC00097
@00000015 FB008093 0060D183 0000FEB7 00FE8E93 00500E13 21D19C63 7FC00097
@0000001C F9A08093 FFA0D183 0FF00E93 00600E13 21D19063 7FC00097 F8208093
@00000023 FFC0D183 00010EB7 F00E8E93 00700E13 1FD19263 7FC00097 F6608093
@0000002A FFE0D183 00001EB7 FF0E8E93 00800E13 1DD19463 7FC00097 F4A08093
@00000031 0000D183 0000FEB7 00FE8E93 00900E13 1BD19663 7FC00097 F2808093
@00000038 FE008093 0200D283 0FF00E93 00A00E13 19D29863 7FC00097 F0C08093
@0000003F FFB08093 0070D283 00010EB7 F00E8E93 00B00E13 17D29863 00C00E13
@00000046 00000213 7FC00097 EE608093 0020D183 00018313 00001EB7 FF0E8E93
@0000004D 15D31663 00120213 00200293 FC521EE3 00D00E13 00000213 7FC00097
@00000054 EB808093 0020D183 00000013 00018313 0000FEB7 00FE8E93 11D31C63
@0000005B 00120213 00200293 FC521CE3 00E00E13 00000213 7FC00097 E8008093
@00000062 0020D183 00000013 00000013 00018313 00010EB7 F00E8E93 0FD31063
@00000069 00120213 00200293 FC521AE3 00F00E13 00000213 7FC00097 E4A08093
@00000070 0020D183 00001EB7 FF0E8E93 0BD19A63 00120213 00200293 FE5210E3
@00000077 01000E13 00000213 7FC00097 E2008093 00000013 0020D183 0000FEB7
@0000007E 00FE8E93 09D19263 00120213 00200293 FC521EE3 01100E13 00000213
@00000085 7FC00097 DEC08093 00000013 00000013 0020D183 00010EB7 F00E8E93
@0000008C 05D19863 00120213 00200293 FC521CE3 7FC00297 DC028293 0002D103
@00000093 00200113 00200E93 01200E13 03D11463 7FC00297 DA428293 0002D103
@0000009A 00000013 00200113 00200E93 01300E13 01D11463 01C01A63 FF000513
@000000A1 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 FF0000FF F00F0FF0
OUTPUT_ARCH("riscv")

ENTRY(test)

MEMORY
{
  flash (rxai!w) : ORIGIN = 0x00400000, LENGTH = 64K
  ram (wxa!ri) : ORIGIN = 0x80000000, LENGTH = 128K
}

PHDRS
{
  flash PT_LOAD;
  ram_init PT_LOAD;
  ram PT_NULL;
}

SECTIONS
{
  __stack_size = DEFINED(__stack_size) ? __stack_size : 2K;

  .init           :
  {
    KEEP (*(SORT_NONE(.init)))
  } >flash AT>flash :flash

    .text           :
  {
    *(.text .text.*)
  } >flash AT>flash :flash

  .fini           :
  {
    KEEP (*(SORT_NONE(.fini)))
  } >flash AT>flash :flash

  .rodata         :
  {
    *(.rdata)
    *(.rodata .rodata.*)
  } >ram AT>ram :ram

  . = ALIGN(4);

  .data          :
  {
    *(.data .data.*)
    . = ALIGN(8);
    PROVIDE( __global_pointer$ = . + 0x800 );
    *(.sdata .sdata.*)
    *(.gnu.linkonce.s.*)
    . = ALIGN(8);
    *(.srodata.cst16)
    *(.srodata.cst8)
    *(.srodata.cst4)
    *(.srodata.cst2)
    *(.srodata .srodata.*)
  } >ram AT>ram :ram_init

  . = ALIGN(4);
  PROVIDE( _edata = . );
  PROVIDE( edata = . );

  PROVIDE( _fbss = . );
  PROVIDE( __bss_start = . );
  .bss            :
  {
    *(.bss .bss.*)
    *(COMMON)
    . = ALIGN(4);
  } >ram AT>ram :ram

  . = ALIGN(8);
  PROVIDE( _end = . );
  PROVIDE( end = . );

  .stack ORIGIN(ram) + LENGTH(ram) - __stack_size :
  {
    PROVIDE( _heap_end = . );
    . = __stack_size;
    PROVIDE( _sp = . );
  } >ram AT>ram :ram
}
# See LICENSE for license details.

#*****************************************************************************
# lui.S
#-----------------------------------------------------------------------------
#
# Test lui instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_CASE( 2, x1, 0x0000000000000000, lui x1, 0x00000 );
  TEST_CASE( 3, x1, 0xfffffffffffff800, lui x1, 0xfffff;sra x1,x1,1);
  TEST_CASE( 4, x1, 0x00000000000007ff, lui x1, 0x7ffff;sra x1,x1,20);
  TEST_CASE( 5, x1, 0xfffffffffffff800, lui x1, 0x80000;sra x1,x1,20);

  TEST_CASE( 6, x0, 0, lui x0, 0x80000 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 000000B7 00000E93 00200E13 05D09A63 FFFFF0B7 4010D093 80000E93
@00000007 00300E13 05D09063 7FFFF0B7 4140D093 7FF00E93 00400E13 03D09663
@0000000E 800000B7 4140D093 80000E93 00500E13 01D09C63 80000037 00000E93
@00000015 00600E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@0000001C FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# lw.S
#-----------------------------------------------------------------------------
#
# Test lw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lw, 0x0000000000ff00ff, 0,  tdat );
  TEST_LD_OP( 3, lw, 0xffffffffff00ff00, 4,  tdat );
  TEST_LD_OP( 4, lw, 0x000000000ff00ff0, 8,  tdat );
  TEST_LD_OP( 5, lw, 0xfffffffff00ff00f, 12, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lw, 0x0000000000ff00ff, -12, tdat4 );
  TEST_LD_OP( 7, lw, 0xffffffffff00ff00, -8,  tdat4 );
  TEST_LD_OP( 8, lw, 0x000000000ff00ff0, -4,  tdat4 );
  TEST_LD_OP( 9, lw, 0xfffffffff00ff00f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x0000000000ff00ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lw x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffff00ff00, \
    la  x1, tdat; \
    addi x1, x1, -3; \
    lw x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lw, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lw, 0xfffffffff00ff00f, 4, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lw, 0xffffffffff00ff00, 4, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lw, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lw, 0xfffffffff00ff00f, 4, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lw, 0xffffffffff00ff00, 4, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lw  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lw  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0x00ff00ff
tdat2:  .word 0xff00ff00
tdat3:  .word 0x0ff00ff0
tdat4:  .word 0xf00ff00f

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 0000A183 00FF0EB7 0FFE8E93 00200E13 27D19A63
@00000007 7FC00097 FE408093 0040A183 FF010EB7 F00E8E93 00300E13 25D19C63
@0000000E 7FC00097 FC808093 0080A183 0FF01EB7 FF0E8E93 00400E13 23D19E63
@00000015 7FC00097 FAC08093 00C0A183 F00FFEB7 00FE8E93 00500E13 23D19063
@0000001C 7FC00097 F9C08093 FF40A183 00FF0EB7 0FFE8E93 00600E13 21D19263
@00000023 7FC00097 F8008093 FF80A183 FF010EB7 F00E8E93 00700E13 1FD19463
@0000002A 7FC00097 F6408093 FFC0A183 0FF01EB7 FF0E8E93 00800E13 1DD19663
@00000031 7FC00097 F4808093 0000A183 F00FFEB7 00FE8E93 00900E13 1BD19863
@00000038 7FC00097 F2008093 FE008093 0200A283 00FF0EB7 0FFE8E93 00A00E13
@0000003F 19D29863 7FC00097 F0008093 FFD08093 0070A283 FF010EB7 F00E8E93
@00000046 00B00E13 17D29863 00C00E13 00000213 7FC00097 EDC08093 0040A183
@0000004D 00018313 0FF01EB7 FF0E8E93 15D31663 00120213 00200293 FC521EE3
@00000054 00D00E13 00000213 7FC00097 EB008093 0040A183 00000013 00018313
@0000005B F00FFEB7 00FE8E93 11D31C63 00120213 00200293 FC521CE3 00E00E13
@00000062 00000213 7FC00097 E7408093 0040A183 00000013 00000013 00018313
@00000069 FF010EB7 F00E8E93 0FD31063 00120213 00200293 FC521AE3 00F00E13
@00000070 00000213 7FC00097 E4008093 0040A183 0FF01EB7 FF0E8E93 0BD19A63
@00000077 00120213 00200293 FE5210E3 01000E13 00000213 7FC00097 E1808093
@0000007E 00000013 0040A183 F00FFEB7 00FE8E93 09D19263 00120213 00200293
@00000085 FC521EE3 01100E13 00000213 7FC00097 DE008093 00000013 00000013
@0000008C 0040A183 FF010EB7 F00E8E93 05D19863 00120213 00200293 FC521CE3
@00000093 7FC00297 DB428293 0002A103 00200113 00200E93 01200E13 03D11463
@0000009A 7FC00297 D9828293 0002A103 00000013 00200113 00200E93 01300E13
@000000A1 01D11463 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513
@000000A8 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 00FF00FF FF00FF00 0FF00FF0 F00FF00F
SRCS=$(wildcard *.S)
OBJS=$(SRCS:.S=.o)
ELFS=$(SRCS:.S=.elf)
BINS=$(SRCS:.S=.code.vh) $(SRCS:.S=.data.vh)

all: ${BINS}

%.o: %.S test_macros.h riscv_test.h
	riscv64-unknown-elf-gcc -c -mabi=ilp32 -march=rv32i -o $@ $<

%.elf: %.o
	riscv64-unknown-elf-ld -Tlink.ld -melf32lriscv $< -o $@

%.code.bin: %.elf
	riscv64-unknown-elf-objcopy -O binary $< $@ -j .init -j .text --change-addresses -0x400000

%.data.bin: %.elf
	riscv64-unknown-elf-objcopy -O binary $< $@ -j .data

%.vh: %.bin
	srec_cat $< -binary -byte-swap 4 -O $@ -VMem 32

clean:
	rm -f ${OBJS} ${ELFS} ${BINS}
# See LICENSE for license details.

#*****************************************************************************
# or.S
#-----------------------------------------------------------------------------
#
# Test or instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, or, 0xf0fff0ff, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, or, 0xff00ff00, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, or, 0xff00ff00, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, or, 0x00ff00ff, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, or, 0 );
  TEST_RR_ZERODEST( 27, or, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF0100B7 F0008093 0F0F1137 F0F10113 0020E1B3 FF100EB7 F0FE8E93
@00000007 00200E13 4BD19263 0FF010B7 FF008093 F0F0F137 0F010113 0020E1B3
@0000000E FFF10EB7 FF0E8E93 00300E13 49D19063 00FF00B7 0FF08093 0F0F1137
@00000015 F0F10113 0020E1B3 0FFF1EB7 FFFE8E93 00400E13 45D19E63 F00FF0B7
@0000001C 00F08093 F0F0F137 0F010113 0020E1B3 F0FFFEB7 0FFE8E93 00500E13
@00000023 43D19C63 FF0100B7 F0008093 0F0F1137 F0F10113 0020E0B3 FF100EB7
@0000002A F0FE8E93 00600E13 41D09A63 FF0100B7 F0008093 0F0F1137 F0F10113
@00000031 0020E133 FF100EB7 F0FE8E93 00700E13 3FD11863 FF0100B7 F0008093
@00000038 0010E0B3 FF010EB7 F00E8E93 00800E13 3DD09A63 00000213 FF0100B7
@0000003F F0008093 0F0F1137 F0F10113 0020E1B3 00018313 00120213 00200293
@00000046 FE5210E3 FF100EB7 F0FE8E93 00900E13 39D31E63 00000213 0FF010B7
@0000004D FF008093 F0F0F137 0F010113 0020E1B3 00000013 00018313 00120213
@00000054 00200293 FC521EE3 FFF10EB7 FF0E8E93 00A00E13 37D31063 00000213
@0000005B 00FF00B7 0FF08093 0F0F1137 F0F10113 0020E1B3 00000013 00000013
@00000062 00018313 00120213 00200293 FC521CE3 0FFF1EB7 FFFE8E93 00B00E13
@00000069 33D31063 00000213 FF0100B7 F0008093 0F0F1137 F0F10113 0020E1B3
@00000070 00120213 00200293 FE5212E3 FF100EB7 F0FE8E93 00C00E13 2FD19663
@00000077 00000213 0FF010B7 FF008093 F0F0F137 0F010113 00000013 0020E1B3
@0000007E 00120213 00200293 FE5210E3 FFF10EB7 FF0E8E93 00D00E13 2BD19A63
@00000085 00000213 00FF00B7 0FF08093 0F0F1137 F0F10113 00000013 00000013
@0000008C 0020E1B3 00120213 00200293 FC521EE3 0FFF1EB7 FFFE8E93 00E00E13
@00000093 27D19C63 00000213 FF0100B7 F0008093 00000013 0F0F1137 F0F10113
@0000009A 0020E1B3 00120213 00200293 FE5210E3 FF100EB7 F0FE8E93 00F00E13
@000000A1 25D19063 00000213 0FF010B7 FF008093 00000013 F0F0F137 0F010113
@000000A8 00000013 0020E1B3 00120213 00200293 FC521EE3 FFF10EB7 FF0E8E93
@000000AF 01000E13 21D19263 00000213 00FF00B7 0FF08093 00000013 00000013
@000000B6 0F0F1137 F0F10113 0020E1B3 00120213 00200293 FC521EE3 0FFF1EB7
@000000BD FFFE8E93 01100E13 1DD19463 00000213 0F0F1137 F0F10113 FF0100B7
@000000C4 F0008093 0020E1B3 00120213 00200293 FE5212E3 FF100EB7 F0FE8E93
@000000CB 01200E13 19D19A63 00000213 F0F0F137 0F010113 0FF010B7 FF008093
@000000D2 00000013 0020E1B3 00120213 00200293 FE5210E3 FFF10EB7 FF0E8E93
@000000D9 01300E13 15D19E63 00000213 0F0F1137 F0F10113 00FF00B7 0FF08093
@000000E0 00000013 00000013 0020E1B3 00120213 00200293 FC521EE3 0FFF1EB7
@000000E7 FFFE8E93 01400E13 13D19063 00000213 0F0F1137 F0F10113 00000013
@000000EE FF0100B7 F0008093 0020E1B3 00120213 00200293 FE5210E3 FF100EB7
@000000F5 F0FE8E93 01500E13 0FD19463 00000213 F0F0F137 0F010113 00000013
@000000FC 0FF010B7 FF008093 00000013 0020E1B3 00120213 00200293 FC521EE3
@00000103 FFF10EB7 FF0E8E93 01600E13 0BD19663 00000213 0F0F1137 F0F10113
@0000010A 00000013 00000013 00FF00B7 0FF08093 0020E1B3 00120213 00200293
@00000111 FC521EE3 0FFF1EB7 FFFE8E93 01700E13 07D19863 FF0100B7 F0008093
@00000118 00106133 FF010EB7 F00E8E93 01800E13 05D11A63 00FF00B7 0FF08093
@0000011F 0000E133 00FF0EB7 0FFE8E93 01900E13 03D11C63 000060B3 00000E93
@00000126 01A00E13 03D09463 111110B7 11108093 22222137 22210113 0020E033
@0000012D 00000E93 01B00E13 01D01463 01C01A63 FF000513 00000593 00B52023
@00000134 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# ori.S
#-----------------------------------------------------------------------------
#
# Test ori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, ori, 0xffffffffffffff0f, 0xffffffffff00ff00, 0xf0f );
  TEST_IMM_OP( 3, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, ori, 0x0000000000ff07ff, 0x0000000000ff00ff, 0x70f );
  TEST_IMM_OP( 5, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, ori, 0xff00fff0, 0xff00ff00, 0x0f0 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 8,  1, ori, 0x0000000000ff07ff, 0x0000000000ff00ff, 0x70f );
  TEST_IMM_DEST_BYPASS( 9,  2, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_SRC1_BYPASS( 10, 0, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 11, 1, ori, 0xffffffffffffffff, 0x0000000000ff00ff, 0xf0f );
  TEST_IMM_SRC1_BYPASS( 12, 2, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_ZEROSRC1( 13, ori, 0x0f0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, ori, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF0100B7 F0008093 F0F0E193 F0F00E93 00200E13 1DD19463 0FF010B7
@00000007 FF008093 0F00E193 0FF01EB7 FF0E8E93 00300E13 1BD19663 00FF00B7
@0000000E 0FF08093 70F0E193 00FF0EB7 7FFE8E93 00400E13 19D19863 F00FF0B7
@00000015 00F08093 0F00E193 F00FFEB7 0FFE8E93 00500E13 17D19A63 FF0100B7
@0000001C F0008093 0F00E093 FF010EB7 FF0E8E93 00600E13 15D09C63 00000213
@00000023 0FF010B7 FF008093 0F00E193 00018313 00120213 00200293 FE5214E3
@0000002A 0FF01EB7 FF0E8E93 00700E13 13D31463 00000213 00FF00B7 0FF08093
@00000031 70F0E193 00000013 00018313 00120213 00200293 FE5212E3 00FF0EB7
@00000038 7FFE8E93 00800E13 0FD31A63 00000213 F00FF0B7 00F08093 0F00E193
@0000003F 00000013 00000013 00018313 00120213 00200293 FE5210E3 F00FFEB7
@00000046 0FFE8E93 00900E13 0BD31E63 00000213 0FF010B7 FF008093 0F00E193
@0000004D 00120213 00200293 FE5216E3 0FF01EB7 FF0E8E93 00A00E13 09D19863
@00000054 00000213 00FF00B7 0FF08093 00000013 F0F0E193 00120213 00200293
@0000005B FE5214E3 FFF00E93 00B00E13 07D19263 00000213 F00FF0B7 00F08093
@00000062 00000013 00000013 0F00E193 00120213 00200293 FE5212E3 F00FFEB7
@00000069 0FFE8E93 00C00E13 03D19863 0F006093 0F000E93 00D00E13 03D09063
@00000070 00FF00B7 0FF08093 70F0E013 00000E93 00E00E13 01D01463 01C01A63
@00000077 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@0000007E FF5FF06F
/* http://srecord.sourceforge.net/ */
#ifndef _ENV_PICORV32_TEST_H
#define _ENV_PICORV32_TEST_H

#define RVTEST_RV32U
#define RVTEST_RV64U RVTEST_RV32U
#define TESTNUM x28
#define DEBUG_REG 0xfffffff0

#define RVTEST_CODE_BEGIN		\
	.text;				\
	.global test;			\
test:

#define RVTEST_PASS			\
.pass:					\
	li	a0,DEBUG_REG;		\
	li	a1,0x1;			\
	sw	a1,0(a0);		\
	j .pass;

#define RVTEST_FAIL			\
.fail:					\
	li	a0,DEBUG_REG;		\
	li	a1,0x0;			\
	sw	a1,0(a0);		\
	j .fail;

#define RVTEST_CODE_END
#define RVTEST_DATA_BEGIN .balign 4;
#define RVTEST_DATA_END

#endif
# See LICENSE for license details.

#*****************************************************************************
# sb.S
#-----------------------------------------------------------------------------
#
# Test sb instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lb, sb, 0xffffffffffffffaa, 0, tdat );
  TEST_ST_OP( 3, lb, sb, 0x0000000000000000, 1, tdat );
  TEST_ST_OP( 4, lh, sb, 0xffffffffffffefa0, 2, tdat );
  TEST_ST_OP( 5, lb, sb, 0x000000000000000a, 3, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lb, sb, 0xffffffffffffffaa, -3, tdat8 );
  TEST_ST_OP( 7, lb, sb, 0x0000000000000000, -2, tdat8 );
  TEST_ST_OP( 8, lb, sb, 0xffffffffffffffa0, -1, tdat8 );
  TEST_ST_OP( 9, lb, sb, 0x000000000000000a, 0,  tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x78, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sb x2, 32(x4); \
    lb x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffffffff98, \
    la  x1, tdat9; \
    li  x2, 0x00003098; \
    addi x1, x1, -6; \
    sb x2, 7(x1); \
    la  x4, tdat10; \
    lb x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lb, sb, 0xffffffffffffffdd, 0, tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lb, sb, 0xffffffffffffffcd, 1, tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lb, sb, 0xffffffffffffffcc, 2, tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lb, sb, 0xffffffffffffffbc, 3, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lb, sb, 0xffffffffffffffbb, 4, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lb, sb, 0xffffffffffffffab, 5, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lb, sb, 0x33, 0, tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lb, sb, 0x23, 1, tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lb, sb, 0x22, 2, tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lb, sb, 0x12, 3, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lb, sb, 0x11, 4, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lb, sb, 0x01, 5, tdat );

  li a0, 0xef
  la a1, tdat
  sb a0, 3(a1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xef
tdat2:  .byte 0xef
tdat3:  .byte 0xef
tdat4:  .byte 0xef
tdat5:  .byte 0xef
tdat6:  .byte 0xef
tdat7:  .byte 0xef
tdat8:  .byte 0xef
tdat9:  .byte 0xef
tdat10: .byte 0xef

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 FAA00113 00208023 00008183 FAA00E93 00200E13
@00000007 3DD19C63 7FC00097 FE008093 00000113 002080A3 00108183 00000E93
@0000000E 00300E13 3BD19C63 7FC00097 FC008093 FFFFF137 FA010113 00208123
@00000015 00209183 FFFFFEB7 FA0E8E93 00400E13 39D19863 7FC00097 F9808093
@0000001C 00A00113 002081A3 00308183 00A00E93 00500E13 37D19863 7FC00097
@00000023 F7F08093 FAA00113 FE208EA3 FFD08183 FAA00E93 00600E13 35D19863
@0000002A 7FC00097 F5F08093 00000113 FE208F23 FFE08183 00000E93 00700E13
@00000031 33D19863 7FC00097 F3F08093 FA000113 FE208FA3 FFF08183 FA000E93
@00000038 00800E13 31D19863 7FC00097 F1F08093 00A00113 00208023 00008183
@0000003F 00A00E93 00900E13 2FD19863 7FC00097 F0008093 12345137 67810113
@00000046 FE008213 02220023 00008283 07800E93 00A00E13 2DD29463 7FC00097
@0000004D ED808093 00003137 09810113 FFA08093 002083A3 7FC00217 EC120213
@00000054 00020283 F9800E93 00B00E13 29D29C63 00C00E13 00000213 FDD00093
@0000005B 7FC00117 E9410113 00110023 00010183 FDD00E93 27D19A63 00120213
@00000062 00200293 FC521EE3 00D00E13 00000213 FCD00093 7FC00117 E6410113
@00000069 00000013 001100A3 00110183 FCD00E93 25D19063 00120213 00200293
@00000070 FC521CE3 00E00E13 00000213 FCC00093 7FC00117 E3010113 00000013
@00000077 00000013 00110123 00210183 FCC00E93 21D19463 00120213 00200293
@0000007E FC521AE3 00F00E13 00000213 FBC00093 00000013 7FC00117 DF410113
@00000085 001101A3 00310183 FBC00E93 1DD19A63 00120213 00200293 FC521CE3
@0000008C 01000E13 00000213 FBB00093 00000013 7FC00117 DC010113 00000013
@00000093 00110223 00410183 FBB00E93 19D19E63 00120213 00200293 FC521AE3
@0000009A 01100E13 00000213 FAB00093 00000013 00000013 7FC00117 D8410113
@000000A1 001102A3 00510183 FAB00E93 17D19263 00120213 00200293 FC521AE3
@000000A8 01200E13 00000213 7FC00117 D5810113 03300093 00110023 00010183
@000000AF 03300E93 13D19A63 00120213 00200293 FC521EE3 01300E13 00000213
@000000B6 7FC00117 D2810113 02300093 00000013 001100A3 00110183 02300E93
@000000BD 11D19063 00120213 00200293 FC521CE3 01400E13 00000213 7FC00117
@000000C4 CF410113 02200093 00000013 00000013 00110123 00210183 02200E93
@000000CB 0DD19463 00120213 00200293 FC521AE3 01500E13 00000213 7FC00117
@000000D2 CBC10113 00000013 01200093 001101A3 00310183 01200E93 09D19A63
@000000D9 00120213 00200293 FC521CE3 01600E13 00000213 7FC00117 C8810113
@000000E0 00000013 01100093 00000013 00110223 00410183 01100E93 05D19E63
@000000E7 00120213 00200293 FC521AE3 01700E13 00000213 7FC00117 C5010113
@000000EE 00000013 00000013 00100093 001102A3 00510183 00100E93 03D19263
@000000F5 00120213 00200293 FC521AE3 0EF00513 7FC00597 C1C58593 00A581A3
@000000FC 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593
@00000103 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 EFEFEFEF EFEFEFEF 0000EFEF 00000000
# See LICENSE for license details.

#*****************************************************************************
# sh.S
#-----------------------------------------------------------------------------
#
# Test sh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lh, sh, 0x00000000000000aa, 0, tdat );
  TEST_ST_OP( 3, lh, sh, 0xffffffffffffaa00, 2, tdat );
  TEST_ST_OP( 4, lw, sh, 0xffffffffbeef0aa0, 4, tdat );
  TEST_ST_OP( 5, lh, sh, 0xffffffffffffa00a, 6, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lh, sh, 0x00000000000000aa, -6, tdat8 );
  TEST_ST_OP( 7, lh, sh, 0xffffffffffffaa00, -4, tdat8 );
  TEST_ST_OP( 8, lh, sh, 0x0000000000000aa0, -2, tdat8 );
  TEST_ST_OP( 9, lh, sh, 0xffffffffffffa00a, 0,  tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x5678, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sh x2, 32(x4); \
    lh x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x3098, \
    la  x1, tdat9; \
    li  x2, 0x00003098; \
    addi x1, x1, -5; \
    sh x2, 7(x1); \
    la  x4, tdat10; \
    lh x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lh, sh, 0xffffffffffffccdd, 0,  tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lh, sh, 0xffffffffffffbccd, 2,  tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lh, sh, 0xffffffffffffbbcc, 4,  tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lh, sh, 0xffffffffffffabbc, 6, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lh, sh, 0xffffffffffffaabb, 8, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lh, sh, 0xffffffffffffdaab, 10, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lh, sh, 0x2233, 0,  tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lh, sh, 0x1223, 2,  tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lh, sh, 0x1122, 4,  tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lh, sh, 0x0112, 6, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lh, sh, 0x0011, 8, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lh, sh, 0x3001, 10, tdat );

  li a0, 0xbeef
  la a1, tdat
  sh a0, 6(a1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0xbeef
tdat2:  .half 0xbeef
tdat3:  .half 0xbeef
tdat4:  .half 0xbeef
tdat5:  .half 0xbeef
tdat6:  .half 0xbeef
tdat7:  .half 0xbeef
tdat8:  .half 0xbeef
tdat9:  .half 0xbeef
tdat10: .half 0xbeef

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 0AA00113 00209023 00009183 0AA00E93 00200E13
@00000007 45D19E63 7FC00097 FE008093 FFFFB137 A0010113 00209123 00209183
@0000000E FFFFBEB7 A00E8E93 00300E13 43D19A63 7FC00097 FB808093 BEEF1137
@00000015 AA010113 00209223 0040A183 BEEF1EB7 AA0E8E93 00400E13 41D19663
@0000001C 7FC00097 F9008093 FFFFA137 00A10113 00209323 00609183 FFFFAEB7
@00000023 00AE8E93 00500E13 3FD19263 7FC00097 F7608093 0AA00113 FE209D23
@0000002A FFA09183 0AA00E93 00600E13 3DD19263 7FC00097 F5608093 FFFFB137
@00000031 A0010113 FE209E23 FFC09183 FFFFBEB7 A00E8E93 00700E13 39D19E63
@00000038 7FC00097 F2E08093 00001137 AA010113 FE209F23 FFE09183 00001EB7
@0000003F AA0E8E93 00800E13 37D19A63 7FC00097 F0608093 FFFFA137 00A10113
@00000046 00209023 00009183 FFFFAEB7 00AE8E93 00900E13 35D19663 7FC00097
@0000004D EE008093 12345137 67810113 FE008213 02221023 00009283 00005EB7
@00000054 678E8E93 00A00E13 33D29063 7FC00097 EB408093 00003137 09810113
@0000005B FFB08093 002093A3 7FC00217 E9E20213 00021283 00003EB7 098E8E93
@00000062 00B00E13 2FD29663 00C00E13 00000213 FFFFD0B7 CDD08093 7FC00117
@00000069 E6010113 00111023 00011183 FFFFDEB7 CDDE8E93 2DD19063 00120213
@00000070 00200293 FC521AE3 00D00E13 00000213 FFFFC0B7 CCD08093 7FC00117
@00000077 E2810113 00000013 00111123 00211183 FFFFCEB7 CCDE8E93 29D19263
@0000007E 00120213 00200293 FC5218E3 00E00E13 00000213 FFFFC0B7 BCC08093
@00000085 7FC00117 DEC10113 00000013 00000013 00111223 00411183 FFFFCEB7
@0000008C BCCE8E93 25D19263 00120213 00200293 FC5216E3 00F00E13 00000213
@00000093 FFFFB0B7 BBC08093 00000013 7FC00117 DA810113 00111323 00611183
@0000009A FFFFBEB7 BBCE8E93 21D19463 00120213 00200293 FC5218E3 01000E13
@000000A1 00000213 FFFFB0B7 ABB08093 00000013 7FC00117 D6C10113 00000013
@000000A8 00111423 00811183 FFFFBEB7 ABBE8E93 1DD19463 00120213 00200293
@000000AF FC5216E3 01100E13 00000213 FFFFE0B7 AAB08093 00000013 00000013
@000000B6 7FC00117 D2810113 00111523 00A11183 FFFFEEB7 AABE8E93 19D19463
@000000BD 00120213 00200293 FC5216E3 01200E13 00000213 7FC00117 CF810113
@000000C4 000020B7 23308093 00111023 00011183 00002EB7 233E8E93 15D19863
@000000CB 00120213 00200293 FC521AE3 01300E13 00000213 7FC00117 CC010113
@000000D2 000010B7 22308093 00000013 00111123 00211183 00001EB7 223E8E93
@000000D9 11D19A63 00120213 00200293 FC5218E3 01400E13 00000213 7FC00117
@000000E0 C8410113 000010B7 12208093 00000013 00000013 00111223 00411183
@000000E7 00001EB7 122E8E93 0DD19A63 00120213 00200293 FC5216E3 01500E13
@000000EE 00000213 7FC00117 C4410113 00000013 11200093 00111323 00611183
@000000F5 11200E93 0BD19063 00120213 00200293 FC521CE3 01600E13 00000213
@000000FC 7FC00117 C1010113 00000013 01100093 00000013 00111423 00811183
@00000103 01100E93 07D19463 00120213 00200293 FC521AE3 01700E13 00000213
@0000010A 7FC00117 BD810113 00000013 00000013 000030B7 00108093 00111523
@00000111 00A11183 00003EB7 001E8E93 03D19463 00120213 00200293 FC5216E3
@00000118 0000C537 EEF50513 7FC00597 B9858593 00A59323 01C01A63 FF000513
@0000011F 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 BEEFBEEF BEEFBEEF BEEFBEEF BEEFBEEF BEEFBEEF 00000000
# See LICENSE for license details.

#*****************************************************************************
# simple.S
#-----------------------------------------------------------------------------
#
# This is the most basic self checking test. If your simulator does not
# pass thiss then there is little chance that it will pass any of the
# more complicated self checking tests.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

RVTEST_PASS

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sll.S
#-----------------------------------------------------------------------------
#
# Test sll instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sll, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  sll, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  sll, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  sll, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  sll, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, sll, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, sll, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, sll, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, sll, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, sll, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, sll, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, sll, 0x1090909080000000, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, sll, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, sll, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, sll, 0x0000001090909080, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, sll, 0x0000084848484000, 0x0000000021212121, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, sll, 0x8000000000000000, 0x0000000021212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, sll, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, sll, 0xffffff8000000000, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, sll, 0x0909080000000000, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sll, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sll, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sll, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, sll, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sll, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sll, 0 );
  TEST_RR_ZERODEST( 43, sll, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00100093 00000113 002091B3 00100E93 00200E13 53D19E63 00100093
@00000007 00100113 002091B3 00200E93 00300E13 53D19263 00100093 00700113
@0000000E 002091B3 08000E93 00400E13 51D19663 00100093 00E00113 002091B3
@00000015 00004EB7 00500E13 4FD19A63 00100093 01F00113 002091B3 80000EB7
@0000001C 00600E13 4DD19E63 FFF00093 00000113 002091B3 FFF00E93 00700E13
@00000023 4DD19263 FFF00093 00100113 002091B3 FFE00E93 00800E13 4BD19663
@0000002A FFF00093 00700113 002091B3 F8000E93 00900E13 49D19A63 FFF00093
@00000031 00E00113 002091B3 FFFFCEB7 00A00E13 47D19E63 FFF00093 01F00113
@00000038 002091B3 80000EB7 00B00E13 47D19263 212120B7 12108093 00000113
@0000003F 002091B3 21212EB7 121E8E93 00C00E13 45D19263 212120B7 12108093
@00000046 00100113 002091B3 42424EB7 242E8E93 00D00E13 43D19263 212120B7
@0000004D 12108093 00700113 002091B3 90909EB7 080E8E93 00E00E13 41D19263
@00000054 212120B7 12108093 00E00113 002091B3 48484EB7 00F00E13 3FD19463
@0000005B 212120B7 12108093 01F00113 002091B3 80000EB7 01000E13 3DD19663
@00000062 212120B7 12108093 FC000113 002091B3 21212EB7 121E8E93 01100E13
@00000069 3BD19663 212120B7 12108093 FC100113 002091B3 42424EB7 242E8E93
@00000070 01200E13 39D19663 212120B7 12108093 FC700113 002091B3 90909EB7
@00000077 080E8E93 01300E13 37D19663 212120B7 12108093 FCE00113 002091B3
@0000007E 48484EB7 01400E13 35D19863 00100093 00700113 002090B3 08000E93
@00000085 01600E13 33D09C63 00100093 00E00113 00209133 00004EB7 01700E13
@0000008C 33D11063 00300093 001090B3 01800E93 01800E13 31D09663 00000213
@00000093 00100093 00700113 002091B3 00018313 00120213 00200293 FE5214E3
@0000009A 08000E93 01900E13 2FD31063 00000213 00100093 00E00113 002091B3
@000000A1 00000013 00018313 00120213 00200293 FE5212E3 00004EB7 01A00E13
@000000A8 2BD31863 00000213 00100093 01F00113 002091B3 00000013 00000013
@000000AF 00018313 00120213 00200293 FE5210E3 80000EB7 01B00E13 27D31E63
@000000B6 00000213 00100093 00700113 002091B3 00120213 00200293 FE5216E3
@000000BD 08000E93 01C00E13 25D19A63 00000213 00100093 00E00113 00000013
@000000C4 002091B3 00120213 00200293 FE5214E3 00004EB7 01D00E13 23D19463
@000000CB 00000213 00100093 01F00113 00000013 00000013 002091B3 00120213
@000000D2 00200293 FE5212E3 80000EB7 01E00E13 1FD19C63 00000213 00100093
@000000D9 00000013 00700113 002091B3 00120213 00200293 FE5214E3 08000E93
@000000E0 01F00E13 1DD19663 00000213 00100093 00000013 00E00113 00000013
@000000E7 002091B3 00120213 00200293 FE5212E3 00004EB7 02000E13 19D19E63
@000000EE 00000213 00100093 00000013 00000013 01F00113 002091B3 00120213
@000000F5 00200293 FE5212E3 80000EB7 02100E13 17D19663 00000213 00700113
@000000FC 00100093 002091B3 00120213 00200293 FE5216E3 08000E93 02200E13
@00000103 15D19263 00000213 00E00113 00100093 00000013 002091B3 00120213
@0000010A 00200293 FE5214E3 00004EB7 02300E13 11D19C63 00000213 01F00113
@00000111 00100093 00000013 00000013 002091B3 00120213 00200293 FE5212E3
@00000118 80000EB7 02400E13 0FD19463 00000213 00700113 00000013 00100093
@0000011F 002091B3 00120213 00200293 FE5214E3 08000E93 02500E13 0BD19E63
@00000126 00000213 00E00113 00000013 00100093 00000013 002091B3 00120213
@0000012D 00200293 FE5212E3 00004EB7 02600E13 09D19663 00000213 01F00113
@00000134 00000013 00000013 00100093 002091B3 00120213 00200293 FE5212E3
@0000013B 80000EB7 02700E13 05D19E63 00F00093 00101133 00000E93 02800E13
@00000142 05D11463 02000093 00009133 02000E93 02900E13 03D11A63 000010B3
@00000149 00000E93 02A00E13 03D09263 40000093 00001137 80010113 00209033
@00000150 00000E93 02B00E13 01D01463 01C01A63 FF000513 00000593 00B52023
@00000157 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# slli.S
#-----------------------------------------------------------------------------
#
# Test slli instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slli, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  slli, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  slli, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  slli, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  slli, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, slli, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, slli, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, slli, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, slli, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, slli, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, slli, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, slli, 0x1090909080000000, 0x0000000021212121, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, slli, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, slli, 0xffffff8000000000, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, slli, 0x0909080000000000, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slli, 0x00000080, 0x00000001, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 24, slli, 0, 31 );
  TEST_IMM_ZERODEST( 25, slli, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00100093 00009193 00100E93 00200E13 27D19A63 00100093 00109193
@00000007 00200E93 00300E13 27D19063 00100093 00709193 08000E93 00400E13
@0000000E 25D19663 00100093 00E09193 00004EB7 00500E13 23D19C63 00100093
@00000015 01F09193 80000EB7 00600E13 23D19263 FFF00093 00009193 FFF00E93
@0000001C 00700E13 21D19863 FFF00093 00109193 FFE00E93 00800E13 1FD19E63
@00000023 FFF00093 00709193 F8000E93 00900E13 1FD19463 FFF00093 00E09193
@0000002A FFFFCEB7 00A00E13 1DD19A63 FFF00093 01F09193 80000EB7 00B00E13
@00000031 1DD19063 212120B7 12108093 00009193 21212EB7 121E8E93 00C00E13
@00000038 1BD19263 212120B7 12108093 00109193 42424EB7 242E8E93 00D00E13
@0000003F 19D19463 212120B7 12108093 00709193 90909EB7 080E8E93 00E00E13
@00000046 17D19663 212120B7 12108093 00E09193 48484EB7 00F00E13 15D19A63
@0000004D 212120B7 12108093 01F09193 80000EB7 01000E13 13D19E63 00100093
@00000054 00709093 08000E93 01100E13 13D09463 00000213 00100093 00709193
@0000005B 00018313 00120213 00200293 FE5216E3 08000E93 01200E13 11D31063
@00000062 00000213 00100093 00E09193 00000013 00018313 00120213 00200293
@00000069 FE5214E3 00004EB7 01300E13 0DD31A63 00000213 00100093 01F09193
@00000070 00000013 00000013 00018313 00120213 00200293 FE5212E3 80000EB7
@00000077 01400E13 0BD31263 00000213 00100093 00709193 00120213 00200293
@0000007E FE5218E3 08000E93 01500E13 09D19063 00000213 00100093 00000013
@00000085 00E09193 00120213 00200293 FE5216E3 00004EB7 01600E13 05D19C63
@0000008C 00000213 00100093 00000013 00000013 01F09193 00120213 00200293
@00000093 FE5214E3 80000EB7 01700E13 03D19663 01F01093 00000E93 01800E13
@0000009A 01D09E63 02100093 01409013 00000E93 01900E13 01D01463 01C01A63
@000000A1 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@000000A8 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# slt.S
#-----------------------------------------------------------------------------
#
# Test slt instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  slt, 0, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  slt, 0, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  slt, 1, 0x0000000000000003, 0x0000000000000007 );
  TEST_RR_OP( 5,  slt, 0, 0x0000000000000007, 0x0000000000000003 );

  TEST_RR_OP( 6,  slt, 0, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 7,  slt, 1, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 8,  slt, 1, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 9,  slt, 1, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 10, slt, 0, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 11, slt, 0, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 12, slt, 1, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 13, slt, 0, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 14, slt, 0, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 15, slt, 1, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 16, slt, 0, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, slt, 0, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, slt, 1, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, slt, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, slt, 1, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, slt, 0, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, slt, 1, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, slt, 0, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, slt, 1, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, slt, 0, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, slt, 1, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, slt, 0, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, slt, 1,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, slt, 0, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, slt, 1,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, slt, 0, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, slt, 1,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, slt, 0, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, slt, 1,  6, 13 );

  TEST_RR_ZEROSRC1( 35, slt, 0, -1 );
  TEST_RR_ZEROSRC2( 36, slt, 1, -1 );
  TEST_RR_ZEROSRC12( 37, slt, 0 );
  TEST_RR_ZERODEST( 38, slt, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 00000113 0020A1B3 00000E93 00200E13 4BD19A63 00100093
@00000007 00100113 0020A1B3 00000E93 00300E13 49D19E63 00300093 00700113
@0000000E 0020A1B3 00100E93 00400E13 49D19263 00700093 00300113 0020A1B3
@00000015 00000E93 00500E13 47D19663 00000093 FFFF8137 0020A1B3 00000E93
@0000001C 00600E13 45D19A63 800000B7 00000113 0020A1B3 00100E93 00700E13
@00000023 43D19E63 800000B7 FFFF8137 0020A1B3 00100E93 00800E13 43D19263
@0000002A 00000093 00008137 FFF10113 0020A1B3 00100E93 00900E13 41D19463
@00000031 800000B7 FFF08093 00000113 0020A1B3 00000E93 00A00E13 3FD19663
@00000038 800000B7 FFF08093 00008137 FFF10113 0020A1B3 00000E93 00B00E13
@0000003F 3DD19663 800000B7 00008137 FFF10113 0020A1B3 00100E93 00C00E13
@00000046 3BD19863 800000B7 FFF08093 FFFF8137 0020A1B3 00000E93 00D00E13
@0000004D 39D19A63 00000093 FFF00113 0020A1B3 00000E93 00E00E13 37D19E63
@00000054 FFF00093 00100113 0020A1B3 00100E93 00F00E13 37D19263 FFF00093
@0000005B FFF00113 0020A1B3 00000E93 01000E13 35D19663 00E00093 00D00113
@00000062 0020A0B3 00000E93 01100E13 33D09A63 00B00093 00D00113 0020A133
@00000069 00100E93 01200E13 31D11E63 00D00093 0010A0B3 00000E93 01300E13
@00000070 31D09463 00000213 00B00093 00D00113 0020A1B3 00018313 00120213
@00000077 00200293 FE5214E3 00100E93 01400E13 2DD31E63 00000213 00E00093
@0000007E 00D00113 0020A1B3 00000013 00018313 00120213 00200293 FE5212E3
@00000085 00000E93 01500E13 2BD31663 00000213 00C00093 00D00113 0020A1B3
@0000008C 00000013 00000013 00018313 00120213 00200293 FE5210E3 00100E93
@00000093 01600E13 27D31C63 00000213 00E00093 00D00113 0020A1B3 00120213
@0000009A 00200293 FE5216E3 00000E93 01700E13 25D19863 00000213 00B00093
@000000A1 00D00113 00000013 0020A1B3 00120213 00200293 FE5214E3 00100E93
@000000A8 01800E13 23D19263 00000213 00F00093 00D00113 00000013 00000013
@000000AF 0020A1B3 00120213 00200293 FE5212E3 00000E93 01900E13 1FD19A63
@000000B6 00000213 00A00093 00000013 00D00113 0020A1B3 00120213 00200293
@000000BD FE5214E3 00100E93 01A00E13 1DD19463 00000213 01000093 00000013
@000000C4 00D00113 00000013 0020A1B3 00120213 00200293 FE5212E3 00000E93
@000000CB 01B00E13 19D19C63 00000213 00900093 00000013 00000013 00D00113
@000000D2 0020A1B3 00120213 00200293 FE5212E3 00100E93 01C00E13 17D19463
@000000D9 00000213 00D00113 01100093 0020A1B3 00120213 00200293 FE5216E3
@000000E0 00000E93 01D00E13 15D19063 00000213 00D00113 00800093 00000013
@000000E7 0020A1B3 00120213 00200293 FE5214E3 00100E93 01E00E13 11D19A63
@000000EE 00000213 00D00113 01200093 00000013 00000013 0020A1B3 00120213
@000000F5 00200293 FE5212E3 00000E93 01F00E13 0FD19263 00000213 00D00113
@000000FC 00000013 00700093 0020A1B3 00120213 00200293 FE5214E3 00100E93
@00000103 02000E13 0BD19C63 00000213 00D00113 00000013 01300093 00000013
@0000010A 0020A1B3 00120213 00200293 FE5212E3 00000E93 02100E13 09D19463
@00000111 00000213 00D00113 00000013 00000013 00600093 0020A1B3 00120213
@00000118 00200293 FE5212E3 00100E93 02200E13 05D19C63 FFF00093 00102133
@0000011F 00000E93 02300E13 05D11263 FFF00093 0000A133 00100E93 02400E13
@00000126 03D11863 000020B3 00000E93 02500E13 03D09063 01000093 01E00113
@0000012D 0020A033 00000E93 02600E13 01D01463 01C01A63 FF000513 00000593
@00000134 00B52023 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# slti.S
#-----------------------------------------------------------------------------
#
# Test slti instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slti, 0, 0x0000000000000000, 0x000 );
  TEST_IMM_OP( 3,  slti, 0, 0x0000000000000001, 0x001 );
  TEST_IMM_OP( 4,  slti, 1, 0x0000000000000003, 0x007 );
  TEST_IMM_OP( 5,  slti, 0, 0x0000000000000007, 0x003 );

  TEST_IMM_OP( 6,  slti, 0, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 7,  slti, 1, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 8,  slti, 1, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 9,  slti, 1, 0x0000000000000000, 0x7ff );
  TEST_IMM_OP( 10, slti, 0, 0x000000007fffffff, 0x000 );
  TEST_IMM_OP( 11, slti, 0, 0x000000007fffffff, 0x7ff );

  TEST_IMM_OP( 12, slti, 1, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 13, slti, 0, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 14, slti, 0, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 15, slti, 1, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 16, slti, 0, 0xffffffffffffffff, 0xfff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slti, 1, 11, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slti, 0, 15, 10 );
  TEST_IMM_DEST_BYPASS( 19, 1, slti, 1, 10, 16 );
  TEST_IMM_DEST_BYPASS( 20, 2, slti, 0, 16,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slti, 1, 11, 15 );
  TEST_IMM_SRC1_BYPASS( 22, 1, slti, 0, 17,  8 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slti, 1, 12, 14 );

  TEST_IMM_ZEROSRC1( 24, slti, 0, 0xfff );
  TEST_IMM_ZERODEST( 25, slti, 0x00ff00ff, 0xfff );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 0000A193 00000E93 00200E13 27D19263 00100093 0010A193
@00000007 00000E93 00300E13 25D19863 00300093 0070A193 00100E93 00400E13
@0000000E 23D19E63 00700093 0030A193 00000E93 00500E13 23D19463 00000093
@00000015 8000A193 00000E93 00600E13 21D19A63 800000B7 0000A193 00100E93
@0000001C 00700E13 21D19063 800000B7 8000A193 00100E93 00800E13 1FD19663
@00000023 00000093 7FF0A193 00100E93 00900E13 1DD19C63 800000B7 FFF08093
@0000002A 0000A193 00000E93 00A00E13 1DD19063 800000B7 FFF08093 7FF0A193
@00000031 00000E93 00B00E13 1BD19463 800000B7 7FF0A193 00100E93 00C00E13
@00000038 19D19A63 800000B7 FFF08093 8000A193 00000E93 00D00E13 17D19E63
@0000003F 00000093 FFF0A193 00000E93 00E00E13 17D19463 FFF00093 0010A193
@00000046 00100E93 00F00E13 15D19A63 FFF00093 FFF0A193 00000E93 01000E13
@0000004D 15D19063 00B00093 00D0A093 00100E93 01100E13 13D09663 00000213
@00000054 00F00093 00A0A193 00018313 00120213 00200293 FE5216E3 00000E93
@0000005B 01200E13 11D31263 00000213 00A00093 0100A193 00000013 00018313
@00000062 00120213 00200293 FE5214E3 00100E93 01300E13 0DD31C63 00000213
@00000069 01000093 0090A193 00000013 00000013 00018313 00120213 00200293
@00000070 FE5212E3 00000E93 01400E13 0BD31463 00000213 00B00093 00F0A193
@00000077 00120213 00200293 FE5218E3 00100E93 01500E13 09D19263 00000213
@0000007E 01100093 00000013 0080A193 00120213 00200293 FE5216E3 00000E93
@00000085 01600E13 05D19E63 00000213 00C00093 00000013 00000013 00E0A193
@0000008C 00120213 00200293 FE5214E3 00100E93 01700E13 03D19863 FFF02093
@00000093 00000E93 01800E13 03D09063 00FF00B7 0FF08093 FFF0A013 00000E93
@0000009A 01900E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@000000A1 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sltiu.S
#-----------------------------------------------------------------------------
#
# Test sltiu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  sltiu, 0, 0x0000000000000000, 0x000 );
  TEST_IMM_OP( 3,  sltiu, 0, 0x0000000000000001, 0x001 );
  TEST_IMM_OP( 4,  sltiu, 1, 0x0000000000000003, 0x007 );
  TEST_IMM_OP( 5,  sltiu, 0, 0x0000000000000007, 0x003 );

  TEST_IMM_OP( 6,  sltiu, 1, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 7,  sltiu, 0, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 8,  sltiu, 1, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 9,  sltiu, 1, 0x0000000000000000, 0x7ff );
  TEST_IMM_OP( 10, sltiu, 0, 0x000000007fffffff, 0x000 );
  TEST_IMM_OP( 11, sltiu, 0, 0x000000007fffffff, 0x7ff );

  TEST_IMM_OP( 12, sltiu, 0, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 13, sltiu, 1, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 14, sltiu, 1, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 15, sltiu, 0, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 16, sltiu, 0, 0xffffffffffffffff, 0xfff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, sltiu, 1, 11, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, sltiu, 0, 15, 10 );
  TEST_IMM_DEST_BYPASS( 19, 1, sltiu, 1, 10, 16 );
  TEST_IMM_DEST_BYPASS( 20, 2, sltiu, 0, 16,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, sltiu, 1, 11, 15 );
  TEST_IMM_SRC1_BYPASS( 22, 1, sltiu, 0, 17,  8 );
  TEST_IMM_SRC1_BYPASS( 23, 2, sltiu, 1, 12, 14 );

  TEST_IMM_ZEROSRC1( 24, sltiu, 1, 0xfff );
  TEST_IMM_ZERODEST( 25, sltiu, 0x00ff00ff, 0xfff );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 0000B193 00000E93 00200E13 27D19263 00100093 0010B193
@00000007 00000E93 00300E13 25D19863 00300093 0070B193 00100E93 00400E13
@0000000E 23D19E63 00700093 0030B193 00000E93 00500E13 23D19463 00000093
@00000015 8000B193 00100E93 00600E13 21D19A63 800000B7 0000B193 00000E93
@0000001C 00700E13 21D19063 800000B7 8000B193 00100E93 00800E13 1FD19663
@00000023 00000093 7FF0B193 00100E93 00900E13 1DD19C63 800000B7 FFF08093
@0000002A 0000B193 00000E93 00A00E13 1DD19063 800000B7 FFF08093 7FF0B193
@00000031 00000E93 00B00E13 1BD19463 800000B7 7FF0B193 00000E93 00C00E13
@00000038 19D19A63 800000B7 FFF08093 8000B193 00100E93 00D00E13 17D19E63
@0000003F 00000093 FFF0B193 00100E93 00E00E13 17D19463 FFF00093 0010B193
@00000046 00000E93 00F00E13 15D19A63 FFF00093 FFF0B193 00000E93 01000E13
@0000004D 15D19063 00B00093 00D0B093 00100E93 01100E13 13D09663 00000213
@00000054 00F00093 00A0B193 00018313 00120213 00200293 FE5216E3 00000E93
@0000005B 01200E13 11D31263 00000213 00A00093 0100B193 00000013 00018313
@00000062 00120213 00200293 FE5214E3 00100E93 01300E13 0DD31C63 00000213
@00000069 01000093 0090B193 00000013 00000013 00018313 00120213 00200293
@00000070 FE5212E3 00000E93 01400E13 0BD31463 00000213 00B00093 00F0B193
@00000077 00120213 00200293 FE5218E3 00100E93 01500E13 09D19263 00000213
@0000007E 01100093 00000013 0080B193 00120213 00200293 FE5216E3 00000E93
@00000085 01600E13 05D19E63 00000213 00C00093 00000013 00000013 00E0B193
@0000008C 00120213 00200293 FE5214E3 00100E93 01700E13 03D19863 FFF03093
@00000093 00100E93 01800E13 03D09063 00FF00B7 0FF08093 FFF0B013 00000E93
@0000009A 01900E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@000000A1 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sltu.S
#-----------------------------------------------------------------------------
#
# Test sltu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sltu, 0, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sltu, 0, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sltu, 1, 0x00000003, 0x00000007 );
  TEST_RR_OP( 5,  sltu, 0, 0x00000007, 0x00000003 );

  TEST_RR_OP( 6,  sltu, 1, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 7,  sltu, 0, 0x80000000, 0x00000000 );
  TEST_RR_OP( 8,  sltu, 1, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 9,  sltu, 1, 0x00000000, 0x00007fff );
  TEST_RR_OP( 10, sltu, 0, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 11, sltu, 0, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 12, sltu, 0, 0x80000000, 0x00007fff );
  TEST_RR_OP( 13, sltu, 1, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 14, sltu, 1, 0x00000000, 0xffffffff );
  TEST_RR_OP( 15, sltu, 0, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 16, sltu, 0, 0xffffffff, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sltu, 0, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, sltu, 1, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, sltu, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sltu, 1, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, sltu, 0, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, sltu, 1, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sltu, 0, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sltu, 1, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sltu, 0, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sltu, 1, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sltu, 0, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sltu, 1,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sltu, 0, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sltu, 1,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sltu, 0, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sltu, 1,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sltu, 0, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sltu, 1,  6, 13 );

  TEST_RR_ZEROSRC1( 35, sltu, 1, -1 );
  TEST_RR_ZEROSRC2( 36, sltu, 0, -1 );
  TEST_RR_ZEROSRC12( 37, sltu, 0 );
  TEST_RR_ZERODEST( 38, sltu, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 00000113 0020B1B3 00000E93 00200E13 4BD19A63 00100093
@00000007 00100113 0020B1B3 00000E93 00300E13 49D19E63 00300093 00700113
@0000000E 0020B1B3 00100E93 00400E13 49D19263 00700093 00300113 0020B1B3
@00000015 00000E93 00500E13 47D19663 00000093 FFFF8137 0020B1B3 00100E93
@0000001C 00600E13 45D19A63 800000B7 00000113 0020B1B3 00000E93 00700E13
@00000023 43D19E63 800000B7 FFFF8137 0020B1B3 00100E93 00800E13 43D19263
@0000002A 00000093 00008137 FFF10113 0020B1B3 00100E93 00900E13 41D19463
@00000031 800000B7 FFF08093 00000113 0020B1B3 00000E93 00A00E13 3FD19663
@00000038 800000B7 FFF08093 00008137 FFF10113 0020B1B3 00000E93 00B00E13
@0000003F 3DD19663 800000B7 00008137 FFF10113 0020B1B3 00000E93 00C00E13
@00000046 3BD19863 800000B7 FFF08093 FFFF8137 0020B1B3 00100E93 00D00E13
@0000004D 39D19A63 00000093 FFF00113 0020B1B3 00100E93 00E00E13 37D19E63
@00000054 FFF00093 00100113 0020B1B3 00000E93 00F00E13 37D19263 FFF00093
@0000005B FFF00113 0020B1B3 00000E93 01000E13 35D19663 00E00093 00D00113
@00000062 0020B0B3 00000E93 01100E13 33D09A63 00B00093 00D00113 0020B133
@00000069 00100E93 01200E13 31D11E63 00D00093 0010B0B3 00000E93 01300E13
@00000070 31D09463 00000213 00B00093 00D00113 0020B1B3 00018313 00120213
@00000077 00200293 FE5214E3 00100E93 01400E13 2DD31E63 00000213 00E00093
@0000007E 00D00113 0020B1B3 00000013 00018313 00120213 00200293 FE5212E3
@00000085 00000E93 01500E13 2BD31663 00000213 00C00093 00D00113 0020B1B3
@0000008C 00000013 00000013 00018313 00120213 00200293 FE5210E3 00100E93
@00000093 01600E13 27D31C63 00000213 00E00093 00D00113 0020B1B3 00120213
@0000009A 00200293 FE5216E3 00000E93 01700E13 25D19863 00000213 00B00093
@000000A1 00D00113 00000013 0020B1B3 00120213 00200293 FE5214E3 00100E93
@000000A8 01800E13 23D19263 00000213 00F00093 00D00113 00000013 00000013
@000000AF 0020B1B3 00120213 00200293 FE5212E3 00000E93 01900E13 1FD19A63
@000000B6 00000213 00A00093 00000013 00D00113 0020B1B3 00120213 00200293
@000000BD FE5214E3 00100E93 01A00E13 1DD19463 00000213 01000093 00000013
@000000C4 00D00113 00000013 0020B1B3 00120213 00200293 FE5212E3 00000E93
@000000CB 01B00E13 19D19C63 00000213 00900093 00000013 00000013 00D00113
@000000D2 0020B1B3 00120213 00200293 FE5212E3 00100E93 01C00E13 17D19463
@000000D9 00000213 00D00113 01100093 0020B1B3 00120213 00200293 FE5216E3
@000000E0 00000E93 01D00E13 15D19063 00000213 00D00113 00800093 00000013
@000000E7 0020B1B3 00120213 00200293 FE5214E3 00100E93 01E00E13 11D19A63
@000000EE 00000213 00D00113 01200093 00000013 00000013 0020B1B3 00120213
@000000F5 00200293 FE5212E3 00000E93 01F00E13 0FD19263 00000213 00D00113
@000000FC 00000013 00700093 0020B1B3 00120213 00200293 FE5214E3 00100E93
@00000103 02000E13 0BD19C63 00000213 00D00113 00000013 01300093 00000013
@0000010A 0020B1B3 00120213 00200293 FE5212E3 00000E93 02100E13 09D19463
@00000111 00000213 00D00113 00000013 00000013 00600093 0020B1B3 00120213
@00000118 00200293 FE5212E3 00100E93 02200E13 05D19C63 FFF00093 00103133
@0000011F 00100E93 02300E13 05D11263 FFF00093 0000B133 00000E93 02400E13
@00000126 03D11863 000030B3 00000E93 02500E13 03D09063 01000093 01E00113
@0000012D 0020B033 00000E93 02600E13 01D01463 01C01A63 FF000513 00000593
@00000134 00B52023 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sra.S
#-----------------------------------------------------------------------------
#
# Test sra instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sra, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_RR_OP( 3,  sra, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_RR_OP( 4,  sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_OP( 5,  sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_OP( 6,  sra, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_RR_OP( 7,  sra, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_RR_OP( 8,  sra, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_RR_OP( 9,  sra, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_RR_OP( 10, sra, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_RR_OP( 11, sra, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_RR_OP( 12, sra, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_RR_OP( 13, sra, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_RR_OP( 14, sra, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_RR_OP( 15, sra, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_RR_OP( 16, sra, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, sra, 0xffffffff81818181, 0xffffffff81818181, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, sra, 0xffffffffc0c0c0c0, 0xffffffff81818181, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, sra, 0xffffffffff030303, 0xffffffff81818181, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, sra, 0xfffffffffffe0606, 0xffffffff81818181, 0xffffffffffffffce );
  TEST_RR_OP( 21, sra, 0xffffffffffffffff, 0xffffffff81818181, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sra, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_ZEROSRC1( 40, sra, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sra, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sra, 0 );
  TEST_RR_ZERODEST( 43, sra, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 800000B7 00000113 4020D1B3 80000EB7 00200E13 59D19463 800000B7
@00000007 00100113 4020D1B3 C0000EB7 00300E13 57D19863 800000B7 00700113
@0000000E 4020D1B3 FF000EB7 00400E13 55D19C63 800000B7 00E00113 4020D1B3
@00000015 FFFE0EB7 00500E13 55D19063 800000B7 00108093 01F00113 4020D1B3
@0000001C FFF00E93 00600E13 53D19263 800000B7 FFF08093 00000113 4020D1B3
@00000023 80000EB7 FFFE8E93 00700E13 51D19263 800000B7 FFF08093 00100113
@0000002A 4020D1B3 40000EB7 FFFE8E93 00800E13 4FD19263 800000B7 FFF08093
@00000031 00700113 4020D1B3 01000EB7 FFFE8E93 00900E13 4DD19263 800000B7
@00000038 FFF08093 00E00113 4020D1B3 00020EB7 FFFE8E93 00A00E13 4BD19263
@0000003F 800000B7 FFF08093 01F00113 4020D1B3 00000E93 00B00E13 49D19463
@00000046 818180B7 18108093 00000113 4020D1B3 81818EB7 181E8E93 00C00E13
@0000004D 47D19463 818180B7 18108093 00100113 4020D1B3 C0C0CEB7 0C0E8E93
@00000054 00D00E13 45D19463 818180B7 18108093 00700113 4020D1B3 FF030EB7
@0000005B 303E8E93 00E00E13 43D19463 818180B7 18108093 00E00113 4020D1B3
@00000062 FFFE0EB7 606E8E93 00F00E13 41D19463 818180B7 18108093 01F00113
@00000069 4020D1B3 FFF00E93 01000E13 3FD19663 818180B7 18108093 FC000113
@00000070 4020D1B3 81818EB7 181E8E93 01100E13 3DD19663 818180B7 18108093
@00000077 FC100113 4020D1B3 C0C0CEB7 0C0E8E93 01200E13 3BD19663 818180B7
@0000007E 18108093 FC700113 4020D1B3 FF030EB7 303E8E93 01300E13 39D19663
@00000085 818180B7 18108093 FCE00113 4020D1B3 FFFE0EB7 606E8E93 01400E13
@0000008C 37D19663 818180B7 18108093 FFF00113 4020D1B3 FFF00E93 01500E13
@00000093 35D19863 800000B7 00700113 4020D0B3 FF000EB7 01600E13 33D09C63
@0000009A 800000B7 00E00113 4020D133 FFFE0EB7 01700E13 33D11063 00700093
@000000A1 4010D0B3 00000E93 01800E13 31D09663 00000213 800000B7 00700113
@000000A8 4020D1B3 00018313 00120213 00200293 FE5214E3 FF000EB7 01900E13
@000000AF 2FD31063 00000213 800000B7 00E00113 4020D1B3 00000013 00018313
@000000B6 00120213 00200293 FE5212E3 FFFE0EB7 01A00E13 2BD31863 00000213
@000000BD 800000B7 01F00113 4020D1B3 00000013 00000013 00018313 00120213
@000000C4 00200293 FE5210E3 FFF00E93 01B00E13 27D31E63 00000213 800000B7
@000000CB 00700113 4020D1B3 00120213 00200293 FE5216E3 FF000EB7 01C00E13
@000000D2 25D19A63 00000213 800000B7 00E00113 00000013 4020D1B3 00120213
@000000D9 00200293 FE5214E3 FFFE0EB7 01D00E13 23D19463 00000213 800000B7
@000000E0 01F00113 00000013 00000013 4020D1B3 00120213 00200293 FE5212E3
@000000E7 FFF00E93 01E00E13 1FD19C63 00000213 800000B7 00000013 00700113
@000000EE 4020D1B3 00120213 00200293 FE5214E3 FF000EB7 01F00E13 1DD19663
@000000F5 00000213 800000B7 00000013 00E00113 00000013 4020D1B3 00120213
@000000FC 00200293 FE5212E3 FFFE0EB7 02000E13 19D19E63 00000213 800000B7
@00000103 00000013 00000013 01F00113 4020D1B3 00120213 00200293 FE5212E3
@0000010A FFF00E93 02100E13 17D19663 00000213 00700113 800000B7 4020D1B3
@00000111 00120213 00200293 FE5216E3 FF000EB7 02200E13 15D19263 00000213
@00000118 00E00113 800000B7 00000013 4020D1B3 00120213 00200293 FE5214E3
@0000011F FFFE0EB7 02300E13 11D19C63 00000213 01F00113 800000B7 00000013
@00000126 00000013 4020D1B3 00120213 00200293 FE5212E3 FFF00E93 02400E13
@0000012D 0FD19463 00000213 00700113 00000013 800000B7 4020D1B3 00120213
@00000134 00200293 FE5214E3 FF000EB7 02500E13 0BD19E63 00000213 00E00113
@0000013B 00000013 800000B7 00000013 4020D1B3 00120213 00200293 FE5212E3
@00000142 FFFE0EB7 02600E13 09D19663 00000213 01F00113 00000013 00000013
@00000149 800000B7 4020D1B3 00120213 00200293 FE5212E3 FFF00E93 02700E13
@00000150 05D19E63 00F00093 40105133 00000E93 02800E13 05D11463 02000093
@00000157 4000D133 02000E93 02900E13 03D11A63 400050B3 00000E93 02A00E13
@0000015E 03D09263 40000093 00001137 80010113 4020D033 00000E93 02B00E13
@00000165 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513
@0000016C 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# srai.S
#-----------------------------------------------------------------------------
#
# Test srai instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  srai, 0xffffff8000000000, 0xffffff8000000000, 0  );
  TEST_IMM_OP( 3,  srai, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_IMM_OP( 4,  srai, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_OP( 5,  srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_OP( 6,  srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_OP( 7,  srai, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_IMM_OP( 8,  srai, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_IMM_OP( 9,  srai, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_IMM_OP( 10, srai, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_IMM_OP( 11, srai, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_IMM_OP( 12, srai, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_IMM_OP( 13, srai, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_IMM_OP( 14, srai, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_IMM_OP( 15, srai, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_IMM_OP( 16, srai, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, srai, 0xffffffffff000000, 0xffffffff80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, srai, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, srai, 0xffffffffff000000, 0xffffffff80000000, 7 );
  TEST_IMM_SRC1_BYPASS( 22, 1, srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, srai, 0, 4 );
  TEST_IMM_ZERODEST( 25, srai, 33, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 4000D193 00000E93 00200E13 2BD19463 800000B7 4010D193
@00000007 C0000EB7 00300E13 29D19A63 800000B7 4070D193 FF000EB7 00400E13
@0000000E 29D19063 800000B7 40E0D193 FFFE0EB7 00500E13 27D19663 800000B7
@00000015 00108093 41F0D193 FFF00E93 00600E13 25D19A63 800000B7 FFF08093
@0000001C 4000D193 80000EB7 FFFE8E93 00700E13 23D19C63 800000B7 FFF08093
@00000023 4010D193 40000EB7 FFFE8E93 00800E13 21D19E63 800000B7 FFF08093
@0000002A 4070D193 01000EB7 FFFE8E93 00900E13 21D19063 800000B7 FFF08093
@00000031 40E0D193 00020EB7 FFFE8E93 00A00E13 1FD19263 800000B7 FFF08093
@00000038 41F0D193 00000E93 00B00E13 1DD19663 818180B7 18108093 4000D193
@0000003F 81818EB7 181E8E93 00C00E13 1BD19863 818180B7 18108093 4010D193
@00000046 C0C0CEB7 0C0E8E93 00D00E13 19D19A63 818180B7 18108093 4070D193
@0000004D FF030EB7 303E8E93 00E00E13 17D19C63 818180B7 18108093 40E0D193
@00000054 FFFE0EB7 606E8E93 00F00E13 15D19E63 818180B7 18108093 41F0D193
@0000005B FFF00E93 01000E13 15D19263 800000B7 4070D093 FF000EB7 01100E13
@00000062 13D09863 00000213 800000B7 4070D193 00018313 00120213 00200293
@00000069 FE5216E3 FF000EB7 01200E13 11D31463 00000213 800000B7 40E0D193
@00000070 00000013 00018313 00120213 00200293 FE5214E3 FFFE0EB7 01300E13
@00000077 0DD31E63 00000213 800000B7 00108093 41F0D193 00000013 00000013
@0000007E 00018313 00120213 00200293 FE5210E3 FFF00E93 01400E13 0BD31463
@00000085 00000213 800000B7 4070D193 00120213 00200293 FE5218E3 FF000EB7
@0000008C 01500E13 09D19263 00000213 800000B7 00000013 40E0D193 00120213
@00000093 00200293 FE5216E3 FFFE0EB7 01600E13 05D19E63 00000213 800000B7
@0000009A 00108093 00000013 00000013 41F0D193 00120213 00200293 FE5212E3
@000000A1 FFF00E93 01700E13 03D19663 40405093 00000E93 01800E13 01D09E63
@000000A8 02100093 40A0D013 00000E93 01900E13 01D01463 01C01A63 FF000513
@000000AF 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# srl.S
#-----------------------------------------------------------------------------
#
# Test srl instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

#define TEST_SRL(n, v, a) \
  TEST_RR_OP(n, srl, ((v) & ((1 << (__riscv_xlen-1) << 1) - 1)) >> (a), v, a)

  TEST_SRL( 2,  0xffffffff80000000, 0  );
  TEST_SRL( 3,  0xffffffff80000000, 1  );
  TEST_SRL( 4,  0xffffffff80000000, 7  );
  TEST_SRL( 5,  0xffffffff80000000, 14 );
  TEST_SRL( 6,  0xffffffff80000001, 31 );

  TEST_SRL( 7,  0xffffffffffffffff, 0  );
  TEST_SRL( 8,  0xffffffffffffffff, 1  );
  TEST_SRL( 9,  0xffffffffffffffff, 7  );
  TEST_SRL( 10, 0xffffffffffffffff, 14 );
  TEST_SRL( 11, 0xffffffffffffffff, 31 );

  TEST_SRL( 12, 0x0000000021212121, 0  );
  TEST_SRL( 13, 0x0000000021212121, 1  );
  TEST_SRL( 14, 0x0000000021212121, 7  );
  TEST_SRL( 15, 0x0000000021212121, 14 );
  TEST_SRL( 16, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, srl, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, srl, 0x0000000010909090, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, srl, 0x0000000000424242, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, srl, 0x0000000000008484, 0x0000000021212121, 0xffffffffffffffce );
  TEST_RR_OP( 21, srl, 0x0000000000000000, 0x0000000021212121, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, srl, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, srl, 0x00000001, 0x80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, srl, 0x00000001, 0x80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_ZEROSRC1( 40, srl, 0, 15 );
  TEST_RR_ZEROSRC2( 41, srl, 32, 32 );
  TEST_RR_ZEROSRC12( 42, srl, 0 );
  TEST_RR_ZERODEST( 43, srl, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 800000B7 00000113 0020D1B3 80000EB7 00200E13 57D19863 800000B7
@00000007 00100113 0020D1B3 40000EB7 00300E13 55D19C63 800000B7 00700113
@0000000E 0020D1B3 01000EB7 00400E13 55D19063 800000B7 00E00113 0020D1B3
@00000015 00020EB7 00500E13 53D19463 800000B7 00108093 01F00113 0020D1B3
@0000001C 00100E93 00600E13 51D19663 FFF00093 00000113 0020D1B3 FFF00E93
@00000023 00700E13 4FD19A63 FFF00093 00100113 0020D1B3 80000EB7 FFFE8E93
@0000002A 00800E13 4DD19C63 FFF00093 00700113 0020D1B3 02000EB7 FFFE8E93
@00000031 00900E13 4BD19E63 FFF00093 00E00113 0020D1B3 00040EB7 FFFE8E93
@00000038 00A00E13 4BD19063 FFF00093 01F00113 0020D1B3 00100E93 00B00E13
@0000003F 49D19463 212120B7 12108093 00000113 0020D1B3 21212EB7 121E8E93
@00000046 00C00E13 47D19463 212120B7 12108093 00100113 0020D1B3 10909EB7
@0000004D 090E8E93 00D00E13 45D19463 212120B7 12108093 00700113 0020D1B3
@00000054 00424EB7 242E8E93 00E00E13 43D19463 212120B7 12108093 00E00113
@0000005B 0020D1B3 00008EB7 484E8E93 00F00E13 41D19463 212120B7 12108093
@00000062 01F00113 0020D1B3 00000E93 01000E13 3FD19663 212120B7 12108093
@00000069 FC000113 0020D1B3 21212EB7 121E8E93 01100E13 3DD19663 212120B7
@00000070 12108093 FC100113 0020D1B3 10909EB7 090E8E93 01200E13 3BD19663
@00000077 212120B7 12108093 FC700113 0020D1B3 00424EB7 242E8E93 01300E13
@0000007E 39D19663 212120B7 12108093 FCE00113 0020D1B3 00008EB7 484E8E93
@00000085 01400E13 37D19663 212120B7 12108093 FFF00113 0020D1B3 00000E93
@0000008C 01500E13 35D19863 800000B7 00700113 0020D0B3 01000EB7 01600E13
@00000093 33D09C63 800000B7 00E00113 0020D133 00020EB7 01700E13 33D11063
@0000009A 00700093 0010D0B3 00000E93 01800E13 31D09663 00000213 800000B7
@000000A1 00700113 0020D1B3 00018313 00120213 00200293 FE5214E3 01000EB7
@000000A8 01900E13 2FD31063 00000213 800000B7 00E00113 0020D1B3 00000013
@000000AF 00018313 00120213 00200293 FE5212E3 00020EB7 01A00E13 2BD31863
@000000B6 00000213 800000B7 01F00113 0020D1B3 00000013 00000013 00018313
@000000BD 00120213 00200293 FE5210E3 00100E93 01B00E13 27D31E63 00000213
@000000C4 800000B7 00700113 0020D1B3 00120213 00200293 FE5216E3 01000EB7
@000000CB 01C00E13 25D19A63 00000213 800000B7 00E00113 00000013 0020D1B3
@000000D2 00120213 00200293 FE5214E3 00020EB7 01D00E13 23D19463 00000213
@000000D9 800000B7 01F00113 00000013 00000013 0020D1B3 00120213 00200293
@000000E0 FE5212E3 00100E93 01E00E13 1FD19C63 00000213 800000B7 00000013
@000000E7 00700113 0020D1B3 00120213 00200293 FE5214E3 01000EB7 01F00E13
@000000EE 1DD19663 00000213 800000B7 00000013 00E00113 00000013 0020D1B3
@000000F5 00120213 00200293 FE5212E3 00020EB7 02000E13 19D19E63 00000213
@000000FC 800000B7 00000013 00000013 01F00113 0020D1B3 00120213 00200293
@00000103 FE5212E3 00100E93 02100E13 17D19663 00000213 00700113 800000B7
@0000010A 0020D1B3 00120213 00200293 FE5216E3 01000EB7 02200E13 15D19263
@00000111 00000213 00E00113 800000B7 00000013 0020D1B3 00120213 00200293
@00000118 FE5214E3 00020EB7 02300E13 11D19C63 00000213 01F00113 800000B7
@0000011F 00000013 00000013 0020D1B3 00120213 00200293 FE5212E3 00100E93
@00000126 02400E13 0FD19463 00000213 00700113 00000013 800000B7 0020D1B3
@0000012D 00120213 00200293 FE5214E3 01000EB7 02500E13 0BD19E63 00000213
@00000134 00E00113 00000013 800000B7 00000013 0020D1B3 00120213 00200293
@0000013B FE5212E3 00020EB7 02600E13 09D19663 00000213 01F00113 00000013
@00000142 00000013 800000B7 0020D1B3 00120213 00200293 FE5212E3 00100E93
@00000149 02700E13 05D19E63 00F00093 00105133 00000E93 02800E13 05D11463
@00000150 02000093 0000D133 02000E93 02900E13 03D11A63 000050B3 00000E93
@00000157 02A00E13 03D09263 40000093 00001137 80010113 0020D033 00000E93
@0000015E 02B00E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@00000165 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# srli.S
#-----------------------------------------------------------------------------
#
# Test srli instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

#define TEST_SRLI(n, v, a) \
  TEST_IMM_OP(n, srli, ((v) & ((1 << (__riscv_xlen-1) << 1) - 1)) >> (a), v, a)

  TEST_SRLI( 2,  0xffffffff80000000, 0  );
  TEST_SRLI( 3,  0xffffffff80000000, 1  );
  TEST_SRLI( 4,  0xffffffff80000000, 7  );
  TEST_SRLI( 5,  0xffffffff80000000, 14 );
  TEST_SRLI( 6,  0xffffffff80000001, 31 );

  TEST_SRLI( 7,  0xffffffffffffffff, 0  );
  TEST_SRLI( 8,  0xffffffffffffffff, 1  );
  TEST_SRLI( 9,  0xffffffffffffffff, 7  );
  TEST_SRLI( 10, 0xffffffffffffffff, 14 );
  TEST_SRLI( 11, 0xffffffffffffffff, 31 );

  TEST_SRLI( 12, 0x0000000021212121, 0  );
  TEST_SRLI( 13, 0x0000000021212121, 1  );
  TEST_SRLI( 14, 0x0000000021212121, 7  );
  TEST_SRLI( 15, 0x0000000021212121, 14 );
  TEST_SRLI( 16, 0x0000000021212121, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, srli, 0x01000000, 0x80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, srli, 0x01000000, 0x80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, srli, 0x00020000, 0x80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, srli, 0x00000001, 0x80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, srli, 0x01000000, 0x80000000, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, srli, 0x00020000, 0x80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, srli, 0x00000001, 0x80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, srli, 0, 4 );
  TEST_IMM_ZERODEST( 25, srli, 33, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 800000B7 0000D193 80000EB7 00200E13 29D19863 800000B7 0010D193
@00000007 40000EB7 00300E13 27D19E63 800000B7 0070D193 01000EB7 00400E13
@0000000E 27D19463 800000B7 00E0D193 00020EB7 00500E13 25D19A63 800000B7
@00000015 00108093 01F0D193 00100E93 00600E13 23D19E63 FFF00093 0000D193
@0000001C FFF00E93 00700E13 23D19463 FFF00093 0010D193 80000EB7 FFFE8E93
@00000023 00800E13 21D19863 FFF00093 0070D193 02000EB7 FFFE8E93 00900E13
@0000002A 1FD19C63 FFF00093 00E0D193 00040EB7 FFFE8E93 00A00E13 1FD19063
@00000031 FFF00093 01F0D193 00100E93 00B00E13 1DD19663 212120B7 12108093
@00000038 0000D193 21212EB7 121E8E93 00C00E13 1BD19863 212120B7 12108093
@0000003F 0010D193 10909EB7 090E8E93 00D00E13 19D19A63 212120B7 12108093
@00000046 0070D193 00424EB7 242E8E93 00E00E13 17D19C63 212120B7 12108093
@0000004D 00E0D193 00008EB7 484E8E93 00F00E13 15D19E63 212120B7 12108093
@00000054 01F0D193 00000E93 01000E13 15D19263 800000B7 0070D093 01000EB7
@0000005B 01100E13 13D09863 00000213 800000B7 0070D193 00018313 00120213
@00000062 00200293 FE5216E3 01000EB7 01200E13 11D31463 00000213 800000B7
@00000069 00E0D193 00000013 00018313 00120213 00200293 FE5214E3 00020EB7
@00000070 01300E13 0DD31E63 00000213 800000B7 00108093 01F0D193 00000013
@00000077 00000013 00018313 00120213 00200293 FE5210E3 00100E93 01400E13
@0000007E 0BD31463 00000213 800000B7 0070D193 00120213 00200293 FE5218E3
@00000085 01000EB7 01500E13 09D19263 00000213 800000B7 00000013 00E0D193
@0000008C 00120213 00200293 FE5216E3 00020EB7 01600E13 05D19E63 00000213
@00000093 800000B7 00108093 00000013 00000013 01F0D193 00120213 00200293
@0000009A FE5212E3 00100E93 01700E13 03D19663 00405093 00000E93 01800E13
@000000A1 01D09E63 02100093 00A0D013 00000E93 01900E13 01D01463 01C01A63
@000000A8 FF000513 00000593 00B52023 FF5FF06F FF000513 00100593 00B52023
@000000AF FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sub.S
#-----------------------------------------------------------------------------
#
# Test sub instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sub, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  sub, 0x0000000000000000, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  sub, 0xfffffffffffffffc, 0x0000000000000003, 0x0000000000000007 );

  TEST_RR_OP( 5,  sub, 0x0000000000008000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sub, 0xffffffff80000000, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 7,  sub, 0xffffffff80008000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sub, 0xffffffffffff8001, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sub, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sub, 0x000000007fff8000, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sub, 0xffffffff7fff8001, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sub, 0x0000000080007fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sub, 0x0000000000000001, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sub, 0xfffffffffffffffe, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sub, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 16, sub, 2, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 17, sub, 3, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 18, sub, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 19, 0, sub, 2, 13, 11 );
  TEST_RR_DEST_BYPASS( 20, 1, sub, 3, 14, 11 );
  TEST_RR_DEST_BYPASS( 21, 2, sub, 4, 15, 11 );

  TEST_RR_SRC12_BYPASS( 22, 0, 0, sub, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 23, 0, 1, sub, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 2, sub, 4, 15, 11 );
  TEST_RR_SRC12_BYPASS( 25, 1, 0, sub, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 1, sub, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 27, 2, 0, sub, 4, 15, 11 );

  TEST_RR_SRC21_BYPASS( 28, 0, 0, sub, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 29, 0, 1, sub, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 2, sub, 4, 15, 11 );
  TEST_RR_SRC21_BYPASS( 31, 1, 0, sub, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 1, sub, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 33, 2, 0, sub, 4, 15, 11 );

  TEST_RR_ZEROSRC1( 34, sub, 15, -15 );
  TEST_RR_ZEROSRC2( 35, sub, 32, 32 );
  TEST_RR_ZEROSRC12( 36, sub, 0 );
  TEST_RR_ZERODEST( 37, sub, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00000093 00000113 402081B3 00000E93 00200E13 4BD19663 00100093
@00000007 00100113 402081B3 00000E93 00300E13 49D19A63 00300093 00700113
@0000000E 402081B3 FFC00E93 00400E13 47D19E63 00000093 FFFF8137 402081B3
@00000015 00008EB7 00500E13 47D19263 800000B7 00000113 402081B3 80000EB7
@0000001C 00600E13 45D19663 800000B7 FFFF8137 402081B3 80008EB7 00700E13
@00000023 43D19A63 00000093 00008137 FFF10113 402081B3 FFFF8EB7 001E8E93
@0000002A 00800E13 41D19A63 800000B7 FFF08093 00000113 402081B3 80000EB7
@00000031 FFFE8E93 00900E13 3FD19A63 800000B7 FFF08093 00008137 FFF10113
@00000038 402081B3 7FFF8EB7 00A00E13 3DD19A63 800000B7 00008137 FFF10113
@0000003F 402081B3 7FFF8EB7 001E8E93 00B00E13 3BD19A63 800000B7 FFF08093
@00000046 FFFF8137 402081B3 80008EB7 FFFE8E93 00C00E13 39D19A63 00000093
@0000004D FFF00113 402081B3 00100E93 00D00E13 37D19E63 FFF00093 00100113
@00000054 402081B3 FFE00E93 00E00E13 37D19263 FFF00093 FFF00113 402081B3
@0000005B 00000E93 00F00E13 35D19663 00D00093 00B00113 402080B3 00200E93
@00000062 01000E13 33D09A63 00E00093 00B00113 40208133 00300E93 01100E13
@00000069 31D11E63 00D00093 401080B3 00000E93 01200E13 31D09463 00000213
@00000070 00D00093 00B00113 402081B3 00018313 00120213 00200293 FE5214E3
@00000077 00200E93 01300E13 2DD31E63 00000213 00E00093 00B00113 402081B3
@0000007E 00000013 00018313 00120213 00200293 FE5212E3 00300E93 01400E13
@00000085 2BD31663 00000213 00F00093 00B00113 402081B3 00000013 00000013
@0000008C 00018313 00120213 00200293 FE5210E3 00400E93 01500E13 27D31C63
@00000093 00000213 00D00093 00B00113 402081B3 00120213 00200293 FE5216E3
@0000009A 00200E93 01600E13 25D19863 00000213 00E00093 00B00113 00000013
@000000A1 402081B3 00120213 00200293 FE5214E3 00300E93 01700E13 23D19263
@000000A8 00000213 00F00093 00B00113 00000013 00000013 402081B3 00120213
@000000AF 00200293 FE5212E3 00400E93 01800E13 1FD19A63 00000213 00D00093
@000000B6 00000013 00B00113 402081B3 00120213 00200293 FE5214E3 00200E93
@000000BD 01900E13 1DD19463 00000213 00E00093 00000013 00B00113 00000013
@000000C4 402081B3 00120213 00200293 FE5212E3 00300E93 01A00E13 19D19C63
@000000CB 00000213 00F00093 00000013 00000013 00B00113 402081B3 00120213
@000000D2 00200293 FE5212E3 00400E93 01B00E13 17D19463 00000213 00B00113
@000000D9 00D00093 402081B3 00120213 00200293 FE5216E3 00200E93 01C00E13
@000000E0 15D19063 00000213 00B00113 00E00093 00000013 402081B3 00120213
@000000E7 00200293 FE5214E3 00300E93 01D00E13 11D19A63 00000213 00B00113
@000000EE 00F00093 00000013 00000013 402081B3 00120213 00200293 FE5212E3
@000000F5 00400E93 01E00E13 0FD19263 00000213 00B00113 00000013 00D00093
@000000FC 402081B3 00120213 00200293 FE5214E3 00200E93 01F00E13 0BD19C63
@00000103 00000213 00B00113 00000013 00E00093 00000013 402081B3 00120213
@0000010A 00200293 FE5212E3 00300E93 02000E13 09D19463 00000213 00B00113
@00000111 00000013 00000013 00F00093 402081B3 00120213 00200293 FE5212E3
@00000118 00400E93 02100E13 05D19C63 FF100093 40100133 00F00E93 02200E13
@0000011F 05D11263 02000093 40008133 02000E93 02300E13 03D11863 400000B3
@00000126 00000E93 02400E13 03D09063 01000093 01E00113 40208033 00000E93
@0000012D 02500E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@00000134 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# sw.S
#-----------------------------------------------------------------------------
#
# Test sw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lw, sw, 0x0000000000aa00aa, 0,  tdat );
  TEST_ST_OP( 3, lw, sw, 0xffffffffaa00aa00, 4,  tdat );
  TEST_ST_OP( 4, lw, sw, 0x000000000aa00aa0, 8,  tdat );
  TEST_ST_OP( 5, lw, sw, 0xffffffffa00aa00a, 12, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lw, sw, 0x0000000000aa00aa, -12, tdat8 );
  TEST_ST_OP( 7, lw, sw, 0xffffffffaa00aa00, -8,  tdat8 );
  TEST_ST_OP( 8, lw, sw, 0x000000000aa00aa0, -4,  tdat8 );
  TEST_ST_OP( 9, lw, sw, 0xffffffffa00aa00a, 0,   tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x12345678, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sw x2, 32(x4); \
    lw x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x58213098, \
    la  x1, tdat9; \
    li  x2, 0x58213098; \
    addi x1, x1, -3; \
    sw x2, 7(x1); \
    la  x4, tdat10; \
    lw x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lw, sw, 0xffffffffaabbccdd, 0,  tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lw, sw, 0xffffffffdaabbccd, 4,  tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lw, sw, 0xffffffffddaabbcc, 8,  tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lw, sw, 0xffffffffcddaabbc, 12, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lw, sw, 0xffffffffccddaabb, 16, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lw, sw, 0xffffffffbccddaab, 20, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lw, sw, 0x00112233, 0,  tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lw, sw, 0x30011223, 4,  tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lw, sw, 0x33001122, 8,  tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lw, sw, 0x23300112, 12, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lw, sw, 0x22330011, 16, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lw, sw, 0x12233001, 20, tdat );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0xdeadbeef
tdat2:  .word 0xdeadbeef
tdat3:  .word 0xdeadbeef
tdat4:  .word 0xdeadbeef
tdat5:  .word 0xdeadbeef
tdat6:  .word 0xdeadbeef
tdat7:  .word 0xdeadbeef
tdat8:  .word 0xdeadbeef
tdat9:  .word 0xdeadbeef
tdat10: .word 0xdeadbeef

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 7FC00097 00008093 00AA0137 0AA10113 0020A023 0000A183 00AA0EB7
@00000007 0AAE8E93 00200E13 47D19063 7FC00097 FD808093 AA00B137 A0010113
@0000000E 0020A223 0040A183 AA00BEB7 A00E8E93 00300E13 43D19C63 7FC00097
@00000015 FB008093 0AA01137 AA010113 0020A423 0080A183 0AA01EB7 AA0E8E93
@0000001C 00400E13 41D19863 7FC00097 F8808093 A00AA137 00A10113 0020A623
@00000023 00C0A183 A00AAEB7 00AE8E93 00500E13 3FD19463 7FC00097 F7C08093
@0000002A 00AA0137 0AA10113 FE20AA23 FF40A183 00AA0EB7 0AAE8E93 00600E13
@00000031 3DD19063 7FC00097 F5408093 AA00B137 A0010113 FE20AC23 FF80A183
@00000038 AA00BEB7 A00E8E93 00700E13 39D19C63 7FC00097 F2C08093 0AA01137
@0000003F AA010113 FE20AE23 FFC0A183 0AA01EB7 AA0E8E93 00800E13 37D19863
@00000046 7FC00097 F0408093 A00AA137 00A10113 0020A023 0000A183 A00AAEB7
@0000004D 00AE8E93 00900E13 35D19463 7FC00097 EE008093 12345137 67810113
@00000054 FE008213 02222023 0000A283 12345EB7 678E8E93 00A00E13 31D29E63
@0000005B 7FC00097 EB408093 58213137 09810113 FFD08093 0020A3A3 7FC00217
@00000062 EA020213 00022283 58213EB7 098E8E93 00B00E13 2FD29463 00C00E13
@00000069 00000213 AABBD0B7 CDD08093 7FC00117 E5010113 00112023 00012183
@00000070 AABBDEB7 CDDE8E93 2BD19E63 00120213 00200293 FC521AE3 00D00E13
@00000077 00000213 DAABC0B7 CCD08093 7FC00117 E1810113 00000013 00112223
@0000007E 00412183 DAABCEB7 CCDE8E93 29D19063 00120213 00200293 FC5218E3
@00000085 00E00E13 00000213 DDAAC0B7 BCC08093 7FC00117 DDC10113 00000013
@0000008C 00000013 00112423 00812183 DDAACEB7 BCCE8E93 25D19063 00120213
@00000093 00200293 FC5216E3 00F00E13 00000213 CDDAB0B7 BBC08093 00000013
@0000009A 7FC00117 D9810113 00112623 00C12183 CDDABEB7 BBCE8E93 21D19263
@000000A1 00120213 00200293 FC5218E3 01000E13 00000213 CCDDB0B7 ABB08093
@000000A8 00000013 7FC00117 D5C10113 00000013 00112823 01012183 CCDDBEB7
@000000AF ABBE8E93 1DD19263 00120213 00200293 FC5216E3 01100E13 00000213
@000000B6 BCCDE0B7 AAB08093 00000013 00000013 7FC00117 D1810113 00112A23
@000000BD 01412183 BCCDEEB7 AABE8E93 19D19263 00120213 00200293 FC5216E3
@000000C4 01200E13 00000213 7FC00117 CE810113 001120B7 23308093 00112023
@000000CB 00012183 00112EB7 233E8E93 15D19663 00120213 00200293 FC521AE3
@000000D2 01300E13 00000213 7FC00117 CB010113 300110B7 22308093 00000013
@000000D9 00112223 00412183 30011EB7 223E8E93 11D19863 00120213 00200293
@000000E0 FC5218E3 01400E13 00000213 7FC00117 C7410113 330010B7 12208093
@000000E7 00000013 00000013 00112423 00812183 33001EB7 122E8E93 0DD19863
@000000EE 00120213 00200293 FC5216E3 01500E13 00000213 7FC00117 C3410113
@000000F5 00000013 233000B7 11208093 00112623 00C12183 23300EB7 112E8E93
@000000FC 09D19A63 00120213 00200293 FC5218E3 01600E13 00000213 7FC00117
@00000103 BF810113 00000013 223300B7 01108093 00000013 00112823 01012183
@0000010A 22330EB7 011E8E93 05D19A63 00120213 00200293 FC5216E3 01700E13
@00000111 00000213 7FC00117 BB810113 00000013 00000013 122330B7 00108093
@00000118 00112A23 01412183 12233EB7 001E8E93 01D19A63 00120213 00200293
@0000011F FC5216E3 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513
@00000126 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
@00000000 DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF DEADBEEF
@00000007 DEADBEEF DEADBEEF DEADBEEF
// See LICENSE for license details.

#ifndef __TEST_MACROS_SCALAR_H
#define __TEST_MACROS_SCALAR_H


#-----------------------------------------------------------------------
# Helper macros
#-----------------------------------------------------------------------

#define TRUNC_32BIT(v) (v & 0xffffffff)

#define TEST_CASE( testnum, testreg, correctval, code... ) \
test_ ## testnum: \
    code; \
    li  x29, TRUNC_32BIT(correctval); \
    li  TESTNUM, testnum; \
    bne testreg, x29, fail;

# We use a macro hack to simpify code generation for various numbers
# of bubble cycles.

#define TEST_INSERT_NOPS_0
#define TEST_INSERT_NOPS_1  nop; TEST_INSERT_NOPS_0
#define TEST_INSERT_NOPS_2  nop; TEST_INSERT_NOPS_1
#define TEST_INSERT_NOPS_3  nop; TEST_INSERT_NOPS_2
#define TEST_INSERT_NOPS_4  nop; TEST_INSERT_NOPS_3
#define TEST_INSERT_NOPS_5  nop; TEST_INSERT_NOPS_4
#define TEST_INSERT_NOPS_6  nop; TEST_INSERT_NOPS_5
#define TEST_INSERT_NOPS_7  nop; TEST_INSERT_NOPS_6
#define TEST_INSERT_NOPS_8  nop; TEST_INSERT_NOPS_7
#define TEST_INSERT_NOPS_9  nop; TEST_INSERT_NOPS_8
#define TEST_INSERT_NOPS_10 nop; TEST_INSERT_NOPS_9


#-----------------------------------------------------------------------
# RV64UI MACROS
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Tests for instructions with immediate operand
#-----------------------------------------------------------------------

#define SEXT_IMM(x) ((x) | (-(((x) >> 11) & 1) << 11))

#define TEST_IMM_OP( testnum, inst, result, val1, imm ) \
    TEST_CASE( testnum, x3, result, \
      li  x1, TRUNC_32BIT(val1); \
      inst x3, x1, SEXT_IMM(imm); \
    )

#define TEST_IMM_SRC1_EQ_DEST( testnum, inst, result, val1, imm ) \
    TEST_CASE( testnum, x1, result, \
      li  x1, val1; \
      inst x1, x1, SEXT_IMM(imm); \
    )

#define TEST_IMM_DEST_BYPASS( testnum, nop_cycles, inst, result, val1, imm ) \
    TEST_CASE( testnum, x6, result, \
      li  x4, 0; \
1:    li  x1, val1; \
      inst x3, x1, SEXT_IMM(imm); \
      TEST_INSERT_NOPS_ ## nop_cycles \
      addi  x6, x3, 0; \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#define TEST_IMM_SRC1_BYPASS( testnum, nop_cycles, inst, result, val1, imm ) \
    TEST_CASE( testnum, x3, result, \
      li  x4, 0; \
1:    li  x1, val1; \
      TEST_INSERT_NOPS_ ## nop_cycles \
      inst x3, x1, SEXT_IMM(imm); \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#define TEST_IMM_ZEROSRC1( testnum, inst, result, imm ) \
    TEST_CASE( testnum, x1, result, \
      inst x1, x0, SEXT_IMM(imm); \
    )

#define TEST_IMM_ZERODEST( testnum, inst, val1, imm ) \
    TEST_CASE( testnum, x0, 0, \
      li  x1, val1; \
      inst x0, x1, SEXT_IMM(imm); \
    )

#-----------------------------------------------------------------------
# Tests for vector config instructions
#-----------------------------------------------------------------------

#define TEST_VSETCFGIVL( testnum, nxpr, nfpr, bank, vl, result ) \
    TEST_CASE( testnum, x1, result, \
      li x1, (bank << 12); \
      vsetcfg x1,nxpr,nfpr; \
      li x1, vl; \
      vsetvl x1,x1; \
    )

#define TEST_VVCFG( testnum, nxpr, nfpr, bank, vl, result ) \
    TEST_CASE( testnum, x1, result, \
      li x1, (bank << 12) | (nfpr << 6) | nxpr; \
      vsetcfg x1; \
      li x1, vl; \
      vsetvl x1,x1; \
    )

#define TEST_VSETVL( testnum, nxpr, nfpr, bank, vl, result ) \
    TEST_CASE( testnum, x1, result, \
      li x1, (bank << 12); \
      vsetcfg x1,nxpr,nfpr; \
      li x1, vl; \
      vsetvl x1, x1; \
    )

#-----------------------------------------------------------------------
# Tests for an instruction with register operands
#-----------------------------------------------------------------------

#define TEST_R_OP( testnum, inst, result, val1 ) \
    TEST_CASE( testnum, x3, result, \
      li  x1, val1; \
      inst x3, x1; \
    )

#define TEST_R_SRC1_EQ_DEST( testnum, inst, result, val1 ) \
    TEST_CASE( testnum, x1, result, \
      li  x1, val1; \
      inst x1, x1; \
    )

#define TEST_R_DEST_BYPASS( testnum, nop_cycles, inst, result, val1 ) \
    TEST_CASE( testnum, x6, result, \
      li  x4, 0; \
1:    li  x1, val1; \
      inst x3, x1; \
      TEST_INSERT_NOPS_ ## nop_cycles \
      addi  x6, x3, 0; \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#-----------------------------------------------------------------------
# Tests for an instruction with register-register operands
#-----------------------------------------------------------------------

#define TEST_RR_OP( testnum, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x3, result, \
      li  x1, TRUNC_32BIT(val1); \
      li  x2, TRUNC_32BIT(val2); \
      inst x3, x1, x2; \
    )

#define TEST_RR_SRC1_EQ_DEST( testnum, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x1, result, \
      li  x1, val1; \
      li  x2, val2; \
      inst x1, x1, x2; \
    )

#define TEST_RR_SRC2_EQ_DEST( testnum, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x2, result, \
      li  x1, val1; \
      li  x2, val2; \
      inst x2, x1, x2; \
    )

#define TEST_RR_SRC12_EQ_DEST( testnum, inst, result, val1 ) \
    TEST_CASE( testnum, x1, result, \
      li  x1, val1; \
      inst x1, x1, x1; \
    )

#define TEST_RR_DEST_BYPASS( testnum, nop_cycles, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x6, result, \
      li  x4, 0; \
1:    li  x1, val1; \
      li  x2, val2; \
      inst x3, x1, x2; \
      TEST_INSERT_NOPS_ ## nop_cycles \
      addi  x6, x3, 0; \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#define TEST_RR_SRC12_BYPASS( testnum, src1_nops, src2_nops, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x3, result, \
      li  x4, 0; \
1:    li  x1, val1; \
      TEST_INSERT_NOPS_ ## src1_nops \
      li  x2, val2; \
      TEST_INSERT_NOPS_ ## src2_nops \
      inst x3, x1, x2; \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#define TEST_RR_SRC21_BYPASS( testnum, src1_nops, src2_nops, inst, result, val1, val2 ) \
    TEST_CASE( testnum, x3, result, \
      li  x4, 0; \
1:    li  x2, val2; \
      TEST_INSERT_NOPS_ ## src1_nops \
      li  x1, val1; \
      TEST_INSERT_NOPS_ ## src2_nops \
      inst x3, x1, x2; \
      addi  x4, x4, 1; \
      li  x5, 2; \
      bne x4, x5, 1b \
    )

#define TEST_RR_ZEROSRC1( testnum, inst, result, val ) \
    TEST_CASE( testnum, x2, result, \
      li x1, val; \
      inst x2, x0, x1; \
    )

#define TEST_RR_ZEROSRC2( testnum, inst, result, val ) \
    TEST_CASE( testnum, x2, result, \
      li x1, val; \
      inst x2, x1, x0; \
    )

#define TEST_RR_ZEROSRC12( testnum, inst, result ) \
    TEST_CASE( testnum, x1, result, \
      inst x1, x0, x0; \
    )

#define TEST_RR_ZERODEST( testnum, inst, val1, val2 ) \
    TEST_CASE( testnum, x0, 0, \
      li x1, val1; \
      li x2, val2; \
      inst x0, x1, x2; \
    )

#-----------------------------------------------------------------------
# Test memory instructions
#-----------------------------------------------------------------------

#define TEST_LD_OP( testnum, inst, result, offset, base ) \
    TEST_CASE( testnum, x3, result, \
      la  x1, base; \
      inst x3, offset(x1); \
    )

#define TEST_ST_OP( testnum, load_inst, store_inst, result, offset, base ) \
    TEST_CASE( testnum, x3, result, \
      la  x1, base; \
      li  x2, result; \
      store_inst x2, offset(x1); \
      load_inst x3, offset(x1); \
    )

#define TEST_LD_DEST_BYPASS( testnum, nop_cycles, inst, result, offset, base ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  la  x1, base; \
    inst x3, offset(x1); \
    TEST_INSERT_NOPS_ ## nop_cycles \
    addi  x6, x3, 0; \
    li  x29, TRUNC_32BIT(result); \
    bne x6, x29, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b; \

#define TEST_LD_SRC1_BYPASS( testnum, nop_cycles, inst, result, offset, base ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  la  x1, base; \
    TEST_INSERT_NOPS_ ## nop_cycles \
    inst x3, offset(x1); \
    li  x29, TRUNC_32BIT(result); \
    bne x3, x29, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#define TEST_ST_SRC12_BYPASS( testnum, src1_nops, src2_nops, load_inst, store_inst, result, offset, base ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  li  x1, result; \
    TEST_INSERT_NOPS_ ## src1_nops \
    la  x2, base; \
    TEST_INSERT_NOPS_ ## src2_nops \
    store_inst x1, offset(x2); \
    load_inst x3, offset(x2); \
    li  x29, result; \
    bne x3, x29, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#define TEST_ST_SRC21_BYPASS( testnum, src1_nops, src2_nops, load_inst, store_inst, result, offset, base ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  la  x2, base; \
    TEST_INSERT_NOPS_ ## src1_nops \
    li  x1, result; \
    TEST_INSERT_NOPS_ ## src2_nops \
    store_inst x1, offset(x2); \
    load_inst x3, offset(x2); \
    li  x29, result; \
    bne x3, x29, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#-----------------------------------------------------------------------
# Test branch instructions
#-----------------------------------------------------------------------

#define TEST_BR1_OP_TAKEN( testnum, inst, val1 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x1, val1; \
    inst x1, 2f; \
    bne x0, TESTNUM, fail; \
1:  bne x0, TESTNUM, 3f; \
2:  inst x1, 1b; \
    bne x0, TESTNUM, fail; \
3:

#define TEST_BR1_OP_NOTTAKEN( testnum, inst, val1 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x1, val1; \
    inst x1, 1f; \
    bne x0, TESTNUM, 2f; \
1:  bne x0, TESTNUM, fail; \
2:  inst x1, 1b; \
3:

#define TEST_BR1_SRC1_BYPASS( testnum, nop_cycles, inst, val1 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  li  x1, val1; \
    TEST_INSERT_NOPS_ ## nop_cycles \
    inst x1, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#define TEST_BR2_OP_TAKEN( testnum, inst, val1, val2 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x1, val1; \
    li  x2, val2; \
    inst x1, x2, 2f; \
    bne x0, TESTNUM, fail; \
1:  bne x0, TESTNUM, 3f; \
2:  inst x1, x2, 1b; \
    bne x0, TESTNUM, fail; \
3:

#define TEST_BR2_OP_NOTTAKEN( testnum, inst, val1, val2 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x1, val1; \
    li  x2, val2; \
    inst x1, x2, 1f; \
    bne x0, TESTNUM, 2f; \
1:  bne x0, TESTNUM, fail; \
2:  inst x1, x2, 1b; \
3:

#define TEST_BR2_SRC12_BYPASS( testnum, src1_nops, src2_nops, inst, val1, val2 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  li  x1, val1; \
    TEST_INSERT_NOPS_ ## src1_nops \
    li  x2, val2; \
    TEST_INSERT_NOPS_ ## src2_nops \
    inst x1, x2, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#define TEST_BR2_SRC21_BYPASS( testnum, src1_nops, src2_nops, inst, val1, val2 ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  li  x2, val2; \
    TEST_INSERT_NOPS_ ## src1_nops \
    li  x1, val1; \
    TEST_INSERT_NOPS_ ## src2_nops \
    inst x1, x2, fail; \
    addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#-----------------------------------------------------------------------
# Test jump instructions
#-----------------------------------------------------------------------

#define TEST_JR_SRC1_BYPASS( testnum, nop_cycles, inst ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  la  x6, 2f; \
    TEST_INSERT_NOPS_ ## nop_cycles \
    inst x6; \
    bne x0, TESTNUM, fail; \
2:  addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \

#define TEST_JALR_SRC1_BYPASS( testnum, nop_cycles, inst ) \
test_ ## testnum: \
    li  TESTNUM, testnum; \
    li  x4, 0; \
1:  la  x6, 2f; \
    TEST_INSERT_NOPS_ ## nop_cycles \
    inst x19, x6, 0; \
    bne x0, TESTNUM, fail; \
2:  addi  x4, x4, 1; \
    li  x5, 2; \
    bne x4, x5, 1b \


#-----------------------------------------------------------------------
# RV64UF MACROS
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Tests floating-point instructions
#-----------------------------------------------------------------------

#define TEST_FP_OP_S_INTERNAL( testnum, flags, result, val1, val2, val3, code... ) \
test_ ## testnum: \
  li  TESTNUM, testnum; \
  la  a0, test_ ## testnum ## _data ;\
  flw f0, 0(a0); \
  flw f1, 4(a0); \
  flw f2, 8(a0); \
  lw  a3, 12(a0); \
  code; \
  fsflags a1, x0; \
  li a2, flags; \
  bne a0, a3, fail; \
  bne a1, a2, fail; \
  j 2f; \
  .align 2; \
  .data; \
  test_ ## testnum ## _data: \
  .float val1; \
  .float val2; \
  .float val3; \
  .result; \
  .text; \
2:

#define TEST_FP_OP_D_INTERNAL( testnum, flags, result, val1, val2, val3, code... ) \
test_ ## testnum: \
  li  TESTNUM, testnum; \
  la  a0, test_ ## testnum ## _data ;\
  fld f0, 0(a0); \
  fld f1, 8(a0); \
  fld f2, 16(a0); \
  ld  a3, 24(a0); \
  code; \
  fsflags a1, x0; \
  li a2, flags; \
  bne a0, a3, fail; \
  bne a1, a2, fail; \
  j 2f; \
  .data; \
  .align 3; \
  test_ ## testnum ## _data: \
  .double val1; \
  .double val2; \
  .double val3; \
  .result; \
  .text; \
2:

#define TEST_FCVT_S_D( testnum, result, val1 ) \
  TEST_FP_OP_D_INTERNAL( testnum, 0, double result, val1, 0.0, 0.0, \
                    fcvt.s.d f3, f0; fcvt.d.s f3, f3; fmv.x.d a0, f3)

#define TEST_FCVT_D_S( testnum, result, val1 ) \
  TEST_FP_OP_S_INTERNAL( testnum, 0, float result, val1, 0.0, 0.0, \
                    fcvt.d.s f3, f0; fcvt.s.d f3, f3; fmv.x.s a0, f3)

#define TEST_FP_OP1_S( testnum, inst, flags, result, val1 ) \
  TEST_FP_OP_S_INTERNAL( testnum, flags, float result, val1, 0.0, 0.0, \
                    inst f3, f0; fmv.x.s a0, f3)

#define TEST_FP_OP1_D( testnum, inst, flags, result, val1 ) \
  TEST_FP_OP_D_INTERNAL( testnum, flags, double result, val1, 0.0, 0.0, \
                    inst f3, f0; fmv.x.d a0, f3)

#define TEST_FP_OP2_S( testnum, inst, flags, result, val1, val2 ) \
  TEST_FP_OP_S_INTERNAL( testnum, flags, float result, val1, val2, 0.0, \
                    inst f3, f0, f1; fmv.x.s a0, f3)

#define TEST_FP_OP2_D( testnum, inst, flags, result, val1, val2 ) \
  TEST_FP_OP_D_INTERNAL( testnum, flags, double result, val1, val2, 0.0, \
                    inst f3, f0, f1; fmv.x.d a0, f3)

#define TEST_FP_OP3_S( testnum, inst, flags, result, val1, val2, val3 ) \
  TEST_FP_OP_S_INTERNAL( testnum, flags, float result, val1, val2, val3, \
                    inst f3, f0, f1, f2; fmv.x.s a0, f3)

#define TEST_FP_OP3_D( testnum, inst, flags, result, val1, val2, val3 ) \
  TEST_FP_OP_D_INTERNAL( testnum, flags, double result, val1, val2, val3, \
                    inst f3, f0, f1, f2; fmv.x.d a0, f3)

#define TEST_FP_INT_OP_S( testnum, inst, flags, result, val1, rm ) \
  TEST_FP_OP_S_INTERNAL( testnum, flags, word result, val1, 0.0, 0.0, \
                    inst a0, f0, rm)

#define TEST_FP_INT_OP_D( testnum, inst, flags, result, val1, rm ) \
  TEST_FP_OP_D_INTERNAL( testnum, flags, dword result, val1, 0.0, 0.0, \
                    inst a0, f0, rm)

#define TEST_FP_CMP_OP_S( testnum, inst, result, val1, val2 ) \
  TEST_FP_OP_S_INTERNAL( testnum, 0, word result, val1, val2, 0.0, \
                    inst a0, f0, f1)

#define TEST_FP_CMP_OP_D( testnum, inst, result, val1, val2 ) \
  TEST_FP_OP_D_INTERNAL( testnum, 0, dword result, val1, val2, 0.0, \
                    inst a0, f0, f1)

#define TEST_INT_FP_OP_S( testnum, inst, result, val1 ) \
test_ ## testnum: \
  li  TESTNUM, testnum; \
  la  a0, test_ ## testnum ## _data ;\
  lw  a3, 0(a0); \
  li  a0, val1; \
  inst f0, a0; \
  fsflags x0; \
  fmv.x.s a0, f0; \
  bne a0, a3, fail; \
  j 1f; \
  .align 2; \
  test_ ## testnum ## _data: \
  .float result; \
1:

#define TEST_INT_FP_OP_D( testnum, inst, result, val1 ) \
test_ ## testnum: \
  li  TESTNUM, testnum; \
  la  a0, test_ ## testnum ## _data ;\
  ld  a3, 0(a0); \
  li  a0, val1; \
  inst f0, a0; \
  fsflags x0; \
  fmv.x.d a0, f0; \
  bne a0, a3, fail; \
  j 1f; \
  .align 3; \
  test_ ## testnum ## _data: \
  .double result; \
1:

#-----------------------------------------------------------------------
# Pass and fail code (assumes test num is in TESTNUM)
#-----------------------------------------------------------------------

#define TEST_PASSFAIL \
        bne x0, TESTNUM, pass; \
fail: \
        RVTEST_FAIL; \
pass: \
        RVTEST_PASS \


#-----------------------------------------------------------------------
# Test data section
#-----------------------------------------------------------------------

#define TEST_DATA

#endif
# See LICENSE for license details.

#*****************************************************************************
# xor.S
#-----------------------------------------------------------------------------
#
# Test xor instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, xor, 0x00ff00ff, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, xor, 0x00000000, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, xor, 0xff00ff00, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, xor, 0x00ff00ff, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, xor, 0 );
  TEST_RR_ZERODEST( 27, xor, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 FF0100B7 F0008093 0F0F1137 F0F10113 0020C1B3 F00FFEB7 00FE8E93
@00000007 00200E13 4BD19063 0FF010B7 FF008093 F0F0F137 0F010113 0020C1B3
@0000000E FF010EB7 F00E8E93 00300E13 47D19E63 00FF00B7 0FF08093 0F0F1137
@00000015 F0F10113 0020C1B3 0FF01EB7 FF0E8E93 00400E13 45D19C63 F00FF0B7
@0000001C 00F08093 F0F0F137 0F010113 0020C1B3 00FF0EB7 0FFE8E93 00500E13
@00000023 43D19A63 FF0100B7 F0008093 0F0F1137 F0F10113 0020C0B3 F00FFEB7
@0000002A 00FE8E93 00600E13 41D09863 FF0100B7 F0008093 0F0F1137 F0F10113
@00000031 0020C133 F00FFEB7 00FE8E93 00700E13 3FD11663 FF0100B7 F0008093
@00000038 0010C0B3 00000E93 00800E13 3DD09A63 00000213 FF0100B7 F0008093
@0000003F 0F0F1137 F0F10113 0020C1B3 00018313 00120213 00200293 FE5210E3
@00000046 F00FFEB7 00FE8E93 00900E13 39D31E63 00000213 0FF010B7 FF008093
@0000004D F0F0F137 0F010113 0020C1B3 00000013 00018313 00120213 00200293
@00000054 FC521EE3 FF010EB7 F00E8E93 00A00E13 37D31063 00000213 00FF00B7
@0000005B 0FF08093 0F0F1137 F0F10113 0020C1B3 00000013 00000013 00018313
@00000062 00120213 00200293 FC521CE3 0FF01EB7 FF0E8E93 00B00E13 33D31063
@00000069 00000213 FF0100B7 F0008093 0F0F1137 F0F10113 0020C1B3 00120213
@00000070 00200293 FE5212E3 F00FFEB7 00FE8E93 00C00E13 2FD19663 00000213
@00000077 0FF010B7 FF008093 F0F0F137 0F010113 00000013 0020C1B3 00120213
@0000007E 00200293 FE5210E3 FF010EB7 F00E8E93 00D00E13 2BD19A63 00000213
@00000085 00FF00B7 0FF08093 0F0F1137 F0F10113 00000013 00000013 0020C1B3
@0000008C 00120213 00200293 FC521EE3 0FF01EB7 FF0E8E93 00E00E13 27D19C63
@00000093 00000213 FF0100B7 F0008093 00000013 0F0F1137 F0F10113 0020C1B3
@0000009A 00120213 00200293 FE5210E3 F00FFEB7 00FE8E93 00F00E13 25D19063
@000000A1 00000213 0FF010B7 FF008093 00000013 F0F0F137 0F010113 00000013
@000000A8 0020C1B3 00120213 00200293 FC521EE3 FF010EB7 F00E8E93 01000E13
@000000AF 21D19263 00000213 00FF00B7 0FF08093 00000013 00000013 0F0F1137
@000000B6 F0F10113 0020C1B3 00120213 00200293 FC521EE3 0FF01EB7 FF0E8E93
@000000BD 01100E13 1DD19463 00000213 0F0F1137 F0F10113 FF0100B7 F0008093
@000000C4 0020C1B3 00120213 00200293 FE5212E3 F00FFEB7 00FE8E93 01200E13
@000000CB 19D19A63 00000213 F0F0F137 0F010113 0FF010B7 FF008093 00000013
@000000D2 0020C1B3 00120213 00200293 FE5210E3 FF010EB7 F00E8E93 01300E13
@000000D9 15D19E63 00000213 0F0F1137 F0F10113 00FF00B7 0FF08093 00000013
@000000E0 00000013 0020C1B3 00120213 00200293 FC521EE3 0FF01EB7 FF0E8E93
@000000E7 01400E13 13D19063 00000213 0F0F1137 F0F10113 00000013 FF0100B7
@000000EE F0008093 0020C1B3 00120213 00200293 FE5210E3 F00FFEB7 00FE8E93
@000000F5 01500E13 0FD19463 00000213 F0F0F137 0F010113 00000013 0FF010B7
@000000FC FF008093 00000013 0020C1B3 00120213 00200293 FC521EE3 FF010EB7
@00000103 F00E8E93 01600E13 0BD19663 00000213 0F0F1137 F0F10113 00000013
@0000010A 00000013 00FF00B7 0FF08093 0020C1B3 00120213 00200293 FC521EE3
@00000111 0FF01EB7 FF0E8E93 01700E13 07D19863 FF0100B7 F0008093 00104133
@00000118 FF010EB7 F00E8E93 01800E13 05D11A63 00FF00B7 0FF08093 0000C133
@0000011F 00FF0EB7 0FFE8E93 01900E13 03D11C63 000040B3 00000E93 01A00E13
@00000126 03D09463 111110B7 11108093 22222137 22210113 0020C033 00000E93
@0000012D 01B00E13 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F
@00000134 FF000513 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
# See LICENSE for license details.

#*****************************************************************************
# xori.S
#-----------------------------------------------------------------------------
#
# Test xori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, xori, 0xffffffffff00f00f, 0x0000000000ff0f00, 0xf0f );
  TEST_IMM_OP( 3, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, xori, 0x0000000000ff0ff0, 0x0000000000ff08ff, 0x70f );
  TEST_IMM_OP( 5, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, xori, 0xffffffffff00f00f, 0xffffffffff00f700, 0x70f );

   #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 8,  1, xori, 0x0000000000ff0ff0, 0x0000000000ff08ff, 0x70f );
  TEST_IMM_DEST_BYPASS( 9,  2, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_SRC1_BYPASS( 10, 0, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 11, 1, xori, 0x0000000000ff0ff0, 0x0000000000ff0fff, 0x00f );
  TEST_IMM_SRC1_BYPASS( 12, 2, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_ZEROSRC1( 13, xori, 0x0f0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, xori, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
/* http://srecord.sourceforge.net/ */
@00000000 00FF10B7 F0008093 F0F0C193 FF00FEB7 00FE8E93 00200E13 1DD19663
@00000007 0FF010B7 FF008093 0F00C193 0FF01EB7 F00E8E93 00300E13 1BD19863
@0000000E 00FF10B7 8FF08093 70F0C193 00FF1EB7 FF0E8E93 00400E13 19D19A63
@00000015 F00FF0B7 00F08093 0F00C193 F00FFEB7 0FFE8E93 00500E13 17D19C63
@0000001C FF00F0B7 70008093 70F0C093 FF00FEB7 00FE8E93 00600E13 15D09E63
@00000023 00000213 0FF010B7 FF008093 0F00C193 00018313 00120213 00200293
@0000002A FE5214E3 0FF01EB7 F00E8E93 00700E13 13D31663 00000213 00FF10B7
@00000031 8FF08093 70F0C193 00000013 00018313 00120213 00200293 FE5212E3
@00000038 00FF1EB7 FF0E8E93 00800E13 0FD31C63 00000213 F00FF0B7 00F08093
@0000003F 0F00C193 00000013 00000013 00018313 00120213 00200293 FE5210E3
@00000046 F00FFEB7 0FFE8E93 00900E13 0DD31063 00000213 0FF010B7 FF008093
@0000004D 0F00C193 00120213 00200293 FE5216E3 0FF01EB7 F00E8E93 00A00E13
@00000054 09D19A63 00000213 00FF10B7 FFF08093 00000013 00F0C193 00120213
@0000005B 00200293 FE5214E3 00FF1EB7 FF0E8E93 00B00E13 07D19263 00000213
@00000062 F00FF0B7 00F08093 00000013 00000013 0F00C193 00120213 00200293
@00000069 FE5212E3 F00FFEB7 0FFE8E93 00C00E13 03D19863 0F004093 0F000E93
@00000070 00D00E13 03D09063 00FF00B7 0FF08093 70F0C013 00000E93 00E00E13
@00000077 01D01463 01C01A63 FF000513 00000593 00B52023 FF5FF06F FF000513
@0000007E 00100593 00B52023 FF5FF06F
/* http://srecord.sourceforge.net/ */
Files in this directory are for repro'ing issues in GCC/Yosys/Icarus/Verilator
and for catching if/when those issues are fixed, so we can start using the newly
not-broken features in Metron.
Files in this directory should pass in all tools.
