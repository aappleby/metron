{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 RobotoMono-SemiBold;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\f0\fs22\cf0
\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch {\f0\fs22\b0\i0 # That seems too simple to call a "paradigm", shouldn't there be more _stuff_ to it?}
\par\plain {\f0\fs22\b0\i0    Nobody was willing to do something as stupid as claim that "x' = f(x)" is a paradigm, so it didn't happen.}
\par\plain \f0\fs22\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs22\b0\i0 ## Wait a second - the phrase \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93atomically change old state into new state\u8221\'94 is so generic as to be meaningless. Of _course_ we change old state into new state, we do it all the time. That isn\u8217\'92t a paradigm, it\u8217\'92s just regular programming.}
\par\pard\plain \tx0\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\ltrch\loch \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 OK, so it's not exactly any of those things. Still, your definition of "temporal programming" sounds rather simplistic - why call it a programming paradigm?}
\par\plain {\f0\fs22\b0\i0     Think about the lack of loops in some functional languages - at first that limitation seems like a annoyance, but once you've gained familiarity with recursion and map/reduce it starts to feel less annoying and more elegant. Going back to a procedural langauge, you might then find yourself annoyed at having to write loops again for something that would be a one-liner in your preferred functional language.}
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 A software developer who tries to read a large chunk of Verilog for the first time is in for a very, very steep learning curve - and it's not a syntax issue. Verilog _looks_ superficially like C but it doesn't _run_ like C, and the explanation that's often given to new devs is something along the lines of "Hardware just doesn't work like that". Which is true, but it's missing the point - The learning curve isn't caused by the language, it's caused by thinking about the problem using the wrong programming paradigm.}
\par\pard\plain \ltrch\loch \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0
\par\plain {\f0\fs22\b0\i0 ## I can already do what you\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92re talking about in \{language\} using \{feature\}, so why coin a new term?}
\par\plain \f0\fs22\b0\i0
\par\plain \f0\fs22\b0\i0}