<?xml version="1.0" encoding="UTF-8"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="03C43B49-1688-4364-BAA5-174AD1C1C2BC">
            <Title>Communicating Sequential Processes</Title>
            <Text> - Communicating Sequential Processes
 - Communicating sequential processes (CSP)
</Text>
        </Document>
        <Document ID="05E1B517-08E4-424E-80EC-8D702270B06A">
            <Title>Learn TLA+</Title>
        </Document>
        <Document ID="06A821B5-F8CD-4801-A0CB-7B35A6D4939D">
            <Title>Synchronous Extensions to Operation-Centric Hardware Description Languages</Title>
            <Text>                Synchronous Extensions to
Operation-Centric Hardware Description Languages

Grace Nordin and James C. Hoe

  Carnegie Mellon University
         Pittsburgh, USA

   {yhn, jhoe}@ece.cmu.edu

                        Abstract                              ically; that is, in each round of state transitions, all transi-
                                                              tions read all state values in one instantaneous step before
   The Abstract Transition System (ATS) is a high-level       the one selected transition writes all state elements in an-
hardware description framework. ATS’s operation-centric       other instantaneous step. Thus, the execution of an ATS can
abstraction permits perspicuous descriptions of complex       be abstractly interpreted as a sequence of atomic applica-
concurrent hardware behavior as a sequence of atomic          tions of transitions, where each transition produces a state
state transitions. However, non-determinism in the ATS        that satisﬁes the predicate of the next transition.
semantics prevents it from capturing the behavior of sys-
tems whose correctness depends upon both function and ex-        The atomic and sequential semantics of ATS do not
act synchronous timing. To address this shortcoming, we       prevent a correct implementation from executing several
present two extensions to ATS—committing transitions and      transitions concurrently. References [9] and [10] describe
synchronously delayed expressions—to support the speciﬁ-      a method for synthesizing ATS into a highly-concurrent
cation of synchronous behaviors and interfaces. The new       clock-synchronous implementation that efﬁciently executes
synchronous extensions compose naturally with the origi-      multiple transitions per clock cycle but still maintain the
nal ATS. We describe a compilation strategy for the syn-      appearance of a sequential and atomic execution. Addi-
chronous extensions that leverages existing ATS synthesis     tional details of ATS and its compilation are described in
capabilities. We also evaluate the new extensions’ ease of    Section 2.
description and synthesis quality in several design exam-
ples.                                                            Despite its various advantages, the non-deterministic se-
                                                              mantics of ATS presents an obstacle to describing hardware
1. Introduction                                               designs that require synchronous and deterministic opera-
                                                              tion. The non-deterministic semantics of ATS says that any
   The Abstract Transition System (ATS), which shares         enabled transition is permitted, but not committed, to exe-
similar semantics as Term Rewriting Systems (TRS) [2]         cute. Hence, an ATS designer could not guarantee that a
and guarded commands [7], was previously proposed for         transition will execute in a particular clock cycle, or even
high-level hardware description and synthesis [9, 10]. ATS    at all. To address this shortcoming, we propose two syn-
hardware description is operation-centric because the de-     chronous extensions to ATS that permit the speciﬁcation of
scription of behavior is organized into atomic operations     synchronous behavior and compose naturally with the orig-
that each affect multiple state elements (rather then next-   inal ATS.
state equations that each control one state element). An
ATS consists of a set of state elements and a set of state       The two extensions are committing transitions and syn-
transitions. An ATS transition comprises a predicate and a    chronously delayed expressions. The resulting ATS+ is in-
set of state-update actions. In a state where the predicates  tended to simplify the description of a hardware system
of several transitions are simultaneously true, any one of    where only a small portion of the overall activity must
those transitions can be selected non-deterministically. The  be synchronous. For example, in a layered communica-
state-update actions of an ATS transition are applied atom-   tion stack, the activities in the upper layers interact with
                                                              asynchronous handshakes (e.g., request/grant), and only the
    00-7803-8509-804$20.00 c 2004 IEEE                        bottom-most physical layer must match the timing of the
                                                              physical medium. When describing a controller for such
                                                              a protocol, we can simplify the speciﬁcation of the upper-
                                                              layers using the original ATS’s simplifying atomic and se-
                                                              quential semantics. At the same time, where necessary, the


AT S = S, So, X                                                   ‘ ’.) In an ATS, if π of transition Tx is enabled in a state
                                                                  s (abbreviated as πTx (s)=true, or simply πTx (s)), then the
S   = R1,.., A1,.., F 1,..                                        concurrent actions prescribed by αTx can be applied atom-
                                                                  ically to update s to δTx (s). We use the notation δTx (s) to
So  = vR1 , .., vA1 , .., vF1 , ..                                mean the resulting state s’ after applying αTx to s; in other
                                                                  words, δTx is the functional equivalent of αTx . Recall from
X   = T1,..,TM                                                    Section 1, the operation-centric transition semantics is non-
                                                                  committing, that is an enabled transition is permitted, but
T   = π,α                                                         not committed to execute.

π   = exp                                                            An R-type register state element can store an integer
                                                                  value up to a speciﬁed maximum word size. The value
α   = aR1 , .., aA1 , .., aF1 , ..                                stored in a register R can be referenced using the side-effect-
                                                                  free get( ) query and set to v using the set(v) action. (In our
aR  =  set(exp)                                                   examples, we abbreviate R.get( ) simply as R and R.set(v)
                                                                  as R:=v.) Figure 1 lists the actions supported for arrays and
aA  =  aset(expidx, expdata)                                      FIFOs; a complete description of ATS, including I/O ele-
       enq(exp) deq()                                             ments, is given in [9]. Without loss of generality, this paper
aF  =                                                             focuses on systems with only R elements.

       endeq(exp) clear()                                         2.2. Compilation

exp = constant R.get()                                               Basic strategy. This paper is concerned with mapping
                                                                  ATS to a clock-synchronous implementation. In the as-
       P rimitiveOp(exp1, .., expn)                               sumed mapping strategy, the elements of S—registers in
                                                                  this case—are instantiated from a design library and the
       A.aget(expidx) F.f irst()                                  transitions in X are combined to form the next-state logic
                                                                  for the instantiated state elements. In each clock cycle, the
       F.notf ull() F.notempty()                                  π expressions of all transitions are evaluated combination-
                                                                  ally and some subset of transitions whose π expression is
    Figure 1. ATS summary                                         asserted is selected to update the state elements on the next
                                                                  clock edge.
physical layer can be described synchronously using the
new ATS+ extensions. The two portions of the design can              In a naive implementation, only one transition is selected
nevertheless be interpreted together under a simple sequen-       in each clock cycle—this automatically satisﬁes the sequen-
tial and atomic interpretation as in the original ATS.            tial and atomic semantics of operation-centric transitions.
                                                                  This naive implementation is functionally correct but in-
   Paper outline. Section 2 provides additional back-             efﬁcient due to a lack of hardware concurrency. The im-
ground on ATS. Section 3 introduces ATS+ extensions.              plementation produced by an ATS compiler in reality em-
Section 4 explains the compilation of ATS+ for hardware           ploys an arbitration logic that selects multiple enabled tran-
synthesis. Section 5 presents an evaluation of ATS+; this         sitions to update state elements concurrently in each clock
evaluation compares ATS+ to Verilog RTL and Esterel. Sec-         cycle, provided the resulting new state values correspond to
tion 6 discusses prior work in operation-centric and syn-         some valid sequence of atomic execution of the same con-
chronous HDLs. Finally, Section 7 presents a summary and          stituent transitions. The ATS compiler generates such an
our conclusions.                                                  arbitration logic based on a static analysis of conﬂict-free
                                                                  (&lt;&gt;CF ) and sequentially-composability (&lt;SC ) properties
2. ATS primer                                                     among the ATS transitions.

   In this section, we present the ATS abstraction. ATS              Arbiter synthesis. &lt;&gt;CF is a symmetric relationship
is an intermediate hardware representation used to support        between two transitions that ensures two transitions could
the compilation of operation-centric source-level languages       be executed correctly in the same clock cycle in a clock-
such as TRSpec [9] and Bluespec [1]. We use ATS to                synchronous implementation. Given Ta and Tb are both ap-
present the ideas in this paper to avoid the complications        plicable in state s, Ta &lt;&gt;CF Tb implies that
of source-level languages.
                                                                    1. applying one transition before the other does not can-
2.1. Overview                                                           cel the applicability of the other (i.e., πTa (δTb (s)) ∧
                                                                        πTb (δTa (s))), and
   ATS is a state-based abstract hardware representation
with operation-centric state transitions. The structure of
ATS is summarized in Figure 1. At the top level, an ATS is
a triple S, So, X . S is a list of explicitly declared state el-
ements, including registers (R), arrays (A), and FIFOs (F ).
So is a list of initial values for the elements in S. X is
a list of transitions, π,α . In a transition, π is a boolean
predicate expression and α is a list of concurrent actions,
with exactly one action for each state element in S. (An
acceptable action for all statement types is the null action


                      (a) T1: A==0 → B:=1                      to execute a number of transitions in sequence, the exe-
                              T2: C==0 → D:=1                  cution of those transitions all observe the same state val-
                                                               ues as latched on the previous clock edge. The second
                      (b) T3: true → B:=A                      characteristic—a direct consequence of the ﬁrst—is that the
                              T4: true → A:=1                  critical delay path of a multi-transition-per-cycle implemen-
                                                               tation is still determined only by the combinational delay of
                      (c) T5: true → B:=A                      the single worst-case transition.
                              T6: true → A:=B
                                                               2.3. Limitations of operation-centric semantics
   Figure 2. Examples of (a) &lt;&gt;CF , (b) &lt;SC , and
   (c) conﬂicting rules. (assume A, B, C, D are                   An enabled ATS transition is permitted, but not commit-
   boolean registers.)                                         ted, to execute. When multiple ATS transitions are enabled
                                                               together, ATS’s abstract semantics allows any one transi-
  2. the two transitions can be applied in either order, in    tion to be selected nondeterministically. Hence, an ATS
      two successive steps, to produce the same ﬁnal state     accepts multiple “correct” versions of deterministic clock-
      (i.e., s’=δTb (δTa (s))=δTa (δTb (s))).                  synchronous implementations. In fact, this freedom is taken
                                                               by the ATS compiler to select a subset of non-conﬂicting
   On the other hand, &lt;SC is an asymmetric relationship        transitions to execute in each clock cycle. The downside of
between two transitions that also ensures two transitions can  this freedom is that although a transition is guaranteed to
be correctly executed in the same clock cycle. The &lt;SC re-     execute only when enabled, a transition is never guaranteed
lationship is less strict than &lt;&gt;CF in that it only requires   to execute on a particular clock cycle, or even at all.
the concurrent execution to agree with one order of exe-
cution. Figure 2 gives examples of &lt;&gt;CF , &lt;SC , and con-          Consequently, ATS lacks the ability to describe a sys-
ﬂicting transitions that cannot be executed in the same clock  tem whose correctness depends both on functionality and
cycle. In these examples, we write a transition π,α con-       the exact timing of events. In BSC, this limitation is ad-
cretely as                                                     dressed by an assert pragma which, when applied to a tran-
                                                               sition, informs the compiler that the transition must execute
   π → R1:=exp1; ... RNR:=expNR;                               if its predicate is enabled. If the compiler cannot correctly
In this notation, we omit registers whose action is ‘ ’ from   guarantee the assertion (e.g., the user labels two conﬂicting
the register-action list. In the &lt;&gt;CF example (a), T1 and      transitions), then the compilation should fail with an error.
T2 read and write two disjoint sets of registers. In the &lt;SC   This assert pragma, in essence, imparts synchronous seman-
example (b), T3 and T4 have a read-write dependence on         tics to the labeled transitions. The assert pragma has been
register A, but concurrent execution of T3 and T4 gives the    successfully used to specify designs with synchronous be-
same result as if T3 is applied before T4 in sequence. In the  havioral constraints. In this paper, we formalize the assert
conﬂicting example (c), a circular dependence between T5       pragma as committing transitions. We also develop the no-
and T6 prevents the two transitions from producing a valid     tation and compilation procedure to enable intuitive integra-
result if executed concurrently.                               tion of synchronous committing transitions with the origi-
                                                               nal non-committing transitions in the same representation
   Formal deﬁnitions of &lt;SC and &lt;&gt;CF are given in [9].         framework.
The same reference also gives theorems that states it is cor-
rect for an ATS compiler to devise an arbitration logic that,  3. Synchronous extensions in ATS+
on each clock cycle, selects an arbitrary subset of enabled
transitions provided                                              We propose two extensions to ATS to support the speciﬁ-
                                                               cation of synchronous behavior. The current formulation of
  1. each pair of transitions is related either by &lt;&gt;CF or     these two extensions assumes the particular synthesis strat-
      &lt;SC , and                                                egy given in [9] and brieﬂy described in Section 2.2. The
                                                               resulting extended system is called ATS+. The ﬁrst exten-
  2. a partial order with respect to &lt;SC exists for the se-    sion is a new class of transitions with committing execu-
      lected transitions.                                      tion semantics. The second extension adds support for syn-
                                                               chronously delayed expressions that enable a transition’s
   Bluespec compiler. The synthesis results in this pa-        predicate and actions to read past values of state elements.
per are produced by the Bluespec Compiler (BSC) [1].           Figure 3 summarizes the structure of ATS+ where it differs
The theorems mentioned above are applied in BSC to pro-        from ATS. As an intermediate representation, the extensions
duce highly concurrent clock-synchronous implementations
from a sequentially conceived and interpreted operation-
centric hardware description. The BSC synthesized im-
plementations have two important characteristics. First,
in each clock cycle, although the implementation appears


AT S+ = S, So, X , Xc                                               3.2. Synchronously delayed expressions

Xc   = Tc1 ,...,TcM                                                    ATS+ with committing transitions has the ability to spec-
                                                                    ify all synchronous hardware behaviors. Unfortunately, de-
Tc   = π,α                                                          scribing synchronous behaviors that span multiple clock pe-
                                                                    riods can be tedious because a committing transition can
exp  = ... “ATS expressions” ...                                    only relate states that are separated by one clock edge. Syn-
                                                                    chronous behaviors that span multiple clock periods must
     exp[expt]                                                      be constructed using a sequence of committing transitions
                                                                    as basic building blocks. Below we introduce two syntactic
     exp[⊕ : expt..expt]                                            shorthands that simplify the speciﬁcation of multiple-cycle
                                                                    synchronous behavior in ATS+.
     Figure 3. ATS+ summary
                                                                       “was” expressions. According to the atomic execu-
in ATS+ enable analogous extensions to be introduced in the         tion semantics, a transition reads the state values before in-
source-level languages.                                             stantaneously updating all state elements. In the synthe-
                                                                    sized clock-synchronous implementation described in Sec-
3.1. Committing transitions                                         tion 2.2, this atomicity is preserved for concurrently exe-
                                                                    cuting transitions in the same clock cycle, even though all
   The deﬁnition of ATS+ includes a new class of commit-            transitions read the same state value latched on the previ-
ting transitions Xc= Tc1 ,....TcN . A committing transition         ous clock edge. This allows us to deﬁne a synchronously
has the same structure π,α as the original ATS transi-              delayed expression exp[t] where (t≥ 0). exp[t] refers to the
tions, which we now refer to as non-committing transitions.         value of exp evaluated t clock cycles ago (in the degenerate
In our examples, we write committing transitions with the           case, exp[0] is effectively exp).
symbol ‘→c’ to differentiate from non-committing transi-
tions. Like non-committing transitions, synchronous tran-              “interval” expressions. Another shorthand is
sitions obey the invariant that they only execute when their        exp[⊕:t..t’] where t’ ≥ t ≥ 0 and exp[⊕:t..t’] means
predicate is true. Furthermore, the execution semantics of
committing transitions remains atomic. Like ATS, the exe-              ((...((exp[t’]⊕exp[t’-1])⊕exp[t’-2])⊕...)⊕exp[t]).
cution of an ATS+ implementation must still correspond to              The user can specify any reduction operator ⊕ appropri-
an interleaving of atomic transitions (both committing and          ate for the datatype of exp. For example, if X is a Boolean
non-committing), where each transition leads to a state that        expression, X[&amp;:1..5] is true if X is true for all ﬁve previous
enables the predicate of the next transition.                       cycles; X[|:1..5] is true if X is true for at least one of the last
                                                                    ﬁve cycles.
   The sequential interleaving of transitions in ATS+ is,              Example. We show a trivial example to further illustrate
however, sectioned into clock periods that each contains one        the syntax and semantics of ATS+ extensions. Additional
or more transitions. The clock periods correspond to the            examples are given in Section 5. Consider T1 and T2,
real clock in a synthesized clock-synchronous implementa-
tion. If a committing transition’s predicate is satisﬁed at the        T1: X[10] &amp; !(Y[&amp;:0..10]) →c A:=B
start of a clock period, then it must be executed in that clock        T2: !X → B:=A
period. Consequently, for a valid ATS+, the set of commit-
ting transitions must be                                            X, Y, A and B are Boolean registers. T1 is a committing tran-
                                                                    sition that enforces the synchronous behavior which says “A
  1. pairwise &lt;&gt;ME1, &lt;&gt;CF or &lt;SC , and                              gets B’s value if X was true 10 clock cycles ago and Y has
                                                                    not been true within the last 10 clock cycles.” T2 is a non-
  2. have a partial-order with respect to &lt;SC .                     committing transition that says “if X is false then B should
                                                                    get A’s value.” However, T2 only executes in a clock cycle
These two conditions ensure all committing transitions that         when the predicate of T1 is false, since T1 and T2 conﬂicts in
could potentially be enabled in the same clock cycle in an          their actions. If T2 were written with ‘→c’ as a committing
implementation can be executed concurrently as required             transition, then T1 and T2 together would not be valid.
by their committing semantics. On the other hand, if a non-
committing transition is enabled in a clock cycle but con-          4. ATS+ compilation
ﬂicts with another enabled committing transition, the non-
committing transition can always be correctly deferred to              Our goal is to map an ATS+ description to a clock-
the next clock cycle.                                               synchronous Verilog RTL description. Our ATS+ compiler
                                                                    is a meta-compiler layered on top of the Bluespec Compiler
    1Ta&lt;&gt;ME Tb implies Ta and Tb have mutually exclusive predicate  (BSC). As shown in Figure 4, the ATS+ compiler compiles
conditions, i.e., ∀s ¬(πTa (s)∧ πTb (s)).


Non−Committing                                                                       T1: true→cRt:=Rt −1,...,Rt:=Rt−1,...,R2:=R1,R1:=exp
                                                                                     T2: pred[((...((Rt ⊕ Rt −1) ⊕ Rt −2) ⊕ ...) ⊕ Rt) /
ATS+ Committing                                Non−committing  Bluespec  Verilog
                                                with ASSERT    Compiler                                  (exp[⊕ : t..t ])] →c action

                                      Source                                      Again T1 creates the equivalent of a shift register chain with
                                                                                  length t’ to hold the delayed values of exp. T2 replaces the
                     Committing                                                   occurrences of exp[⊕:t..t’] in the pred by a direct reduction
                                                                                  of the delayed values between t and t’. The (t==0) case
                                    to−Source                                     requires a trivially different special case.

   Delayed De−Sugar  Translation                                                  4.2. Committing transitions
Expressions
                                                                                     The delayed expressions in an ATS+ are expanded one
             Figure 4. Compilation overview                                       at a time until only committing and non-committing tran-
                                                                                  sitions without delayed expressions remain. In the sec-
an ATS+ description into the equivalent ATS description by                        ond pass of ATS+ compilation, every committing transi-
                                                                                  tion is recast into a non-committing transition annotated by
  1. de-sugaring synchronously delayed expressions, and                           BSC’s assert pragma. The committing transitions need to
  2. translating committing transitions to Bluespec’s non-                        be checked for validity according to the requirement posed
                                                                                  in Section 3.1 (i.e., the committing transitions should be
      committing transitions with the assert pragma.                              pairwise &lt;&gt;ME, &lt;&gt;CF , or &lt;SC ). By design, this validity
The resulting ATS description is sent to BSC for conﬂict                          check coincides with BSC’s existing check for the schedul-
analysis and then synthesis to Verilog RTL. We use com-                           ing of asserted transitions. If BSC cannot schedule all of
mercial tools to complete the synthesis ﬂow below the RTL                         the asserted transitions, it will generate an error. The com-
level.                                                                            mitting transitions generated by the ATS+ compiler during
                                                                                  the delayed expression expansion cannot change the valid-
4.1. Delayed expressions                                                          ity of an ATS+. However, because BSC’s conﬂict analysis
                                                                                  is a conservative approximation, it is possible for a valid set
   The ﬁrst pass of ATS+ compilation expands delayed ex-                          of committing transitions to fail compilation. This issue is
pressions into a set of committing transitions without de-                        discussed as the latter of the two optimizations described
layed expressions.                                                                next.

   “was” expressions. A was expression, exp[t], refers to                         4.3. Optimizations
the value of exp at t cycles ago. First consider the transition,
                                                                                     Interval optimization. For delayed intervals with large
   T0: pred[[exp[t]]] →c action                                                   upper bounds, the shift register chain introduces a high area
                                                                                  overhead. A Boolean interval expression using the reduc-
where “pred[[exp[t]]]” means exp[t] appears in the boolean                        tion operator ‘&amp;’ can be optimized by computing the reduc-
pred expression. Assuming (t&gt;0), the ATS+ compiler ex-                            tion using a saturation counter. This optimization replaces
pands this transition to                                                          a (t’-t+1)-bit section of the shift register chain with a log2
                                                                                  (t’-t+2) -bit counter. This optimization is expressed in the
   T1: true →c Rt:=Rt−1, ..., R2:=R1,R1:=exp                                      expansion below. Given
   T2: pred[[Rt / exp[t]]] →c action
                                                                                     T0: pred[[exp[&amp;: t..t ]]] →c action
where pred[[Rt / exp[t]]] means pred with all occurrences
of exp[t] replaced by Rt. (If t==0, exp[0] simply becomes                         the optimized expansion assuming (t&gt;0) is
exp.)
                                                                                     T1: !exp →c Rctr := (t’-t+1)
   T1 creates the equivalent of a shift register chain of                            T2: exp &amp; Rctr!=0 →c Rctr := Rctr - 1
length t to hold the delayed values of exp from the last t                           T3: pred[[(Rctr == 0)[t − 1]/(exp[&amp; : t..t ])]]→caction
cycles. In T2, all references to exp[t] in pred have been re-
placed by explicit references to Rt. The expansion is analo-                      Rctr is 0 only if exp has been true for the previous (t’-t+1)
gous for a was expression in the actions of a transition.                         consecutive cycles. Thus, exp[&amp;:t..t’] equals (Rctr==0)[t-
                                                                                  1]. Again, the (t==0) requires a trivially different special
   “interval” expressions. Next consider a transition that                        case.
uses an interval expression exp[⊕: t..t’] in its predicate, that
is

   T0: pred[[exp[⊕ : t..t ]]] →c action

Assuming (t&gt;0), the expansion of this transition is


                 T1: X &amp; Y →c A := B                           Table 1. Area in um2 after synthesis and lay-
                 T2: X &amp; !Y →c B := A                          out

                 T3: (X &amp; Y)[3] →c A := B                      Examples            Verilog ATS+
                 T4: (X &amp; !Y)[3] →c B := A
                                                               1 true →c B:= A[5]  344 344
                 T5: X[3] &amp; Y[3] →c A := B
                 T6: X[3] &amp; !Y[3] →c B := A                    2 true →c B:= A[&amp;:5..25] 1688 1688

Figure 5. Examples where delayed expres-                       3 Example 2 (optimized) 979 995
sions obscure dependence
                                                               4 Shared Token 1    1020 1036

                                                               5 Shared Token 2    7897 8106

   Conﬂict analysis. First, consider T1 and T2 in Fig-         Table 2. Cycle time in nanoseconds after syn-
ure 5. BSC’s conﬂict analysis can easily recognize that the    thesis and layout
two transitions have mutually exclusive predicates on the
value of Y. Therefore, T1 and T2 are valid and synthesiz-      Examples            Verilog ATS+
able together even though their actions are neither &lt;&gt;CF
nor &lt;SC . Next consider T3 and T4 with predicates that are     1 true →c B:= A[5]  0.14 0.14
mutually exclusive delayed expressions. In this case, after
de-sugaring, the actions of T3 and T4 are each predicated      2 true →c B:= A[&amp;:5..25] 0.15 0.15
by values of delay registers that corresponds to the values
of (X&amp;Y) and (X&amp;!Y) from 3 cycles ago. In this case, BSC       3 Example 2 (optimized) 0.15 0.14
would fail to recognize that the delayed predicate values are
mutually exclusive since they appear to be coming from two     4 Shared Token 1    0.15 0.16
uncorrelated registers. T3 and T4 would not be synthesiz-
able by BSC although they are valid together.                  5 Shared Token 2    0.17 0.18

   To fully expose the data dependencies between transi-       In Tables 1 and 2, we report the synthesized area and cy-
tions to BSC, the ATS+ compiler pushes the delay of an         cle time of ATS+ and RTL Verilog examples. The results
expression down into its variables, as shown in transitions    are generated using Synopsis Design Compiler for a com-
T5 and T6. After common sub-expression elimination, the        mercial 0.18um standard cell library. In these examples,
expression Y[3] in the de-sugared version of both T5 and T6    the quality of the circuits generated from ATS+ description
would be replaced by references to the same delay register.    through BSC and from hand-coded Verilog are very similar.
Thus, BSC would be able to deduce T5 &lt;&gt;ME T6, and suc-         In the ﬁrst two examples based on standalone primitives,
cessfully synthesize these two transitions together. How-      the circuits synthesized from ATS+ through BSC are es-
ever, the push transformation increases the number of shift-   sentially identical to those synthesized directly from hand-
register chains in a design since each delayed variable uses   coded RTL and therefore have the same area and cycle time.
its own chain. Therefore, BSC is actually invoked twice        In addition, we synthesized the interval expression example
by our ATS+ compiler. First, pushed transitions are com-       both with and without the optimization discussed in Sec-
piled by ATS+ compiler and then BSC to enable the most         tion 4.3. We compare the result to a Verilog counterpart that
precise conﬂict analysis possible. To produce the more ef-     has been manually converted to use counters. The counter
ﬁcient implementation, the ATS+ compiler and BSC are in-       optimization achieves the expected area reduction. The de-
voked again with the unmodiﬁed transitions, annotated with     gree of impact from this optimization is a function of the
pragmas to override BSC’s analysis.                            interval length.

5. Results                                                        Delayed expressions primitives. We ﬁrst compare how
                                                               simple ATS+ delayed expressions would be expressed in
   In this section, we compare ATS+ to hand-coded Ver-         Verilog RTL and Esterel. The two primitive statements are
ilog RTL, and the synchronous language Esterel [5] in terms
of ease of description. We compare ATS+ synthesis qual-          1. was expression: true →c B:= A[5]
ity to Verilog RTL synthesis. The examples used include
standalone primitive statements as well as small examples.       2. interval expression: true →c B:= A[&amp;:5..25]

                                                               Equivalent statements in Esterel and Verilog are given in
                                                               Figure 6.2 In both examples, because neither Esterel nor

                                                                   2To conserve space, we omit the matching end statements in Esterel
                                                               and Verilog examples.


ATS+                   ATS+                                                       T0: true →c Token := (Token + 1) % 3;
true →c B:=A[5];       true →c B := A[&amp;: 5..25];                                  T1: Token==0, Req0 →c Ack:=001, Free:=False;
                                                                                  T2: Token==1, Req1 →c Ack:=010, Free:=False;
Esterel                Esterel                                                    T3: Token==2, Req2 →c Ack:=100, Free:=False;
loop                   loop                                                       T4: Free, Req0 → Ack:=001, Free:=False;
                                                                                  T5: Free, Req1 → Ack:=010, Free:=False;
  present pre(A)         trap T in                                                T6: Free, Req2 → Ack:=100, Free:=False;
    then emit A1 end;       repeat 20 times
                              pause;                                   Figure 8. ATS+ description of the arbiter in
  present pre(A1)             present A else exit T end;               Shared Token 2.
    then emit A2 end;       loop
    :                         pause;                                Verilog support references to values more than one cycle
                              present A then emit X                 ago, the equivalent expression has to be explicitly con-
  present pre(A4)                else exit T end                    structed from single-cycle primitives.
    then emit B end;
                          loop                                         Shared token example 1. This example is based on an
  pause;                   present pre(X) then emit X1 end;         arbiter that manages the sharing of a common resource be-
                           present pre(X1) then emit X2 end;        tween two clients with the help of a token. A client is al-
Verilog                    :                                        lowed to use the resource if it logically possesses the token.
  always @(clk) begin      present pre(X4) then emit B end;         A client must maintain its request signal until it is granted
    B &lt;= A4;               pause;                                   the token. This example has a hard synchronous require-
    A4 &lt;= A3;                                                       ment that a client must be granted a token within 10 cycles
    :                  Verilog                                      or less. Excerpts of descriptions for this arbiter in ATS+,
    A1 &lt;= A;             always @(clk) begin                        Verilog and Esterel are shown in Figure 7.
                            B &lt;= A3
                            A3 &lt;= A2;                                  The ATS+ description speciﬁes the above requirements
                            :                                       with four transitions. The ﬁrst two are committing tran-
                            A1 &lt;= (ctr==0);                         sitions that specify the synchronous requirement, i.e., if a
                            ctr &lt;= A ? (ctr ? ctr - 1 : 0 ) : 21 ;  client has been waiting for 10 cycles, then the token must
                                                                    be taken from the other client. The last two non-committing
Figure 6. Code comparison of delayed expres-                        transitions say a client may get the token upon request,
sions primitives                                                    provided there are no other committing or non-committing
                                                                    transitions that conﬂict with the token grant.
  ATS+
    ReqA[&amp;:0..10], Token !=A →c Token := A;                            The equivalent Esterel description consists of three par-
    ReqB[&amp;:0..10], Token !=B →c Token := B;                         allel loops. We use the ﬁrst two loops to keep track of ten
    ReqA → Token := A;                                              successive requests. It is important to point out that since
    ReqB → Token := B;                                              both Esterel and Verilog are deterministic, their descriptions
                                                                    must ﬁx a priority for what happens if both clients request
  Esterel                                                           the token but neither has waited without a token for 10 cy-
    loop                                                            cles.
       trap T in
         repeat 10 times pause; present ReqA else exit T end;          Shared token example 2. We present another shared-
         end repeat;                                                token arbiter. Only excerpts of the ATS+ description are
         loop                                                       shown in Figure 8. This arbiter handles requests from three
           pause; present ReqA then emit TenReqAs else exit T end;  clients for a shared resource and uses a circulating token
       (Similar Loop for TenReqBs)                                  that cycles among the clients to determine priority. The
       loop                                                         ﬁrst transition circulates the token among the three clients.
       present TenReqAs then                                        The next three committing transitions indicate that a re-
         if not(?Token = 0) then pause; emit Token(0)               quest from the client who currently holds the token will be
         else present TenReqBs then                                 granted right away. The ﬁnal three non-committing transi-
           if not(?Token = 1) then pause; emit Token(1)             tions handle granting the request to a client without a to-
           else present ReqA then pause; emit Token(0)              ken if the token holder is not requesting in the same cycle.
              else present ReqB then pause; emit Token(1)           Non-committing transitions are ideal in these latter scenar-
   Verilog                                                          ios since these events do not have hard synchronous require-
   always @(posedge CLK) begin                                      ments. This exempliﬁes the use of non-determinism to un-
         Token &lt;= Tokennxt;
         if (ReqA) ReqActr &lt;= ReqActr + 1;
         else ReqActr &lt;= 0;
         if (ReqB) ReqBctr &lt;= ReqBctr + 1;
         else ReqBctr &lt;= 0;
   always @(*) begin
       if ((ReqActr == 10) &amp;&amp; (Token != 0)) Tokennxt = 0;
       else if ((ReqBctr == 10) &amp;&amp; (Token != 1)) Tokennxt = 1;
       else if (ReqA) Tokennxt = 0;
       else if (ReqB) Tokennxt = 1;
       else Tokennxt = Token;

Figure 7. Code comparison of arbiter in
shared token 1.


burden the designer of “don’t care” decisions.                 and to Verilog RTL in synthesis quality. We show that ATS+
                                                               enables compact descriptions of complex synchronous and
6. Related work                                                asynchronous behavior and permits efﬁcient synthesis to
                                                               clock-synchronous implementations.
   ATS is an high-level hardware representation based on
operation-centric state transitions. ATS descriptions are not  Acknowledgements
behavioral descriptions [4] in that an ATS description is not
a procedural description with sequential control ﬂow (as in       We like to thank Bluespec, Inc. for providing access and
C or behavioral Verilog.) ATS is developed as an interme-      support to the Bluespec language and compiler.
diate representation for the compilation of TRSpec [9] and
is currently also used to support Bluespec [1]. Our synthe-    References
sis ﬂow uses the Bluespec operation-centric language and
compiler.                                                        [1] L. Augustsson, et al. Bluespec: Language deﬁnition.
                                                                      http://www.bluespec.org, 2001.
   The ATS model of computation is inspired by Term
Rewriting Systems (TRS) [2], a well-known reduction for-         [2] F. Baader and T. Nipkow. Term Rewriting and All That.
malism with lineage from Lambda calculus. ATS is also                 Cambridge University Press, 1998.
similar to Dijkstra’s guarded commands [7]. Similar seman-
tics has also served as the basis of parallel programming        [3] A. Benveniste, et al. The synchronous languages twelve
languages [6], hardware description languages for syn-                years later. Proc of IEEE, 91(1), Jan 2003.
chronous and asynchronous design synthesis [13, 15, 16],
and languages for hardware design veriﬁcation [12, 14].          [4] R. A. Bergamaschi. Behavioral synthesis: An overview. TR
                                                                      20944, IBM T.J. Watson Research Center, Aug 1997.
   ATS+ supports the natural speciﬁcation of synchronous
and asynchronous behaviors in the same framework. The            [5] G. Berry. Proof, Language and Interaction: Essays in Hon-
synchronous subset of ATS+ is a simple synchronous lan-               our of Robin Milner, chapter The Foundations of Esterel.
guage. “Synchronous languages” [3] refer to a class of for-           MIT Press, 2000.
mal speciﬁcation/programming languages that are exempli-
ﬁed by Esterel [5], Lustre [8] and Signal [11]. Synchronous      [6] K. M. Chandy and J. Misra. Parallel Program Design.
languages typically offer 1. a discrete model of time, 2.             Addison-Wesley, 1988.
explicit expressions of concurrency, and 3. a deterministic
compiled behavior.                                               [7] E. W. Dijkstra. Guarded commands, nondeterminacy, and
                                                                      formal derivation of programs. In Comm of ACM, volume
7. Conclusions                                                        18(8), Aug 1975.

   In this paper, we presented committing transitions and        [8] N. Halbwachs, et al. The synchronous data ﬂow program-
synchronously delayed expressions as two synchronous ex-              ming language LUSTRE. Proc of IEEE, 79(9), Sept 1991.
tensions to ATS. These two new synchronous language ele-
ments enable ATS+ to capture both synchronous and asyn-          [9] J. C. Hoe. Operation-Centric Hardware Description and
chronous behaviors in the same hardware description. The              Synthesis. PhD thesis, Massachusetts Institute of Technol-
intent is to allow the original ATS’s simplifying atomic and          ogy, Jun 2000.
sequential semantics to assist in the description of com-
plex concurrent internal behaviors, and in the same de-        [10] J. C. Hoe and Arvind. Synthesis of operation-centric hard-
scription, the synchronous extensions are used to describe            ware descriptions. In International Conference on Computer
synchronous interfaces to external modules or internal syn-           Aided Design. IEEE, July 2000.
chronous IP blocks.
                                                               [11] P. Le Guernic, et al. Programming real-time applications
   We described the compilation of the synchronous exten-             with SIGNAL. Proc of IEEE, 79(9), Sept 1991.
sions using existing ATS synthesis capabilities (i.e., BSC).
Namely, synchronously delayed expressions are expanded         [12] T. Lee et al. Automatic veriﬁcation of asynchronous circuits.
into automatically generated committing transitions, and              IEEE Design and Test of Computers, 12(1), Spring 1995.
both the user and the generated committing transitions
are translated into non-committing transitions annotated by    [13] A. P. Ravn and J. Staunstrup. Synchronized transitions. TR
BSC’s assert pragma. In our evaluation, we compared ATS+              AAR-219, University of Aarhus, 1987.
to Verilog RTL and Esterel in terms of ease of description
                                                               [14] V. M. Rodrigues and F. R. Wagner. Synchronous transitions
                                                                      and their temporal logic. In Proc. Workshop de Me´todos
                                                                      Formais, 1998.

                                                               [15] J. Staunstrup and M. R. Greenstreet. From high-level de-
                                                                      scriptions to VLSI circuits. BIT, 28(3), 1988.

                                                               [16] J. Staunstrup and M. R. Greenstreet. Formal Methods for
                                                                      VLSI Design, chapter 2. Kluwer, 1994.
</Text>
        </Document>
        <Document ID="06BDE2E2-EC67-4265-ADF2-217ADFA5208E">
            <Title>The Essence of Bluespec</Title>
            <Text>a synchronous digital circuit transforms old statet into new state every clock cycle. 

</Text>
        </Document>
        <Document ID="07B0D7C6-57CE-4D6F-8AD9-11F06A261A5F">
            <Title>Notes</Title>
        </Document>
        <Document ID="09A53032-CCC7-4F95-B226-D0A8B5427C16">
            <Title>Averest/Quartz</Title>
            <Text> - Averest / Quartz
   - Lots of examples http://www.averest.org/#documentation_Quartz_examples
   - http://www.averest.org/examples/Quartz/EmbeddedSystems/CruiseControl/CruiseControl.html
       - this is probably a good example of implicit state in the pc
   - &quot;Averest is the result of still ongoing research efforts of the chair on embedded systems at the department of computer science of the university of Kaiserslautern&quot;
   - http://www.averest.org/examples/Quartz/EmbeddedSystems/Elevator.html
      - There is _implicit_ state in the position of the program counter!
      - There's still an imaginary chef
      - hell there's an explicit loop :P
   - Presentation in 2021
   - &quot;pause&quot; keyword but no old/new
   - &quot;the ordering of microsteps in a macrostep does not matter&quot;
   - &quot;Dynamic scheduling of micro steps&quot; - eh, I don't like that
      - well yeah you have to do that because you're not distinguishing old and new
      - they patch around it with next(x)
   Some of the existing synchronous languages are &quot;weird&quot;
      Quartz has a _lot_ of new kinds of statements
         even the presentation shows a &quot;how not to do it&quot; example








 - “http://www.averest.org/pdf/QuartzPresentation.pdf”
</Text>
        </Document>
        <Document ID="0A8AC0AD-E008-4821-B5B1-2CEF6318E625">
            <Title>The Definition</Title>
            <Text>Temporal programs atomically change old state into new state.</Text>
        </Document>
        <Document ID="0C4BE6E3-50F0-482E-9F7D-C59722065F40">
            <Title>Code Examples</Title>
            <Text>struct TapePlayer {
   bool locked = false;
   bool playing = false;

   void update(bool play, bool stop, bool lock, bool unlock) {
      if (locked &amp;&amp; unlock) @locked = false;
      if (lock) @locked = true;
      if (!@locked) {
         if (play) @playing = true;
         if (stop) @playing = false;
      }
   }
}





for (int i=0; i&lt;512; i++) {
  float x2 = x*x - y*y + cx;
  float y2 = 2.0*x*y + cy;
  x = x2;
  y = y2;
}

for( int i=0; i&lt;512; i++ ) {
  x@ = x*x - y*y + cx;
  y@ = 2.0*x*y + cy;
}





struct FDIV2 {
   bool c;
   void update() {
      @c = !c;
   }
}

struct Fibonacci {
   int a = 1;
   int b = 1;
   void update() {
      @a = b;
      @b = a + b;
   }
}

struct Switch {
   bool s = false;
   void update(bool on, bool off) {

   }
}

struct Counter {
   int c;
   void update(bool reset, bool x) {
      @c = reset ? 0 : c + x;
   }
}

struct Stopwatch {
   int count = 0;
   int time = 0;  
   bool running = 0;
   bool frozen = 0;
   void update(bool on_off, bool reset, bool freeze) {
      @running = running ^ @on_off;
      @frozen = frozen ^ @freeze;
      @count = @reset ? 0 : @running ? count + 1 : count;
      @time = @frozen ? time : @count;
   }
}



struct TapePlayer {
   bool locked = false;
   bool playing = false;

   void update(bool play, bool stop, bool lock, bool unlock) {
      if (locked &amp;&amp; unlock) @locked = false;
      if (lock) @locked = true;
      if (!@locked) {
         if (play) @playing = true;
         if (stop) @playing = false;
      }
   }
}




struct Clock {
   int second;
   int minute;
   int hour;

   void update(int clock) {
      if (posedge(clock)) {
         second@ = second + 1;
      }
      if (second@ == 60) {
         second@ = 0;
         minute@ = minute + 1;
      }
      if (minute@ == 60) {
         minute@ = 0;
         hour@ = hour@ + 1;
      }
      if (hour@ == 24) {
         hour@ = 0;
      }
   }

   void some_other_update() {
      if (second@ == 0 &amp;&amp; minute@ == 0 &amp;&amp; hour@ == 0) {
         printf(&quot;Happy new year!
&quot;);
      }
   }
}</Text>
        </Document>
        <Document ID="0F74FC65-0340-4362-85CC-82B0A85DE507">
            <Title>FAQ</Title>
        </Document>
        <Document ID="11F17ADB-ACAC-46E0-960F-F82E55B818FE">
            <Title>Functional Reactive Programming?</Title>
            <Text>You’re just redefining reactive programming / functional reactive programming.
    “A := b + c” continuously assigns to a

</Text>
        </Document>
        <Document ID="13468B2E-9F37-4E3F-863F-90135FD9FE39">
            <Title>Checking statistical properties of protocols using TLA+</Title>
        </Document>
        <Document ID="15132E5A-F0FA-4410-AD84-B7E52C9204BA">
            <Title>Temporal Programming in C</Title>
        </Document>
        <Document ID="1564A019-0064-43E0-85B9-FAD25BC2509E">
            <Title>Bluespec</Title>
        </Document>
        <Document ID="16E6C956-C9B3-4FE7-A803-28FD5AC827BF">
            <Title>Bluespec SystemVerilog User Guide</Title>
            <Text>   Bluespec SystemVerilog
           User Guide

       Revision: 24 November 2008
Copyright c 2000 – 2008 Bluespec, Inc.

                              1


Contents

Table of Contents             2

1 Getting Started             6

1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.2 Making sure you’re ready to go . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.3 Quick Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.4 Components of BSV Release . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.5 License Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.6 Utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2 Designing with Bluespec     9

2.1 Components of a BSV Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.2 Overview of the BSV process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.3 Using the Main Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

2.3.1 Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.3.2 Command Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3 Managing Projects           12

3.1 Creating a Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.2 Setting Project Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.2.1 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.2.2 Compile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

3.2.3 Link/Simulate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.2.4 Editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

3.2.5 Waveform Viewer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

3.3 Editing Files with the Project Files Window . . . . . . . . . . . . . . . . . . . . . . . 19

3.4 Saving a Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.4.1 Saving Window Placement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.4.2 Backup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.4.3 Export Makeﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.5 Maintaining Multiple Settings for a Single Design . . . . . . . . . . . . . . . . . . . . 22

4 Building a Project          22

4.1 Type Check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

4.2 Compile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

4.2.1 Compiling a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

4.2.2 Compiling a Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

                           2


      4.2.3 Specifying modules for code-generation . . . . . . . . . . . . . . . . . . . . . 24
      4.2.4 Importing other packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
      4.2.5 Understanding separate compilation . . . . . . . . . . . . . . . . . . . . . . . 26
      4.2.6 Interfacing to foreign modules and functions . . . . . . . . . . . . . . . . . . . 27
4.3 Link . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
      4.3.1 Linking with Bluesim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
      4.3.2 Creating a SystemC Model Instead of a Bluesim Executable . . . . . . . . . . 30
      4.3.3 Linking with Verilog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.4 Simulate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.5 Full Rebuild . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.6 Stop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
4.7 Clean and Full Clean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

5 Analyzing the Project     35

5.1 Viewing Packages with the Package Window . . . . . . . . . . . . . . . . . . . . . . . 35

5.2 Viewing Types with the Type Browser . . . . . . . . . . . . . . . . . . . . . . . . . . 37

5.3 Viewing Waveforms with the Module Browser . . . . . . . . . . . . . . . . . . . . . . 38

5.4 Analyzing the Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

5.4.1 Warnings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

5.4.2 Rule Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

5.4.3 Method Call . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

5.4.4 Rule Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

5.5 Viewing Scheduling Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

5.5.1 Conﬂict . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

5.5.2 Execution Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

5.5.3 Urgency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

5.5.4 Combined . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

5.5.5 Combined Full . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

6 BSC ﬂags                  46

6.1 Common compile and linking ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

6.2 Controlling default ﬂag values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

6.3 Verilog back-end . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

6.4 Resource scheduling (all back ends) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

6.5 Setting the path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

6.6 License-related ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

6.7 Miscellaneous ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

6.8 Run-time system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

                         3


6.9 Automatic recompilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
6.10 Compiler transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
6.11 Compiler optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
6.12 BSV debugging ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
6.13 Understanding the schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
6.14 C/C++ ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

7 Compiler messages     57

7.1 Warnings and Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

7.1.1 Type-checking Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

7.1.2 Scheduling Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

7.1.3 Path Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

7.2 Other messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

7.2.1 Compilation progress . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

7.2.2 Scheduling information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

8 Verilog back end      63

8.1 Bluespec to Verilog name mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

8.1.1 Interfaces and Ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

8.1.2 State elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

8.1.3 Rules and related signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

8.1.4 Other signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

8.2 Verilog header comment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

9 Bluesim back end      72

9.1 Bluesim tool ﬂow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

9.2 Bluesim simulation ﬂags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

9.3 Interactive simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

9.3.1 Command scripts for Bluesim . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

9.4 Value change dump (VCD) output . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

9.5 Bluesim multiple clock domain support . . . . . . . . . . . . . . . . . . . . . . . . . . 79

A Bluetcl Reference     80

A.1 Invoking Bluetcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

A.2 Packages and namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

A.3 Customizing Bluetcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

A.4 General Bluetcl package command reference . . . . . . . . . . . . . . . . . . . . . . . 81

A.4.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

A.4.2 Bluetcl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

                     4


      A.4.3 Bluesim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
      A.4.4 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
      A.4.5 InstSynth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
A.5 Workstation package command reference . . . . . . . . . . . . . . . . . . . . . . . . . 90
      A.5.1 Help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
      A.5.2 WS::Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
      A.5.3 WS::Build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
      A.5.4 WS::File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
      A.5.5 WS::Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
      A.5.6 WS::Wave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
      A.5.7 WS::Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
A.6 Customizing the Workstation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
      A.6.1 Bluetcl interpreters in the workstation . . . . . . . . . . . . . . . . . . . . . . 96
      A.6.2 Adding items to the toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
A.7 Bluetcl Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
      A.7.1 expandPorts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

Index                     99

Commands by Namespace     102

                       5


1 Getting Started

1.1 Introduction

This document explains the mechanics and logistics of compiling and simulating a Bluespec Sys-
temVerilog (BSV) speciﬁcation. Bluespec SystemVerilog includes the development workstation, a
full-featured graphical environment for designing with Bluespec. You can create, edit, compile, sim-
ulate, analyze, and debug Bluespec designs from within the workstation or from the command line.
You can choose the editors, simulators, and waveform viewers to use along with Bluespec-based
analysis tools. The development workstation builds on Bluetcl, a collection of Tcl extensions,
scripts, and packages providing Bluespec-speciﬁc extensions to Tcl. A Bluetcl reference is provided
in Appendix A.

Please refer to the BSV Reference Guide, style guide, and tutorials for information on how to design
and write speciﬁcations in the Bluespec SystemVerilog environment.

1.2 Making sure you’re ready to go

The BSV system runs on both 32 bit and 64 bit Linux platforms. To generate simulation executables
using the Bluesim backend, your machine will need to have a C++ compiler installed which is
compatible with the default compiler used in the release. Recommended conﬁgurations can be
found in README.txt in the install directory, along with installation instructions.

The exact installation details for BSV may vary with diﬀerent computing environments. The fol-
lowing are examples of setting the Unix environment variables for common shells. Note that the
BLUESPECDIR variable must be set, while BLUESPEC HOME is a convenience.

# Bluespec Environment for csh/tcsh

setenv BLUESPEC_HOME /tools/Bluespec-yyyy.mm

setenv BLUESPECDIR $BLUESPEC_HOME/lib

setenv PATH  ${PATH}:${BLUESPEC_HOME}/bin

# Bluespec Environment for bash/ksh
export BLUESPEC_HOME=/tools/Bluespec-yyyy.mm
export BLUESPECDIR=$BLUESPEC_HOME/lib
export PATH=$PATH:$BLUESPEC_HOME/bin

1.3 Quick Start

Once Bluespec is installed, and the Unix environment variables are set, execute the command
bluespec to start the development workstation:

                                                           bluespec

This command brings up main workstation window, from which you can perform all Bluespec tasks.
You can also add the name of an existing Bluespec project ﬁle as you start the workstation:

                                              bluespec project.bspec

where project.bspec is the project ﬁle name. This starts the workstation and opens the project.
The project ﬁle contains the saved project preferences and settings.
From the command line, you can invoke the BSV compiler with:

                                              bsc arguments

             6


1.4 Components of BSV Release

BSV is released with the following components:

    • The BSV language syntax: BSV allows a designer to develop a high-level, behavioral, hardware
       design utilizing atomic rules, which can be compiled to a Verilog RTL design. For a complete
       description of the BSV language, refer to the BSV Reference Guide.

    • BSV compiler: The compiler takes BSV syntax and generates a hardware description, for
       either Verilog or Bluesim.

    • Library packages: BSV is shipped with a growing set of libraries which provide common and
       useful programming idioms and hardware structures.

    • Verilog modules: Several primitive BSV elements, such as FIFOs and registers, are expressed
       as Verilog primitives.

    • Bluesim: a cycle simulator for BSV designs.
    • Bluetcl: a collection of Tcl extensions, scripts, and packages to link into a Bluespec design.

Also included is a complete set of documentation, including tutorials, examples and white papers.
The $BLUESPEC HOME/doc/BSV directory contains this user guide, the BSV Reference Guide, a style
guide and a known problems and solutions reference (kpns).

    • User Guide: This manual which explains how to run the development workstation, the compiler
       (binary), what ﬂags are available, and how to read the tool output.

    • BSV Reference Guide: The BSV Reference Guide is a stand-alone reference that fully describes
       the subset of SystemVerilog supported by the Bluespec Compiler.

    • Style Guide: The style guide is a supplement that describes styles and patterns to help designers
       express their designs in the Bluespec environment.

    • KPNS: The known problems and solutions (kpns) describe some known issues with the compiler
       and their solutions.

All of the documentation, along with tutorials, papers, and examples can be accessed from the
Help→BSV option on the main toolbar of the development workstation. There is also available a
hyperlinked documentation index, index.html, installed in the $BLUESPEC HOME directory.
The workstation consists of a set of windows and browsers providing diﬀerent views of the design.
The particular window used for a task depends on the information you want to see and the stage of
the design. The following table summarizes the windows and browsers in the workstation.

                                                                7


                          Bluespec Workstation Windows

Stage             Window                       Function

All               Main Window                  Central control window. Manage projects, set
Pre-elaboration   Project Files Window         project options, build projects, and monitor
                  Package Window               status.
Post-elaboration                               View, edit and compile ﬁles in the project.
                  Type Browser                 Load packages into the workstation and browse
                                               their contents. Provides a high-level view of
                  Module Browser               the types, interfaces, functions and modules
                  Schedule Analysis Window     deﬁned in the package.
                  Scheduling Graphs            Primary means for viewing information about
                                               types and interfaces. Displays the full struc-
                                               ture hierarchy and all the concrete types de-
                                               rived from resolution of polymorphic types.
                                               Displays the design hierarchy and an overview
                                               of the contents of each module. Links to exter-
                                               nal waveform viewers.
                                               View schedule information including warnings,
                                               method calls, and conﬂicts between rules for a
                                               module.
                                               Graphical view of schedules, conﬂicts, and de-
                                               pendencies.

Within the development workstation you choose the editors, Verilog simulators, and waveform view-
ers to use along with Bluespec-speciﬁc analysis tools. The following third-party products can be
accessed from the workstation but are not provided by Bluespec:

• Editors: gvim and emacs
• Verilog Simulators: modelsim, ncverilog, vcs, vcsi, cver, iverilog, and veriwell
• Waveform Viewers: SpringSoft/Novas (Verdi, Debussy, nWave)
• Graph Software: graphviz

The package graphviz, including the Tcl extensions, must be installed to use the scheduling graphs
in the development workstation. The graphviz Tcl extensions (TclDot) must be compatible with
Tcl 8.5 to work with the development workstation. You may need to adjust the autopath for the
graphvix package in the ﬁle $HOME/.bluetclrc for your installation.

1.5 License Files

Bluespec utilizes the FLEXnet licensing package. A Bluespec-issued license ﬁle must be installed
before you can use BSV.

All licensing ﬁles are located in the $BLUESPEC HOME/util/flexlm directory. This directory contains
FLEXnet licensing executables and Bluespec speciﬁc daemons. The subdirectories are speciﬁc to
machine architecture and operating system. The README ﬁle lists the daemons currently supported
by Bluespec, as well as directions for editing the license ﬁle.

Refer to the FLEXnet user guide, LicensingEndUserGuide.pdf, for more details on managing
and running the FLEXnet licensing package. Bluespec ﬂags relating to licensing are discussed in
Section 6.6.

                                            8


1.6 Utilities

Bluespec provides BSV editing modes for the editors emacs, vim, and jedit. The ﬁles are in
subdirectories in the $BLUESPEC HOME/util directory. Each directory contains a README ﬁle with
installation instructions for the editor.

The $BLUESPEC HOME/util directory also contains an GNU enscript .st ﬁle for printing Bluespec
SystemVerilog language ﬁles. A README ﬁle in the directory contains instructions for installation
and use.

2 Designing with Bluespec

2.1 Components of a BSV Design

A BSV program consists of one or more outermost constructs called packages. All BSV code is
assumed to be inside a package. Furthermore, the BSV compiler and other tools assume that there
is one package per ﬁle, and they use the package name to derive the ﬁle name. For example, a
package called Foo is assumed to be located in the ﬁle Foo.bsv.

When using the Bluespec development workstation you will also have a project ﬁle, (project-
name.bspec), which is a saved collection of options and parameters. Only the development work-
station deﬁnes project ﬁles; you do not have a .bspec project ﬁle if you use Bluespec completely
from the Unix command line.

The design may also include Verilog modules and C functions. Additional ﬁles will be generated as a
result of the compile, link, and simulation tasks. Some ﬁles are only generated for a particular back
end (Bluesim or Verilog), others are used by both back ends. The following table lists the diﬀerent
ﬁle types and their roles.

           File Types in the life of a BSV Design

File Type  Description                                 Bluesim Verilog

.bsv       BSV source File                             √  √
.bspec     Workstation project File
                                                       √  √

The .bi and .bo ﬁles are intermediate ﬁles not viewed b√y the user √
.bi        Text ﬁle containing information about the

           items exported from the package             √  √

.bo        Binary ﬁle containing code for the package

           in an intermediate form

.ba        Elaborated module ﬁle                       √  √

.v         Generated Verilog ﬁle                          √

.h         C++ header ﬁles                             √

.cxx       Generated C++ source ﬁle                    √

.o         Compiled object ﬁles                        √

.so        Compiled shared object ﬁles                 √

2.2 Overview of the BSV process

This section provides a brief overview of the stages of designing with BSV. Later sections contain
more detailed explanations of the compilation and linking processes. Refer to Section 6 for a complete

                                     9


listing of the ﬂags available for guiding the compiler. All ﬂags can be used both from within the
development workstation or directly from the Unix command line.
Designing with BSV has three distinct stages. You can use the Bluespec development workstation
or the Unix command line throughout each stage of the process. Figure 1 illustrates the following
steps in building a BSV design:

   1. A designer writes a BSV program, including Verilog and C components as desired.
   2. The BSV program is compiled into a Verilog or Bluesim speciﬁcation. This step is comprised

       of two distinct stages:
        (a) pre-elaboration - parsing and type checking
        (b) post-elaboration - code generation
   3. The compilation output is either linked into a simulation environment or processed by a syn-
       thesis tool.

                                           Figure 1: BSV compilation stages
We use the compilation stage to refer to the two steps, type checking and code generation, as shown
inside the dotted box in Figure 1. As the ﬁgure shows, the code generation speciﬁcation that is
output by the BSV compiler is subject to a second run of the compiler to link it into a simulation
or synthesis environment. We refer to this as the linking stage, even though the same compiler is
used to perform the linking. The BSV compiler is required to link Bluesim generated modules. For
Verilog, the generated modules can be handled as you would any other Verilog modules; they can

                                                                10


be linked with the Bluespec compiler or you can choose to use the generated Verilog ﬁles manually
instead.
You perform the above actions: compile, link, and simulate, from the Build menu (Section 4) in
the development workstation, or directly from a Unix command line.
Once you’ve generated the Verilog or Bluesim implementation, the development workstation provides
the following tools to help analyze your design:

    • Interface with an external waveform viewer, with additional Bluespec-provided annotations,
       including structure and type deﬁnitions

    • Schedule Analysis viewer providing multiple perspectives of a module’s schedule
    • Scheduling graphs providing a graphical display of schedules, conﬂicts, and dependencies

       among rules and methods.

2.3 Using the Main Window

The Main window, as shown in Figure 2, is the control center of the Bluespec development work-
station. From this window you can manage projects, set project options, and monitor status while
working in the development workstation. The window displays all commands executed in addition
to warnings, errors, and messages generated by the BSV compiler and the development workstation.

                                         Figure 2: Main window components

The main window consists of the following components:
    • The menu bar, from which you can launch all actions.
    • The toolbar, a set of icons implementing shortcuts for frequently used actions. All toolbar
       icons also appear as menu bar items.
    • The status/log window displaying commands, project status, messages, warnings, and er-
       rors.
    • The command window where you can enter Tcl commands. All actions available through
       the development workstation user interface have analogous Tcl commands. (Refer to Appendix
       A for the full description of supported commands).

                                                                11


2.3.1 Messages

The messages displayed in the status/log window are generated by both the BSV compiler and the
development workstation and are color-coded by type as follows:

    • red: error or warning from the compiler
    • black: a result or status from the compiler (example - compiling)
    • dark red: error from the development workstation
    • blue: information from the development workstation (example - compile ﬁnished)

The red and black messages are the same messages returned by the BSV compiler on the command
line while the dark red and blue messages are generated by the development workstation. When the
compiler returns errors or warnings (red messages), you can double-click on the message to open the
ﬁle at the speciﬁed line.

2.3.2 Command Line

The workstation command line is a prompt to a Tcl shell. All standard Tcl as well as Bluetcl
commands can be executed from this prompt. You can also write your own Tcl commands, procs,
and scripts using any combination of Tcl and Bluetcl commands. These must be added to the
.bluetclrc ﬁle before you can execute them from the development workstation command line.
Section A.3 for more information on customizing with Bluetcl and the development workstation.
To display the list of available Bluetcl commands, type Bluetcl::help at the workstation com-
mand line. To display the list of Bluetcl workstation commands, type WS::help -list. For more
information on Bluetcl commands refer to the Bluetcl reference guide in Appendix A.

3 Managing Projects

The basic unit of work within the Bluespec development workstation is the Project. The project
ﬁle (projectname.bspec) is a named collection of project settings and options. You manage (open,
create, save, close) projects from the Project menu. You modify the project options through the
Project→Options menu, described in Section 3.2.

3.1 Creating a Project

When you create a new project in the Bluespec development workstation, a projectname.bspec ﬁle is
created. This ﬁle takes the default project settings and tool selections from the ﬁle .bluespec/setup.tcl
in your home directory.
To create a new project, select New from the Project pull-down menu. The dialog window, shown
in Figure 3, will prompt you for the Project directory and the Project Name. When you create a
new project the project directory may be empty or may already be populated with .bsv ﬁles. There
may even already be an existing .bspec ﬁle. New indicates that you want to deﬁne a new project,
creating a new .bspec ﬁle, even if it uses ﬁles in a directory already included in another project.
After you press OK to close the New Project window, the Project Options window will open,
so you can set up your project.

                                                                12


                                            Figure 3: New Project Window

3.2 Setting Project Options

Once a project is created, the user options are modiﬁed through the Project→Options menu. The
Options window contains the following tabs:

    • Files
    • Compile
    • Link Simulate
    • Editor
    • Waveform Viewer

The default values for these options are taken from the ﬁle .bluespec/setup.tcl in your home
directory. Edit this ﬁle to set up a default proﬁle for new projects.
All of the ﬁelds in the Options tabs correspond either to bsc compiler ﬂags or values passed to the
bsc compiler, as described in Section 6. For a full listing of all bsc compiler ﬂags, type:

                                                      exec bsc -help

in the workstation command window or:

                                                          bsc -help

from a Unix command prompt.

3.2.1 Files
The Files tab, shown in Figure 5, contains the following options:

    • Top File and Top Module
    • Location of generated and included ﬁles
    • Search path directories
    • Display criteria

The following table shows the ﬁelds on the Files tab along with the associated compiler ﬂags. When
you compile from the workstation, the workstation supplies the appropriate compile ﬂag and value
to the bsc command.

                                                                13


Field             ﬂag        Task         Description

Top Module        -e         Link         Speciﬁes the top-level module for simulation
.bo/.bi/.ba ﬁles  -bdir      Compile      output directory for .bi/.bo/ba ﬁles
Bluesim ﬁles      -simdir    Compile      output directory for Bluesim intermediate ﬁles
Verilog ﬁles      -vdir      Compile      output directory for .v ﬁles
Info Files        -info-dir  Compile      output directory for cross-info ﬁles
Search Path       -p         Compile      directory path for source and intermediate ﬁles

                             Figure 4: Compiler ﬂags by Field

Top File and Top Module The top ﬁle contains the top package, which includes the top syn-
thesized module of the hierarchy. The top ﬁle imports all other ﬁles all other ﬁles and modules used
in the design. To compile a design, the top ﬁle must be speciﬁed. To link, the top module must also
be speciﬁed.

The values for top ﬁle and top module are stored in the workstation meta variables %P and %M
respectively. These variables can be used with Makeﬁles and custom commands for compiling,
linking, and simulating in the workstation.

Files Location The 4 ﬁles location ﬁelds indicate where output ﬁles should be placed during build
tasks, as well as where the development workstation looks for the generated ﬁles. The default is
in the directory in which the input ﬁles reside. The ﬂags the ﬁelds correspond to are shown in the
table in Figure 4. See Section 6.5 for more details about these ﬂags.

Search Path The Search Path contains the default locations where the compiler looks for source
and intermediate ﬁles. These are the directories supplied to the -p ﬂag.
When a project is created in the development workstation, the following directories are automatically
added to the search path:

    • .: the project directory
    • %/Prelude:basic compiled BSV library packages
    • %/Libraries: additional compiled BSV library packages

% is the {$BLUESPECDIR} environment variable, which must be set to install directory/lib.
You can add, remove, and reorder directories in the search path.

Display patterns The display include and exclude patterns are used by the Project Files win-
dow to determine which ﬁles from the project path to display. The ﬁles displayed are selected by
ﬁle extension. By default, all ﬁles in the search path with an extension of .bsv are displayed in the
Project Files window. In this tab you can add patterns to include or exclude. For example, you
may want to display Verilog ﬁles in the search path, in which case you would add *.v to the include
patterns. Or if you wanted to display all ﬁles, except for .bi and .bo ﬁles, you would specify *.*
for the Include Patterns and *.bi and *.bo for the Exclude Patterns.

                                      14


                 Figure 5: Compiler Options - Files

3.2.2 Compile

The Compile tab, shown in Figure 6, is where you indicate whether you are compiling to Bluesim
or Verilog. This is the same value as on the Link/Simulate tab.

The rest of the tab is divided into two sections; one section contains options for when you are
compiling via bsc, the other for when you are using a makeﬁle.

There are two additional ﬁelds when the compilation type is bsc, compile options and RTS options.
Compile options are any of the compile ﬂags as described in Section 6, while the RTS options are the
-Hsize and -Ksize ﬂags, described in Section 6.8. All bsc compiler ﬂags should be typed in exactly
as they would be on the command line. When you compile the project, the speciﬁed ﬂags will be
applied. The following table lists the ﬁeld on the Compile tab and the associated bsc compiler
ﬂags.

Field            Compiler ﬂag  Description

Bluesim          -sim          Compiles for Bluesim
Verilog          -verilog      Compiles for Verilog
Compile options  BSC ﬂags      Flags described in Section 6
RTS options      -Hsize        Maximum heap size
                 -Ksize        Maximum stack size

                               15


                                         Figure 6: Project Options - Compile

When the compilation type is make, you can specify the following ﬁelds.
    • Makeﬁle: Name of the makeﬁle
    • Target
    • Clean target
    • Full clean target
    • Make options: options for make command

You can use Unix environment variables and the workstation meta variables (%P for package name
and %M for module name) in the makeﬁle ﬁelds.

3.2.3 Link/Simulate
The link stage is the second call to the compiler which links the generated hardware description into
the simulation environment. The target simulation environment (Bluesim or Verilog) is set on the
Compiler tab, but can also be modiﬁed from the Link/Simulate tab.

                                                                16


The Link/Simulate tab, as shown in Figure 7, is used to specify options for linking and simulation.
The three types of link operations available through the development workstation are as follows:

    • Link via bsc: use the Bluespec compiler bsc command
    • Link via make: use a makeﬁle to control the link
    • Link via custom command: specify a custom command to link to a diﬀerent simulation

       environment
Diﬀerent ﬁelds are required for each link operation type.

                                           Figure 7: Project Options - Link
Link via bsc Linking via bsc runs the Bluespec compiler again to link the compiled hardware
description into the simulation environment, Bluesim or Verilog, as determined by the option set on
the top of the tab. On the Link/Simulate tab you specify the following ﬁelds:

    • the name of the output ﬁle
    • output directory
    • linking ﬂags

                                                                17


When left blank, the output directory defaults to the current working directory. The output ﬁle
name and output directory are passed to the bsc command with the -o ﬂag. The following table
lists the ﬁeld on the Link/Simulate tab and the associated bsc compiler ﬂags.

Field         Compiler ﬂag  Description
Bluesim       -sim
Verilog       -verilog      Compiles for Bluesim
Output name   -o            Compiles for Verilog
                            Name for the binary being created; the default
Link options  BSC ﬂags      name is a.out
Simulator     -vsim         Flags described in Section 6
                            Speciﬁes which Verilog simulator to use

Simulate If compiling to Bluesim, you can specify Bluesim run options, such as the -V ﬂag to
generate .vcd ﬁles, in the Simulate options ﬁeld.
If the Compile to target is Verilog, the following simulators can be chosen in the Link/Simulate
tab:

    • iverilog
    • modelsim
    • ncverilog
    • vcsi
    • cver
    • vcs
    • veriwell

When using any of the above simulators, use the Simulate options ﬁeld to specify the simulation
plusarg variables +bscvcd and +bsccycle, as described in Section 4.3.3.

Link via make The ﬁelds on the Link/Simulate tab for Link via make are as follows:

    • Makeﬁle
    • Target
    • Simulation Target
    • Clean Target
    • Options

You can use Unix environment variables and the workstation meta variables (%P for package name
and %M for module name) in the makeﬁle ﬁelds.

Linking via custom command You can use other simulation environments, by supplying the
Link command and the command to launch the simulator (Simulate Command). This allows you to
link the design with any simulation environment you choose.
You can use Unix environment variables and the workstation meta variables (%P for package name
and %M for module name) in the link and simulate command ﬁelds.

                                                                18


                                          Figure 8: Project Options - Editor

3.2.4 Editor

The editor is selected in the Editor tab, as shown in Figure 8. The supported editors are gvim and
emacs. The selected editor is used whenever ﬁles are opened within the development workstation.
Bluespec editing modes for these editors are provided in the $BLUESPEC HOME/util directory, along
with README ﬁles for their use.

3.2.5 Waveform Viewer

The development workstation can interface to the waveform viewers provided by SpringSoft/Novas
(Verdi, Debussy, nWave). The command for selecting and launching the waveform viewer, along
with viewer options are set in the Waveform Viewer tab, as shown in Figure 9.

3.3 Editing Files with the Project Files Window

The Project Files window is the primary window for viewing, editing, and compiling individual
design ﬁles. When you open a project, the workstation opens the Project Files window displaying
all the ﬁles meeting the criteria speciﬁed in the Files option tab. By default, all .bsv ﬁles in the
project search path are listed.

                                                                19


                                   Figure 9: Project Options - Waveform Viewer

To edit a ﬁle from the Project Files window, you can either double-click on the ﬁle, or use the
Edit pull down menu. The editor set in the Editor option tab (gvim or emacs) will be used.
You can also create a new ﬁle from the Project Files window. Select Edit→New and a new ﬁle
will open in the text editor.
Within this window you can compile individual ﬁles or entire projects. Section 4.2 describes the
compile process. You can execute an action (edit, refresh, typecheck, compile) on a ﬁle by selecting
the ﬁle and then either using the context menu to select an action or the File pull-down menu.
To change the ﬁles displayed, editor used, or any of the other project options, use the Project→Options
menu. See Section 3.2 for a complete description of the Project Options and how to modify them.

3.4 Saving a Project

When you save a project, either through the Save or Save As options on the Project menu, you
are saving the options deﬁned on the Project Options tabs.

                                                                20


                                           Figure 10: Project Files Window
3.4.1 Saving Window Placement
The development workstation consists of multiple windows, many of which may be open at the same
time. You can save the relative placement of the windows by selecting Save Placement on the
Project menu. The placement is only saved through the Save Placement option, it is not saved
when saving a project.
3.4.2 Backup
Use the Backup Project option on the Project menu, shown in Figure 11, to create a tar ﬁle of
your project. You choose which ﬁles to include by ﬁle type. The default is to include all the .bsv
ﬁles from the search path.

                                          Figure 11: Backup Project Window

3.4.3 Export Makeﬁle
Use the Export Makeﬁle option on the Project menu to generate a Makeﬁle based on the pa-
rameters set in the Project Options. The Makeﬁle will include the following targets:

    • compile
                                                                21


    • link
    • simulate
    • clean
    • full clean

The development workstation will prompt you for the directory and name of the Makeﬁle. The
default is to create a ﬁle named Makefile in the project directory.

3.5 Maintaining Multiple Settings for a Single Design

A single design may have multiple sets of options or settings. For example, you may want to generate
both Bluesim and Verilog targets from a single design, or save both test and production settings, or
use diﬀerent versions of library ﬁles. In each case you will have a unique set of options; each set is
saved in its own project (.bspec) ﬁle.
The following example describes some the settings for generating both Bluesim and Verilog from a
single set of .bsv ﬁles.

    • Each target is its own project, deﬁned by its own .bspec ﬁle.
    • The same .bsv ﬁles are used in both projects therefore the project directories are the same.
    • In the Project Options the following ﬁelds are diﬀerent:

          – In the Files tab diﬀerent output directories are speciﬁed for each project so the generated
              ﬁles are not overwritten when the other target is compiled. All output ﬁles (Bluesim or
              Verilog, .bo/.bi/.ba, Info ﬁles, have diﬀerent directories speciﬁed for each project.

          – In the Compile tab, the target is set to Bluesim in one project, and Verilog in the other.
          – Also in the Compile tab diﬀerent compiler ﬂags may be used for each target.
    • In the Link/Simulate tab, diﬀerent output directories are speciﬁed and well as link compiler
       options for each project.
    • Also in the Link/Simulate tab diﬀerent simulators are speciﬁed along with any options for
       the simulator.

The development workstation project saves each group of settings and options in the .bspec ﬁle,
allowing you to maintain multiple design environments for single set of .bsv ﬁles.

4 Building a Project

In the development workstation, the Build menu contains the following actions:

    • Type Check
    • Compile
    • Link
    • Simulate
    • Full Rebuild

                                                                22


    • Stop
    • Clean
    • Full Clean

Most of these actions are accessible from the toolbar, as shown in Figure 12.

                                            Figure 12: Workstation Toolbar

4.1 Type Check

There are two stages in compilation, type checking and code generation, executed by a single compile
command. The simplest compilation of a BSV design is to run only the ﬁrst stage of the compiler
which is the Type Check task, generating the .bi/.bo ﬁles. Once the type check is complete, you
have enough module information to use the Package and the Type Browser windows. When you
select the Type Check task, the compiler stops before code generation, even if there are no errors
in the compile.
A BSV design often imports other packages. The development workstation will automatically type
check those packages, if necessary, when you type check a project. When type checking an individual
ﬁle you must specify typecheck with deps if you want to type check the imported packages.
Section 4.2.4 discusses importing packages in more detail.

4.2 Compile

The Compile task runs the full compilation including both the type checking and code generation
stages. The ﬁrst stage (type check) generates the .bi/.bo ﬁles. The second stage (code generation)
generates an elaborated module ﬁle (.ba) and, when the target is Verilog, a (.v) ﬁle. These generated
ﬁles have the same name as the module they implement, not the name of the package or ﬁle they
come from.
To run the compiler through to code generation, a module must be marked for synthesis. The
recommended method is to use the synthesize attribute in the BSV code. You can also specify
a top module in the Project Options→Files tab, which is the same as passing the top module
with the -g compiler ﬂag. See Section 4.2.3 and the The BSV Reference Guide for information on
synthesizable modules.
A package often imports other packages. The development workstation will automatically recompile
imported packages, if necessary, when you compile a project. This is the same as specifying the
-u option on the command line. When compiling an individual ﬁle you must specify compile
with deps if you want to recompile imported packages. Section 4.2.4 discusses importing packages.

                                                                23


Section 4.2.5 contains a detailed explanation of techniques and considerations when compiling a
collection of BSV modules.

The compiler automatically runs through to code generation if no errors are encountered in the type
checking stage and a module is marked for synthesis. If errors are encountered in the type check
stage, the compiler will halt before generating the .bi/.bo ﬁles. In this case the Package and
Type Browser windows will not be able to display the project speciﬁc packages, as they depend
on these intermediate ﬁles. If errors are encountered in the second stage, the .bi/.bo ﬁles will be
created but the .ba ﬁles will not. In this case the Module Browser, Schedule Analysis, and
Scheduling Graphs windows will not display project-speciﬁc packages. Bluespec-provided library
packages can always be viewed in the workstation, since the .bi/.bo ﬁles for these packages are
always available.

To view the scheduling graphs the compiler ﬂag -sched-dot, described in Section 6.13, must be
speciﬁed for compilation, in the Project Options→Compile tab. This ﬂag generates the .dot
ﬁles from which the graphs are generated.

4.2.1 Compiling a File

A project usually contains multiple packages and ﬁles. To compile a single ﬁle, use the Project
Files window. Select the ﬁle to be compiled and then Compile, from either the File pull-down
menu or the context menu.

Compiling with dependencies Compiling with dependencies means that you want to compile
any imported ﬁles, if necessary, before compiling the selected ﬁle. This is equivalent to compiling
with the -u ﬂag. The compiler compares the time stamps on the .bi/.bo ﬁles to determine if the
imported ﬁle has changed since the last compilation. When you compile with dependencies only
changed ﬁles will be recompiled. You can choose Compile with Deps from both the File and the
context menus.

4.2.2 Compiling a Project

You can compile your complete project from the toolbar, the Build menu or the Project Files
window. Before compiling, the ﬁle to be compiled must be speciﬁed in the top ﬁle ﬁeld on the Files
option tab.

The top module is not required for compiling, but is required for linking. If the top module is not
speciﬁed, the synthesize attribute must be used in the BSV code to compile through code gener-
ation. Otherwise, the project will only be compiled through elaboration, generating the .bi/.bo
ﬁles, but not the .ba ﬁle. Specifying the top module in the Files tab is equivalent to using the -g
ﬂag with the name of the module.

When compiling a project from the development workstation the -u ﬂag is always used; timestamps
on all imported ﬁles are checked and ﬁles are recompiled as necessary.

4.2.3 Specifying modules for code-generation

A module can be selected for code-generation either in the BSV code or at compile-time. The recom-
mended method is to mark the module for code-generation in the BSV code, using the synthesize
attribute (see the BSV Reference Guide for more information on attributes). The alternative is at
compile-time, to use the Top Module ﬁeld which instructs the compiler to generate code for a
particular module. This is the same as using the -g ﬂag (Section 6.1) on the Unix command line
with the bsc command, From the command line, the -g ﬂag can be used multiple times within a
compile command line to specify multiple modules for code generation.

                                                                24


Whether the generated code will be Bluesim or Verilog depends on which back end has been selected
through the Options window or with the -verilog and -sim command line ﬂags.
Not all modules written in BSV are synthesizable. To be synthesized the module must be of type
Module and not of any other module type that can be deﬁned with ModuleCollect. A module is
synthesizable if its interface is a type whose methods and subinterfaces are all convertible to wires.
A method is convertible to wires if it meets the following conditions:

    • its argument types are convertible to wires which means either

          – it is in the Bits class OR
          – it is a function whose argument and return type are convertible to wires

    • its return type is Action OR

    • its return type is a value or ActionValue where either

          – the value is convertible to bits (i.e. in the Bits class) OR
          – the ﬁeld is an exported clock or reset.

A module to be synthesized is allowed to have non-interface inputs, such as clocks and resets.
Parameters to the module are allowed if they are convertible to bits.
Clock and Reset subinterfaces are convertible to wires.
If none of the modules are marked for synthesis, the compiler will not generate a hardware description
(a Verilog .v ﬁle or a Bluesim .ba ﬁle).

4.2.4 Importing other packages

To compile a package that imports another package, the BSV compiler needs the .bi/.bo ﬁles from
the imported package. One way to provide these ﬁles is to run the compiler on each imported ﬁle
before running the compiler. Or the development workstation will automatically determine which
ﬁles are needed and recompile as necessary, when compiling a project. If the .bi/.bo ﬁles already
exist, the compiler will only recompile if the ﬁle has changed since the last compilation, as indicated
by the imported ﬁle having a more recent date than the ﬁle being compiled.
For example, to compile a package Foo that imports another package Baz, the BSV compiler needs
to examine the ﬁles Baz.bi and Baz.bo. If Baz is in the ﬁle Baz.bsv, then this ﬁle needs to be run
through the compiler to produce the necessary .bi and .bo ﬁles before the compiler can be invoked
on Foo.bsv. If in the workstation you compile a project or compile a ﬁle with dependencies, or from
the command line use the -u ﬂag, the compiler will check to see if Baz.bi and Baz.bo exist, and if
they exist, it will check the compilation date. The compiler will recompile the Baz ﬁle if necessary.
BSV is shipped with a large set of library ﬁles which provide common and useful hardware structures
as described in the BSV Reference Guide. If a package being imported is one of these standard
library package, such as FIFO or UInt, then the source code will already have been compiled and
the resulting .bi/.bo ﬁles are available in a library directory with the compiler installation (in the
same way that C header and object ﬁles are stored in standard include and library directories). The
compiler looks for these ﬁles in:

                                                        %/Prelude/
                                                        %/Libraries/

                                                                25


If you are importing packages from other directories, the directories must be added to the search
path on the Files tab on the Options menu, as described in Section 3.2.1. The Bluespec Prelude
and Libraries directories are automatically added to the search path when a project is created.

BSV is also shipped with a set of library ﬁles for which both the BSV source is provided in the
BSVSource directory, along with compiled .bi/.bo ﬁles in the Libraries directory. You can use
these packages as provided, or edit and customize them to your own speciﬁcations. To use a cus-
tomized version of the these ﬁles, include the directory containing the .bsv source ﬁles in the search
path. If the directory containing the .bsv ﬁles is in any position in the search path, the modiﬁed
.bsv will be used, and not the precompiled .bi/.bo ﬁles from the Libraries directory.

4.2.5 Understanding separate compilation

The BSV compiler has two main stages; ﬁrst it converts BSV modules into a collection of states and
rules, and then it converts the rule-representation into a hardware description.

When compiling a collection of BSV modules, it is up to the user to decide which of these modules
should be compiled to hardware separately, and which should be subsumed into the parent module.
By default, all hierarchy is ﬂattened into one top-level module in the ﬁnal hardware description,
but the user can specify modules which should stay in the hierarchy and have separate hardware
descriptions.

What happens when a module m1 instantiates another module m2? If the sub-module m2 is provided
as a BSV description, that description will need to be compiled into a set of rules and then those
rules combined with the rules for m1 to be converted, by the code-generation stage, into a hardware
description.

If m2 is provided as a hardware description (that is, implemented in a Verilog ﬁle or in Bluesim
header and object ﬁles), then the hardware description for m1 will contain an instantiation of m2.
The implementation of m2 is kept in its own ﬁle. For the Verilog back end, this produces a m1.v
ﬁle with a Verilog module m1 which instantiates m2 by name and connects to its ports but doesn’t
contain the implementation of m2. Both implementation ﬁles, m1.v and m2.v, must be provided to
the simulation or synthesis tools.

Even if m2 is provided as a BSV description, the user can decide to generate a separate hardware
description for the module. This is done by putting the synthesize attribute in the BSV description
or using the -g ﬂag, indicating that the module should be synthesized as a separate module, apart
from the instantiating module.

The implementation in a .bo reﬂects whether hardware was generated for a module. If a hardware
description was generated for a module, then the implementation in the .bo will be merely a pointer
to the location of that description (be it .v or .o). If hardware was not generated for the module,
then an entirely BSV representation will be stored in the .bo ﬁle.

Thus, a single .bsv ﬁle can be compiled in diﬀerent ways to produce very diﬀerent .bo ﬁles. When
the compiler is generating hardware for another BSV ﬁle that imports this package, it will need to
read in the information in the .bo ﬁle. How it is compiled depends on the ﬂags used. Therefore,
compiling the new ﬁle will be aﬀected by how the imported ﬁle was compiled earlier! It is important,
therefore, to remove these automatically generated ﬁles before beginning a new compilation project,
especially if a diﬀerent module hierarchy is desired.

For example, if a user were to generate Verilog for a module mkFoo just for testing purposes, the
Foo.bo would encapsulate into its own description the information that a Verilog module had been
generated for module mkFoo. If the user then wanted to generate Verilog for a larger design, which
included this module, but wanted the larger design to be compiled into one, hierarchy-free Verilog
module, then the .bo ﬁle would have to be deleted so that a new version could be created that only
contained the state-and-rules description of the module.

                                                                26


When using the development workstation the Clean tasks (Section 4.7) will remove these ﬁles. The
Clean task removes the .bo ﬁles, while the Real Clean task removes the generated Verilog (.v)
ﬁles as well.

4.2.6 Interfacing to foreign modules and functions

Foreign modules and functions can be included as part of a BSV model. A designer can specify
that the implementation of a particular BSV module is provided as either a Verilog module or a C
function.

Importing Verilog modules

Using the importBVI syntax, a designer can specify that the implementation of a particular BSV
module is a Verilog module, as described in the BSV Reference Guide. The module is treated exactly
as if it were originally written in BSV and then converted to hardware by the compiler, but instead
of the .v ﬁle being generated by the compiler, it was supplied independently of any BSV code. It
may have been written by hand or supplied by a vendor as an IP, etc. The Verilog ﬁles for these
modules need to be linked in to the simulation. This process is described in Section 4.3.1 for Bluesim
simulations and 4.3.3 for Verilog simulations.
Several primitive BSV elements, such as FIFOs and register ﬁles, are expressed this way — as Verilog
primitives. When simulating or synthesizing a design generated with the Verilog back end, you will
need to include the appropriate hardware descriptions for these primitives. Verilog descriptions for
Bluespec-provided primitive elements can be found in:

                                               ${BLUESPECDIR}/Verilog/

Note: We attempt to be sure that the Bluesim and Verilog models simulate identically. Simulations
using 4-state (X and Z) logic, user supplied Verilog, or other unsupported or nonstandard parts are
never guaranteed to match.

Importing C functions

Using the importBDPI syntax, the user can specify that the implementation of a BSV function is
provided as a C function. The same implementation can be used when simulating with Bluesim
or with Verilog. In Bluesim, the imported functions are called directly. In Verilog, the functions
are accessed via the Verilog VPI. The compilation and linking procedures for these backends are
described in Sections 4.3.1 for Bluesim simulations, and 4.3.3 for Verilog simulations.

4.3 Link

The compiled hardware description must be linked into a simulation environment before you can
simulate the project. The result of the linking stage is a binary which, when executed, simulates
a module. The Bluespec compiler is required for linking Bluesim generated modules. You can also
use the Bluespec development workstation and compiler to link Verilog ﬁles and to run the Verilog
simulator speciﬁed in the Link/Simulate tab of the Project→Options window.
To link the project, select Link from the toolbar or the Build menu.
The simulation environment and location of the implementation ﬁles are speciﬁed in the Files
tab of the Options menu. The top-level module must also be speciﬁed in Files tab of the the
Options menu. You can specify additional link compiler ﬂags, as described in Section 6, in the
Link/Simulate tab of the Options menu.

                                                                27


If you’ve compiled your design and you still cannot link (the Link option is grayed out), the design
is not ready to be linked. To determine the cause, you should verify that:

    • The compile completed successfully and .ba ﬁles were generated for the .bsv ﬁles.

    • A top module is speciﬁed in the Project Options menu, Files tab.

4.3.1 Linking with Bluesim

For the Bluesim back end, linking means incorporating a set of Bluesim object ﬁles that implement
BSV modules into a Bluesim simulation environment. See Section 9 for a description of this envi-
ronment. Bluesim is speciﬁed in the Project Options window or by using the -sim ﬂag. In an
installation of the BSV compiler, the ﬁles for this simulation environment are stored with the other
Bluesim ﬁles at: ${BLUESPECDIR}/Bluesim/.
Speciﬁcally, the linking stage generates a C++ object for each elaborated module. For each module,
it generates .h and .cxx ﬁles which are compiled to a .o ﬁle. The C++ compiler to use is deter-
mined from the CXX environment variable (the default is c++) and any ﬂags speciﬁed in CXXFLAGS
or BSC CXXFLAGS are added to the command line. Also generated are the ﬁles schedule.h and
schedule.cxx, which implement the global schedule computed by combining the schedules from all
the individual modules in the design. Once compiled to .o ﬁles, these objects are linked with the
Bluesim library ﬁles to produce an .so shared object ﬁle. This shared object ﬁle can be dynamically
loaded into Bluetcl using the sim load command. For convenience, a wrapper script is generated
along with the .so ﬁle which automates loading and execution of the simulation model.
If you want to see all the CAN FIRE and WILL FIRE signals, you must specify the -keep-fires ﬂag
(described in Section 6.12) when compiling and linking with Bluesim.
The typical command to link BSV ﬁles to generate Bluesim executables is:

                                   bsc -sim -e -keep-fires mkFoo mkFoo.ba

Imported Verilog modules in Bluesim

Using the importBVI syntax, a designer can specify that the implementation of a particular BSV
module is a Verilog module. The module is treated exactly as if it were originally written in BSV,
but was converted to hardware by the compiler.
Bluesim does not currently support importing Verilog modules directly. If a Bluesim back end is
used to generate code for this system, then a Bluesim model of the Verilog module needs to be
supplied in place of the Verilog description. Such a model would need to be compiled from a BSV
description and used conditionally, depending on the backend. The environment functions genC and
genVerilog (as deﬁned in the BSV Reference Guide) can be used to determine when to compile
this code.
For example, you might have a design, mkDUT, which instantiates a submodule mkSubMod, which is a
pre-existing Verilog ﬁle that you want to use when generating Verilog:

                                          module mkDUT (...);
                                               ...
                                               SubIFC submod &lt;- mkSubMod;
                                               ...

                                          endmodule

You would write an importBVI statement:

                                                                28


                         import &quot;BVI&quot; module mkSubMod (SubIFC); ... endmodule

But this won’t work for a Bluesim simulation - Bluesim expects a .ba ﬁle for mkSubMod.
The way to write one BSV ﬁle for both Verilog and Bluesim is to change mkSubMod to be a wrapper,
which conditionally uses a Verilog import or a BSV-written implementation, depending on the
backend:

                         module mkSubMod (SubIFC);
                             SubIFC _i &lt;- if (genVerilog)
                                                       mkSubMod_verilog
                                                  else
                                                       mkSubMod_bluesim;
                             return _i;

                         endmodule

                         // note that the import has a different name
                         import &quot;BVI&quot; mkSubMod =

                               module mkSubMod_verilog (SubIFC); ... endmodule

                         // an implementation of mkSubMod in BSV
                         module mkSubMod_bluesim (SubIfc);

                             ...
                         endmodule

This code will import Verilog when compiled to Verilog and it will use the native BSV implementation
otherwise (when compiling to Bluesim).

Imported C functions in Bluesim

Using the importBDPI syntax, the user can specify that the implementation of a BSV functions
is provided as a C function. When compiling a BSV ﬁle containing an import-BDPI statement,
an elaboration ﬁle (.ba) is generated for the import, containing information about the imported
function. When linking, the user will specify the elaboration ﬁles for all imported functions in
addition to the elaboration ﬁles for all modules in the design. This provides the Bluespec compiler
with information on how to link to the foreign function. In addition to this link information, the
user will have to provide access to the foreign function itself, either as a C source ﬁle (.c), an object
ﬁle (.o), or from a library (.a).
When user provided .c ﬁles are to be compiled and linked, the C compiler to be used is given by
the CC environment variable and the ﬂags by the CFLAGS and BSC CFLAGS variables. The default
compiler is cc. If the extension on the ﬁle is not .c, but .cxx, .cpp or .cc, the C++ compiler will
be used instead. The default C++ compiler is c++, but the compiler invocation can be controlled
with the CXX, CXXFLAGS and BSC CXXFLAGS environment variables.
Arguments can also be passed through bsc directly to the C compiler, C++ compiler and linker
using the -Xc, -Xc++ and -Xl options, respectively.
As an example, let’s say that the user has a module mkDUT and a testbench mkTB in the ﬁle DUT.bsv.
The testbench uses the foreign C function compute vector to compute an input/output pair for
testing the design. Let’s assume that the source code for this C function is in a ﬁle called vectors.c.
The command-line and compiler output for compiling and linking this system would look as follows:

                                                                29


         # bsc -u -sim DUT.bsv
         checking package dependencies
         compiling DUT.bsv
         Foreign import file created: compute_vector.ba
         code generation for mkDUT starts
         Elaborated Bluesim module file created: mkDUT.ba
         code generation for mkTB starts
         Elaborated Bluesim module file created: mkTB.ba

         # bsc -sim -e mkTB -o bsim mkTB.ba mkDUT.ba compute_vector.ba vectors.c
         Bluesim object created: mkTB.{h,o}
         Bluesim object created: mkDUT.{h,o}
         Bluesim object created: schedule.{h,o}
         User object created: vectors.o
         Simulation shared library created: bsim.so
         Simulation executable created: bsim

An elaboration ﬁle is created for the foreign name of the function, not the BSV name that the
function is imported as. In this example, compute vector is the link name, so the elaboration ﬁle
is called compute vector.ba.

In this example, the user provided a C source ﬁle, which BSC has compiled into an object (here,
vectors.o). If compilation of the C source ﬁle needs access to header ﬁles in non-default locations,
the user may specify the path to the header ﬁles with the -I ﬂag (see Section 6.5).

If the user has a pre-compiled object ﬁle or library, that ﬁle can be speciﬁed on the link command-
line in place of the source ﬁle. In that situation, the Bluespec compiler does not need to compile an
object ﬁle, as follows:

         # bsc -sim -e mkTB -o bsim mkTB.ba mkDUT.ba compute_vector.ba vectors.o
         Bluesim object created: mkTB.{h,o}
         Bluesim object created: mkDUT.{h,o}
         Bluesim object created: schedule.{h,o}
         Simulation shared library created: bsim.so
         Simulation executable created: bsim

In both situations, the object ﬁle is ﬁnally linked with the Bluesim design to create a simulation
binary. If the foreign function uses any system libraries, or is itself a system function, then the
linking stage will need to include those libraries. This is done on the Project Options→Files tab
in the workstation. From the command line the user can specify libraries to include with the -l ﬂag
and can specify non-default paths to the libraries with the -L ﬂag (see Section 6.5).

4.3.2 Creating a SystemC Model Instead of a Bluesim Executable

Instead of linking .ba ﬁles into a Bluesim executable, the linking stage can be instructed to generate
a SystemC model by replacing the -sim ﬂag with the -systemc ﬂag, or by putting the -systemc
ﬂag in the options ﬁeld of the Link/Simulate option tab. All other aspects of the linking stage,
including the use of environment variables, the object ﬁles created, and linking in external libraries,
are identical to the normal Bluesim tool ﬂow.

When using the -systemc ﬂag, the object ﬁles created to describe the design in C++ are not linked
into a Bluesim executable. Instead, some additional ﬁles are created to provide a SystemC interface
to the compiled model. These additional SystemC ﬁles use the name of the top-level module extended
with a systemc suﬃx.

                                                                30


# bsc -sim GCD.bsv
Elaborated Bluesim module file created: mkGCD.ba

# bsc -systemc -e mkGCD mkGCD.ba
Bluesim object created: mkGCD.{h,o}
Bluesim object created: schedule.{h,o}
SystemC object created: mkGCD_systemc.{h,o}

There are a few additional restrictions on models with which -systemc can be used. The top-level
interface of the model must not contain any combinational paths through the interface. For the same
reason, ActionValue methods and value methods with arguments are not allowed in the top-level
interface.

Additionally, value methods in the top-level interface must be free of scheduling constraints that
require them to execute after rules in the design. This means that directly registered interfaces are
the most suitable boundaries for SystemC model generation.

The SystemC model produced is a clocked, signal-level model. Single-bit ports use the C++ type
bool, and wider ports use the SystemC type sc bv&lt;N&gt;. Subinterfaces (if any) are ﬂattened into
the top-level interface. The names of ports obey the same naming conventions (and the same port-
naming attributes) as the Verilog backend (See Section 8.1).

The SystemC model interface is deﬁned in the produced .h ﬁle, and the implementation of the model
is split among the various .o ﬁles produced. The SystemC model can be instantiated within a larger
SystemC design and linked with other SystemC objects to produce a ﬁnal system executable, or it
can be used to cosimulate inside of a suitable Verilog or VHDL simulator.

                  Division of Functionality Among Files

File                  Purpose

* systemc.{cxx,h,o} Top-level SystemC interface

*.{cxx,h,o}       Implementation of modules

schedule.{cxx,o}  Implementation of schedule ordering and constraints

The *.{cxx,h,o} ﬁles contain the implementations of the modules, each as its own C++ class. The
classes have methods corresponding to the rules and methods in the BSV source for the module and
member variables for many logic values used in the implementation of the module.

The * systemc.{cxx,h,o} ﬁles contain the top-level SystemC module for the system. This module is
an SC MODULE with ports for the module clocks and resets as well as for the signals associated
with each method in the top-level interface. Its constructor instantiates the implementation modules
and initializes the simulation kernel. Its destructor shuts down the simulation kernel and releases the
implementation module instances. The SystemC module contains SC METHODs which are sensitive
to the module’s clocks and transfer data between the SystemC environment and the implementation
classes, translating between SystemC data types and BSV data types.

The schedule.{cxx,o} ﬁles contain the scheduling logic which sequences rules and method calls and
enforces the scheduling constraints during rule execution. The scheduling functions are called only
through the simulation kernel, never directly from user code.

When linking the produced SystemC objects into a larger system, all of the .o ﬁles produced must
be linked in, as well the standard SystemC libraries and Bluesim kernel and primitive libraries.

# c++ -I/usr/local/systemc-2.1/include -L/usr/local/systemc-2.1/lib-linux \
         -I$BLUESPECDIR/Bluesim -L$BLUESPECDIR/Bluesim/g++4 \
         -o gcd.exe mkGCD.o mkGCD_systemc.o schedule.o top.cxx TbGCD.cxx \
         -lsystemc -lbskernel -lbsprim -lpthread

                  31


Note: The proper Bluesim library search directory depends on the compiler ABI version used for
linking. The utility program $BLUESPECDIR/bin/c++family can be used to determine the correct
subdirectory (g++3, g++4, g++3 64, g++4 64, etc.).

4.3.3 Linking with Verilog

For the Verilog back end, linking means invoking a Verilog compiler to create a simulator binary ﬁle
or a script to execute and run the simulation. Section 8 describes the Verilog output in more detail.
The Verilog simulator is speciﬁed in the Project Options→Link/Simulate tab or by using the
-vsim ﬂag.

The Link/Simulate tab and the -vsim ﬂag (along with the equivalent BSC VERILOG SIM environ-
ment variable) govern which Verilog simulator is employed; at present, natively supported choices
for -vsim are vcs, vcsi, ncverilog, modelsim, cver, iverilog, and veriwell. If the simulator is
not speciﬁed bsc will attempt to detect one of the above simulators and use it.

When the argument to -vsim contains the slash character (/), then the argument is interpreted as
the name of a script to run to create the simulator binary. Indeed, the predeﬁned simulator names
listed above refer to scripts delivered with the Bluespec distribution; thus, -vsim vcs is equivalent to
-vsim $BLUESPECDIR/bin/bsc build vsim vcs. The simulator scripts distributed with Bluespec
are good starting points should the need to use an unsupported simulator arise.

In some cases, you may want to append additional ﬂags to the Verilog simulator command that
is used to generate the simulator executable. The BSC VSIM FLAGS environment variable is used
for this purpose. Thus, for instance, setting its value to -y verilog libs will add the directory
verilog libs to the simulator search path (for simulators such as iverilog and vcs).

The generated Verilog can be put into a larger Verilog design, or run through any existing Verilog
tools. Bluespec also provides a convenient way to link the generated Verilog into a simulation using a
top-level module (main.v) to provide a clock for the design. The Bluespec-provided main.v module
instantiates the top module and toggles the clock every ﬁve simulation time units. The default
main.v is the default used when running a Verilog simulation in the development workstation.
From the command line the following command generates a simulation binary mkFoo.exe:

                                bsc -verilog -e mkFoo -o mkFoo.exe mkFoo.v

With this command the top level Verilog module main is taken from main.v. main.v provides a
clock and a reset, and instantiates mkFoo, which should provide an Empty interface. An executable
ﬁle, mkFoo.exe is created.

The default main.v allows two plusarg arguments to be used during simulation: +bscvcd and
+bsccycle. The argument +bscvcd generates a value change dump ﬁle (VCD); +bsccycle prints a
message each clock cycle. These are speciﬁed in the Simulate options ﬁeld of the Link/Simulate
tab on the Options menu. Or from the command line:

                                          ./mkFoo.exe +bscvcd +bsccycle

Imported Verilog functions in Verilog

When Verilog code is generated for a system that uses a Verilog-deﬁned module, the generated code
contains an instantiation of this Verilog module with the assumption that the .v ﬁle containing
its deﬁnition is available somewhere. This ﬁle is needed if the full system is to be simulated or
synthesized (the linking stage). Note that VHDL modules can be used instead of Verilog modules if
your simulator supports mixed language simulation.

                                                                32


When simulating or synthesizing a design generated with the Verilog back end, you need to in-
clude the Verilog descriptions for these primitives. The Verilog descriptions for Bluespec-provided
primitive elements (FIFOs, registers, etc.) can be found in:

                                               ${BLUESPECDIR}/Verilog/

Imported C functions in Verilog

In a BSV design compiled to Verilog, foreign functions are simulated using the Verilog Procedural
Interface (VPI). The generated Verilog calls a user-deﬁned system task anywhere the imported
function is needed. The system task is implemented as a C function which is a wrapper around the
user’s imported C function, to handle the VPI protocols.

The usual Verilog ﬂow is that BSV modules are generated to Verilog ﬁles, which are linked together
into a simulation binary. The user has the option of doing the linking manually or by calling BSC.
Imported functions can be linked in either case.

As with the Bluesim ﬂow, when compiling a BSV ﬁle containing an import-BDPI statement, an
elaboration ﬁle is generated for the import, containing information about the imported function.
However, with Verilog generation, the VPI wrapper function is also generated. For example, using
the scenario from the previous section but compiling to Verilog, the user would see the following:

                  # bsc -u -verilog DUT.bsv
                  compiling DUT.bsv
                  Foreign import file created: compute_vector.ba
                  VPI wrapper files created: vpi_wrapper_compute_vector.{c,h}
                  code generation for mkDUT starts
                  Verilog file created: mkDUT.v
                  code generation for mkTB starts
                  Verlog file created: mkTB.v

The compilation of the import-BDPI statement has not only generated an elaboration ﬁle for the
imput but has also generated the ﬁle vpi wrapper compute vector.c (and associated header ﬁle).
This ﬁle contains both the wrapper function compute vector calltf() as well as the registering
function for the wrapper, compute vector vpi register(). The registering function is what tells
the Verilog simulator about the user-deﬁned system task. Included in the comment at the top of
the ﬁle is information needed for linking manually.

When linking manually, this C ﬁle typically needs to be compiled to an object ﬁle (.o or .so) and
provided on the command line to the Verilog linker, along with the object ﬁles for the user’s function
(in this example, vectors.c). The Verilog linker also needs to be told about the registering function.
For some Verilog simulators, the registering function is named on the command-line. For other
simulators, a C object ﬁle must be created containing the array vpi startup array with pointers
to all of the registering functions (to be executed on start-up of the simulation). An example of this
start-up array is given in the comment at the top of the generated wrapper C ﬁles. Some simulators
require a table for imported system functions (as opposed to system tasks). The table is provided
in a ﬁle with .tab or .sft extension. The text to be put in these ﬁles is also given in the comment
at the top of the wrapper ﬁle. The text also appears later in the ﬁle with the tag “tab:” or “sft:”
prepended. A search for the appropriate tag (with a tool like grep) will extract the necessary lines
to create the table ﬁle.

Linking via BSC does all of this automatically:

                                                                33


       # bsc -verilog -e mkTB -o vsim mkTB.v mkDUT.v compute_vector.ba vectors.c
       VPI registration array file created: vpi_startup_array.c
       User object created: vectors.o
       VPI object created: vpi_wrapper_compute_vector.o
       VPI object created: vpi_startup_array.o
       Verilog binary file created: vsim

To perform linking via BSC, the user provides on the command-line not only the Verilog ﬁles for
the design but also the foreign import ﬁles (.ba) for each imported function and the C source or
object ﬁles implementing the foreign functions. As shown in the above example, the linking process
will create the ﬁle vpi startup array.c, containing the registration array, and will compile it to
an object ﬁle. The linking process will then pass all of the VPI ﬁles along to the Verilog simulation
build script (see Section 4.3.3) which will create any necessary table ﬁles and invoke the Verilog
simulator with the proper command-line syntax for using VPI.
If the foreign function uses any system libraries, or is itself a system function, then the Verilog
linking will need to include those libraries. As with the Bluesim ﬂow, the user can specify to BSC
the libraries to include with the -l ﬂag and can specify non-default paths to the libraries with the
-L ﬂag (see Section 6.5).

4.4 Simulate

The Simulate task simulates the output generated by the linking task, using the simulator and
options speciﬁed in the Options window. The results are displayed in the status/log window.
To view waveforms, you must generate a waveform dump ﬁle (.vcd) during simulation. This can
be done with the -V ﬂag for a Bluesim simulation, or for Verilog simulators using the Bluespec-
provided main.v ﬁle, specifying the +bscvcd ﬂag during simulation. Simulation ﬂags are entered in
the options ﬁeld of the Project Options→Link/Simulate window, as described in Section 3.2.3.

4.5 Full Rebuild

The Full Rebuild task combines the following build steps:

   1. Full Clean
   2. Compile
   3. Link
   4. Simulate

4.6 Stop

To stop a build process before completion, use the Stop option. It stops a compile, link or simulation
by sending a kill to the process and any subprocesses. You can also Stop during a Full Rebuild
or to end a simulation which doesn’t complete.

                                                                34


4.7 Clean and Full Clean

There are two options to clean your ﬁles: Clean and Full Clean. Clean removes the intermediate
ﬁles generated during compilation: the .bi/.bo, .ba, and .o ﬁles. Before recompiling, you may
want to remove the intermediate ﬁles to force the compiler to recompile all imported packages. Full
Clean removes all generated result ﬁles - .sched, .v, .so, and .exe - in addition to the intermediate
compilation ﬁles.

If you are compiling via a makeﬁle, then both Clean and Full Clean will instead execute the
appropriate target in the makeﬁle, as speciﬁed in the Compile and Link/Simulate tabs of the
Project→Options window.

5 Analyzing the Project

The design browsers within the development workstation provide diﬀerent views of the design. The
following table summarizes the windows and browsers in the development workstation.

Window  Bluespec Development Workstation Windows                                  Required
                Function                                                          Files
                                                                                  .bspec
Main Window               Central control window. Manage projects, set project    .bsv
Project Files Window      options, build projects, and monitor status.            .bi/.bo
Package Window            View, edit and compile ﬁles in the project.
                          Pre-elaboration viewer for the design. Load packages    .bi/.bo
Type Browser              into the development workstation and browse their
                          contents. Provides a high-level view of the types, in-  .ba
Module Browser            terfaces, functions and modules deﬁned in the pack-
                          age.                                                    .ba
Schedule Analysis Window  Primary means for viewing information about types
Scheduling Graphs         and interfaces. Displays the full structure hierarchy   .ba
                          and all the concrete types derived from resolution of   .dot
                          polymorphic types.
                          Post-elaboration module viewer, including rules and
                          method calls. Displays the design hierarchy and an
                          overview of the contents of each module. Provides an
                          interface to the waveform viewer.
                          View schedule information including warnings,
                          method calls, and conﬂicts between rules for a mod-
                          ule.
                          Graphical view of schedules, conﬂicts, and dependen-
                          cies.

5.1 Viewing Packages with the Package Window

The Package window provides a high-level view of the contents of the project, sorted by package.
You can perform the following tasks in the Package window:

    • View a complete list of packages.
    • View the import hierarchy by selected package.
    • View the contents of each package.

                          35


    • View basic information on types, interfaces, functions, and modules.
    • Navigate to the Type Browser for a particular type.
    • Open and edit source code.
    • Search types and functions for a string or a regular expression.

                                               Figure 13: Package Window

The Package window has two panes. The left pane lists packages by directory, the right pane
displays the deﬁnition of the selected object. To view a package or any object within it, the package
must ﬁrst be loaded (Package→Load) into the development workstation. When you load a package,
all packages imported by that package are loaded along with it. Therefore, if you load the top package
(Package→Load Top Package), all packages used by the project will be loaded. The Prelude
package is automatically imported in every BSV design and will be loaded along with the ﬁrst
package you load. If you don’t see a speciﬁc package in the left pane, has not been loaded yet.
The Package window will only display packages which have .bi/.bo ﬁles. Since library ﬁles
(Bluespec-provided ﬁles in the %/Prelude and %/Libraries directories) are precompiled, these are al-
ways available, even before compiling the project. Project speciﬁc ﬁles have to be compiled through
type checking (.bi/.bo ﬁles) to view them in the Package window.
Click on the icon next to the package name to expand and view the types, interfaces, functions and
modules deﬁned in the package. Click on the name of any item in the package to view its deﬁnition
in the right pane. The Package window can be helpful in displaying the functions deﬁned in a
package, especially for packages such as Vector which contain many functions.
The amount of information displayed for each item type is limited and detailed information is only
available for leaf items - types, interfaces and modules. For more details on types and interfaces, in-
cluding full structure hierarchies and the resolution of polymorphic types, select a type and navigate
(View→Send to Type) to the Type Browser.
For any object in which the .bsv ﬁle is in the path, you can view (and modify) the source code
directly by selecting View Source. You cannot view (or edit) the source code for any object deﬁned
in the Prelude or Bluespec Foundation libraries, since only compiled versions are provided for these
packages.

                                                                36


The action Package→Import hierachy uses the selected package as the top of the hierarchy and
displays a hierarchical list of imported packages. To view the entire hierarchy of the project, select
the top package and then view the Import hierarchy.
To search for a string anywhere in a package, use the Package→Search function, either from the
Package menu or at the bottom of the Package window (Find). With this function you can search
all loaded packages for a name or regular expression. This can help you ﬁnd a type or function, as
well as its arguments.

5.2 Viewing Types with the Type Browser

The Type Browser is the primary means for viewing information about types and interfaces. The
Type Browser expands the ﬁrst-level type deﬁnition available in the Package window, displaying
the full structure hierarchy and the concrete types derived from the resolutions of polymorphic types.
For interfaces, the Type Browser displays the methods and attributes deﬁned on the interface.
The Type Browser can be used to view size, width, and hierarchy information for types.

                                                 Figure 14: Type Browser

Before using the Type Browser you must ﬁrst Load a package into the development workstation
from the Package Window or the Type Browser. The following methods load a type into the
workstation:

    • Send to Type from the Package Window
    • Type→Add from Type pull down menu
    • Type entry ﬁeld at the bottom of the browser.
When using Type→Add, you can select a type or enter a type (existing or new), in the entry
window. You can also add a new type in the entry ﬁeld at the bottom of the browser. The arrow
provides a history function of all types you’ve entered in the ﬁeld.
As in the Package window, you can view the source code for any type that you can modify, that is
the source (.bsv) ﬁle is in the search path of the project. You cannot view (or edit) the source code
for any object deﬁned in the Prelude or Bluespec Foundation libraries, since only compiled versions
are provided for these packages. Bluespec does provide some source libraries in the BSVSource
directory.

                                                                37


                                               Figure 15: Module Browser

5.3 Viewing Waveforms with the Module Browser

The Module Browser, shown in Figure 15, provides a post-elaboration view of the instantiated
module hierarchy. It also provides a link to an external waveform viewer, using the instantiated
module hierarchy and type deﬁnitions along with waveform dump ﬁles to display additional Bluespec
type data along with the waveforms.
The development workstation currently interfaces to separately installed third-party waveform view-
ers supplied by SpringSoft/Novas, appending type data and full type hierarchies to the bit types
typically displayed in waveform viewers. When viewing designs through the development worka-
tion you can see signals with full type deﬁnition, including structures, structure hierarchies, and
enumerated types, as shown in Figure 16.
In order to view waveforms, you must have generated a waveform dump ﬁle during simulation, as
described in Section 4.4. Only synthesized modules are simulated and can be viewed with a waveform
viewer.
Follow these steps to view waveforms from the development workstation:

   1. Load the top module (Module→Load Top Module) to obtain the module hierarchy from
       the .bi/.bo ﬁles.

   2. Start or Attach the waveform viewer (Wave Viewer→Start or Wave Viewer→Attach) to
       initiate communication between the workstation and the waveform viewer.

   3. Load the waveform dump ﬁle either from the workstation (Wave Viewer→Load Dump
       File) or from within the waveform viewer itself.

   4. Select a module or signals and send (Send to Wave) to the viewer.

You can modify the waveform viewer settings directly from WaveViewer→Options. See Section
3.2.5 for more information about waveform viewer options.

                                                                38


                                             Figure 16: Sample Waveforms

5.4 Analyzing the Schedule

The Schedule Analysis window is for viewing and querying information about the schedule for a
single module. The following four tabs each display a diﬀerent perspective of the schedule:

    • Warnings: displays warnings generated by the compiler about scheduling decisions.
    • Rule Order: displays which methods are called by a selected rule.
    • Method Call: displays which rules use a selected method.
    • Rule Relations: displays conﬂicts between two selected rules.

A module has to be loaded in the workstation before you can view its scheduling information.
If the module has not already been loaded through another window, you can load it from the
Module→Load menu. The workstation will read the bluespec generated ﬁles and load in the
module and all dependent modules. You can load the entire project by loading the top module
(Module→Load Top Module).
The Schedule Analysis window shows the schedule for a speciﬁc module. Since multiple modules
may be loaded at the same time, use the Module→Set Module option to chose the module for
analysis. The title bar of Schedule Analysis window displays the name of the active module.

5.4.1 Warnings

The Warnings tab displays two types of warnings: static execution warnings and urgency warnings,
as shown in Figure 17.
When three or more rules cannot execute in the same cycle, even though any two of the rules can, the
compiler will introduce a conﬂict between two of the rules and generate a static execution warning
message.
When two rules conﬂict and the user has not speciﬁed the urgency of the rules, the compiler generates
an urgency warning, indicating that it has made an arbitrary choice as to which rule is more urgent.
More detail about these messages can be found in the BSV Users Guide.

                                                                39


                                   Figure 17: Schedule Browser - Warnings Tab

5.4.2 Rule Order

The Rule Order tab, shown in Figure 18, displays the details of the rules in a module. The module
is divided in two panes; the left listing the rules and methods in the module in execution order, the
right displaying information about the selected rule or method. When you select a rule from the left
pane, the right pane displays the following details:

    • Predicate or condition to ﬁre
    • Methods called
    • Blocking rules - scheduling conﬂicts which block execution
    • Position in the source ﬁle

The predicate is the condition for the rule to ﬁre. If the predicate is True, the rule ﬁres every cycle.
If it is False, it never ﬁres.
To view the source for a rule, select Module→View Source. It will open an editor window with
the source ﬁle in which the rule is deﬁned, at the position indicated on the right pane. If no position
is listed, the rule or method is part of the BSV library and cannot be modiﬁed and the source ﬁle
cannot be opened.

5.4.3 Method Call

The Method Call tab displays all instances of method calls in the module. It is divided into two
panes, as shown in Figure 19. The left pane lists the method calls by module instance. The right
pane displays information on the object selected in the left pane.
When ﬁrst opened, the left pane displays a list of module instances. To display the method calls for
each instance, click on the expand icon next to the method.

                                                                40


                                  Figure 18: Schedule Browser - Rule Order Tab

When an instance is selected, the right pane displays more detail about the module instance: the
module, the input and output ports and, if available, the position in the source code. To view the
source for an instance, select Module→View Source. It will open an editor window with the
source ﬁle in which the instance is deﬁned, at the position indicated on the right pane. If no position
is listed, the module is part of the BSV library and cannot be modiﬁed, and therefore, the source
ﬁle cannot be opened.
When a method is selected, the rules and submodules which use the method are displayed in the
right pane.

5.4.4 Rule Relations

The Rule Relations tab describes conﬂicts between any two rules, as shown in Figure 20. This is
the same information generated from the -show-rule-rel compile ﬂag, Section 6.13.
If the compiler can determine that the predicates of the two rules are mutually exclusive (disjoint),
then the two rules can never be ready in the same cycle and therefore conﬂicts are irrelevant and
will not be computed.
For each conﬂict found, the conﬂicting calls are listed. The types of conﬂicts are as follows:

    • &lt;&gt;: The rules use a pair of methods which are not conﬂict free. The rules either cannot be
       executed in the same clock cycle or they can but one must be sequenced ﬁrst. The compiler
       lists the methods used in each rule which are the source of the conﬂict.

    • &lt;: The ﬁrst rule cannot be executed in sequence before the second rule, because they use
       methods which cannot sequence in that order. Again, the compiler lists the methods used in
       each rule which are the source of the conﬂict.

    • resource: A conﬂict introduced because of resource arbitration, where more rules are vying for
       a method than there are available ports for the method.

    • cycle: A conﬂict introduced by the compiler to break an execution order cycle.
    • attribute: A conﬂict introduced by a scheduling attribute, such as the preempts attribute.

                                                                41


                                 Figure 19: Schedule Browser - Method Call Tab

5.5 Viewing Scheduling Graphs

The Scheduling Graphs option on the Schedule Analysis displays the scheduling graphs. To
view the graphs, the following conditions must be met:

    • The graphviz Tcl extensions (TclDot) must be installed as described in Section 1.4.
    • The .dot ﬁles must have been generated during compilation by specifying the compiler ﬂag

       -sched-dot (Section 6.13) in the options ﬁeld on the Project Options→Compiler tab.
    • You must have a synthesized module.

The following ﬁve graphs are available for each synthesized module:

    • Conﬂict
    • Execution Order
    • Urgency
    • Combined
    • Combined Full

In each of these graphs, the nodes are rules and methods and the edges represent some relationship
between pairs of rules/methods. Methods are represented by a box and rules are represented by an
ellipse, so that they are visually distinguishable.
You can perform the following tasks for each of the Scheduling Graphs:

    • Filter the graph by selecting speciﬁc nodes and edges to display or to remove from the graph.
       The conﬂict graph in Figure 21 shows the ﬁlter options on the left side of the window.

    • Change the text label on the graph with the Rename button.

                                                                42


                                Figure 20: Schedule Browser - Rule Relations Tab
    • Hide the ﬁlter options with the Hide button. Use View→Show Filter to unhide the ﬁlter

       options.
    • Save the graph as a ﬁle from the View→Export menu. You will be prompted for a name

       and format for the export ﬁle.
    • Zoom by using the Zoom menu or the slide bar at the top of the screen.

                                   Figure 21: Conﬂicts Graph with ﬁlter options
5.5.1 Conﬂict
The conﬂicts graph, shown in Figure 21, displays rules/methods which conﬂict either completely
(they cannot execute in the same cycle) or in one direction (if they execute in the same cycle, it

                                                                43


has the be in the opposite order). Complete conﬂicts are represented by bold non-directional edges.
Ordering conﬂicts are represented by dashed directional edges, pointing from the node which must
execute ﬁrst to the node which must execute second.
When a group of nodes form an execution cycle, as shown in Figure 21, the compiler breaks the cycle
by turning one of the edges into a complete conﬂict and emits a warning. This graph is generated
before that happens, so it includes any cycles and can be used to debug any such warnings.

5.5.2 Execution Order

                                          Figure 22: Execution Order Graph

The execution order graph, shown in Figure 22, is similar to the conﬂicts graph, except that it only
includes the execution order edges; the full-conﬂict edges have been dropped. As a result, there is no
need to distinguish between the types of edges (bold versus dashed), so all edges appear as normal
directional edges.
This graph is generated after cycles have been broken and therefore describes the ﬁnal execution
order for all rules/methods in the module.

5.5.3 Urgency
The edges in the urgency graph, as shown in Figure 23, represent urgency dependencies. They are
directional edges which point from a more urgent node to a less urgent node (meaning that if the
rules/methods conﬂict, then the more urgent one will execute and block the less urgent one). Two
rules/methods have an edge either because the user speciﬁed a descending urgency attribute or
because there is a data path (though method calls) from the execution of the ﬁrst rule/method to
the predicate of the second rule/method.
If there is a cycle in the urgency graph, the compiler reports an error. This graph is generated before
such errors, so it will contain any cycles and is available to help debug the situation.

5.5.4 Combined
In the combined graph, shown in Figure 24 and the combined full graph, shown in Figure 25,
there are two nodes for each rule/method. One node represents the scheduling of the rule/method

                                                                44


 Figure 23: Urgency Graph

Figure 24: Combined Graph
                 45


(computing the CAN FIRE and the WILL FIRE signals) and one node represents the execution of the
rule/method’s body. The nodes are labelled Sched and Exec along with the rule/method name. To
further help visually distinguish the nodes, the Sched nodes are shaded.
The edges in this graph are a combination of the execution order and urgency graphs. This is the
graph in which the microsteps of a cycle are performed: compute whether a rule will ﬁre, execute a
rule, and so on.
In the rare event that the graph has a cycle, the compiler will report an error. This graph is generated
prior to that error, so it will contain the cycle and be available to help in debugging the situation.

5.5.5 Combined Full

                                           Figure 25: Combined Full Graph

Sometimes the execution or urgency order between two rules/methods is underspeciﬁed and either
order is a legal schedule. In those cases, the compiler picks an order and warns the user that it did
so.
The combined full graph, shown in Figure 25 is the same as the combined graph above, except that
it includes the arbitrary edges which the compiler inserted. The new edges are bold and colored
blue, to help highlight them visually.
This is the ﬁnal graph which determines the static schedule of a module (the microsteps of computing
predicates and executing bodies).
As with the above graph, there are separate Sched and Exec nodes for each rule/method, where the
Sched nodes are shaded.

6 BSC ﬂags

There are a number of ﬂags used by the compiler for compilation (synthesis) and linking. Flags
are entered on the command line or, in the development workstation, added to the compile or link
options ﬁelds in the Project→Options window.
You can obtain an up-to-date listing of the available ﬂags along with brief explanations by going to
a Unix command line and entering:

                                                                46


                           bsc -help

Or from the workstation command line type:

                           exec bsc -help

Most ﬂags may be preceded by a -no to reverse their eﬀect. Flags that appear later on the command
line override earlier ones.

The following ﬂags make the compiler print progress-report messages as it does its work:

                 -verbose                       be talkative
                 -v                             same as -verbose

6.1 Common compile and linking ﬂags

The following ﬂags are the common ﬂags used by the compiler. These ﬂags are automatically
generated by the development workstation, so you will only use them when executing bsc from a
Unix command line.

-g module        generate code for ‘module’ (requires -sim or -verilog)
-u               check and recompile packages that are not up to date
-sim             compile BSV generating Bluesim object
-verilog         compile BSV generating Verilog file
-vsim simulator  specify which Verilog simulator to use
-e module        top-level module for simulation
-o name          name of generated executable

The -vsim ﬂag (along with the equivalent BSC VERILOG SIM environment variable) governs which
Verilog simulator is employed. The natively supported choices for -vsim are vcs, vcsi, ncverilog,
modelsim, cver, iverilog, and veriwell. If a simulator is not speciﬁed bsc will attempt to detect
one of the above simulators and use it.

6.2 Controlling default ﬂag values

The environment variable BSC OPTIONS enables the user to set default ﬂag values to be used each
time the compiler is called. If set, the value of BSC OPTIONS is automatically prepended to the
compiler option values typed on the bsc command line. This avoids the need to set speciﬁed ﬂag
values each time the compiler is called.
For instance, in order to control the default value of the -p (path) option, the BSC OPTIONS envi-
ronment variable could be set as follows:

                                     # Bluespec Environment for csh/tcsh
                                     setenv BSC_OPTIONS &quot;-p .:./MyLib:+&quot;

                                     # Bluespec Environment for bash/ksh
                                     export BSC_OPTIONS=&quot;-p .:./MyLib:+&quot;

Once set, the BSV compiler would now search for packages in the ./MyLib directory before looking
in the default Prelude and Library areas. Note that since the compiler recognizes multiple uses
of the same ﬂag on the command line, the user can use the -p ﬂag along with the BSC OPTIONS
environment variable to control the search path. For example, if in addition to the BSC OPTIONS set
above the user enters the following bsc command, :

                                            47


                                         bsc -verilog -p ./MyLib2:+ Foo.bsv

the compiler would now use the path

                                                    ./MyLib2:.:./MyLib:+

which is a prepending of the -p command line value to the value set by the BSC OPTIONS environment
variable.

6.3 Verilog back-end

The following additional ﬂags are available when using the Verilog back end.

-remove-unused-modules  remove unconnected modules from the Verilog
-v95                    generate strict Verilog 95 code
-unspecified-to val     remaining unspecified values are set to:

-remove-dollar           ’X’, ’0’, ’1’, ’Z’, or ’A’
-Xv arg                 remove dollar signs from Verilog identifiers
                        pass argument to the Verilog link process

The -remove-unused-modules will remove from the generated Verilog any modules which are not
connected to an output. This has has the eﬀect of removing redundant or unused modules, which
would also be done by synthesis tools. This option should be used on modules undergoing synthesis,
and not be used for testbench modules.

The -v95 ﬂag restricts the Verilog output to pure Verilog-95. By default, the Verilog output uses
features which are not in the Verilog-95 standard. These features include passing module parameters
by name and use of the $signed system task for formatting $display output. When the -v95 ﬂag
is turned on, uses of these features are removed, but comments are left in the Verilog indicating the
parameter names or system tasks which were removed.

The -unspecified-to val ﬂag deﬁnes the value which any remaining unspeciﬁed values should be
tied to. The valid set of values are: X, 0, 1, Z, or A, where the ﬁrst four correspond to the Verilog
value, and A corresponds to a vector of alternating ones and zeros. The default value is A. The choice
of value is used by both the Verilog and Bluesim back ends. However, since Bluesim is a two-value
simulator, it does not support the values X and Z. For ﬁnal synthesis runs, the use of X (or 0) is
strongly suggested to give the best synthesis results.

The -remove-dollar ﬂag causes identiﬁers in Verilog output to substitute underscores instead of
dollar signs to separate instance names from port names. If this substitution causes a name collision,
the underscore is suﬃxed with a number until a non-colliding name is found.

The -Xv ﬂag passes the speciﬁed string argument to the Verilog link process. Only one argument
can be passed with each -Xv ﬂag. If you want to pass multiple arguments, then the ﬂag must be
speciﬁed multiple times, once for each argument.

6.4 Resource scheduling (all back ends)

The following ﬂags are available to direct resource scheduling:

-resource-off           fail on insufficient resources
-resource-simple        reschedule on insufficient resources

                        48


Resource scheduling for a particular interface method involves ﬁnding all rules that call that method.
A single method name can refer to multiple ports in the hardware — for example, a double-ported
RAM can have two read ports, but a design in BSV can use the name read and it will rely on the
compiler to determine which port is being used. If the number of rules that use read is two or less,
then there is no problem; each rule is connected to its own port and there is never any contention.
If the number of rules vying for a method is more than the number of copies of that method, then
a problem exists.

If -resource-off is speciﬁed, the compiler will give up and tell the user that resource scheduling
is not possible. This is the default behavior. The straightforward way to proceed is by adding
logic that explicitly arbitrates between the competing rules (choosing the more important one to ﬁre
depending on the situation).

The alternative way to resolve a resource conﬂict is to block competing rules until the number of
rules vying for a method is less than the number of available ports for that method. This behavior
can be turned on with the -resource-simple ﬂag. The compiler selects rules to block from the
competing rules arbitrarily (and may change its selection when diﬀerent compilation ﬂags or compiler
versions are used), so this ﬂag is not recommended for a completed design, but automatic resource
arbitration can be useful when experimenting.

6.5 Setting the path

-i dir                override $BLUESPECDIR
-p path               directory path (‘:’ sep.) for source and intermediate
                      files
-bdir dir             output directory for .bi, .bo, and .ba files
-simdir dir           output directory for Bluesim intermediate files
-vdir dir             output directory for .v files
-info-dir dir         output directory for cross-info files
-I path               include path for compiling foreign C/C++ source
-L path               library path for linking foreign C/C++ objects
-l library            library to use when linking foreign C/C++ objects

There are default locations where the compiler looks for source and and intermediate ﬁles. The
ﬂags -i and -p are available to override the default locations or to specify additional directories to
search in. See Section 4.2.4 for more information. The -i ﬂag overrides the environment variable
BLUESPECDIR, which is used in the default value for the directory path of the -p ﬂag. The -p
ﬂag takes a path argument, which is a colon-delimited list of directories. This path is used to
ﬁnd Bluespec source and intermediate ﬁles imported by the package being compiled (including the
standard prelude, and ﬁles included by the BSV preprocessor). The path can contain the character
%, representing the BLUESPECDIR directory, as well as +, representing the current path. The default
path is:

                                               .:%/Prelude:%/Libraries

The -bdir, -simdir, -vdir, and -info-dir ﬂags specify where output ﬁles should be placed. The
default is the directory in which the input ﬁle(s) reside.
The ﬂags -I, -L, and -l are used during the linking stage when foreign C functions are imported.
The -I and -L ﬂags add to the path of where to ﬁnd C header ﬁles and libraries, respectively. The
libraries to be used during linking are speciﬁed by the -l ﬂag.

                      49


6.6 License-related ﬂags

The following ﬂags are related to the license:

-licenseWarning days    sets the number of days before a license expires to
                        issue a warning
-print-expiration       print the expiration date and exit
-show-license-detail    show more details regarding license acquisition
-wait-for-license       wait for license to free rather than exit
-license-type           sets the type of license to checkout
-runtime-license        control use of run-time license
                        vs. compile-time license

To ﬁnd out when your Bluespec compiler license expires, use -print-expiration. By default, bsc
warns when the license expires in 30 days or less, use -licenseWarning to set the warning period.
The option -show-license-detail shows details of the license acquisition including search path
and the server where the license was acquired.

The option -wait-for-license is useful for batch operations when the user does not want the job
to fail due to a busy license. Under this option, the Bluespec compiler will queue a request for a
license and then block execution until a license is freed. License queuing is under the control of
the FLEXnetTMsoftware. If you kill a process which is waiting for a license, ensure that all threads
are killed; FLEXnetTMstarts a separate thread to communicate with the license server. You should
always specify the license type when waiting for a license.

The option -license-type speciﬁes the type of license to check out. Bluespec oﬀers ﬂoating and
seat licenses. A ﬂoating (or BComp) license is held until the compile completes. A seat (or BSeat)
license is tied to a user and is held for a speciﬁed amount of time, usually a workday. The time a
seat license is held is determined in your site contract.

Valid arguments to the -license-type ﬂag are Any, Floating, or Seat. The default behavior is
Any, in which case the compiler will ﬁrst attempt to check out a seat license, and then, if that fails,
a ﬂoating license. If this fails, the compiler will terminate (unless the -wait-for-license ﬂag was
speciﬁed).

By default, Bluesim models require a BSIM license at run-time. The option -no-runtime-license
generates SystemC or Bluesim models that do not require a runtime license. This option requires
the existence of either a SYSCUNLIC or BSIMUNLIC license at compile time in order to create the
unlicensed runtime model.

6.7 Miscellaneous ﬂags

Here are some other ﬂags recognized by the compiler:

-D macro                define a macro for the SystemVerilog preprocessor
-E                      run just the preprocessor, dumping result to stdout
-print-flags            print flag values after command-line parsing
-steps n                terminate elaboration after this many function
                        unfolding steps
-steps-max-intervals n  terminate elaboration after this number of unfolding
                        messages
-steps-warn-interval n  issue a warning each time this many unfolding steps are
                        executed

Preprocessor macros may be deﬁned on the command line using the -D option. Two versions are
supported, a simple macro deﬁnition and an assignment of a string to a macro:

                                                50


                                                        -D foo
                                                        -D size=148

Note that a space is required after the -D, and that no spaces are allowed in the macro names, values
or around the equals.

Function deﬁnitions in BSV are purely compile-time entities. The compiler replaces all function calls
by their bodies and continually simpliﬁes expressions. Function deﬁnitions may be recursive as long
as this substitution and simpliﬁcation process terminates, but of course the compiler cannot pre-
dict whether it will terminate. The -steps, -steps-warn-interval and -steps-max-intervals
ﬂags provide feedback and safety mechanisms for potentially inﬁnite function unfoldings. The
-steps-warn-interval tells the compiler to issue a compilation warning every time that many
function unfolding steps are executed. This provides feedback to a designer that a particular design
requires an unusual amount of eﬀort to elaborate. A designer may choose to terminate elabora-
tion and investigate whether there is a bug, inﬁnite loop or an ineﬃcient construct in a design
or they may choose to let elaboration proceed to see if additional time will result in elaboration
completing. The -steps-max-intervals ﬂag is the safety mechanism. It prevents an unattended
compilation from consuming resources indeﬁnitely by terminating elaboration after a certain num-
ber of function unfolding warnings. This means, for example, with the default values of 100000 for
-steps-warn-interval and 10 for -steps-max-intervals an inﬁnite compilation will execute for
1000000 steps, issuing 9 unfolding warnings before terminating with an unfolding error message. The
-steps ﬂag is a simpler version of this mechanism. It is equivalent to setting -steps-warn-interval
to the argument of -steps and -steps-max-intervals to 1.

The settings that are being used by the compiler can be dumped with -print-flags.

6.8 Run-time system

These ﬂags are passed along to the Haskell compiler run-time system that is used to execute the
Bluespec compiler. Among the RTS ﬂags available are:

-Hsize               set the maximum heap size
-Ksize               set the maximum stack size

As the compiler executes, it allocates its internal intermediate data structures in a heap memory
managed by its run-time system (RTS). When compiling a large BSV design, the compiler may run
out of heap space. If you encounter this, please rerun the compiler with a larger heap space, using
the ﬂags:

                     bsc ... +RTS -H&lt;size&gt; -RTS ...

For example, to use an 80-megabyte heap, you would enter:

                     bsc ... +RTS -H80M -RTS ...

Similarly, if you run out of stack space, you can increase the stack with the -K RTS ﬂag. If a design
runs out of stack space, it is probably caught in an inﬁnite loop. For large designs that involve many
recursive functions, it may be necessary to increase the stack size. If you run out of stack space,
ﬁrst try increasing the stack to a reasonable size, such as 10 or 15 megabytes. If you still exhaust
the stack memory, try examining your design for inﬁnite loops.

Any ﬂags encapsulated between +RTS and -RTS are passed to the run-time system and are not given
to the BSV compiler itself. In addition to -H and -K, various ﬂags are available to control garbage
collection, memory usage, function unfolding, etc. However, the user should never need to use these
other ﬂags.

                     51


6.9 Automatic recompilation

-u              check and recompile packages that are not up to date
-show-compiles  show recompilations

The -u ﬂag implements a make-like functionality. If a needed .bi or .bo ﬁle is found to be older
or non-existent compared to the .bsv ﬁle, the latter is recompiled. Similarly, if a .bsv ﬁle has a
modiﬁcation time that is more recent than that of any of its generated Verilog or Bluesim modules,
the .bsv ﬁle is recompiled.

The -show-compiles ﬂag turns on the compiler output during recompilation of auxiliary ﬁles. It
can also be used as -no-show-compiles to suppress the compiler output.

For the purposes of comparing modiﬁcation times, the intermediate ﬁles (.bi, .bo, and .ba) are
assumed to be in the same directory as the .bsv source ﬁle. If no ﬁle is found there, the compiler
then searches in the directory speciﬁed by the -bdir ﬂag (if used). The generated Verilog ﬁles and
Bluesim ﬁles are assumed to be in the same directory as the source unless the -simdir or -vdir
ﬂag is used, respectively.

6.10 Compiler transformations

-aggressive-conditions construct implicit conditions aggressively

-split-if       split &quot;if&quot; in actions

-lift           lift method calls in &quot;if&quot; actions

When a rule contains an if-statement, the compiler has the option either of splitting the rule
into two mutually exclusive rules, or leaving it as one rule for scheduling but using MUXes in the
production of the action. Rule splitting can sometimes be desirable because the two split rules are
scheduled independently, so non-conﬂicting branches of otherwise conﬂicting rules can be scheduled
concurrently. The -split-if ﬂag tells the compiler to split rules. Splitting is turned oﬀ by default
for two reasons:

• When a rule contains many if-statements, it can lead to an exponential explosion in the
   number of rules. A rule with 15 if-statements might split into 215 rules, depending on how
   independent the statements (and their branch conditions) are. An explosion in the number
   of rules can dramatically slow down (and cause other problems) for later compiler phases,
   particularly scheduling.

• Splitting propagates the branch condition of each if to the predicates of the split rules. Re-
   sources required to compute rule predicates are reserved on every cycle. If a branch condition
   requires a scarce resource, this can starve other parts of the design that want to use that
   resource.

If you need the eﬀect of splitting for certain rules, but do not want to split all the rules in an entire
design using -split-if, use the (*split*) and (*nosplit*) attributes, as described in the BSV
Reference Guide.

When rules are not split along if-statements, it is important to lift actions through the if-statement.
If both branches of an if-statement call the same method but with diﬀerent arguments, it’s better
to make one call to the method and MUX the argument. The -lift ﬂag turns on this optimization.
Lifting is recommended when rule splitting is turned oﬀ. When rule splitting is on, lifting is not
required and can make rules more resource hungry. Currently, lifting with splitting oﬀ can result
in poor resource allocation, so we recommend using -no-lift with -split-if.

                               52


When the action in a branch of an if-statement has an implicit condition, that condition needs to
be propagated to the rule predicate. This can be done conservatively, by simply placing implicit
conditions for all branches in the predicate. Or it can be done more aggressively (i.e. attempting
to ﬁre the concerned rule more often), by linking each implicit condition with its associated branch
condition. The ﬂag -aggressive-conditions turns on this feature. This ﬂag is oﬀ by default
because, as discussed above, propagating branch conditions to rule predicates can have undesirable
eﬀects. However, if -split-if is on, branch conditions will be propagated to rule predicates regard-
less, so we recommend using -aggressive-conditions with -split-if, since it may improve the
generated schedule.

6.11 Compiler optimizations

-O                       turn on various optimizations

-opt-undetermined-vals aggressive optimization of undetermined values

The -O ﬂag turns on several compiler optimizations. Using these optimization, there may be an
increase in bsc runtime, memory use or both.

In late stages of the compiler, don’t-care values are converted into speciﬁc constants. In order
that the Verilog and Bluesim simulation paths produce exactly the same value dumps, the compiler
assigns a value to the don’t-care signals at the point where the Verilog and Bluesim back ends
diverge. However, the Verilog back end can generate more eﬃcient hardware if it is allowed to assign
the don’t-care signals better values based on context. The -opt-undetermined-vals ﬂag permits
the Verilog back end of the compiler to make better decisions about don’t-care values. This ﬂag is
oﬀ by default. Turning this ﬂag on may produce better hardware in Verilog, but can result in the
Bluesim and Verilog simulations producing diﬀerent intermediate values.

Some non-deterministic optimizations are used during scheduling, which may result in excessive run
time or conversely, a too conservative (less optimal) schedule. The eﬀort is controlled with the
following switches.

-scheduler-effort limit  set effort for disjoint testing during scheduling
-warn-scheduler-effort   displays warnings when the scheduler limit is reached

The default limit is 20, and typical values range from 10 to 500. This value should not be changed
unless a less-than-optimal schedule is observed, and -warn-scheduler-effort shows that the limit is
indeed exceeded. Larger limits may cause excessive runtime, and still not produce optimal schedules.
Note that the scheduled Verilog is logically correct even if this limit is exceeded.

6.12 BSV debugging ﬂags

The following ﬂags might be useful in debugging a BSV design:

                             53


-check-assert        test assertions with the Assert library

-keep-fires          preserve CAN_FIRE and WILL_FIRE signals

-keep-inlined-boundaries preserve inlined register and wire boundaries

-remove-false-rules  remove rules whose condition is provably false

-remove-starved-rules remove rules that are never fired by the generated

                     schedule

-remove-empty-rules  remove rules whose bodies have no actions

-show-module-use     output instantiated Verilog modules names

-show-range-conflict show predicates when reporting a parallel

                     composability error

-show-method-conf    show method conflict information in the generated code

-show-stats          show package statistics

-Werror              make warnings to errors

-continue-after-errors aggressively continue compilation after an error has

                     been detected

-warn-method-urgency warn when a method’s urgency is arbitrarily chosen

-warn-action-shadowing warn when a rule’s action is overwritten by a later rule

The -check-assert ﬂag instructs the compiler to abort compilation if an boolean assertion ever
fails. These are assertions which are explicitly embedded in a BSV design using the Assert package
(see the Bluespec Reference Guide). If this ﬂag is oﬀ, assertions of this type in a BSV design are
ignored.

To view rule ﬁrings in the Verilog output, use the -keep-fires ﬂag. This ﬂag will direct the compiler
to leave the CAN FIRE and WILL FIRE signals in the output Verilog (some of which might otherwise
be optimized away). These signals are generated for each rule and indicate whether a rule’s predicate
would allow the rule to ﬁre in the current cycle and whether the scheduler chose the rule to ﬁre in
the current cycle, respectively. Leaving these signals in the Verilog allows the designer to dump the
signals to VCD and view the ﬁrings in a waveform viewer.

When elaborating a design, if the compiler determines that a rule’s explicit condition is always false,
it issues a warning about the situation and removes the rule from the design (so the presumably
irrelevant rule does not interfere with scheduling). Sometimes, for debugging purposes it can be
helpful to preserve this (never enabled) rule in the output code. That can be done by disabling
the -remove-false-rules ﬂag (i.e. passing -no-remove-false-rules). As you might expect, the
compiler will ﬁnd more false rules when aggressive optimization (i.e. -O) is turned on, but it can be
helpful to turn oﬀ -O when you want to examine the condition that the compiler can prove false.

Similarly, the compiler might determine, after scheduling, that a rule will never ﬁre because con-
ﬂicting rule(s) block it whenever it is enabled. The compiler warns about such rules, but does not
remove them by default because they probably indicate an important problem in scheduling the
design. If you wish to removed these rules, you can use the -remove-starved-rules ﬂag.

The compiler may also determine that the body of a rule has no actions, either because there are no
actions in the body or because the compiler can prove at elaboration time that none of the actions
in the body can happen. The -remove-empty-rules ﬂag causes these rules to be removed when
it is on, which it is by default. The compiler will generate a warning for such rules, since they are
likely to indicate a problem in the design.

Conﬂict relationships between methods of the generated module’s interface can be dumped (in the
generated code) with the -show-method-conf ﬂag. This is enabled by default and is useful for
documenting the interface protocol a generated module expects (particularly when the generated
module is going to be called by non-Bluespec modules). The -show-stats ﬂag dumps various
statistics at the end of each compiler stage (such as the number of rules and number of deﬁnitions). To
ﬁnd out what Verilog modules are instantiated by the generated module, use the -show-module-use
ﬂag. This ﬂag causes the compiler to create a ﬁle mkFoo.use which contains a list of each Verilog
module instantiated by module mkFoo, separated by newlines.

                                    54


The -show-range-conflict ﬂag is used to display more information when the compiler reports error
message G0004. By default, the compiler omits the conditions of the method calls, because they
can be very large expressions in some cases, which distract from debugging rather than help. When
more detail is required, the -show-range-conflict ﬂag can be turned on and the full condition is
displayed.

By default, the compiler stops once it ﬁnds errors in a module. The -continue-after-errors ﬂag
allows the compiler to continue on to other modules and other phases after an error is encountered.
This may be helpful in ﬁnding multiple errors in a single compile, though some of later errors may
be misleading and vanish once the cause of initial error is ﬁxed. Note that the compiler may not be
able to successfully complete because of the cumulative eﬀects of errors encountered.

The -warn-method-urgency ﬂag displays a warning when a method and a rule have an aribitrary
urgency order. By defualt the ﬂag is on.

The -warn-action-shadowing ﬂag displays a warning when there are two rules executing in the
same cycle and calling the same Action method. In this case, the state update of the ﬁrst method is
ignored because it is overwritten by the state update of the second method. This can only occur for
methods which are annotated as non-conﬂicting, for example, register writes. Otherwise the Action
methods will conﬂict. This ﬂag is on by default.

6.13 Understanding the schedule

These ﬂags generate output to help you understand the schedule for a generated module.

-show-rule-rel r1 r2  display scheduling information about rules r1 and r2
-show-schedule        show generated schedule
-sched-dot            generate .dot files with schedule information

If the rules in a design are not ﬁring the way you thought they would, the -show-schedule and the
-show-rule-rel ﬂags may help you inspect the situation. See section 7.2.2 for a description on the
output generated by these ﬂags.
The -sched-dot ﬂag generates .dot (DOT) ﬁles which contain text representation of a graph. There
are many tools in the graphviz family, for example dotty, which read, manipulate, and render DOT
ﬁles to visible format. See www.graphviz.org for more information.
When speciﬁed, the following graph ﬁles are generated for each synthesized module (mod is the
module name):

   1. conﬂicts (mod conﬂict.dot)

   2. execution order (mod exec.dot)

   3. urgency (mod urgency.dot)

   4. combined (mod combined.dot)

   5. combined full (mod combined full.dot)

In each of these graphs, the nodes are rules and methods and the edges represent some relationship
between pairs of rules/methods. In all graphs, methods are represented by a box and rules are
represented by an ellipse, so that they are visually distinguishable.

                      55


conﬂicts (mod conﬂict.dot) A graph of rules/methods which conﬂict either completely (cannot
execute in the same cycle) or conﬂict in one direction (if they execute in the same cycle, it has the be
in the opposite order). Complete conﬂicts are represented by bold non-directional edges. Ordering
conﬂicts are represented by dashed directional edges, pointing from the node which must execute
ﬁrst to the node which must execute second.

When a group of nodes form an execution cycle (such as A before B before C before A), the compiler
breaks the cycle by turning one of the edges into a complete conﬂict and emits a warning. This
DOT ﬁle is generated before that happens, so it includes any cycles and can be used to debug any
such warnings.

execution order (mod exec.dot) This is similar to the conﬂicts graph, except that it only
includes the execution order edges; the full-conﬂict edges have been dropped. As a result, there
is no need to distinguish between the types of edges (bold versus dashed), so all edges appear as
normal directional edges.

This DOT ﬁle is generated after cycles have been broken and therefore describes the ﬁnal execution
order for all rules/methods in the module.

urgency (mod urgency.dot) The edges in this graph represent urgency dependencies. They are
directional edges which point from a more urgent node to a less urgent node (meaning that if the
rules/methods conﬂict, then the more urgent one will execute and block the less urgent one). Two
rules/methods have an edge either because the user speciﬁed a descending urgency attribute or
because there is a data path (though method calls) from the execution of the ﬁrst rule/method to
the predicate of the second rule/method.

If there is a cycle in the urgency graph, BSC reports an error. This DOT ﬁle is generated before
such errors, so it will contain any cycles and is available to help debug the situation.

combined (mod combined.dot) In this and the following graph, there are two nodes for each
rule/method. One node represents the scheduling of the rule/method (computing the CAN FIRE and
the WILL FIRE signals) and one node represents the execution of the rule/method’s body. The nodes
are labelled Sched and Exec along with the rule/method name. To further help visually distinguish
the nodes, the Sched nodes are shaded.

The edges in this graph are a combination of the execution order and urgency graphs. This is the
graph in which the microsteps of a cycle are performed: compute whether a rule will ﬁre, execute a
rule, and so on.

In the rare event that the graph has a cycle, BSC will report an error. This DOT ﬁle is generated
prior to that error, so it will contain the cycle and be available to help in debugging the situation.

combined full (mod combined full.dot) Sometimes the execution or urgency order between
two rules/methods is under speciﬁed and either order is a legal schedule. In those cases, BSC picks
an order and warns the user that it did so.

This DOT graph is the same as the combined graph above, except that it includes the arbitrary
edges which the compiler inserted. The new edges are bold and colored blue, to help highlight them
visually.

This is the ﬁnal graph which determines the static schedule of a module (the microsteps of computing
predicates and executing bodies).

As with the above graph, there are separate Sched and Exec nodes for each rule/method, where the
Sched nodes are shaded.

                                                                56


6.14 C/C++ ﬂags

These ﬂags run the C preprocessor and pass arguments to C tools.

-cpp       preprocess the source with the C preprocessor
-Xc arg    pass argument to the C compiler
-Xc++ arg  pass argument to the C++ compiler
-Xcpp arg  pass argument to the C preprocessor
-Xl arg    pass argument to the C/C++ linker

The -cpp ﬂags runs the C preprocessor on the source ﬁle before the BSV preprocessor is run. The
CC environment variable speciﬁes which C compiler will be used. If the environment variable is not
speciﬁed, the compiler will run the default (cc) which must be found in the path.

The ﬂags -Xcpp, -Xc, -Xc++, and -Xl pass the speciﬁed argument to the C preprocessor, C compiler,
C++ compiler and C/C++ linker respectively. Only one argument can be passed with each -X ﬂag.
If you want to pass multiple arguments, then the ﬂag must be speciﬁed multiple times, once for each
argument. Example:

           -Xcpp -Dfoo=bar -Xcpp /l/usr/local/special/include

7 Compiler messages

7.1 Warnings and Errors

The following is an example of a warning from the Bluespec compiler:

              Warning: &quot;Test.bsv&quot;, line 5, column 9: (G0021)
                 According to the generated schedule, rule &quot;r1&quot; can never fire.

All warnings and errors have this form, as illustrated below. They begin with the position of the
problem, a tag which is unique for each message, and the type (either “Error” or “Warning”).

                                            &lt;type&gt;: &lt;position&gt;: (&lt;tag&gt;)
                                               &lt;message&gt;

The unique tag consists of a letter, indicating the class of message, and a four digit number. There are
four classes of messages. Tags beginning with P are for warnings and errors in the parsing stage of the
compiler. Tags beginning with T are type-checking and elaboration messages. Tags beginning with
G are for problems in the back-end, or code-generation, including rule scheduling. Tags beginning
with S are for ﬁle handling problems, command-line errors, and other system messages.

7.1.1 Type-checking Errors

If there is a type mismatch in your design, you will encounter a message like this:

           57


                             Error: &quot;Test.bsv&quot;, line 3, column 10: (T0020)
                                 Type error at:
                                 x

                                 Expected type:
                                 Prelude::Bool

                                 Inferred type:
                                 Prelude::Bit#(8)

This message points to an expression (here, x) whose type does not match the type expected by the
surrounding code.

You can think of this like trying to put a square block into a round hole. The square type and the
round type don’t match, so there is a problem. The type of the expression (the block) doesn’t match
the type that the surrounding code is expecting (the hole). In the error message, the “expected
type” is hole and the “inferred type” is the block.

7.1.2 Scheduling Messages

Static execution order When multiple rules execute in the same cycle, they must execute in a
sequence, with each rule completing its state update before the next rule begins. In order to simplify
the muxing logic, the Bluespec compiler chooses one execution order which is used in every clock
cycle. If rule A and rule B can be executed in the same cycle, then they will always execute in the
same order. The hardware does not dynamically choose to execute them in the order “A before B”
in one cycle and “B before A” in a later cycle.

There may be times when three or more rules cannot execute in the same cycle, even though any
two of the rules can. Consider three rules A, B, and C, where A can be sequenced before B but not
after, B can only be sequenced before C, and C can only be sequenced after A. For any two rules,
there is an order in which they may be executed in the same cycle. But there is no order for all
three. If the conditions of all three rules are satisﬁed, the scheduler cannot execute all of them. It
must make a decision to execute only two – for example, only A and B. But notice that this is not
all. The scheduler must pick an order for all three rules, say “A before B before C.” That means
that not only will C not ﬁre when both A and B are chosen to execute, but also that C can never ﬁre
when A is executed. This is because the compiler has chosen a static order, with A before C, which
prevents rule C from ever executing before rule A. Eﬀectively, the compiler has created a conﬂict
between rules A and C.

If the compiler must introduce such a conﬂict, in order to create a static execution order, it will
output a warning:

          Warning: &quot;Test.bsv&quot;, line 30, column 0: (G0009)
             The scheduling phase created a conflict between the following rules:
                   ‘RL_One’ and ‘RL_Two’
             to break the following cycle:
                   ‘RL_One’ -&gt; ‘RL_Two’ -&gt; ‘RL_Three’ -&gt; ‘RL_One’

Rule urgency The execution order of rules speciﬁes the order in which chosen rules will appear
to execute within a clock cycle. It does not say anything about the order in which rules are chosen.
The scheduling phase of the compiler chooses a set of rules to execute, and then that set is executed
in the order speciﬁed by the static execution order. The order in which the scheduling phase chooses
rules to put into that set can be diﬀerent from the execution order. The scheduling phase may ﬁrst

                                                                58


consider whether to include rule B before considering whether to include rule A, even if rule A will
execute ﬁrst. This order of consideration by the scheduling phase is called the urgency order.

If rule A and B conﬂict and cannot be executed in the same cycle, but can be ready in the same
cycle, then the ﬁrst one chosen by the scheduler will be the one to execute. If rule B is chosen before
rule A then we say that B is more urgent than A.

If two rules conﬂict and the user has not speciﬁed which rule should be more urgent, the compiler
will make its own (arbitrary) choice and will warn the user that it has done so, with the following
warning:

               Warning: &quot;Test.bsv&quot;, line 24, column 0: (G0010)
                  Rule &quot;one&quot; was treated as more urgent than &quot;two&quot;. Conflicts:
                     &quot;one&quot; cannot fire before &quot;two&quot;: calls to x.write vs. x.read
                     &quot;two&quot; cannot fire before &quot;one&quot;: calls to y.write vs. y.read

As you can see, this warning also includes details about how the compiler determined that the rules
conﬂict. This is because an unexpected urgency warning could be due to a conﬂict that the user
didn’t expect.

If the conﬂict is legitimate, the user can avoid this warning by specifying the urgency order between
the rules (and thus not leave it up to the vagaries of the compiler). The user can specify the urgency
with the descending urgency attribute. See the BSV Reference Guide for more information on
scheduling attributes.

Note that methods of generated modules are treated more urgent than internal rules.

Urgency between two rules can also be implied by a data dependency between the more urgent rule’s
action and the less urgent rule’s condition. This is because the ﬁrst rule must execute before the
scheduler can know whether the second rule is ready. See Section 7.1.3 for more information on how
such paths are created.

If a contradiction is created, between the user-supplied attributes, the path-implied urgency rela-
tionships, and/or the assumed relationship between methods and rules, then an error is report, as
follows:

          Error: &quot;Test.bsv&quot;, line 8, column 8: (G0030)
             A cycle was detected in the urgency requirements for this module:
                ‘bar’ -&gt; ‘RL_foo’
             The relationships were introduced for the following reasons:
                (bar, RL_foo) introduced because of method/rule requirement
                (RL_foo, bar) introduced because of the following data dependency:
                   [WillFire signal of rule/method ‘RL_foo’,
                     Enable signal of method ‘wset’ of submodule ‘the_rw’,
                     Return value of method ‘whas’ of submodule ‘the_rw’,
                     Output of top-level method ‘RDY_bar’,
                     Enable signal of top-level method ‘bar’,
                     CanFire signal of rule/method ‘bar’]

7.1.3 Path Messages

Some state elements, such as RWire, allow reading of values which were written in the same cycle.
These elements can be used to avoid the latency of communicating through registers. However, they
should only be used to communicate from a rule earlier in the execution sequence to a rule later in
the sequence. Other uses are invalid and are detected by the compiler.

                                                                59


For example, if a value read in a rule’s condition depends on the writing of that value in the rule’s
action, then you have an invalid situation where the choosing of a rule to ﬁre depends on whether
that rule has ﬁred! In such cases, the compiler will produce the following error:

    Error: &quot;Test.bsv&quot;, line 20, column 10: (G0033)
       The condition of rule ‘RL_flip’ depends on the firing of that rule. This is
       due to the following path from the rule’s WILL_FIRE to its CAN_FIRE:
          [WillFire signal of rule/method ‘RL_flip’,
            Control mux for arguments of method ‘wset’ of submodule ‘the_x’,
            Argument 1 of method ‘wset’ of submodule ‘the_x’,
            Return value of method ‘wget’ of submodule ‘the_x’,
            CanFire signal of rule/method ‘RL_flip’]

Similarly, if the ready signal of a method has been deﬁned as dependent on the enable signal of that
same method, then an invalid situation has been created, and the compiler will produce an error
(G0035). The ready signal of a method must also be computed prior to knowing the inputs to the
method. If the ready signal of a method depends on the values of the arguments to that method,
an error message will be reported (G0034).
A combinational cycle can result if a bypass primitive is used entirely within a single rule’s action.
In such cases, the compiler will produce an error explaining the source objects involved in the
combinational path, in data-dependency order:

      Error: &quot;Test.bsv&quot;, line 4, column 8: (G0032)
         A cycle was detected in the design prior to scheduling. It is likely that
         an action in this module uses circular logic. The cycle is through the
         following:
            [Argument 1 of method ‘wset’ of submodule ‘the_rw’,
             Return value of method ‘wget’ of submodule ‘the_rw’]

7.2 Other messages

The Bluespec compiler can also emit status messages during the course of compilation.

7.2.1 Compilation progress

When the compiler ﬁnishes generating Verilog code for a module, it will output the location of the
ﬁle which it generated:

                                          Verilog file created: mkGCD.v

The following message is output when elaborating a design for Bluesim:

                           Elaborated Bluesim module file created: mkGCD.ba

When an elaboration ﬁle is generated to a Bluesim object, the following message is given:

                                     Bluesim object created: mkGCD.{h,o}

If previously generated Bluesim object ﬁles still exist, are newer than the .ba ﬁle from which they
were generated, and the module does not instantiate any modiﬁed sub-modules, then the existing
object ﬁles will be reused. In this case the following message is seen instead of the message above:

                                                                60


                                      Bluesim object reused: mkGCD.{h,o}

When the Bluesim object is linked to create a simulation binary, the following message is given:

                               Simulation shared library created: mkGCD.so
                               Simulation executable created: mkGCD

Automatic recompilation As described in Section 6.9, the -u ﬂag can be used to check depen-
dencies and recompile any needed packages which have been updated since their last compilation.
The -show-compiles ﬂag, which is on by default, will have the compiler output messages about the
dependent ﬁles which need recompiling, as follows:

                                     checking package dependencies
                                     compiling ./FindFIFO2.bsv
                                     compiling ./FiveStageCPUStall.bsv
                                     compiling CPUTest.bsv
                                     code generation for mkCPUTest starts
                                     packages up to date

Verbose output The -v ﬂag causes the compiler to output much progress information. First,
the version of the Bluespec compiler is displayed, followed by license information. Then, as each
phase of compilation is entered, a starting message is displayed. When the phase is completed, a
done message is displayed along with the time spent in that phase. During the import phase, the
compiler lists all of the header ﬁles which were read, including the full path to the ﬁles. During the
binary phase, the compiler lists all of the binary ﬁles which were read. Prior to code generation,
all of the modules to be compiled in the current package are listed:

                                         modules: [mkFiveStageCPUStall_]

Then, code generation is performed for each module, in the order listed. Each is prefaced by a
divider and the name of the module being generated:

                             *****
                             code generation for mkFiveStageCPUStall starts

After all modules have been generated, the header (.bi) and binary (.bo) ﬁles are output for the
package with the following message:

                                              Generate interface files

Finally, the total elapsed time of compilation is displayed.
Whenever the C or C++ compiler is invoked from BSC (such as during Bluesim compilation or
when compiling or linking foreign C functions), the executed command is displayed:

            exec: c++ -Wall -Wno-unused -O3 -fno-rtti -g -D_FILE_OFFSET_BITS=64
            -I/tools/bsc/lib/Bluesim -c -o mkGCD.o mkGCD.cxx

                                                                61


7.2.2 Scheduling information

There are two ﬂags which can be used to dump the schedule generated by the compiler and the
information which led to that schedule: -show-schedule and -show-rule-rel.
The -show-schedule ﬂag outputs three groups of information: method scheduling information (if
the module has methods), rule scheduling information, and the linear execution order of rules and
methods (see the paragraph on static execution order in Section 7.1.2). The output is in a ﬁle
modulename.sched in the directory speciﬁed by the info-dir (Section 6.5) ﬂag.
For each method, the following information is given: the method’s name, the expression for the
method’s ready signal (1 if it is always ready), and a list of conﬂict relationships with other methods.
Any methods which can execute in the same clock cycle as the current method, in any execution
order, are listed as “conﬂict-free.” Any methods which can execute in the same clock cycle but only
in a speciﬁc order are labelled either “sequenced before” (if the current method must execute ﬁrst)
or “sequenced after” (if the current method must execute second). Any methods which cannot be
called in the same clock cycle as this method are listed as “conﬂicts.” The following is an example
entry:

                             Method: imem_get
                             Ready signal: True
                             Conflict-free: dmem_get, dmem_put, start, done
                             Sequenced before: imem_put
                             Conflicts: imem_get

For each rule, the following information is given: the rule’s name, the expression for the rule’s ready
signal, and a list of more urgent rules which can block the execution of this rule. The more urgent
rules conﬂict with the current rule and, if chosen to execute, they will prevent the current rule from
executing in the same clock cycle (see the paragraph on rule urgency in Section 7.1.2). The following
is an example entry:

                            Rule: fetch
                            Predicate: the_bf.i_notFull_ &amp;&amp; the_started.get
                            Blocking rules: imem_put, start

The -show-schedule ﬂag will inform you that a rule is blocked by a conﬂicting rule, but won’t show
you why the rules conﬂict. It will show you that one rule was sequenced before another rule, but it
won’t tell you whether the other order was not possible due to a conﬂict. For conﬂict information,
you need to use the -show-rule-rel ﬂag.
The -show-rule-rel ﬂag can be used, during code generation, to query the compiler about the
conﬂict relationship between two rules. Since this requires re-running the compiler, it is most useful
to give the wildcard arguments \* \* and dump all rule relationships in one compile.

                                                 -show-rule-rel \* \*

If you only want to see the conﬂict relationships for a single rule, you can use:

                                             -show-rule-rel \* rulename2

which will output all the rule relationships for rulename2. No other uses of the wildcard argument
\* are valid with this ﬂag.
The following is an example entry in the -show-rule-rel output:

                                                                62


               Scheduling info for rules &quot;RL_execute_jz_taken&quot; and &quot;RL_fetch&quot;:
               predicates are not disjoint

                     &lt;&gt;
                     conflict:
                     calls to

                         the_pc.set vs. the_pc.get
                         the_bf.clear_ vs. the_bf.i_notFull_
                         the_pc.set vs. the_pc.set
                         the_bf.clear_ vs. the_bf.enq_
                     &lt;
                     conflict:
                     calls to
                         the_pc.set vs. the_pc.get
                         the_bf.clear_ vs. the_bf.i_notFull_
                         the_bf.clear_ vs. the_bf.enq_
                     no resource conflict
                     no cycle conflict
                     no attribute conflict

For the two rules given, several pieces of information are provided. If the compiler can determine
that the predicates of the two rules are mutually exclusive, then the two rules can never be ready
in the same cycle and therefore we need never worry about whether the actions can be executed in
the same clock cycle. In the above example, the predicates could not be determined to be disjoint,
so conﬂict information was computed.

Two rules have a &lt;&gt;-type conﬂict if they use a pair of methods which are not conﬂict free. The rules
either cannot be executed in the same clock cycle or they can but one must be sequenced ﬁrst. The
compiler lists the methods used in each rule which are the source of the conﬂict.

Two rules have a &lt;-type conﬂict if the ﬁrst rule mentioned cannot be executed in sequence before
the second rule, because they use methods which cannot sequence in that order. There is no entry
for &gt;-type conﬂicts; for that information, look for an entry for the two rules in the opposite order
and consult the &lt;-type conﬂict. Again, the compiler lists the methods used in each rule which are
the source of the conﬂict.

If a conﬂict was introduced between two rules because of resource arbitration (see Section 6.4), that
information will be displayed third. The fourth line indicates whether a conﬂict was introduced
to break an execution order cycle (see Section 7.1.2). The ﬁfth, and last, line indicates whether a
conﬂict was introduced by a scheduling attribute or operator in the design, such as the preempts
attribute (see the BSV Reference Guide for more information on pre-emption).

8 Verilog back end

The Verilog code produced by the BSV compiler can either be executed using standard Verilog
execution/interpretation tools or it can be compiled into netlists using standard synthesis tools.
The generated code uses Bluespec-deﬁned modules such as registers and FIFOs; these can be found
in $BLUESPECDIR/Verilog. These modules must be used for simulation or synthesis, though creating
a simulator with bsc -e automatically includes them. For example, to run the vcs simulator, use
the following command:

                       bsc -vsim vcs -e mkToplevel mkToplevel.v otherfiles.v

See Section 4.3.3 for details on choosing the Verilog simulator.

                                                                63


8.1 Bluespec to Verilog name mapping

To aid in the understanding and debugging of the generated Verilog code, this section describes the
general structure and name transformations that occur in mapping the original BSV source code
into Verilog RTL. The section is based on a single example, which implements a greatest common
denominator (GCD) algorithm. The source BSV code for the example is shown in Figure 26. The
generated Verilog RTL is shown in Figures 27 and 28.

8.1.1 Interfaces and Ports

The interface section of a BSV design is used to specify the ports (input and outputs) of the generated
Verilog code. The BSV interface speciﬁcation for the GCD example is repeated below.

    interface ArithIO_IFC #(parameter type aTyp); // aTyp is a parameterized type
          method Action start(aTyp num1, aTyp num2);
          method aTyp result();

    endinterface: ArithIO_IFC

This interface speciﬁcation leads to the following Verilog port speciﬁcation. In the BSV speciﬁcation
shown in Figure 26, the type parameter aTyp has been bound to be a 51-bit integer.

module mkGCD(CLK,                    // input 1 bit (implicit)
                    RST_N,           // input 1 bit (implicit)
                    start_num1,      // input 51 bits (explicit)
                    start_num2,      // input 51 bits (explicit)
                    EN_start,        // input 1 bit (implicit)
                    RDY_start,       // output 1 bit (implicit)
                    result,          // output 51 bits (explicit)
                    RDY_result       // output 1 bit (implicit)
                    );

Note that the generated Verilog includes a number of ports in addition to the num1, num2, and
result signals that are speciﬁed explicitly in the interface deﬁnition. More speciﬁcally, each BSV
interface has implicit clock and reset signals, whereas the generated Verilog includes these signals as
CLK and RST N. In addition, both the start and result methods have associated implicit signals.

The Verilog implementation of the start method (an input method) includes input signals for the
arguments num1 and num2 which were explicitly declared in the BSV interface. The Verilog port
names corresponding to these inputs have the method name prepended, however, to avoid duplicate
port names. They have the generated names start num1 and start num2. In addition to these
explicit signals, there are also the implicit signals EN start, a 1-bit input signal, and RDY start, a
1-bit output signal.

Similarly, the Verilog implementation of the result method (an output method) includes the result
output signal speciﬁed by the BSV interface, as well as the implicit signal RDY start, a 1-bit output
signal.

Since the implicit signal names are generated automatically by the BSV compiler, the BSV syntax
provides a way in which the user can control the naming of these signals using attributes speciﬁed in
the BSV source code. In order to rename the generated clock and reset signals, the following syntax
is used:

(* osc=&quot;clk&quot; *)
(* reset=&quot;rst&quot; *)

                                 64


More information on clock and reset naming attributes is available in the Bluespec Reference Guide.
The user may remove Ready signals by adding the attribute always ready to the method deﬁnition.
Similarly, the user may remove enable signals by adding the attribute always enabled to the method
deﬁnition. The syntax for this is shown below.

                                      (* always_ready, always_enabled *)

More information on interface attributes is available in the BSV Reference Guide.
In addition to the provided interface, a BSV module declaration may include parameters and argu-
ments (such as clocks, resets, and used interfaces). When such a module is synthesized, these inputs
become input ports in the generated Verilog. If a Verilog parameter is prefered, the designer can
specify this by using the optional parameter keyword. For example, consider the following module:

             module mkMod #(parameter Bit#(8) chipId, Bit#(8) busId) (IfcType);

This module has two instantiation parameters, but only one is marked to be generated as a parameter
in Verilog. This BSV module would synthesize to a Verilog module with parameter chipId and input
port busId in addition to the ports for the interface IfcType:

                                               module mkMod(busId,
                                                                    ...);

                                                  parameter chipId = 0;
                                                  input [7 : 0] busId;
                                                  ...

Parameters generated in this way have a default value of 0.

8.1.2 State elements

State elements, synthesized from mkFIFO and the like, are instantiated as appropriate elements in
the generated Verilog. For example, consider the following BSV code fragment:

             FIFO #(NumTyp) queue1 &lt;- mkFIFO; // queue1 is the FIFO instance

The above fragment produces the following Verilog instantiation:

                       FIFO2 #(.width(51)) queue1(.CLK(CLK),
                                                                  .RST_N(RST_N),
                                                                  .D_IN(queue1$D_IN),
                                                                  .ENQ(queue1$ENQ),
                                                                  .DEQ(queue1$DEQ),
                                                                  .D_OUT(queue1$D_OUT),
                                                                  .CLR(queue1$CLR),
                                                                  .FULL_N(queue1$FULL_N),
                                                                  .EMPTY_N(queue1$EMPTY_N));

                                                                65


Note that the Verilog instance name matches the instance name used in the BSV source code.
Similarly, the associated signal names are constructed as a concatenation of the Verilog instance
name and the Verilog port names.

Registers instantiated with mkReg, mkRegU, and mkRegA are treated specially. Rather than declare a
bulky module instantiation, they are declared as Verilog reg signals and the contents of the module
(for setting and initializing the register) are inlined. For example, consider the following BSV code
fragment:

                     Reg #(NumTyp) x(); // x is the interface to the register
                     mkReg reg_1(x); // reg_1 is the register instance

                     Reg #(NumTyp) y();
                     mkRegU reg_2(y);

                     Reg #(NumTyp) z();
                     mkRegA reg_3(z);

Which generates the following Verilog instantiation:

                   reg [50 : 0] reg_1, reg_2, reg_3;
                   wire [50 : 0] reg_1$D_IN, reg_2$D_IN, reg_3$D_IN;
                   wire reg_1$EN, reg_2$EN, reg_3$EN;

                   always@(posedge CLK)
                   begin

                      if (!RST_N)
                         reg_1 &lt;= ‘BSV_ASSIGNMENT_DELAY 51’d0;

                      else
                         if (reg_1$EN) reg_1 &lt;= reg_1$D_IN;

                      if (reg_2$EN) reg_2 &lt;= reg_2$D_IN;
                   end

                   always@(posedge CLK , negedge RST_N)
                   if (!RST_N)

                      reg_3 &lt;= ‘BSV_ASSIGNMENT_DELAY 51’d0;
                   else

                      if (reg_3$EN) reg_3 &lt;= ‘BSV_ASSIGNMENT_DELAY reg_3$D_IN;

                   ‘ifdef BSV_NO_INITIAL_BLOCKS
                   ‘else // no BSV_NO_INITIAL_BLOCKS
                   // synopsys translate_off
                   initial
                   begin

                      reg_1 = 51’h2AAAAAAAAAAAA;
                      reg_2 = 51’h2AAAAAAAAAAAA;
                      reg_3 = 51’h2AAAAAAAAAAAA;
                   end
                   // synopsys translate_on
                   ‘endif // BSV_NO_INITIAL_BLOCKS

Register assignments are guarded by the macro BSV ASSIGNMENT DELAY, deﬁned to be empty by
default. In simulation, delaying assignment to registers and other state elements with respect to the

                                                                66


relevant clock may be eﬀected by deﬁning BSV ASSIGNMENT DELAY (generally to “#0” or “#1”) in the
Verilog simulator.1
All registers are initialized with the distinguishable hex value A in order to guarantee consistent
simulation in both Verilog and Bluesim, in the presence of multiple clocks and resets. This initial-
ization is guarded by the macro BSV NO INITIAL BLOCKS, which, if deﬁned in the Verilog simulator
or synthesis tool, disables the initial blocks.
The bsc command line option -remove-unused-modules can be used to remove primitives and
modules which do not impact any output port. This option should only be used on synthesized
modules, and not on testbenches.

8.1.3 Rules and related signals

For each instantiated rule, two combinational signals are created:

    • CAN FIRE rulelabel: This signal indicates that the preconditions for the associated rule have
       been satisﬁed and the rule can ﬁre at the next clock edge. The rule may not ﬁre (execute)
       because the scheduler has assigned a higher priority to another rule and simultaneous rule
       ﬁring causes resource conﬂicts.

    • WILL FIRE rulelabel: This signal indicates that the rule will ﬁre at the next clock edge.
       That is, its preconditions have been met, and the scheduler has determined that no resource
       conﬂicts will occur. Multiple rules can ﬁre during one cycle provided that there are no resource
       conﬂicts between the rules.

The rulelabel substring includes an unmangled version of the source rule name as well as a RL
preﬁx and optionally a &lt;n&gt; suﬃx. This suﬃx appears when it is needed to create a unique name
from the instances from diﬀerent submodules.

8.1.4 Other signals

Signals beginning with an underscore ( ) character are internal combinational signals generated
during elaboration and synthesis. These should not be used during debug.

8.2 Verilog header comment

When the Bluespec compiler generates the Verilog ﬁle for a module, it includes a comment with
information about the compile and the module’s interface. The header for the GCD example is
shown in Figure 29. This comment would appear at the top of the ﬁle mkGCD.v.
The header begins with information about the version of the Bluespec software which was used to
generate the ﬁle and the date of compilation. The subsequent information relates to the module’s
interface and its Verilog properties.
The method conﬂict information documents the scheduling constraints on the methods. These are
Bluespec semantics which must be respected when using the module. They are the same details
which the user must provide when importing his own Verilog module (see BVI import in the BSV
Reference Guide). This information is included or omitted based on the -show-method-conf ﬂag,
which is on by default. The format of the information is similar to the method output of the
-show-schedule ﬂag (see Section 7.2.2).

    1While the creative possibilities this feature opens—such as deﬁning BSV ASSIGNMENT DELAY to “~”—may seem
tempting at times, we discourage uses for purposes other than delaying assignment with respect to the clock edge.

                                                                67


typedef UInt#(51) NumTyp;

interface ArithIO_IFC #(parameter type aTyp); // aTyp is a paramerized type
      method Action start(aTyp num1, aTyp num2);
      method aTyp result();

endinterface: ArithIO_IFC

// The following is an attribute that tells the compiler to generate
// separate code for mkGCD
(* synthesize *)
module mkGCD(ArithIO_IFC#(NumTyp)); // here aTyp is defined to be type Int

Reg#(NumTyp) x(); // x is the interface to the register
mkRegU reg_1(x); // reg_1 is the register instance

Reg #(NumTyp) y(); // y is the interface to the register
mkRegU reg_2(y); // reg_2 is the register instance

rule flip (x &gt; y &amp;&amp; y != 0);
      x &lt;= y;
      y &lt;= x;

endrule

rule sub (x &lt;= y &amp;&amp; y != 0);
      y &lt;= y - x;

endrule

method Action start(NumTyp num1, NumTyp num2) if (y == 0);
      action
            x &lt;= num1;
            y &lt;= num2;
      endaction

endmethod: start

method NumTyp result() if (y == 0);
      result = x;

endmethod: result

endmodule: mkGCD

                  Figure 26: BSV Source Code For The GCD Example

                                     68


‘ifdef BSV_ASSIGNMENT_DELAY
‘else
‘define BSV_ASSIGNMENT_DELAY
‘endif

module mkGCD(CLK,
       RST_N,

       start_num1,
       start_num2,
       EN_start,
       RDY_start,

       result,
       RDY_result);
   input CLK;
   input RST_N;

   // action method start
   input [50 : 0] start_num1;
   input [50 : 0] start_num2;
   input EN_start;
   output RDY_start;

   // value method result
   output [50 : 0] result;
   output RDY_result;

   // signals for module outputs
   wire [50 : 0] result;
   wire RDY_result, RDY_start;

   // register reg_1
   reg [50 : 0] reg_1;
   wire [50 : 0] reg_1$D_IN;
   wire reg_1$EN;

   // register reg_2
   reg [50 : 0] reg_2;
   reg [50 : 0] reg_2$D_IN;
   wire reg_2$EN;

   // rule scheduling signals
   wire WILL_FIRE_RL_flip, WILL_FIRE_RL_sub;

   // inputs to muxes for submodule ports
   wire [50 : 0] MUX_reg_2$write_1__VAL_3;

   // remaining internal signals
   wire reg_1_ULE_reg_2___d3;

                             Figure 27: Generated Verilog GCD Example (part 1)

                                                               69


 // action method start
   assign RDY_start = reg_2 == 51’d0 ;

   // value method result
   assign result = reg_1 ;
   assign RDY_result = reg_2 == 51’d0 ;

   // rule RL_sub
   assign WILL_FIRE_RL_sub = reg_1_ULE_reg_2___d3 &amp;&amp; reg_2 != 51’d0 ;

   // rule RL_flip
   assign WILL_FIRE_RL_flip = !reg_1_ULE_reg_2___d3 &amp;&amp; reg_2 != 51’d0 ;

   // inputs to muxes for submodule ports
   assign MUX_reg_2$write_1__VAL_3 = reg_2 - reg_1 ;

   // register reg_1
   assign reg_1$D_IN = EN_start ? start_num1 : reg_2 ;
   assign reg_1$EN = EN_start || WILL_FIRE_RL_flip ;

   // register reg_2
   always@(EN_start or
   start_num2 or
   WILL_FIRE_RL_flip or
   reg_1 or WILL_FIRE_RL_sub or MUX_reg_2$write_1__VAL_3)
   begin

      case (1’b1) // synopsys parallel_case
         EN_start: reg_2$D_IN = start_num2;
         WILL_FIRE_RL_flip: reg_2$D_IN = reg_1;
         WILL_FIRE_RL_sub: reg_2$D_IN = MUX_reg_2$write_1__VAL_3;
         default: reg_2$D_IN = 51’h2AAAAAAAAAAAA /* unspecified value */ ;

      endcase
   end
   assign reg_2$EN = EN_start || WILL_FIRE_RL_flip || WILL_FIRE_RL_sub ;

   // remaining internal signals
   assign reg_1_ULE_reg_2___d3 = reg_1 &lt;= reg_2 ;

   // handling of inlined registers

   always@(posedge CLK)
   begin

      if (reg_1$EN) reg_1 &lt;= ‘BSV_ASSIGNMENT_DELAY reg_1$D_IN;
      if (reg_2$EN) reg_2 &lt;= ‘BSV_ASSIGNMENT_DELAY reg_2$D_IN;
   end

   // synopsys translate_off
   ‘ifdef BSV_NO_INITIAL_BLOCKS
   ‘else // not BSV_NO_INITIAL_BLOCKS
   initial
   begin

      reg_1 = 51’h2AAAAAAAAAAAA;
      reg_2 = 51’h2AAAAAAAAAAAA;
   end
   ‘endif // BSV_NO_INITIAL_BLOCKS
   // synopsys translate_on
endmodule // mkGCD

                             Figure 28: Generated Verilog GCD Example (part 2)

                                                               70


//

// Generated by Bluespec Compiler, version 3.8.68 (build 8860, 2006-06-16)

//

// On Mon Aug 7 10:34:26 EDT 2006

//

// Method conflict info:

// Method: start

// Sequenced after: result

// Conflicts: start

//

// Method: result

// Conflict-free: result

// Sequenced before: start

//

//

// Ports:

// Name                     I/O size props

// RDY_start                O1

// result                   O 51 reg

// RDY_result               O1

// CLK                      I 1 clock

// RST_N                    I 1 unused

// start_num1               I 51

// start_num2               I 51

// EN_start                 I1

//

// No combinational paths from inputs to outputs

//

//

             Figure 29: Generated Verilog Header For The GCD Example

                                   71


The port information provides RTL-level information about the Verilog design. There is an entry
for each port which speciﬁes whether the port is an input or an output, the port’s size in bits, and
any properties of the port. The possible properties are reg, const, unused, clock, clock gate,
and reset. The reg property indicates that there is no logic between the port and a register – if
the port is an input then the value is immediately registered, and if the port is an output than the
value comes directly from a register. The const property indicates that the value of the port never
changes, it is constant. Ports with the unused property are not connected to any state element or
other port, and so their values are unused. The clock, clock gate, and reset properties indicate
that the port is a clock oscillator, clock gate, and reset port, respectively.
The ﬁnal information in the comment is a list of any combinational paths from inputs to outputs.
If there is an unregistered path from an input port write val (corresponding to the val argument
of method write) to an output port read, it will appear as follows:

                             // Combinational paths from inputs to outputs:
                             // write_val -&gt; read

Multiple inputs which have a combinational path to one output are grouped together, for brevity,
as follows:

                             // Combinational paths from inputs to outputs:
                             // (add_x, add_y, add_z) -&gt; add

This situation arises often for read methods with arguments. Multiple outputs are not grouped;
there is only ever one output listed on the right-hand side.

9 Bluesim back end

Bluesim is a cycle simulator for generated BSV designs. It is cycle-accurate with the Verilog gener-
ated for the same designs. Bluesim can output VCD ﬁles for a simulation and oﬀers other debugging
capabilities as described below.

9.1 Bluesim tool ﬂow

When a BSV design is compiled and linked using the Bluesim back end, the compiler links the design
with a driver, to produce a stand-alone executable. When the executable is invoked, the default
driver “clocks” the circuit and executes it.
The Bluesim back-end compiles modules in a Bluespec design to C++ objects which contain the
module data and temporaries and which deﬁne routines for executing the rules and methods of
each module. In addition to the modules, scheduling routines are generated which coordinate the
execution of rules throughout the entire design. Primitive modules, functions, and system tasks are
implemented as elements of a library supplied with the compiler.

9.2 Bluesim simulation ﬂags

The following ﬂags can be given on the command line to the Bluesim simulation executable:

                                                                72


-c &lt;commands&gt; = execute commands given as an argument

-f &lt;file&gt; = execute script from file

-h      = print help and exit

-m &lt;N&gt;  = execute for N cycles

-v      = print version information and exit

-V [&lt;file&gt;] = dump waveforms to VCD file (default: dump.vcd)

-w      = wait for a license if none is immediately available

+&lt;arg&gt;  = Verilog-style plus-arg

The -c ﬂag provides one or more commands to be executed by the simulator (see Section 9.3 for
command syntax).

The -f ﬂag directs the simulator to execute commands from the given script ﬁle (see Section 9.3 for
command syntax).

The -h ﬂags directs the simulator to print a help message which describes the available ﬂags.

The -m ﬂag forces the simulation to stop after a certain number of cycles; the default behavior is to
execute forever or until the $finish system task is executed.

The -v ﬂag directs the simulator to print some version information related to the simulation model,
including the compiler version used to create it and the time and date at which it was created.

The -V ﬂag causes the simulator to dump waveforms to a VCD ﬁle. If a ﬁle name is provided the
waveforms will be written the named ﬁle, otherwise the default ﬁle name “dump.vcd” will be used.

The -w ﬂag directs the simulator to wait for a license to become available when none is available
immediately. Without the -w ﬂag, the simulator will exit if it no license is available. You can generate
Bluesim models which do not require a Bluesim license at runtime by using the no-untimed-license
ﬂag (Section 6.6).

Arguments can be passed to the simulation model with +&lt;arg&gt;. These values can be tested by the
BSV model via the $test$plusargs system task.

9.3 Interactive simulation

The simulator can be executed in an interactive or scripted mode. Commands and scripts can be
given using the -c and -f ﬂags. Alternatively, the simulation object can be loaded directly in Bluetcl
using the sim load command.

Bluetcl extends a TCL shell with a sim command whose sub-commands control all aspects of loading,
executing and interacting with a Bluesim simulation object. For a list of Bluetcl sim sub-commands,
see the Bluetcl appendix A.4.2.

There are two ways to access these simulation commands, through scripting or interactively. When
a model is compiled through the Bluesim backend, it generates a .so ﬁle containing the simulation
object. It also generates an executable program that provides a convenient way to run and use the
simulation object. Passing the -c or -f ﬂags to the executable enables scripting the simulation.

To run the simulation interactively, the standard Bluetcl tool should be used.

In addition to these actions accessible through the sim command, all of the normal functions of a
TCL interpreter as well as additional Bluespec-speciﬁc extensions are available in Bluetcl and they
can be freely intermixed.

Note that the TCL interpreter behaves diﬀerently when executing a script than when running
interactively. In an interactive session, the TCL interpreter will print the value returned by each
command (if any), but when executing a script output is only generated in response to an explicit
output command (eg. puts).

                                                                73


load and unload

Before working with a Bluesim simulation object, it must be loaded – this is done automatically
when using the -c and -f options but must be done manually when using Bluetcl directly. The
full command to load a simulation object in Bluetcl is sim load followed by the name of the .so
ﬁle.
Loading a simulation object triggers the checkout of a BSIM license, unless the object was created
using the no-runtime-license option (Section 6.6). If you are manually loading a simulation object
and would like to wait if a license is unavailable, add the keyword wait after the name of the .so
ﬁle. When using the -c or -f ﬂags, in which the model is loaded automatically, adding the -w ﬂag
indicates the desire to wait for a license.
A simulation object can be unloaded using the sim unload command. Unloading the simulation
will check in the BSIM license. Any active object is automatically unloaded when the simulator
exits or before loading a new simulation object, so it is not normally necessary to manually perform
a sim unload.

arg

The sim arg command allows a Verilog-style plusarg to be set interactively. The command sim arg
&lt;string&gt; adds the supplied string to the end of the list of plusargs searched by the $test$plusargs
system task. The “+” character should not be included in the string argument.

run, step, stop and sync

The sim run command runs the current simulation to completion.
The sim runto command runs the current simulation to the time given as its argument.
The sim step command advances the current simulation for a given number of cycles of the currently
active clock domain.
The sim nextedge command advances the current simulation until the next edge in any clock
domain. The currently active domain does not change, so a subsequent sim step command will
still execute according to the active domain regardless of the clock edge to which a sim nextedge
command advances.
By default, these commands will not return until the requested simulation activity is complete.
However, sim step, sim runto and sim run can be instructed to return immediately by adding
the keyword async to the end of the command sequence (eg. sim step 100 async). This will
cause the command to return immediately so that additional commands can be processed while the
simulation continues to run asynchronously.
There are two commands that synchronize with an asynchronously spawned simulation: stop and
sync. The stop command will pause the simulation at the end of the currently executing simulation
cycle. The sync command will wait for the simulation to complete normally before returning.
As examples of the behavior of the run and step simulation commands, assume that we have a
simulation executable named “bsim”. Then

                                                    bsim -c ’sim run’

is equivalent to just

                                                              bsim

                                                                74


and

                                                bsim -c ’sim step 100’

is equivalent to using the -m ﬂag

                                                        bsim -m 100

Note that when a model is loaded, simulation time is at 0 and no clock edges have occurred. Stepping
1 cycle from that point will advance past the ﬁrst clock edge, and if the ﬁrst rising edge of the active
clock occurs at time 0 then the step command will move from before the edge at time 0 to after the
edge at time 0.

time
The sim time command returns the current simulation time.
It could be used interactively within Bluetcl

                    % sim load bsim.so
                    % sim step 10
                    % sim time
                    90

or within a script

                    bsim -c ’sim step 10; puts [sim time]’
                    90

clock

The sim clock command provides information on the currently deﬁned clocks and allows the user
to change the active clock domain used by the sim step command.
With no argument, the sim clock command returns a list containing a clock description for each
currently deﬁned clock. Each clock description is itself a list of 10 diﬀerent pieces of information
about the clock domain:

    • a unique number assigned to the clock domain
    • a ﬂag indicating if the clock is the currently active domain (1 indicates active, 0 indicates not

       active)
    • the textual name of the clock domain
    • the initial value of the clock (0 or 1)
    • the delay before the ﬁrst edge of the clock
    • the duration of the low clock phase
    • the duration of the high clock phase
    • the number of elapsed cycles of this clock

                                                                75


    • the current value of the clock signal (0 or 1)

    • the time of the last edge of the clock

Here is sample output from a sim clock command for a design with 2 clock domains:

                 % sim clock
                 {0 1 CLK 0 0 5 5 12 1 110} {1 0 {mc$CLK_OUT} 0 0 0 0 3 0 100}

This output indicates that there are 2 domains. The ﬁrst is domain number 0 and is the currently
active clock. It is called “CLK” and is initially low, rises at time 0 and then alternates every ﬁve
time units. At the current simulation time, 12 cycles have elapsed in the “CLK” clock domain and
its current clock value is 1, after a rising edge at time 110. The second domain is number 1 and is
not the currently active clock used for stepping. It is called “mc$CLK OUT” and we have no timing
information because it is not a periodic waveform (it is internally generated in the model). At the
current simulation time, 3 cycles have elapsed in the “mc$CLK OUT” domain and its current value
is 0, after a falling edge at time 100.
To change the currently active clock, simply use the sim clock &lt;name&gt; form of the command, where
the name argument speciﬁes which clock to be made active. After executing this command, future
sim step commands will step through cycles in the newly activated clock domain.

                 % sim clock {mc$CLK_OUT}
                 % sim clock
                 {0 0 CLK 0 0 5 5 12 1 110} {1 1 {mc$CLK_OUT} 0 0 0 0 3 0 100}

Note that the clock name argument was quoted in curly braces so that the TCL interpreter would
treat the dollar-sign in the clock domain name as a literal dollar-sign.

ls, cd, up and pwd

Bluesim allows the user to navigate through the hierarchy of module instantiations using the sim
cd and sim up commands.
To move down one or more levels of hierarchy, provide a path to the sim cd command. The path
must consist of a sequence of instance names separated by ‘.’. A path which begins with . is
considered to be an absolute path from the top of the hierarchy, but a path which does not begin
with . is interpreted as a path relative to the current location.
The sim up command is used to move up the hierarchy into parents of the current directory. It can
be given a numeric argument to control how many levels to ascend, or it can be used without an
argument to move up one level.
As a special case, the sim cd command will return the user to the uppermost point in the hierarchy
if used without a path argument.
To ﬁnd your current location in the module hierarchy, use the sim pwd command.
At any point in the hierarchy, the sim ls command can be used to list the sub-instances, rules and
values at that level of hierarchy. The command can be given any number of patterns to control
which names are listed. If no argument is given, it is equivalent to sim ls *.
The patterns follow the standard syntax for ﬁlename globbing:

    • ?: Matches any single character

                                                                76


    • *: Matches any number of characters (possibly none)

    • [. . . ]: Matches any character inside of the brackets

    • [a-z]: Matches any character in the speciﬁed range

    • [!. . . ]: Matches any character which does not match speciﬁcation inside the brackets

The instance separator character ‘.’ is never matched in a pattern. The special characters ?,* and
[ can be escaped in a pattern using a backslash (\).

       % sim pwd
       .
       % sim ls
       {b__h380 signal} {CAN_FIRE_RL_done signal} {CAN_FIRE_RL_incr signal}
       {count module} {level1 module} {mid1 module} {mid2 module} {RL_done rule}
       {RL_incr rule} {WILL_FIRE_RL_done signal} {WILL_FIRE_RL_incr signal}
       % sim ls level1.*
       {level1.level2 module}
       % sim cd level1.level2
       % sim pwd
       .level1.level2
       % sim ls RL_*
       {RL_incr rule} {RL_sub1_flip rule} {RL_wrap rule}
       % sim up
       % sim pwd
       .level1

lookup, get and getrange

In addition to navigating through the instance hierarchy, Bluesim allows the user to examine the
simulation values at run-time, using the sim lookup, sim get and sim getrange commands.
To get the value for a signal, you must ﬁrst obtain a “handle” for the value using the sim lookup
command. The command takes as an argument a pattern describing the absolute or relative path to
the desired signal. A relative path is interpreted in the current directory unless an optional second
argument is given containing the handle to a diﬀerent starting directory. sim lookup will return a
handle for every simulation object which matches the pattern argument.

Once the handle of a signal is known, its value can be obtained using the sim get command. This
command takes one or more handles as arguments and returns the raw values associated with the
handles, as sized hexadecimal numbers.

                  % set WF_incr [sim lookup .level1.level2.WILL_FIRE_RL_incr]
                  150533432
                  % sim get $WF_incr
                  1’h1
                  % sim ls .mid?.count
                  {mid1.count module} {mid2.count module}
                  % eval sim get [sim lookup .mid?.count]
                  4’h9 4’h1

The sim getrange command is a specialized command to get values for handles which represent
multiple values, such the storage inside of a FIFO or register ﬁle. The command takes the handle
for the value range object along with either a single address or a start and end address pair.

                                                                77


                                      % sim getrange [sim lookup rf] 0 3
                                      16’h0 16’h1 16’h2 16’h3
                                      % sim getrange [sim lookup rf] 2
                                      16’h2
                                      % sim getrange [sim lookup fifo] 0
                                      16’h8

Details about the simulation object referenced by a handle can be obtained using the sim describe
command.

vcd

The sim vcd command controls dumping of waveforms to a VCD ﬁle. Use sim vcd on to enable
dumping and sim vcd off to disable it. The form sim vcd &lt;file&gt; enables dumping to a ﬁle of
the given name, rather than the default ﬁle named “dump.vcd”.

version

The sim version command prints details about the tool version used to build the current simulation
object. It returns a list of 5 TCL objects: the year of the release, the month of the release, the
(optional) release tag, the revision number of the release, and the time at which the object was
created (as a number of seconds since the start of 1970).
An example of using the sim version command to print the date and time at which a simulation
object was created:

                             % puts [clock format [lindex [sim version] 4]]
                             Fri Dec 14 01:24:39 PM EST 2007

9.3.1 Command scripts for Bluesim

The Bluesim simulator can be run with a command script by using the -c or -f arguments.

                                               ./bluesim -f script.tcl

The contents of the script ﬁle can be standard TCL commands or any Bluetcl command extensions,
including the sim commands. When used in this way, some aspects of Bluesim’s behavior change to
be more appropriate for executing scripts:

    • No prompt is displayed.
    • The result of each command is not printed. An explicit puts should be used to print command

       output in a script.
    • Error messages include line numbers and stack traces.
    • Errors and Ctrl-C end the simulation.

No sim load command is required when using a script, because the model will automatically be
loaded before the script is executed and unloaded on exit.
No exit command is required when using a script, because the simulator will automatically exit
when it reaches the end of the script ﬁle.
Comments can be included in the script ﬁle by starting a line with the TCL comment character #.

                                                                78


                       # Run 300 cycles
                       sim step 300
                       # Enable dumping VCD waveforms for the next 10 cycles
                       sim vcd on
                       sim step 10

9.4 Value change dump (VCD) output

The Bluesim simulator supports generation of a value change dump (VCD) to record the changes
in user-selected state components. VCD ﬁles are an industry-standard way to record simulator
state changes for use by external post-processing tools. For example, Novas Debussy, Undertow,
and gtkWave are graphical waveform display programs that can be used to browse simulator state
recorded in VCD ﬁles.
The Verilog system task $dumpvars may be used with no arguments to request VCD for all variables.
Selective dumping with this task is not supported at this time. The Verilog system tasks $dumpon
and $dumpoff can be used to turn VCD dumping on and oﬀ at speciﬁc times during simulation.
Specifying -V &lt;file&gt; argument or using the sim vcd &lt;file&gt; command in a script will cause the
simulator to output a VCD ﬁle of that name, in which the state of all registers and the internal
signals of all BSV modules are dumped at the end of each cycle.
VCD ﬁles dumped by Bluesim attempt to match VCD ﬁles generated by Verilog simulation as closely
as possible. Known diﬀerences between Bluesim- and Verilog-generated VCD ﬁles are documented
in the Known Problems and Solutions (KPNS ) document accompanying each release.

9.5 Bluesim multiple clock domain support

The Bluesim backend supports a subset of the multiple-clock-domain (MCD) features supported by
the Verilog backend, including bit, pulse and word synchronizers as well as synchronized FIFOs.
However, some MCD features supported in Verilog are not supported in Bluesim:

    • mkNullCrossing

                                                                79


A Bluetcl Reference

Bluetcl is a Tcl extension with a collection of scripts and packages providing an interface into the
Bluespec view of a design; Bluewish adds the tk windowing commands to Bluetcl. This document
uses Bluetcl to refer to the combination of Bluetcl and Bluewish. You can execute Bluetcl commands
and scripts from a unix command line or from the command window in the development workstation.
Bluetcl contains several layers (scripts, commands, packages) which should be familiar to the Tcl
programmer. You can use Bluetcl extensions within Tcl scripts. More information on Tcl is available
at www.tcl.tk or from the many books and references written about Tcl/Tk.

A.1 Invoking Bluetcl

Bluetcl commands can be run either interactively or through Tcl scripts. These commands load,
execute, and interact with Bluespec-generated ﬁles. As with the Bluespec compiler, pre-elaboration
information is obtained from the .bi/.bo ﬁles, and post-elaboration information is obtained from
the .ba ﬁles.
Bluetcl commands can be invoked in the following ways.

    • You can invoke Bluetcl from a unix prompt by typing bluetcl. This command provides a Tcl
       shell with the Bluetcl extensions.

    • You can type bluewish at a unix prompt. This adds the Wish extensions to the Bluetcl shell.
    • When in the Bluespec Development Workstation, the command window provides a Bluetcl

       shell.
    • Finally, you can write and use Tcl scripts which utilize Bluetcl. For an example of a Tcl script

       provided by Bluespec, see Section A.7.1.

A.2 Packages and namespaces

Bluetcl is organized into a collection of packages, which are described in this appendix. The major
packages are:

    • The Bluetcl package which contains the low-level commands to interact with Bluespec ﬁles
       and designs.

    • The Bluesim package containing Bluesim command extensions.2
    • The WS package contains commands for interacting with the workstation.

The standard Tcl packages Itcl, Itk, and Iwidgets are available with Bluetcl and can be used
when creating your own scripts.
All commands in the Bluetcl package are in the Bluetcl namespace. All commands in the Bluesim
package are in the Bluesim namespace. The commands in the WS package are divided into multiple
namespaces.
When referencing a command you must specify the namespace. Example:

      Bluetcl::version

    2The sim command for interacting with Bluesim simulation objects (.so ﬁles) is contained in both the Bluetcl and
Bluesim packages.

                                                                80


Alternately, you can import commands from a namespace. The following example imports all the
commands in a namespace:

      namespace import ::Bluetcl::*

Or you can import a single command:

      namespace import ::Bluetcl::schedule

Since the WS package contains multiple namespaces, you must specify the full namespace when
referencing a WS command or importing the commands from the namespace. Example:

      WS::Build::link
      namespace import ::WS::Build::link

Refer to the Tcl documentation for additional information on packages and namespaces.

A.3 Customizing Bluetcl

You can use Bluetcl, along with all standard Tcl constructs, to write scripts, issue commands, and
customize the development workstation. Bluetcl, Bluewish, and the development workstation all
source the setup ﬁle $HOME/.bluetclrc during initialization. You can customize Bluetcl and the
development workstation by adding to the .bluetclrc ﬁle.

The namespace import command can be put in the .bluetclrc ﬁle, providing the command into
the current namespace when the ﬁle is sourced. This will allow you to use just the command name
in scripts or from the command line.

A.4 General Bluetcl package command reference

A.4.1 Conventions

The following conventions are used within the command reference:

name     identiﬁer
keyword  as is
[...]    optional
{...}    repeated

Note: For repeated arguments ({ }), one or more arguments may be speciﬁed. If only one item
is speciﬁed, no brackets ({ }) are necessary. If multiple arguments are speciﬁed the list must be
enclosed in brackets.

A.4.2 Bluetcl

This sections describes the commands in the Bluetcl package. These commands provide a low-level
interface to access Bluespec-speciﬁc ﬁles (.bo/.bi/.ba) for use by Tcl programmers; they are not
intended for interactive use.
Before using a command from the Bluetcl package, the following Tcl command must be executed,
either in a script, from the command line, or in the .bluetclrc ﬁle:

                                                                81


      package require Bluetcl

All commands in the Bluetcl package are in the Bluetcl:: namespace. The namespace must
be referenced, as described in Section A.3, either by using the namespace import command or by
prepending the command name with Bluetcl::. Example:

      Bluetcl::bpackage list

Bluetcl::bpackage

Controls loading and unloading of packages and returns package information. When a package is
loaded, all dependent (imported) packages are loaded as well.

bpackage load packname   Reads in the .bi/.bo package and all imported packages. Pack-
                         ages are searched in the standard bsc way, via the -p ﬂag. Re-
bpackage list            turns a list of all packages which are loaded.
bpackage clear           Returns the list of packages which are loaded.
bpackage depend          Clear all currently loaded packages.
bpackage search regex    Returns package dependencies of all currently loaded packages.
bpackage types packname  Searches packages for names matching a regular expression.
                         Returns a list of type names found in the package.

Bluetcl::defs

Returns a list of the components deﬁned in a package. Components returned include types, synthe-
sized modules, and functions.

defs all {packname}      Returns a list of all components which are deﬁned in the pack-
                         age.
defs type {packname}     Returns a list of all types which are deﬁned in the package.
defs module {packname}   Returns a list of all module names deﬁned in the package which
                         are marked synthesize.
defs func {packname}     Returns a tagged structure list of all functions which are deﬁned
                         in the package.

Bluetcl::ﬂags

Returns or sets the status of ﬂags used by the Bluespec compiler.

ﬂags show {ﬂagname}      Show the value of the speciﬁed ﬂags.

ﬂags set {ﬂagname = value} Set the ﬂags to the value provided. Multiple ﬂags may be set

                         in a single command.

Bluetcl::help

Help with no arguments will list all available help topics. Optionally, an argument can be provided
to get help on a speciﬁc topic. Also, ’help list’ will return a string listing the names of all commands.

help                     Returns a list of all help topics.
help list                Returns a string listing the name of all commands
help command             Returns help for the speciﬁed command.

                         82


Bluetcl::module

Returns information on synthesized (post elaboration) modules.

module load modname             Loads the module and all instantiated submodules into the
                                workstation. Returns a list of the modules loaded.
module clear                    Clear all loaded modules
module submods modname          Returns a 3-tuple. The ﬁrst element of the tuple is a tag (primi-
                                tive or user), the second is a list of pairs contain the synthesized
module rules modname            submodule name and its interface type. The third element is a
module ifc modname              list of function which have not been in-lined.
module methods modname          Returns a list of rule names in the module.
module ports modname            Returns a list of interface types in the module.
module porttypes mod-           Returns a list of the ﬂattened methods in the module.
name                            Returns a list of the ports in the module.
module list                     Returns a list of the types of the ports in the module.

                                Returns a list of all loaded modules.

Bluetcl::rule

Returns information about rules in a post elaboration module.

rule rel modname {rule1 rule2}  Shows the relationship between two rules in the module.
rule full modname rule          Returns a tagged structure detailing the rules position, pred-
                                icates expression, attributes and method calls.

Bluetcl::schedule

Returns scheduling information for a synthesized module. The schedule command requires a sub-
command and the module name.

schedule execution modname      Returns a list of rule/method names in execution order.
schedule methodinfo modname     For example, if r1 ﬁres after r2, then the output would
schedule pathinfo modname       be: RL r1 RL r2.
schedule urgency modname        Returns scheduling relationships between all pairs of meth-
schedule warnings modname       ods.
                                Returns a list of combinational paths through the module.
                                Each element is a list of two elements: a list of inputs and
                                an output that they connect to.
                                Returns a list of lists, one for each rule/method, in urgency
                                order. Each lists contains two elements: the rule name and
                                a list of rules which would block that rule from ﬁring.
                                Returns a list of scheduling warnings. The result is a list
                                of three elements: the position of the warning, the tag for
                                the warning, and the complete warning message.

Bluetcl::sim

Controls all aspects of loading, executing and interacting with a Bluesim simulation object. These
commands are used when running Bluesim interactively, as described in section 9.3.
This command is also provided in the Bluesim package. See section A.4.3 for the complete deﬁnition.

                                83


Bluetcl::submodule

Returns information about each submodule and which rules use the methods of the submodule.

submodule full modname     Returns information about each submodule in the speciﬁed
                           module and the rules which use the methods of the submod-
                           ule.

Bluetcl::type

Finds and returns type information.

type constr typename       Shows the type constructor for the provided type name. The
type full typeconstructor  type constructor is the type arguments needed for the type.
                           Returns an error if the typename is not found in any of the
                           loaded packages.
                           Returns a tagged structure based on the type constructor argu-
                           ment. The type constructor provided must be fully qualiﬁed.

Bluetcl::version

Returns the current compiler version

version                    Returns a list of 3 items: the compiler version, the version date,
                           and the build version. The compiler version is provided in year-
                           month-(annotation) format.

A.4.3 Bluesim

The Bluesim package contains the sim command which controls Bluesim interactive mode. This
command is also found in the Bluetcl package.
Before using a command from the Bluesim package, the following Tcl command must be executed,
either in a script, from the command line, or in the .bluetclrc ﬁle:

      package require Bluesim

All commands in the Bluesim package are in the Bluesim:: namespace. The namespace must
be referenced, as described in Section A.3, either by using the namespace import command or by
prepending the command name with Bluesim::. Example:

      Bluesim::sim clock

sim

Controls all aspects of loading, executing and interacting with a Bluesim simulation object. These
commands are used when running Bluesim interactively, as described in section 9.3. This command
is also provided in the Bluetcl package (A.4.2).

sim arg string             Set a simulation plus-arg. Adds the supplied string to the end
                           of the list of plusargs searched by the $test$plusargs system
                           task.

                                      84


sim cd [path]              Change location in hierarchy. The path must consist of a se-
                           quence of instance names separated by a period (.). A path
sim clock                  which begins with a . is an absolute path from the top of the
sim clock [name]           hierarchy, but one which does not begin with a . is relative to
sim describehandle         the current location. No provided path will return the user to
sim get handle             the uppermost point in the hierarchy.
sim getrange handle addr
sim load model [wait]      Returns a list containing a clock description for each currently
sim lookup pattern [root]  deﬁned clock.
sim ls pattern*            Select the named clock, make it the active clock.

sim nextedge               Describe the object to which a symbol handle refers.
sim pwd
sim run [async]            Returns the simulation value for the object with the provided
                           handle. The value is returned as a sized hexadecimal number.
sim runto time [async]
                           Get simulation values from a range.
sim step [cycles] [async]
                           Load a bluesim model object. Checks out a BSIM license. Use
sim stop                   the wait argument to wait for an available license.
sim sync
sim time                   Lookup symbol handles. Returns a handle for every simulation
sim unload                 object which matches the pattern.
sim up [N]
sim vcd [on | oﬀ | ﬁle]    List the sub-instances, rules and values at that level of the hi-
sim version                erarchy. If a pattern is provided, it controls which names are
                           listed. No pattern is equivalent to sim ls *.

                           Advance simulation to the next clock edge in any domain.

                           Print current location in hierarchy.

                           Run simulation to completion. The keyword async cause the
                           command to return immediately so that additional commands
                           can be processed while the simulation continues to run asyn-
                           chronously.

                           Run simulation to a given time. The keyword async cause the
                           command to return immediately so that additional commands
                           can be processed while the simulation continues to run asyn-
                           chronously.

                           Advance simulation a given number of cycles. The keyword
                           async cause the command to return immediately so that addi-
                           tional commands can be processed while the simulation contin-
                           ues to run asynchronously.

                           :stop the simulation at the end of the currently executing sim-
                           ulation cycle.

                           Wait for simulation to complete normally before returning

                           Display current simulation time.

                           Unload the current bluesim model. Checks in the BSIM license.

                           Move up the module hierarchy into the parents of the current
                           directory. It will move up N levels if N is provided.

                           Control dumping waveforms to a VCD ﬁle named ﬁle. If no ﬁle
                           name is provided, it will use the default ﬁle dump.vcd.

                           Show Bluesim model version information.

                           85


A.4.4 Types

Before using a command from the Types package, the following Tcl command must be executed,
either in a script, from the command line, or in the .bluetclrc ﬁle:

      package require Types

All commands in the Types package are in the Types:: namespace. The namespace must be
referenced, as described in Section A.3, either by using the namespace import command or by
prepending the command name with Types::. Example:

      Types::import_package packagename

import package

This command is used to load or reload packages into the workstation.

import package packname  Loads the necessary package information into the workstation.
                         You can use the command to reload a package or add additional
                         packages.

show types

Returns information on the types in a design.

show types packname      Shows all the type constructors found in the package.

show type size Type      Shows the expanded sub-ﬁelds and structure positions of Type.
                         Type must be non-polymorphic, i.e. Maybe#(Int#(1)) is ac-
                         ceptable, but not Maybe#(a).

show type ﬁeld Type posi- Similar to the show type size command, except it only shows

tion                     the ﬁeld of the structure which contains the bit at the speciﬁed

                         position.

A.4.5 InstSynth

The InstSynth package contains scripts to generate instance speciﬁc synthesis in Bluespec Sys-
temVerilog. These scripts use Bluespec’s typeclass and overloading to match a module’s instantiation
with a speciﬁc instance which may instantiate a synthesized module.
When using any of the commands in the InstSynth package, the package must be loaded ﬁrst.

       package require InstSynth

The InstSynth package contains the commands genTypeClass, genSpecificInst, and genSynthMod.

                                               86


                 InstSynth Commands

genTypeClass     genTypeClass packname {modname}

                 Creates an include ﬁle for a package containing a typeclass for
                 overloading of a module and a default instance for the module.
                 Multiple modules within the same package can be speciﬁed in a
                 single command.

genSpecificInst  genSpeciﬁcInst packname modname type

                 Modiﬁes the packname.include.bsv ﬁle with an instance for each
                 missing type.

genSynthMod      genSynthMod packname modname type

                                    Generates a synthesize module wrapper for a given module and
                                    type within a package. The generated module is returned as a
                                    string from this function.

Example using InstSynth.tcl to generate instance speciﬁc synthesis modules

Overview: This example demonstrates how to use the InstSynth.tcl package to use Bluespec’s
typeclass and overloading to match a module’s instantiation with a speciﬁc instance to instantiate
a synthesized module.

The example is composed of three .bsv ﬁles: m1.bsv which contains the module deﬁnition for mkM1,
m2.bsv which contains the module deﬁnition for mkM2 and instantiates multiple instances of mkM1,
and Top.bsv containing the testbench mkTb. The two modules mkM1 and mkM2 are polymorphic. The
testbench mkTb instantiates mkM2 and is not polymorphic.

The polymorphic modules are instantiated in the hierarchy as shown in ﬁgure 30.

                                        Figure 30: Example Module Hierarchy

Steps for using InstSynth
   1. Compile your design with bsc as normal, creating the .bi and .bo ﬁles.
   2. Generate typeclass and default instances for modules with the genTypeClass command, spec-
       ifying the packages and modules for instance speciﬁc synthesis. The genTypeClass command
       will generate an include ﬁle (&lt;package&gt;.include.bsv) for each package.

                                                                87


   The include ﬁle will contain a type class (named MakeInst &lt;module&gt;) for each module and a
   general catch-all instance of that type class.
   The type class contains one method, which is a module constructor. The method is named
   &lt;module&gt; Synth and has the same arguments as the general polymorphic module. The instance
   of this type class is a thin wrapper which instantiates the polymorphic module and prints a
   message about the type which is synthesized.
   Example of the include ﬁle for m1.bsv (m1.include.bsv) after this step:

     typeclass MakeInst_mkM1 #(type ifc_t);
           module mkM1_Synth ( ifc_t ifc) ;

     endtypeclass

     instance MakeInst_mkM1 #( ClientServer::Server#(a, a) )
           provisos (Bits#(a, sa)) ;

           module mkM1_Synth ( ClientServer::Server#(a, a) ifc) ;
                  let _i &lt;- mkM1 ;
                  messageM (&quot;No concrete definition of mkM1 for type &quot; +
                                   (printType (typeOf (_i))));
                  messageM (&quot;Execute: InstSynth::genSpecificInst m1 mkM1 {&quot; +

                                     &quot; {&quot; + (printType (typeOf(asIfc (_i)))) + &quot;}&quot;
                                     + &quot; }&quot; );
                  return _i ;
           endmodule
     endinstance

3. Manually edit the .bsv ﬁle to include the generated ﬁle. For example, add the line ‘include
   &quot;&lt;package&gt;.include.bsv&quot; at the bottom of the ﬁle for &lt;package&gt;. In this example, you
   would add the line ‘include &quot;m1.include.bsv&quot; to the ﬁle m1.bsv.

4. Manually edit the .bsv ﬁle to change the module constructor from &lt;module&gt; to &lt;module Synth&gt;
   at each point you would like an instance synthesized. In this example, change mkM1 to
   mkM1 Synth in the m2.bsv ﬁle, and change mkM2 to mkM2 Synth in the Top.bsv ﬁle where
   you want to synthesize an instance.

5. Compile the design again with bsc. The compile will generate messages listing mising instances
   along with the genSpecificInst command to create each missing instance. Execute the
   commands one at a time to generate an instance for each missing type.
   The genSpecificInst command will modify the include.bsv ﬁles, adding the instances. For
   example, in this step, the following lines are added to the m1.include.bsv ﬁle to resolve the
   Server#(a,a) type.

   module mkM1__ClientServer_Server_Bit_3_Bit_3_(
                                                   ClientServer::Server#(Bit#(3), Bit#(3)) ifc ) ;

          let _i &lt;- mkM1 ;
          return _i ;
   endmodule

   instance MakeInst_mkM1 #( ClientServer::Server#(Bit#(3), Bit#(3)) ) ;
          module mkM1_Synth ( ClientServer::Server#(Bit#(3), Bit#(3)) ifc );
                let _i &lt;- mkM1__ClientServer_Server_Bit_3_Bit_3_ ;
                messageM(&quot;Using mkM1__ClientServer_Server_Bit_3_Bit_3_ for mkM1 of

                                                            88


                                 type: &quot; +
                                    (printType (typeOf (_i))));

                     return _i ;
               endmodule
       endinstance

       Note that the code added in this step does not add to or change the behavior of the design.
       Only the additional hierarchy is added.

   6. Add provisos to the polymorphic modules to avoid early binding of the module. Otherwise
       compiling at this point will not show the speciﬁc instances because the instance of the Synth
       is bound before the speciﬁc type of the module is known. In this example, mkM1 Synth would
       be bound before the speciﬁc type of mkM2 is known. To ﬁx this, provisos are added to the
       polymorphic module mkM2. The module mkM2 has three instantiations of mkM1, therefore a
       proviso for each instantiation is added.

       module mkM2 (Server#(a,a)) provisos (Bits#(a,sa)
                                        ,MakeInst_mkM1#(Server#(a,a))
                                        ,MakeInst_mkM1#(Server#(Tuple2#(a,a),Tuple2#(a,a)))
                                        ,MakeInst_mkM1#(Server#(Tuple3#(a,a,a),Tuple3#(a,a,a)))
                                        );

   7. Compile with bsc again.

   8. Continue until there are no missing instance messages. A Verilog ﬁle will be created for each
       synthesized module instance.

SynthInst Example Files
m1.bsv: Module mkM1 is deﬁned in the package (ﬁle) m1.bsv:

    import ClientServer :: *;
    import GetPut :: *;
    import FIFOF :: * ;

    module mkM1 (Server#(a,a)) provisos (Bits#(a,sa));
         FIFOF#(a) fifo &lt;- mkFIFOF;

         interface request = toPut (fifo);
         interface response = toGet (fifo);
    endmodule

m2.bsv: Module mkM2 is deﬁned in the package m2.bsv. Note that there are three instantiations of
mkM1. You can choose to synthesize any or all of the instances.

    import FIFO::*;
    import GetPut::*;
    import ClientServer::*;
    import m1 :: *;

    module mkM2 (Server#(a,a)) provisos (Bits#(a,sa)
         Server#(a,a) m1_1 &lt;- mkM1;
         Server#(Tuple2#(a,a),Tuple2#(a,a)) m1_2 &lt;- mkM1;

                                                                89


         Server#(Tuple3#(a,a,a),Tuple3#(a,a,a)) m1_3 &lt;- mkM1;

         rule r0;
              let { x1,x2 } &lt;- m1_2.response.get();
              m1_3.request.put (tuple3 (x1,x2,x2));

         endrule

         interface Put request;
              method Action put (a x);
                   m1_2.request.put (tuple2(x,x));
              endmethod

         endinterface

         interface Get response;
              method ActionValue#(a) get ();
                   let { y1,y2,y3 } &lt;- m1_3.response.get();
                   return (y1);
              endmethod

         endinterface
    endmodule

Top.bsv: The testbench is contained in the ﬁle Top.bsv

    import ClientServer :: *;
    import GetPut :: *;
    import m2 :: *;

    (* synthesize *)
    module mkTb (Empty);

         Reg#(int) cycle &lt;- mkReg (0);

         Server#(Bit#(3), Bit#(3)) m2_3 &lt;- mkM2;
         Server#(Bit#(7), Bit#(7)) m2_6 &lt;- mkM2;
         Server#(Bit#(8), Bit#(8)) m2_8 &lt;- mkM2;

         rule r1;
              $display (&quot;%0d: r1: put (%0d)&quot;, cycle, cycle);
              m2_3.request.put (truncate (pack (cycle)));
              m2_6.request.put (truncate (pack (cycle)));
              cycle &lt;= cycle + 1;
              if (cycle &gt; 8) $finish(0);

         endrule

         rule r2;
              let x_3 &lt;- m2_3.response.get ();
              let x_6 &lt;- m2_6.response.get ();
              $display (&quot;%0d: r2: %0d,%0d &lt;= get&quot;, cycle, x_3, x_6);

         endrule
    endmodule

A.5 Workstation package command reference

The WS package provides a programming interface to customize the workstation. Speciﬁcally, com-
mands available from the workstation menus and toolbars can be executed from the workstation

                                                                90


command line or included in Tcl scripts which are executed from the workstation. These commands
are only available in the workstation. Attempting to use them in Bluetcl or Bluewish will result in
an error.
Tcl scripts using WS commands must be added to the .bluetclrc ﬁle.
The WS package is divided into several sub-namespaces. To execute a command you must either
specify the full path, including the package and namespace, or import the namespace before executing
the command.
For example, to execute the link command, in the workstation command line you would type:

      WS::Build::link

Or, you could import the Build namespace, then execute the command:

      namespace import ::WS::Build::*
      link

The namespace only has to be imported once in a session. After it has been imported, you can
execute any of the commands in the namespace without providing the full path name. The Tcl
documentation provides additional information on using namespaces.

A.5.1 Help
The help command is in the WS namespace. Examples:

WS::help
WS::help -command reload_packages

help                       Displays help for the help command.
[-list]                    Displays all available WS commands.
[-content]                 Activates Help → Content window.
[-bsv]                     Activates Help → BSV window.
[-about]                   Activates Help →About window.
[-command command name ]   Displays help for the speciﬁed command

A.5.2 WS::Analysis

The Analysis namespace contains the workstation commands used to analyze the current design
and populate the workstation browser windows.
Example:

WS::Analysis::get_schedule_warnings

load module module name    Loads the speciﬁed module.
module collapse all        Collapses the hierarchical view to show only module list.
reload module module name  Reloads the currently loaded module.
add type type              Adds the speciﬁed type/types to the Type Browser win-
                           dow.

                                     91


type collapse all               Collapses the type hierarchy.

import hierarchy [ package name ] Shows the imports hierarchy for the speciﬁed package or
                                                   the top ﬁle in a separate window.

load package package name       Loads a package with the speciﬁed name.

package collapse all            Collapse the hierarchical view to show only package list.

package refresh                 Refreshes the package hierarchy.

reload packages                 Reloads all loaded packages.

remove type key                 Removes information for speciﬁed type from the Type
                                Browser window.

search in packages pattern      Searches for the pattern in the package hierarchy.
[-next | -previous]             If not speciﬁed defaults to -next.

get execution order [ module name ] Displays rules and methods for the speciﬁed module
                                                        in the Schedule Analysis window.

get method call [ module name ] Displays the Method Call perspective of the Schedule
                                                   Analysis window for the speciﬁed module.

get rule info rule name         Displays information for the speciﬁed rule in the Rule
                                Order perspective of the Schedule Analysis window.

get rule relations rule1 rule2  Displays relations for the given pair of rules in the Rule
                                relations perspective of the Schedule Analysis window. In
                                case of multiple rules rule should be given in ”” quotes

get schedule warnings           Displays warnings occurred during scheduling for the
[ module name ]                 speciﬁed module in the Schedule Analysis window.

show schedule module name       Opens the Schedule Analysis window for the speciﬁed
                                module.

A.5.3 WS::Build

The Build namespace contains the workstation commands available on the Build menu.
Example:

WS::Build::link

clean                           Removes compilation/simulation speciﬁc result ﬁles.
compile
                                Compiles the current project with already deﬁned op-
compile ﬁle ﬁle name            tions.
[-withdeps]
[-typecheck]                    Compiles the speciﬁed ﬁle.
full clean                      Consider ﬁle dependencies
                                Typecheck only
link
                                Removes all logs and result ﬁles created during last com-
                                pilation/simulation. If compilation via makeﬁle has been
                                deﬁned then appropriate target will be executed.

                                Links the project

                                92


simulate                        Calls simulator for the current project with already de-
typecheck                       ﬁned options.

                                Typechecks the current project with already deﬁned op-
                                tions.

A.5.4 WS::File

The File namespace contains the commands used to open ﬁles and create new ﬁles. A ﬁle is opened
with editor speciﬁed in the project options.

new ﬁle ﬁle name [-path location ] Creates a new ﬁle and launches the editor on it.

open ﬁle location               Launches the editor

[-line number ] [-column number ] line number and column number where ﬁled opened

A.5.5 WS::Project

The Project namespace contains the commands to manage projects, including creating new projects,
opening and closing projects, and the actions to set and get project options for the current project.

Example:

WS::Project::close_project

backup projectarchive ﬁle name  Archives the project to the ﬁle named.
[-input ﬁles]                   Include all input ﬁles.
[-project dir]                  Include all ﬁles in project directory.
[-search path]                  Include ﬁles on search path
[-options option ]              Options for tar command
[-search path ﬁles ﬁle ext ]    Include ﬁles in search path with these extensions only.

close project                   Closes the current project without saving any changes.

get bluesim options             Returns Bluesim options for the current project.

get bsc options                 Returns bsc options for the current project.

get compilation results location Returns paths where compilation results are located.

get compilation type            Returns compilation type (bsc or make) for current
                                project.

get link bsc options            Returns link bsc options for the current project.

get link custom command         Returns link custom command for the current project.
command

get link make options           Returns link make options for the current project.

get link type                   Returns link type for the current project.

get make options                Returns compile make options.

get project editor              Returns editor speciﬁc information for the current
                                project.

get sim custom command          Returns simulation custom command for the current
command                         project.

                                93


get top ﬁle                       Returns top ﬁle and top module for the current project.

get verilog simulator             Returns verilog simulator for the current project.

new project project name          Creates a new project with the project name.
[-location project path]          project location
[-paths {search path location} ]  Search path separated by ;

open project project ﬁle          Opens the speciﬁed project.

refresh [ﬁle name]                Refreshes information about current project.

save project                      Saves all information related to the current project.

save project as project name      Saves current project with a new name.
[-path location ]                 Can optionally specify a new location.

set bluesim options               Speciﬁes bluesim options for the current project.

set bsc options                   Speciﬁes bsc compile options for the current project.
-bluesim | -verilog               Target (Bluesim or Verilog)
[-options options ]               Additional options

set compilation results location  Speciﬁes paths where the compilation results should be
                                  written.
[-vdir location ]                 Verilog output
[-bdir location ]                 bsc ﬁles
[-simdir location ]               simulation results

set compilation type              Speciﬁes the compilation type for the current project.
bsc | make                        Must be either bsc or make.

set link bsc options ﬁlename      Speciﬁes link bsc options for the current project.
[-bluesim | -verilog]             Link via Bluesim or Verilog
[-path directory]
[-options option ]

set link custom command           Speciﬁes link custom command for the current project.
command

set link make options             Speciﬁes link make options
Makeﬁle                           Name of Makeﬁle
[-target target ]                 Name of Build target
[-clean target ]                  Name of Clean target
[-fullclean target ]              Name of Full clean target
[-options options ]               Options for make command

set link type type                Speciﬁes link type for the current project.
bsc | make | custom command       Must be bsc, make, or custom command

set make options Makeﬁle          Speciﬁes compile makeﬁle and make options.
[-target target ]                 Name of Build target
[-clean target ]                  Name of Clean target
[-fullclean target ]              Name of Full clean target
[-options options ]               Options for make command

set project editor editor name    Speciﬁes editor for the current project.
[-command command ]               Command used to launch editor

set search paths                  Adds search paths to the current project.
{location:location }              Directories are separated by :

                                  94


set sim custom command              Speciﬁes simulation custom command for the project.
command
                                    Speciﬁes top ﬁle for the current project.
set top ﬁle ﬁle                     Optional top module.
[-module module name ]              Speciﬁes verilog simulator for the current project.

set verilog simulator
simulator name [-options options ]

A.5.6 WS::Wave

The Wave namespace contains the commands used with the waveform viewer.
Example:

WS::Wave::reload_dump_file

attach waveform viewer              Attaches to the waveform viewer.

get nonbsv hierarchy hier           Returns the hierarchy for the current waveform viewer.

get waveform viewer                 Returns the waveform viewer for the current project.

load dump ﬁle dump ﬁle path         Loads the dump ﬁle.

reload dump ﬁle                     Reloads the currently loaded dump ﬁle.

set nonbsv hierarchy hier           Speciﬁes the hierarchy for the waveform viewer.

set waveform viewer viewer name     Speciﬁes the waveform viewer for the current project.
[-command command ]                 Command to launch the viewer.
[-options options ]                 Viewer options
[-close 0 or 1]                     1 to close viewer on Bluespec close

start waveform viewer               Starts the speciﬁed waveform viewer.

A.5.7 WS::Window

The Window namespace contains the commands to show, minimize, and close the windows and graphs
in the workstation.
Example:

WS::Window::show -package

close all                           Closes all currently opened windows.

minimize all                        Minimizes all currently active windows except the main
                                    window.
show
                                    Activates the speciﬁed window. If the window is already
-project                            active then focus will be set on it.
-editor                             Project Files window.
-schedule analysis                  Editor window.
-module browser                     Schedule Analysis window.
-type browser                       Module Browser window.
-package                            Type Browser window.
                                    Package Browser window.

                                    95


show graph      Activates or sets focus on the speciﬁed graph window.
-conﬂict        conﬂict graph
-exec           execution order graph
-urgency        urgency graph
-combined       combined graph
-combined full  combined full graph

A.6 Customizing the Workstation

The ﬁles .bluetclrc and /.bluespec/setup.tcl can be edited to customize the workstation. The
ﬁle .bluetclrc is used to add Bluetcl commands and scripts to the workstation and is sourced when
the workstation is started. The ﬁle /.bluespec/setup.tcl contains the default settings for project
options and is read when a new project is created. All other ﬁles in /.bluespec are used by the
workstation and must not be edited.

A.6.1 Bluetcl interpreters in the workstation

The Bluespec workstation uses two separate interpreters: the main interpreter controls all the win-
dows and the state of the workstation, while the second, slave interpreter is the user command shell
in the main window. Both interpreters source the ﬁle $HOME/.bluetclrc, which is where you add
your customizations. Each interpreter is independent from the other; it has its own name space for
commands, procedures, and global variables, as described in the standard Tcl documentation.

Customization for the workstation interpreter is limited to adding toolbar items. The user command
interpreter has the same ﬂexible features of Bluetcl, plus the commands from the WS namespaces
to interface with the workstation. To annotate the diﬀerent interpreter use, global variables are
deﬁned. For the main interpreter, the global variable bscws is deﬁned. For the command shell, the
global variable bscws interp is deﬁned.

Workstation customizations can be added to the .bluetclrc ﬁle as well, but since those commands
are only valid when using the workstation, their execution must be conditional on the global variable.

A.6.2 Adding items to the toolbar

To add a new item to the toolbar, use the Bluetcl command register tool bar item which has
the following prototype:

proc register_tool_bar_item itemname &quot;command&quot; iconfilename &quot;helpstring &quot;

Example: Customizing the Workstation
In this example three additional toolbars items are added. The ﬁrst displays the Bluespec version,
the second launches a window for a command named simplePopUp, and the third automates a
common series of tasks. You can execute the simplePopUp script from either the toolbar or from a
Bluewish prompt. The proc waveFormLoad will not work outside the workstation.
The bottom of the example demonstrates how to customize the workstation command window, in
this case by importing the Build commands from the WS namespace.
To use these commands add them to the .bluetclrc ﬁle.

############################################
## Customizations for the Bluespec Development Workstation
## Add 3 items to the toolbar

                                                                96


if { [info exists bscws] } {
    puts &quot;Customizing the Bluespec Development workstation&quot;

    # Print out the version
    register_tool_bar_item myVersion &quot;puts {[Bluetcl::version]}&quot; Bluespec.gif &quot;Version&quot;
    # Simple popup window example
    register_tool_bar_item myGlobals &quot;simplePopUp&quot; cog.gif &quot;Simple PopUp Script&quot;
    # Grouping common actions in the WS.
    register_tool_bar_item bu &quot;waveFormLoad&quot; add.gif &quot;Show module browser&quot;

}

# Simple pop up window callable from the toolbar or command line
proc simplePopUp {} {

    package require Tk
    set msg &quot;Popup window example for customizing Bluespec\nVersion
[Bluetcl::version]&quot;
    tk_messageBox -icon info -message $msg -title &quot;Pop Up Window&quot;
}

# Script to automate a common task
# This will from a workstation toolbar, or Workstation command window
# but will not work outside the workstation
proc waveFormLoad {} {

    WS::Window::show -module_browser
    WS::Analysis::load_module [WS::Project::get_top_module]
    WS::Wave::start_waveform_viewer
    after 10000
    WS::Wave::load_dump_file dump.vcd
}

## Customizations for the workstation command line
if { [info exists bscws_interp] } {

    # Import all the Build commands into the command interp
    # I.e. compile, link, simulate
    namespace import WS::Build::*
}

#####################################################################

A.7 Bluetcl Scripts

Scripts are self-contained commands you run from a shell. A Tcl script may be include any combi-
nation of Bluetcl and Tcl commands.
The scripts described in this section are provided by Bluespec in the $BLUESPECDIR/tcllib/bluespec
directory. To execute a script, type the fully qualiﬁed script name. For example, to execute the
expandPorts script from a command prompt you would type:

      $BLUESPECDIR/tcllib/bluespec/expandPorts.tcl

If you are already in a Tcl shell, type exec before the script name:

                                                                97


      exec $BLUESPECDIR/tcllib/bluespec/expandPorts.tcl

To execute your own Tcl scripts from within the Bluespec development workstation they need to be
added to the workstation in the ~/.bluetclrc ﬁle.

A.7.1 expandPorts
Script to create a Verilog wrapper ﬁle which expands structures into separate Verilog ports.

Usage:

expandPorts.tcl {options} packname modname module.v

options          Optional command line switches:
-p path          path, if supplied to the bsc command
-verilog         compile to verilog (default)
-sim             compile to bluesim
-include outﬁle  output ﬁle for include.vh
-wrapper outﬁle  output ﬁle for wrapper.v
-rename ﬁle.tcl  Tcl script creating rename pin structure
-makerename      Create empty .rename.tcl ﬁle to edit for -rename
-interface name  Interface to expand - defaults to package name (packname)
packname         Name of the input .bo ﬁle.
modname          Name of the top level module.
module.v         bsc generated Verilog (.v) ﬁle for the module being wrapped.

                 98


Index                                           -remove-empty-rules (debugging ﬂag), 54
                                                -remove-false-rules (debugging ﬂag), 54
+ (Bluesim simulation ﬂag), 72                  -remove-starved-rules (debugging ﬂag), 54
+bsccycle, 18                                   -remove-unused-modules (compiler ﬂag), 48
+bsccycle (Verilog simulation), 32              -resource-off (compiler ﬂag), 48
+bscvcd, 18                                     -resource-simple (compiler ﬂag), 48
+bscvcd (Verilog simulation), 32                -runtime-license (compiler ﬂag), 50
-D (compiler ﬂag), 50                           -sched-dot (compiler ﬂag), 24, 42
-E (compiler ﬂag), 50                           -sched-dot (debugging ﬂag), 55
-Hsize (compiler ﬂag), 51                       -scheduler-effort (compiler ﬂag), 53
-I (compiler ﬂag), 30, 49                       -show-compiles (compiler ﬂag), 52, 61
-Ksize (compiler ﬂag), 51                       -show-license-detail (compiler ﬂag), 50
-L (compiler ﬂag), 30, 34                       -show-method-conv (debugging ﬂag), 54
-O (compiler ﬂag), 53                           -show-module-use (debugging ﬂag), 54
-V, 18                                          -show-range-conflict (debugging ﬂag), 54
-V (Bluesim simulation ﬂag), 72                 -show-rule-rel (debugging ﬂag), 55, 62
-Werror (debugging ﬂag), 54                     -show-schedule (debugging ﬂag), 55, 62
-Xc++ (compiler ﬂag), 57                        -show-stats (debugging ﬂag), 54
-Xcpp (compiler ﬂag), 57                        -sim (compiler ﬂag), 25, 47
-Xc (compiler ﬂag), 57                          -simdir (compiler ﬂag), 49
-Xl (compiler ﬂag), 57                          -split-if (compiler ﬂag), 52
-Xv (compiler ﬂag), 48                          -steps (compiler ﬂag), 50
-aggressive-conditions (compiler ﬂag), 52       -steps-max-intervals (compiler ﬂag), 50
-bdir (compiler ﬂag), 49                        -steps-warn-interval (compiler ﬂag), 50
-c (Bluesim simulation ﬂag), 72                 -systemc (compiler ﬂag), 30
-check-assert (debugging ﬂag), 54               -u (compiler ﬂag), 47, 52, 61
-continue-after-errors (debugging ﬂag), 54      -unspecified-to (compiler ﬂag), 48
-cpp (compiler ﬂag), 57                         -v (Bluesim simulation ﬂag), 72
-e (compiler ﬂag), 47                           -v (compiler ﬂag), 47, 61
-f (Bluesim simulation ﬂag), 72                 -v95 (compiler ﬂag), 48
-g (compiler ﬂag), 24, 26, 47                   -vdir (compiler ﬂag), 49
-g (compiler ﬂag), 23                           -verbose (compiler ﬂag), 47
-h (Bluesim simulation ﬂag), 72                 -verilog (compiler ﬂag), 25, 47
-help (compiler ﬂag), 47                        -vsim, 32
-i (compiler ﬂag), 49                           -vsim (compiler ﬂag), 47
-info-dir (compiler ﬂag), 49                    -w (Bluesim simulation ﬂag), 72
-keep-fires (debugging ﬂag), 54                 -wait-for-license (compiler ﬂag), 50
-keep-inlined-boundaries (debugging ﬂag),       -warn-action-shadowing (debugging ﬂag), 54
                                                -warn-method-urgency (debugging ﬂag), 54
            54                                  -warn-scheduler-effort (compiler ﬂag), 53
-l (compiler ﬂag), 30, 34, 49                   .ba, 23
-license-type (compiler ﬂag), 50                .ba (ﬁle type), 9
-licenseWarning (compiler ﬂag), 50              .bi (ﬁle type), 9
-lift (compiler ﬂag), 52                        .bi/.bo, 23
-m (Bluesim simulation ﬂag), 72                 .bluetclrc, 81, 91, 96
-no (compiler ﬂag), 47                          .bo (ﬁle type), 9, 26
-no-runtime-license (compiler ﬂag), 50          .bspec, 12
-o (compiler ﬂag), 47                           .bsv (ﬁle type), 9
-opt-undetermined-vals (compiler ﬂag), 53       .cxx (ﬁle type), 9
-p (compiler ﬂag), 49                           .h (ﬁle type), 9
-print-expiration (compiler ﬂag), 50
-print-flags (compiler ﬂag), 50
-remove-dollar (compiler ﬂag), 48

                                            99


.o (ﬁle type), 9                             default settings, 12, 13
.v, 23                                       defs (bluetcl command), 82
.v (ﬁle type), 9                             descending urgency attribute, 44
%M (meta variable), 14, 16, 18               documentation, 7
%P (meta variable), 14, 16, 18
                                             editor options, 19
attributes                                   emacs, 19
      descending urgency, 44                 emacs (text editor), 9
      preempts, 41                           enscript, 9
      synthesize, 23, 24                     error messages, 57
                                             execution order (scheduling graph), 44
automatic recompilation, 52, 61
                                             ﬁle types, 9
backup, 21                                   ﬁlter, 42
Bluesim, 27, 72                              flags (bluetcl command), 82
                                             FLEXnet, 8
      importing C functions, 29              full clean, 35
      interactive mode, 73
      linking .ba ﬁles, 28                   graphviz, 8, 42
      MCD, 79                                gvim, 19
      multiple clock domains, 79
      scripting, 73, 78                      help (bluetcl command), 82

         commands, 73                        import, 35
         navigation, 76                      import packages, 23
      simulation ﬂags, 72                    importBDPI, 27, 29, 33
Bluesim back end, 28, 29, 48, 72             importBVI, 27, 28
Bluesim ﬂags, 72                             importing C, 27, 29, 33
BLUESPEC HOME, 6                             importing foreign functions, 27
BLUESPECDIR, 6                               importing packages, 25
Bluetcl, 7                                   importing Verilog, 27, 28, 32
bpackage (bluetcl command), 82               installing, 6
bsc, 17                                      iverilog (Verilog simulator), 32
bsc ﬂags, 46
BSC OPTIONS, 47                              jedit (text editor), 9
build, 22
                                             library packages, 25
clean, 35                                    licensing, 8
code generation, 24                          link, 10, 27
combined (scheduling graph), 44              link options, 16
combined full (scheduling graph), 46         linking, 27
compilation, 26                              linking ﬂags, 47
compile, 10, 23
compile ﬂags, 47                             makeﬁle
compile options, 15                                exporting, 21
compile with deps, 24                              using, 16, 18, 35
compiler ﬂags
                                             modelsim (Verilog simulator), 32
      -g, 23                                 module (bluetcl command), 83
      -sched-dot, 24, 42
      using, 16                              ncverilog (Verilog simulator), 32
Compiler messages, 57
compiler messages, 12, 39                    options, 13
compiler optimizations, 53                         compiler, 19
compiler transformations, 52                       editor, 19
conﬂict (scheduling graph), 43                     ﬁles, 19
cver (Verilog simulator), 32                       search path, 19

debugging ﬂags, 54                    100


package, 35                               urgency (scheduling graph), 44
path ﬂags, 49                             utilities, 9
path messages, 59
preempts attribute, 41                    value change dump
proﬁle, 13                                      Bluesim, 79
progress messages, 60                           Verilog, 32
project, 12
                                          VCD
resource scheduling, 48                         Bluesim, 79
rule (bluetcl command), 83                      Verilog, 32
rules, 67
run-time ﬂags, 51                         vcs (Verilog simulator), 32
                                          vcsi (Verilog simulator), 32
save, 20                                  Verilog, 23, 27
save placement, 21
schedule (bluetcl command), 83                  importing, 27
scheduling, 62                                  linking, 32
scheduling graphs, 42                           simulator, 32
                                          Verilog back end, 32, 33, 48, 63
      combined, 44                        Verilog ﬂags, 48
      combined full, 46                   Verilog header comment, 67
      conﬂict, 43                         Verilog ports, 64
      execution order, 44                 Verilog Procedural Interface (VPI), 27, 33
      urgency, 44                         Verilog simulator
scheduling messages, 58                         cver, 32
search path, 14                                 iverilog, 32
selecting modules, 24                           modelsim, 32
settings                                        ncverilog, 32
      compile options, 15                       vcs, 32
      default, 12, 13                           vcsi, 32
      editor options, 19                        veriwell, 32
      link options, 16                    veriwell (Verilog simulator), 32
      Project Options menu, 13            version (bluetcl command), 84
      search path, 14                     VHDL, 32
      simulate options, 18                view source, 36
      waveform viewer options, 19         vim (text editor), 9
sim (bluesim command), 84
sim (bluetcl command), 83                 warnings messages, 57
simulate options, 18                      waveform viewer
SpringSoft/Novas, 19
state elements, 65                              options, 19, 38
submodule (bluetcl command), 84                 SpringSoft/Novas, 19
synthesize (attribute), 24, 26                  using, 38
synthesize attribute, 23, 24              window placement, 21
SystemC
      linking .ba ﬁles, 30         101
SystemC back end, 30

Tcl, 11
top ﬁle, 24
top module, 23
top package, 36
type (bluetcl command), 84
type check, 23
type-checking error messages, 57


Commands by Namespace

Bluesim                                       open ﬁle, 93
      sim, 84                           WS::Project

Bluetcl                                       backup project, 93
      bpackage, 82                            close project, 93
      defs, 82                                get bluesim options, 93
      ﬂags, 82                                get bsc options, 93
      help, 82                                get compilation results location, 93
      module, 83                              get compilation type, 93
      rule, 83                                get link bsc options, 93
      schedule, 83                            get link custom command, 93
      sim, 83                                 get link make options, 93
      submodule, 84                           get link type, 93
      type, 84                                get make options, 93
      version, 84                             get project editor, 93
                                              get sim custom command, 93
Types                                         get top ﬁle, 93
      import package, 86                      get verilog simulator, 94
      show types, 86                          new project, 94
                                              open project, 94
WS                                            refresh, 94
      help, 91                                save project, 94
                                              save project as, 94
WS::Analysis                                  set bluesim options, 94
      add type, 91                            set bsc options, 94
      get execution order, 92                 set compilation results location, 94
      get method call, 92                     set compilation type, 94
      get rule info, 92                       set link bsc options, 94
      get rule relations, 92                  set link custom command, 94
      get schedule warnings, 92               set link make options, 94
      import hierarchy, 92                    set link type, 94
      load module, 91                         set make options, 94
      load package, 92                        set project editor, 94
      module collapse all, 91                 set search paths, 94
      package collapse all, 92                set sim custom command, 94
      package refresh, 92                     set top ﬁle, 95
      reload module, 91                       set verilog simulator, 95
      reload packages, 92               WS::Wave
      remove type, 92                         attach waveform viewer, 95
      search in packages, 92                  get nonbsv hierarchy, 95
      show schedule, 92                       get waveform viewer, 95
      type collapse all, 91                   load dump ﬁle, 95
                                              reload dump ﬁle, 95
WS::Build                                     set nonbsv hierarchy, 95
      clean, 92                               set waveform viewer, 95
      compile, 92                             start waveform viewer, 95
      compile ﬁle, 92                   WS::Window
      full clean, 92                          close all, 95
      link, 92                                minimize all, 95
      simulate, 92                            show, 95
      typecheck, 93                           show graph, 95

WS::File                         102
      new ﬁle, 93
</Text>
        </Document>
        <Document ID="1C65438B-F20E-4CD5-8620-3CE1B6BD8F53">
            <Title>Surely this has been explored before?</Title>
            <Text>
### Surely this has all been investigated already - why haven’t I ever heard of temporal programming before?

There have been a small number of languages that model something similar to temporal programming; you can find them in Wikipedia under the entry “Synchronous Programming Languages”.

OK, this is starting to sound somewhat interesting. Surely all of this has been researched thoroughly by now?
    Absolutely, but not to the extent you might think.
    The ideas have been floating around for years in various obscure programming languages, research papers, and talks
    &lt;reference list&gt;

</Text>
        </Document>
        <Document ID="1EB36BDE-0795-41D4-B481-0C1620FC5683">
            <Title>Explicit data graph CPU</Title>
            <Text>Instructions refer to previous instructions as inputs
</Text>
        </Document>
        <Document ID="232AC60D-6945-4711-A0F4-AAB28AC6F0F4">
            <Title>Temporal Programming for Hardware</Title>
        </Document>
        <Document ID="2592BC1C-AA99-4DEA-9595-576DE89207AC">
            <Title>Guarded Atomic Actions</Title>
            <Text> - Guarded Atomic Actions
 - “Guarded atomic actions”
</Text>
        </Document>
        <Document ID="2A401011-5BBB-4B6E-BD5F-16C74FCBB707">
            <Title>The Conceptual Leap</Title>
            <Text>Now for a bit of a conceptual leap - This model of computation as used in Lamport's &quot;Temporal Logic of Actions&quot; _is_ a programming paradigm. It's not a complicated one, but it's distinctly different from the &quot;state changes incrementally&quot; style of imperative programming and the &quot;state doesn't change&quot; style of functional programming. You can also think of it as a reformulation of Synchronous Programming - one that focuses on &quot;all state changes simultaneously&quot; instead of &quot;lots of things happen simultaneously&quot;.

It's also not at all new - it's the programming paradigm that folks who write code for FPGAs all day think in by default. It's also a paradigm that most software developers _don't_ think in by default, which is part of why Verilog and VHDL can seem so incomprehensible at first. It's a paradigm that a lot of us use every day, but we're so implicitly familiar with it our different sub-areas of programming that we don't really have a word for it at a global level.

In honor of Leslie Lamport's work on temporal logic, I propose we call it &quot;Temporal Programming&quot;.
</Text>
        </Document>
        <Document ID="2A9DA0E7-1B70-4030-899F-C16B90B36026">
            <Title>Have you heard of...</Title>
        </Document>
        <Document ID="2ADAC996-1C1F-455E-9DF8-B0E63F803674">
            <Title>Unwrapping a temporal program</Title>
            <Text>Unwr</Text>
        </Document>
        <Document ID="2C9345D4-B22E-43A5-B712-F408027669D6">
            <Title>Bluespec</Title>
        </Document>
        <Document ID="2CE61B12-9C5F-4D3F-B452-65CB47B32871">
            <Text>data moving around a chip, data moving around a codebase

led scanner example
	What if you need 1000 LED scanners running at different rates?</Text>
        </Document>
        <Document ID="3015FFE4-4D2E-485F-84DE-4C19A8C61C35">
            <Title>What can we express in a temporal programming language?</Title>
            <Text>
## What can we express in a temporal language that we can't express in a procedural or functional language


</Text>
        </Document>
        <Document ID="39354146-508C-4E91-91D9-39CA04689864">
            <Title>What is Temporal Programming good for?</Title>
        </Document>
        <Document ID="40B82475-E27A-40BA-AF31-FCF4BDD1F241">
            <Title>Plaid</Title>
            <Text>
 - Plaid
</Text>
        </Document>
        <Document ID="49C24234-0610-447F-B873-72AEDA8003D0">
            <Title>Finite State Automata?</Title>
        </Document>
        <Document ID="4C628C76-49A0-49E0-88B7-9FE0FDB5906B">
            <Title>Esterel</Title>
            <Text> - Esterel
   - esterel-eda.com is defunct
   - http://www.esterel-technologies.com/ is defunct
   - Ansys bought Esterel 10 years ago but it doesn't appear on their website?
      - search may just be broken
   - They appear to sell SCADE
   - http://www.tni-valiosys.com/ defunct




It's almost like the machines are _embedded_ in the code in Esterel, instead of the machines _being_ the code.

In some ways, we can see Esterel and Lustre as two examples of doing temporal programming &quot;inside&quot; imperative/functional programming


 - Esterel has some uncanny similarities
    - “The language version is that of the Esterel v5 system, version v5 91. This new language version extends the previous version v5 21 by the addition of new pre operators, which makes it possible to access the previous status and value of a signal.”
“Esterel v4 was much better than Esterel v3 since it avoided state space explosion. However, it required generated circuits to be acyclic. Although this condition is standard in hardware or data-flow systems design, it turned out to be too restrictive for Esterel.”
</Text>
        </Document>
        <Document ID="4FE9B898-81A4-4235-8668-0FF16571C796">
            <Title>Blech</Title>
            <Text> - Blech
   blech-lang.org
   &quot;The software is not ready for production use. It has neither been developed nor tested for a specific use case.&quot;
   &quot;Blech is no longer under active development at Bosch Research&quot;
</Text>
        </Document>
        <Document ID="5298CB3B-D568-4409-8673-B50C88CEB8C6">
            <Title>Signal</Title>
            <Text> - Signal
   - &quot;Implementation of the data-flow synchronous language Signal&quot;
      - can reference past values of a signal with $
      - stuff like &quot;X := U default V&quot; defines a merge of two event streams, which is out of scope for TP
      - individual signals have a &quot;clock&quot; defining when they are present/absent
   - http://www.irisa.fr/espresso/home_html/ defunct
   - http://polychrony.inria.fr/
   - https://www-verimag.imag.fr/Synchron.html defunct
   - http://polychrony.inria.fr/Download/download.php how old is this stuff
   - &quot;The Synchronous Programming Language SIGNAL&quot; 2004
</Text>
        </Document>
        <Document ID="548C2750-D287-498E-8632-B9B05FD9F241">
            <Title>Performance &amp; Efficiency</Title>
        </Document>
        <Document ID="56307444-8AE8-49A2-B641-2CEA2CAC0544">
            <Title>Operation-Centric Hardware Description and Synthesis</Title>
            <Text>IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004  1277

Operation-Centric Hardware
 Description and Synthesis

   James C. Hoe, Member, IEEE, and Arvind, Fellow, IEEE

   Abstract—The operation-centric hardware abstraction is useful                  element’s next-state logic. Alternatively, the behavior of a
for describing systems whose behavior exhibits a high degree                      hardware system can be described as a collection of opera-
of concurrency. In the operation-centric style, the behavior of                   tions, where each operation can atomically update all or some
a system is described as a collection of operations on a set of                   of the state elements. In this paper, we refer to this style of
state elements. Each operation is speciﬁed as a predicate and a                   descriptions as operation-centric because the description of
set of simultaneous state-element updates, which may only take                    behavior is organized into individual operations. Our notion
effect in case the predicate is true on the current state values.                 of operation-centric models for hardware description is in-
The effect of an operation’s state updates is atomic, that is, the                spired by the term rewriting systems (TRS) formalism [1].
legal behaviors of the system constitute some sequential inter-                   The operation-centric hardware model of computation is also
leaving of the operations. This atomic and sequential execution                   analogous to Dijkstra’s guarded commands [7]. Similar models
semantics permits each operation to be formulated as if the rest                  of computation can be found in some parallel programming
of the system were frozen and thus simpliﬁes the description of                   languages (e.g., UNITY [5]), hardware-description languages
concurrent systems. This paper presents an approach to syn-                       for synchronous and asynchronous design synthesis (e.g.,
thesize an efﬁcient synchronous digital implementation from an                    synchronized transitions (ST) [13], [16], [17]), and languages
operation-centric hardware-design description. The resulting                      for hardware-design veriﬁcation (e.g., st2ﬂ [12], SINC [14]).
implementation carries out multiple operations per clock cycle                    In Section VII, we compare our description and synthesis
and yet maintains the semantics that is consistent with the atomic                approach to synchronized transitions.
and sequential execution of operations. The paper deﬁnes, and
then gives algorithms to identify, conﬂict-free and sequentially                     The operation-centric model of computation consists of a set
composable operations that can be performed in the same clock                     of state variables and a set of state transition rules. Each atomic
cycle. The paper further gives an algorithm to generate the hard-                 transition rule represents one operation. An execution is inter-
wired arbitration logic to coordinate the concurrent execution of                 preted as a sequence of atomic applications of the state transi-
conﬂict-free and sequentially composable operations. Lastly, the                  tion rules. A rule can be optionally guarded by a predicate con-
paper evaluates synthesis results based on the TRAC compiler for                  dition such that a rule is applicable only if the system’s state
the TRSPEC operation-centric hardware-description language.                       satisﬁes the predicate condition. If several rules are enabled by
The results from a pipelined processor example show that an                       the same state, any one of the enabled rules can be nondeter-
operation-centric framework offers a signiﬁcant reduction in                      ministically selected to update the state in one step, and after-
design time, while achieving comparable implementation quality                    wards, a new step begins on the updated new state. With pred-
as traditional register-transfer-level design ﬂows.                               icated/guarded transition rules, an execution is interpreted as a
                                                                                  sequence of atomic rule applications such that each rule applica-
   Index Terms—Conﬂict-free, high-level synthesis, operation-cen-                 tion produces a state that satisﬁes the predicate condition of the
tric, sequentially composable, term-rewriting systems (TRS).                      next rule to be applied. The atomicity of operation-centric state
                                                                                  transition rules simpliﬁes the task of hardware description by
                           I. INTRODUCTION                                        permitting the designer to formulate each rule/operation under
                                                                                  the assumption that the system is not simultaneously affected
M OST hardware-description frameworks, whether                                    by other potentially conﬂicting operations—the designer does
         schematic or textual, make use of concurrent state ma-                   not have to worry about race conditions between different op-
chines (or processes) as their underlying computation model.                      erations. This permits an apparently sequential description of
For example, in a register-transfer-level (RTL) language,                         potentially concurrent hardware behaviors.
the design entities are the individual registers (or other state
primitives) and their corresponding next-state equations. We                         It is important to note that the simplifying atomic and se-
refer to this style of descriptions as state-centric because the                  quential semantics of operations does not prevent a legal im-
description of behavior is organized by the individual state                      plementation from executing several operations concurrently.
                                                                                  Implicit parallelism between operations can be exploited by an
   Manuscript received March 11, 2003; revised December 19, 2003. This work       optimizing compiler that produces a synchronous implemen-
was supported in part by the Defense Advanced Research Projects Agency, De-       tation that executes several operations concurrently in a clock
partment of Defense, under Ft. Huachuca Contract DABT63-95-C-0150 and in          cycle. However, the resulting concurrent implementation must
part by the Intel Corporation. J. C. Hoe was supported in part by an Intel Foun-  not introduce new behaviors, that is, behaviors which are not
dation Graduate Fellowship during this research. This paper was recommended       producible under the atomic and sequential execution seman-
by Associate Editor R. Gupta.                                                     tics. This paper presents an approach to synthesize such a syn-

   J. C. Hoe is with the Department of Electrical and Computer Engi-
neering, Carnegie Mellon University, Pittsburgh, PA 15213 USA (e-mail:
jhoe@ece.cmu.edu).

   Arvind is with Computer Science and Artiﬁcial Intelligence Laboratory,
Massachusetts Institute of Technology, Cambridge, MA 02139-4307 USA
(e-mail: arvind@csail.mit.edu).

   Digital Object Identiﬁer 10.1109/TCAD.2004.833614

0278-0070/04$20.00 © 2004 IEEE


1278                   IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

chronous hardware implementation from an operation-centric            Fig. 1. ATS summary.
description. The paper provides algorithms for detecting oppor-
tunities for the concurrent execution of operations and for gener-
ating a hardwired arbitration logic to coordinate the concurrent
execution in an implementation.

   This paper is organized as follows. Section II ﬁrst presents
the abstract transition systems (ATS), an simple operation-cen-
tric hardware formalism used to develop and explain the syn-
thesis procedures. Section III next describes the basic synthesis
procedure to create a reference implementation that is function-
ally correct but inefﬁcient. The inefﬁciencies of the reference
implementation are addressed in Sections IV and V using two
optimizations based on the concurrent execution of conﬂict-free
and sequentially composable operations, respectively. The re-
sulting optimized implementation incorporates a hardwired ar-
bitration logic that enables the concurrent execution of con-
ﬂict-free and sequentially composable operations. Section VI
presents a comparison of designs synthesized from an opera-
tion-centric description versus an state-centric RTL description.
Section VII discusses related work, and Section VIII concludes
with a summary.

      II. OPERATION-CENTRIC TRANSITION SYSTEMS

   We have developed an source-level language called TRSPEC
to support operation-centric hardware design speciﬁcation
[9]. TRSPEC’s syntax and semantics are adaptations of a
well-known formalism, TRS [1]. To avoid the complications
of a source language, instead, we present a low-level opera-
tion-centric hardware formalism called ATS. ATS is developed
as the intermediate representation in our TRSPEC compiler.
In this paper, we use ATS to explain how to synthesize an
efﬁcient implementation from an operation-centric hardware
speciﬁcation.

                                                                      Fig. 2. Synchronous state primitives.

A. ATS Overview

The structure of ATS is summarized in Fig. 1. At the top level,       A register can store an integer value up to a speciﬁed max-

an ATS is deﬁned as a triple            . is a list of explicitly     imum word size. The value stored in a register can be refer-

declared state elements, including registers , arrays and             enced using the side-effect-free       query and set to using

ﬁrst-in-ﬁrst-out (FIFO) queues . is a list of initial values          the        action (written as          and         , respectively).

for the elements in . is a set of operation-centric transi-           An entry of an array can be referenced using the side-effect-free

tions, where each transition is a pair  . In a transition, is a                  query and set to using the              action. For

boolean predicate expression, and is a list of simultaneous ac-       brevity, we abbreviate                 as   in our examples.

tions, exactly one action for each state element in . (An accept-     The oldest value in a FIFO can be referenced using the side-ef-

able action for all state-element types is the null action “ .”)      fect-free      query, and can be removed by the          action.

In an ATS, if of is enabled in a state [abbreviated as                A new value can be added to a FIFO using the             action.

      , or simply                       ], then the simultaneous ac-  The            action is a compound action that conceptually ﬁrst

tions prescribed by are applied atomically to update to               dequeues the oldest entry before enqueuing a new entry. In ad-

. We use the notation         to mean the resulting state . In        dition, the contents of a FIFO can be cleared using the

other words, is the functional equivalent of .                        action. The status of a FIFO can be queried using the side-ef-

                                                                      fect-free             and              queries. Conceptually, an

B. ATS State Elements and Actions                                     ATS FIFO has a bounded but unspeciﬁed size. The exact size

   In this paper, we concentrate on the synthesis of ATS with         is only set at implementation time, and hence a speciﬁcation
three types of state elements: , , and . The three types of
state elements are depicted in Fig. 2 with signals of their sup-      must be valid for all possible sizes. Applying an        to a full
ported interfaces. Below, we describe the three types of state
elements and their usage.                                             FIFO or applying           to an empty FIFO is illegal. (Applying

                                                                                 action to a full FIFO is legal however.) Any transi-

                                                                      tion that queries or acts on a FIFO must include the appropriate

                                                                                 or              queries in its predicate condition.


HOE AND ARVIND: OPERATION-CENTRIC HARDWARE DESCRIPTION AND SYNTHESIS                                                            1279

                                                                      branch in the pipeline is about to be taken or if the pipeline is

                                                                      about to encounter an exception).

                                                                          The execution of the different instruction types in the second

                                                                      pipeline stage can be similarly described as separate atomic

                                                                      transitions. First, consider                 for executing

                                                                      an                   instruction, where

= Fig. 3. Simple two-stage pipelined processor example with S
h;                ; i.
    ;          ;

Besides registers, arrays, and FIFOs, the complete ATS in-                is enabled only when the next pending instruction in

cludes register-like state elements for input and output. An input    is an instruction. When applied, its actions carry out the

state element is like a register but without the action. A            semantics of the instruction. Next, consider two separate

    query on an input element returns the value presented on a        transitions                                               and

corresponding external input port. An output state element                                               that specify the two possible

supports both     and , and its content is visible to the             executions of a               branch-if-zero instruction

outside of the ATS on a corresponding output port. For brevity,

we omitted the discussion of and in this paper; for the most

part, and are treated as during synthesis.

C. Pipelined Processor Example

In this example, we describe a two-stage pipelined processor,

where a pipeline buffer is inserted between the fetch and exe-

cute stages. In an ATS, we use a FIFO, instead of a register, as

the pipeline buffer. The buffering property of a FIFO provides

the isolation needed to permit the operations in the two stages to

be described independently. Although the resulting description

reﬂects an elastic pipeline, our synthesis can infer a legal imple-

mentation that operates synchronously and has stages separated                     tests for conditions when the next pending instruc-

by registers (explained further in Section VI-A).                     tion is a instruction and the branch condition is not met. The

The key state elements and datapath of the two-stage                  resulting action of                is to leave the pipeline state un-

pipelined processor example is shown in Fig. 3. The processor         modiﬁed other than to remove the executed instruction from

consists of state elements                                  .             . On the other hand, when            is satisﬁed, besides set-

The ﬁve state elements are: the program counter, the                  ting to the new branch target,               must also simulta-

register ﬁle (an array of integer values),  the instruction           neous clear the content of because the       transition given

memory (an array of instructions),          the data memory (an       earlier actually follows a simple branch speculation by always

array of integer values), and the pipeline buffer (a FIFO of          incrementing . Thus, if a branch is taken later, could hold

instructions). In an actual synthesis, the data width of the state    zero or more speculatively fetched wrong-path instructions.

elements would be inferred from the type declaration given in             In this two-stage pipeline description,  in the ﬁrst stage

the source-level description.                                         and a transition in the second stage could become applicable at

Next, we examine ATS transitions that describe the behavior           the same time. Even though conceptually only one transition is

of this two-stage pipelined processor. Instruction fetching in        to take place in each step, an implementation of this processor

the fetch stage can be described by the transition                    description must carry out both fetch and execute transitions in

                  . This transition should fetch an instruction from  the same clock cycle; otherwise, the implementation does not

the current program location in     and enqueuing the instruc-        behave like a pipeline. Nevertheless, the implementation must

tion into . This transition should be enabled whenever is             also ensure that a concurrent execution of multiple transitions

not full. In ATS notation                                             produces the same result as a sequentialized execution of the

                                                                      same transitions in some order. In particular, consider the con-

                                                                      current execution of          and            . Both transitions up-

                                                                      date and . In this case, the implementation has to guar-

                                                                      antee that these transitions are applied in some sequential order.

                                                                      However, it is interesting to note that the choice of ordering de-

                                                                      termines how many bubbles are inserted after a taken branch,

Notice the speciﬁcation of the      transition is unconcerned         but it does not affect the processor’s ability to correctly execute

with what happens elsewhere in the pipeline (e.g., if an earlier      a program.


1280                     IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

      III. SYNTHESIZING A REFERENCE IMPLEMENTATION

   This section introduces a basic synthesis procedure that maps     M Fig. 4. Monolithic arbitrator for an -transition ATS.
an operation-centric ATS into an state-centric RTL-level rep-
resentation. It is assumed that commercial RTL-synthesis tools
would complete the synthesis path to a ﬁnal physical implemen-
tation. The synthesis procedure described in this section pro-
duces a straightforward implementation that executes only one
transition per clock cycle. In this synthesis, the elements of
are instantiated from a design library to constitute the state ele-
ments in the implementation. The transitions in are combined
to form the next-state logic for the state elements in a three step
procedure. The resulting reference implementation is function-
ally correct but contain many inefﬁciencies, most particularly
its lack of concurrency due to the single-transition-per-cycle re-
striction. This inefﬁciency is addressed in Sections IV and V by
two increasingly sophisticated optimizations that enables con-
current execution of conﬂict-free and sequentially composable
transitions.

A. Extraction of and

In this ﬁrst step, all value expressions in the ATS are mapped

to combinational signals evaluated on the current values of the      Fig. 5. Circuits for combining two transitions’ actions on the same state
                                                                     element.
state elements. In particular, this step creates a set of signals,

      , that are the signals of transitions            in

an -transition ATS. The logic mapping in this step assumes all

required combinational resources are available. Standard RTL         next-state values via a multiplexer controlled by the signals.

optimizations can be applied later to simplify the combinational     Fig. 5 illustrates the merging circuit for a register that can be

logic and to share redundant logic.                                  acted on by two transitions.

                                                                     This merging scheme assumes at most one transition’s action

B. Arbitration Logic                                                 is applied to a particular state element in a clock cycle. Further-

In this step, we create an arbitrator to sequence the execution      more, all the actions of a selected transition must be selected in

of enabled transitions. The arbitrator circuit generates the set of  the same clock cycle at all affected state elements to ensure the

arbitrated enable signals            based on          .             appearance of an atomic transition. The two assumptions above

The block diagram of a generic arbitrator is shown in Fig. 4.        are trivially met in a single-transitions-per-cycle implementa-

Any valid arbitrator must, at least, ensure for any :                tion. The details of the merging circuit for all three ATS state

1)                    ;                                              element types are given next as RTL equations.

2)                                             .                     For each , the set of transitions that update is

For a single-transition-per-cycle reference implementation, the                                    where  is the action on
arbitrator is further constrained to assert at most one signal in
each clock cycle, reﬂecting the selection of one applicable tran-    by . ’s data and latch enable inputs are
sition. A priority encoder is a valid arbitrator for the reference
implementation.

                                                                     For each , the set of transitions that write is

C. Next-State Logic Composition                                              . ’s write address                               , data  , and

   Lastly, one conceptually begins by creating independent           enable  inputs are
versions of the next-state logic, each corresponding to one of the
                                                                     The set of transitions that enqueue a new value into is
    transitions in the ATS. Next, the versions of next-state
logic are merged, state-element by state-element, using the
signals for arbitration at each state element. For example, a par-
ticular register may have transitions that affect it over time.

           because some transitions may not affect the register.
The register takes on a new value if any of the relevant tran-
sitions is applicable in a clock cycle. Thus, the register’s latch
enable is the logical-OR of the signals from the relevant
transitions. The new value of the register is selected from the


HOE AND ARVIND: OPERATION-CENTRIC HARDWARE DESCRIPTION AND SYNTHESIS                                                         1281

The set of transitions that dequeue from is                         intermediate state    must still satisfy , or vice versa.

Similarly, the set of transitions that clear the contents of is     Otherwise, concurrent execution of and is not possible

   This conceptual construction based on merging separate           since there is not a legal sequential execution of and in
versions of next-state logic would result in a large amount of du-
plicated logic and resources. In reality, our compiler performs     two consecutive atomic steps.
extensive common-subexpression elimination and constant
propagation transformations to simplify the synthesized RTL         There are two approaches to carrying out the effects of
netlist. Furthermore, in the multiple-transition-per-cycle imple-
mentations discussed later, our compiler also analyze whether       and in the same clock cycle. The ﬁrst approach adds to the
two transitions are mutually-exclusive to enable time-multi-
plexed reuse of resources such as arithmetic units and interface    reference implementation in Section III the cascaded combi-
ports to the state elements. The two primary inefﬁciencies of
this reference implementation are that: 1) only one transitions     national logic of the two transitions, in essence introducing a
is permitted per cycle and 2) all transitions must be arbitrated
through a centralized arbitration circuit. These two inefﬁcien-     brand new transition that is the composition of and . How-
cies are addressed together by the optimizations in the next two
sections.                                                           ever, arbitrary cascading is not always desirable since it leads

                                                                    to an explosion in circuit size and a longer cycle time. In our

                                                                    approach, and are executed in the same clock cycle only

                                                                    if the correct ﬁnal state can be reconstructed from an indepen-

                                                                    dent and parallel evaluation of their combinational logic on the

                                                                    same starting state. In other words, the resulting multitransition

                                                                    implementation should only require minimal new hardware and

                                                                    have similar (or even shorter) cycle time as compared to the ref-

                                                                    erence implementation. This section ﬁrst develops an optimiza-

                                                                    tion based on the conﬂict-free relationship  . Section V

                                                                    next presents another optimization based on the sequential-com-

                                                                    posability          relationship that can expose additional hard-

                                                                    ware concurrency.

                                                                    A. Conﬂict-Free Transitions

D. Correctness of the Reference Implementation                                  is a symmetric relationship that imposes a stronger

   The reference implementation given above is not strictly         than necessary requirement for executing two transitions con-
equivalent to the ATS. In the reference implementation, unless
the arbitrator employs true randomization, the implementation       currently. However, the symmetry of          permits a more
is always deterministic. In other words, the implementation
can only embody one of the behaviors allowed by the ATS. An         straightforward implementation than . Given and are
implementation is said to implement an ATS correctly if: 1)
the implementation’s sequence of state transitions corresponds      both applicable in state ,           implies that applying
to some execution of the ATS and 2) the implementation
maintains liveness. Thus, the implementation could enter a          ﬁrst does not revoke the applicability of , and vice versa
livelock if the ATS depends on nondeterminism for forward
progress. The reference implementation can use a round-robin        (i.e.,                         .             further im-
priority encoder to ensure weak-fairness, that is, a transition is
guaranteed to be selected at least once if it remains applicable    plies that the two transitions can be applied in either order in
for a bounded number of consecutive cycles.
                                                                    two successive steps to produce the same ﬁnal state,
       IV. CONCURRENT EXECUTION OF CONFLICT-FREE
                              TRANSITIONS                                                        . In order to permit a straightfor-

                                                                    ward implementation,              further requires that an im-

                                                                    plementation could produce ’ by applying the parallel com-

                                                                    position of and to the same initial state . The par-

                                                                    allel composition function     takes two action lists and

                                                                            and returns a new action list that is their pair-wise union;

                                                                                is undeﬁned if and performs conﬂicting

                                                                    actions on any state element. The conﬂict-free relationship and

                                                                    the parallel composition function are deﬁned below formally.

                                                                    Deﬁnition 1—Conﬂict-Free Relationship: Two transitions

                                                                    and are said to be conﬂict-free                       if and

                                                                    only if

Although the semantics of ATS deﬁnes an execution in

sequential and atomic steps, a hardware implementation can

execute multiple transitions concurrently in one clock cycle.

However, in a multiple-transitions-per-cycle implementation,

the composite state transition taken in each clock cycle must where is the functional equivalent of                       .
correspond to some sequentialized execution of the constituent Deﬁnition 2—Parallel Composition:
ATS transitions. For example, a necessary condition for an im-

plementation in state to concurrently execute two applicable

transitions and is that  . In

other words, after applying the actions of to , the resulting


1282                     IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

where                                                                  and write-set of a transition, a sufﬁcient condition that ensures
                                                                                        is

                   case of                                             In other words, conservatively, two transitions are     if they

                                  undeﬁned                             do not have data (read-after-write) or output (write-after-write)
                   case of
                                                                       dependence between them.
                                  undeﬁned
                   case of                                             If two transitions and never become applicable in the

                                                                       same state (i.e.,                          , then they are said to

                                                                       be mutually exclusive,                 . Two transitions that are

                                                                             also satisfy the deﬁnition of         . An exact test for

                                                                             requires determining the satisﬁability of the expression

                                                                                            . Fortunately, the expression is usually a

                                                                       conjunction of relational constraints on the current values of the

                                                                       state elements. A conservative test that scans two expressions

                                                                       for contradicting constraints on any one state element works

                                                                       well in practice.

                                                                       C. Arbitration of Conﬂict-Free Transitions

                              undeﬁned                                 By applying Theorem 1, instead of selecting a single transi-

                                                                       tion per clock cycle, an arbitrator (like the one shown in Fig. 4)

Below, Theorem 1 extends the composition of two                        can select a number of applicable transitions that are all pair-

transitions to multiple pairwise   transitions. Theorem 1              wise       . In other words, in each clock cycle, the signals

states that it is safe to execute in the same cycle, by parallel       should satisfy the condition

composition, any number of applicable transitions that are all

pairwise           . Each pair from the transitions selected for con-

current execution must be          , because     is not a tran-        where is the arbitrated enable signal for transition . Given

sitive. The resulting composite state transition corresponds to        a set of applicable transitions in a clock cycle, many different

the sequential execution of the selected applicable transitions in     subsets of pairwise     transitions could exist. Selecting the

any order.                                                             optimum subset would require weighing the relative importance

Theorem 1—Composition of                    Transitions: Given a       of the transitions, which is impossible for the arbitrator synthesis

collection of transitions applicable in state , if all tran-           algorithm to discern without user feedback or annotation. An

sitions are pairwise        , then the following holds for any         objective selection metric is to simply maximize the number of

ordering              :                                                transitions executed in each clock cycle.

                                                                       Below, we describe the construction of an efﬁcient arbitrator

                                                                       that selects multiple pairwise         transitions per clock cycle.

                                                                       In a partitioned arbitrator, transitions in are ﬁrst partitioned

                                                                       into as many disjoint arbitration groups,            , as possible

                                                                       such that

where is the functional equivalent of the parallel composi-            This partitioning ensures that a transition is          with any

tions of                 , in any order. (A proof for Theorem 1        transition not in the same group and, hence, each arbitration

is given in [9].)                                                      group can be arbitrated independently of other groups. Below,

                                                                       we ﬁrst describe the formation of          groups and then the

B. Static Determination of                                             arbitration within individual groups.

The arbitrator-synthesis algorithm given later in this section               Step 1)        -Group Partitioning: can be par-

is compatible with a conservative test for       , that is, if the           titioned into     -arbitration groups by ﬁnding the

test fails to identify a pair of transitions as  , the algorithm             connected components of an undirected conﬂict graph

generates a less optimal but still correct implementation. A con-            whose nodes are transitions               and whose edges

servative static determination of           can be made by com-              are                              . Each connected compo-

paring the read-set and write-set of the transitions. The read-set           nent in the conﬂict graph is a        -arbitration group.

of a transition is the set of state elements in read by the ex-              For a given conﬂict graph, the partitioning into  -ar-

pressions in either or . The write-set of a transition is the set            bitration groups is unique. For example, the undirected

of state elements in that are acted on by . For this analysis,               graph (a) in Fig. 6 depicts the           relationships in

the head and the tail of a FIFO are considered to be separate el-            an ATS with six transitions. Graph (b) in Fig. 6 gives

ements. Using            and       that extracts the read-set                the corresponding conﬂict graph. The conﬂict graph has


HOE AND ARVIND: OPERATION-CENTRIC HARDWARE DESCRIPTION AND SYNTHESIS                                                      1283

                                                                          Fig. 7. Enumerated arbitration lookup table for Arbitration Group 1 in Fig. 6.

Fig. 6. Analysis of conﬂict-free transitions: (a) Conﬂict-free graph and                       is not unique. In general, the generation
(b) Corresponding conﬂict graph and its connected components.

                                                                          of   -group arbitrator can beneﬁt from user input in se-

                                                                          lecting the most “productive” subset (which may not be the max-

     three connected components, corresponding to the three               imal subset).

             -arbitration groups.

     Step 2)            -Group Arbitrator: For a given                    E. Performance Gain

             -arbitration group containing                      ,             When can be partitioned into arbitration groups, the in-

                        can be generated locally within the               dividual partitioned arbitrators are smaller and faster than the

     group from                                using a priority           single monolithic encoder in the reference implementation from

     encoder. However, additional concurrency within a                    Section III. The partitioned arbitrators also reduce wiring cost

             -arbitration group is possible.                              and delay since and signals of unrelated transitions are not

                                                                          brought together for arbitration.

D. Enumerated Group Arbitrator                                                The property of the parallel composition function ensures that

For example, Arbitration Group 1 in Fig. 6 contains three                 transitions are      only if their actions do not conﬂict at

transitions             , such that              , but neither            any state element. Hence, the state update logic from the ref-

nor is        with . Although the three transitions cannot                erence implementation can be used unchanged in  -arbi-

be arbitrated independently of each other, and can be se-                 trated implementations. Consequently, combinational delay of

lected together as long as is not selected in the same clock              the next-state logic is not increased by the  optimization.

cycle. In general, for a given state , each group arbitrator can in-      All in all, a        -arbitrated implementation should achieve

dependently select multiple pairwise-            transitions within       better performance than its corresponding reference implemen-

its arbitration group.                                                    tation by allowing more transitions to execute in a clock cycle

For a         -arbitration group with transitions                         without increasing the cycle time.

and              can be computed locally by a combinational

function that is equivalent to a       lookup table indexed by                 V. CONCURRENT EXECUTION OF SEQUENTIALLY
                                                                                            COMPOSABLE TRANSITIONS
                        . The binary data value    at the

table entry with binary index          can be determined by                   As noted in Section IV-A, the             relationship is a suf-

ﬁnding a maximal clique in an undirected graph whose nodes                ﬁcient but not necessary condition for concurrent execution

and edges are deﬁned as follows:                                          of multiple transitions in the same clock cycle. This section

                        is asserted                                       presents a more exact requirement to extract additional concur-

                                                                          rency from within a  -arbitration group.

This is the conﬂict-free graph of the subset that corresponds             A. Sequentially Composable Transitions
                                                                             Consider the following ATS example:

to the asserted positions in the binary index      . For each

     that is in the selected clique, assert . For example, Arbitra-

tion Group 1 from Fig. 6 can be arbitrated using the enumerated

lookup table in Fig. 7. The lookup table selects and when

they are applicable together. This lookup table also reﬂects an

arbitrary decision that should be selected instead of if

and are both applicable in the same cycle. A similar decision             In this ATS, all transitions are always applicable. Furthermore,

is imposed between and . This freedom in           -group                                  and its functional equivalent are well-de-

arbitrator generation highlights the fact that, whereas the par-          ﬁned for any choice of two transitions and . Nevertheless,

titioning of independent             arbitration groups is unique,        the  arbitrator proposed in the previous section would not

the maximal asserted subset of ’s for a given combination of              permit and to execute in the same clock cycle because


1284                       IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

                             in general. A more careful re-ex-                              case of

amination should reveal that, for all ,         is always con-

sistent with at least one ordering of sequentially executing

and . Hence, the concurrent execution of any two transitions

above can be supported efﬁciently in an implementation. On the

other hand, the concurrent execution of all three transitions in a

parallel composition is not possible due to circular data depen-

dencies among the three transitions. These considerations are

captured by the sequential composability relationship             .                                       undeﬁned

         is a relaxation of     . In particular, is not sym-

metric. The intuition behind is that concurrent execution                Based on the above deﬁnitions, a sufﬁcient condition for
                                                                                     is
of a set of transitions does not need to produce the same result

as all possible sequential execution of those transitions, just one

such sequence. Hence, given and that are applicable in                                                               is deﬁned

state ,           only requires the concurrent execution of              where        and             extract the read-set and write-set of

and on to correspond to                     , but not necessarily to     a transition as explained in Section IV-B. Notice, unlike in the

             . Similarly,          only implies                          conservative condition for       , permits

and does not require                                  .                              to be nonempty as long as       is deﬁned.

Concurrent execution of sequentially composable transitions              Like in the discussion of        , the relationship for two

requires an asymmetric composition function to combine                   transitions can be extended to enable multiple transitions to be

the action lists from two transitions. Like     ,            returns     composed. More speciﬁcally, Theorem 2 below extends sequen-

a new action list by composing actions on the same element               tial composition to multiple transitions that are all pair-wise

from two action lists. The state-speciﬁc composition functions           and whose transitive closure on is ordered. The or-

      ,      and           are the same as   ,               and         dering requirement is necessary to ensure the selected transi-

except in two cases where          allows conﬂicting actions to          tions are not circularly dependent as described in the opening

be sequentialized. First,                                is              paragraphs of this section.

since the effect of the ﬁrst action is overwritten by the second in      Theorem 2—Composition of Transitions: Given a se-

a sequential application. Second,               returns                  quence of transitions,                 , that are all applicable in

since regardless of , applying     leaves the FIFO emptied.              state , if              for all  , then

Below, the sequential composability relationship and the se-

quential composition function are deﬁned formally.

Deﬁnition 3—Sequential Composability: Two transitions

and are said to be sequentially composable                           if

and only if

where is the functional equivalent of                        .
   Deﬁnition 4—Sequential Composition:                                  where is the functional equivalent of the nested sequential

where                                                                    composition                                 . (A proof

                                    case of                              for Theorem 2 is given in [9].)

                               case of                                   B. Arbitration of Transitions

                                                                         By applying Theorem 2, the arbitrator of a  -arbitration

                                                                         group (from Step 2, Section IV-C) can select in each state the

                                                                         set of applicable transitions such that there exists an ordering of

                                                                         those transitions            , where        if                  .

                                                                         Similar to the formation of the            -arbitration group in

                                                                         Section IV-C, the construction of a partitioned arbitrator

                                                                         involves ﬁnding    arbitration subgroups as the connected

                                                                         components in the further relaxed (with fewer edges) conﬂict

                                                                         graph of a         -arbitration group. In the conﬂict graph for

                                                                         analysis, the nodes are                    , and the edges are

                                            undeﬁned


HOE AND ARVIND: OPERATION-CENTRIC HARDWARE DESCRIPTION AND SYNTHESIS                                                               1285

                                                                            Notice, if the cycle in the original SC graph (a) had not been
                                                                            broken, would be a third separate component in the conﬂict
                                                                            graph; this could lead to a incorrect condition where , ,
                                                                            and are enabled together.

                                                                            C. Complications to the State-Update Logic

                                                                            When transitions are allowed in the same clock cycle,

                                                                            the register-update logic cannot assume that at most one transi-

                                                                            tion acts on a register in each clock cycle. When multiple actions

                                                                            are enabled for a register, the register update logic should ignore

&lt; Fig. 8. Analysis of sequentially composable transitions. (a) Directed     all except for the latest action with respect to the SC-ordering

&lt; graph. (b) Corresponding acyclic directed  graph. (c) corresponding       of a         -arbitration group. (It can be shown that all transi-

conﬂict graph and its connected components.                                 tions that could update the same register in the same cycle are

                                                                            in the same  -arbitration group.) For each in , the set

                                                                            of transitions that update is                          . The

                                                                            register’s latch enable signal remains

where is

Two nodes are connected if their corresponding transitions are              However, a new data-input signal must be used with an
                                                                            arbitrator to observe SC-ordering. The new signal is

related by neither  nor . As an added complication,

considered in this analysis must be acyclic to satisfy the

SC-ordering requirement in Theorem 2 (to avoid the concur-

rent execution of circularly dependent transitions). Therefore,

the conﬂict graph must be based on a version of that has                    where                          . The expression con-

been made acyclic by removing cycle-inducing edges. Given an                tains ’s from the set of transitions

acyclic , the ordering assumed in Theorem 2 agrees with

any topological sort of the corresponding acyclic graph.                                                     comes before
                                                                                                           ordering
(We refer to this ordering as the SC-ordering below.)                                    in the

Fig. 8 provides an example of analysis. The directed

graph (a) in Fig. 8 depicts the original sequential compos-

ability relationships in an  -arbitration group with ﬁve                    In essence, the register’s data input is selected through a
                                                                            prioritized multiplexer that gives higher priority to transitions
transitions. A directed edge from to implies                             .  later in the -ordering. Under the current deﬁnition of ,
                                                                            the update logic for arrays and FIFOs can remain unchanged
Edges between , , and form a cycle., Graph (b) in                           from Section III.

Fig. 8 shows the acyclic graph when the edge from                                             VI. EVALUATION AND RESULTS

to is removed. Graph (b) yields the SC-ordering of , ,                         The synthesis procedures outlined in the previous sections
                                                                            have been implemented in the term architectural complier
, , and . (The order of and can be reversed also.)                          (TRAC). TRAC accepts TRSPEC descriptions and outputs
                                                                            synthesizable RTL descriptions in the Verilog hardware de-
For a given cyclic graph, multiple acyclic derivations are                  scription language. This section discusses the results from
                                                                            applying TRSPEC and TRAC to the design and synthesis of a
possible depending which edge is removed from a cycle. Other                ﬁve-stage pipelined implementation of the MIPS R2000 ISA
                                                                            [10].
possibilities in this example would be to remove the edge from
                                                                            A. Synchronous Pipeline Synthesis
to or from to .
                                                                               As in the processor from Section II-C, the MIPS processor
Graph (c) in Fig. 8 gives the corresponding conﬂict graph.                  is described as a pipeline whose ﬁve stages are separated by
                                                                            FIFOs. The exact depth of the FIFOs is not speciﬁed in the
The connected components in the conﬂict graph form the                      description and, hence, TRAC is allowed to instantiate one-
                                                                            deep FIFOs (basically registers) as pipeline buffers. Flow-con-
-arbitration subgroups. Transitions in different -arbi-                     trol logic is added to ensure the single-register FIFOs are not
                                                                            overﬂowed or underﬂowed by enqueue and dequeue actions. In
tration subgroups are either conﬂict-free or sequentially-com-

posable, and each subgroup can be arbitrated independently.

’s for the transitions in a -arbitration subgroup can be

generated locally within the subgroup using a priority encoder.

For example, conﬂict graph (c) in Fig. 8 has two connected

components, corresponding to two -arbitration subgroups.

In the unary Arbitration Subgroup 2,         without any ar-

bitration. The signals for transitions in Arbitration Subgroup

1 can be generated using a priority encoding of their corre-

sponding ’s. More transitions in Arbitration Subgroup 1 can

be selected concurrently using an enumerated combinational

lookup table logic similar to the one described in Section IV-D.


1286          IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

                                                                                                                      TABLE I
                                                                                                 SUMMARY OF MIPS CORE SYNTHESIS RESULTS

Fig. 9. Synchronous pipeline with combinational multistage feedback ﬂow  compiled by the {Synopsys Design Compiler} to target both
control.                                                                 Synopsys CBA and LSI Logic 10K Series technology libraries.
                                                                         Table I summarizes the prelayout area and speed estimates
a naive construction, the single-register FIFO is full if its register   reported by Synopsys. The row labeled “TRSPEC” charac-
                                                                         terizes the implementation synthesized from the TRSPEC
holds valid data; the FIFO is empty if its register holds a bubble.      description. The row labeled “Hand-coded RTL” characterizes
                                                                         the implementation synthesized from a hand-coded Verilog
With only local ﬂow control between neighboring stages, the              description of the same ﬁve-stage pipelined microarchitecture.
                                                                         The results indicate that the TRSPEC description produces
overall pipeline would contain a bubble in every other stage in          an implementation that is competitive in size and speed to
                                                                         the implementation resulting from the hand-coded Verilog
the steady state. For example, if pipeline buffer and                    description. This similarity should not be surprising because,
                                                                         after all, both descriptions are describing the same microarchi-
are occupied and buffer  is empty, the operation in stage                tecture, albeit following very different design abstractions and
                                                                         methodologies. The same conclusion has also been reached on
        would be enabled to advance at the clock edge, but the           comparisons of other designs and when we targeted the designs
                                                                         for implementation on FPGAs.
operation in stage is held back because buffer   appears
                                                                            The TRSPEC and the hand-coded Verilog descriptions are
full during the same clock cycle. The operation in stage is not          similar in length (790 versus 930 lines of source code), but the
                                                                         TRSPEC description was developed in less than one day (eight
enabled until the next clock cycle when buffer   is empty.               hours), whereas the hand-coded Verilog description required
                                                                         nearly ﬁve days to complete. The TRSPEC description can be
In TRAC-synthesized implementations, to allow simulta-                   translated in a literal fashion from an ISA manual. Whereas, the
                                                                         hand-coded Verilog description faces a greater representation
neous enqueue and dequeue actions, a single-register FIFO is             gap between the ISA speciﬁcation and RTL. The RTL designer
                                                                         also needs to manually inject implementation-level information
considered empty both when it is actually empty or when it is            that is not part of the ISA-level speciﬁcation. In a TRSPEC de-
                                                                         sign ﬂow, the designer can rely on TRAC to correctly complete
enabled for dequeuing at the next clock edge. Simultaneous               the design with suitable implementation decisions.

enqueue and dequeue actions are permitted as a sequential                C. Current Synthesis Limitations

composition where the dequeue action is considered to have                  The synchronous hardware synthesis procedure presented in
                                                                         this paper has two important limitations. First, the procedure al-
taken place before the enqueue action. In hardware terms, this           ways maps the entire effect of an operation into a single clock
                                                                         cycle. Second, the procedure always maximizes hardware con-
creates a combinational multistage feedback path for FIFO                currency. In many hardware applications, there are restrictions
                                                                         on the amount and the type of resources available. Under those
ﬂow control that propagates from the last stallable pipeline             assumptions, it may not be optimal or even realistic to execute
                                                                         an operation in one clock cycle. In future work, we are devel-
stage to the ﬁrst pipeline stage. The cascaded feedback scheme           oping another synthesis approach, where the effect of an op-
                                                                         eration can be executed over multiple clock cycles, while also
shown in Fig. 9 allows stage to advance both when pipeline               being overlapped with the execution of other multiple-cycle op-
                                                                         erations. The key issue in this future work also hinges on how
buffer        is actually empty and when buffer        is                to ensure the resulting implementation correctly maintains the
                                                                         atomic and sequential execution semantics of the operation-cen-
going to be dequeued at the coming clock edge. This scheme               tric hardware abstraction.

allows the entire pipeline to advance synchronously on each                                      VII. RELATED WORK

clock edge. A stall in an intermediate pipeline stage causes all            In comparison to operation-centric abstractions, traditional
                                                                         state-centric abstractions more closely reﬂect the true nature
up-stream stages to stall at once. A caveat to this scheme is that

the multistage feedback path could become the critical path,

especially in a deeply pipelined design. In this case, one may

want to break the feedback path at select stages by inserting

two-deep FIFOs with local ﬂow control. A cyclic feedback path

can also be broken by inserting a two-deep FIFO with local

ﬂow control.

B. Synthesis Results

   The synthesis results are presented for a TRSPEC de-
scription that implements the MIPS R2000 integer ISA with
the exception of multiple/divide, partial-word or nonaligned
load/stores, coprocessor interfaces, privileged instructions and
exception modes. Memory load instructions and branch/jump
instructions also deviate from the ISA by not obeying the
required delayed-execution semantics. (The complete TRSPEC
description of the ﬁve-stage pipelined processor model is given
in [9].)

   The processor description is compiled by TRAC into a
synthesizable Verilog RTL description, which is subsequently


HOE AND ARVIND: OPERATION-CENTRIC HARDWARE DESCRIPTION AND SYNTHESIS  1287

(e.g., explicit concurrency and synchronization) of the under-        than both the conﬂict-free and the sequential composability re-
lying hardware implementation. Hence, they are relatively sim-        quirements given in Theorems 1 and 2. In particular, the se-
pler to synthesize into hardware implementations, and they af-        quential composability optimization enables signiﬁcantly more
ford designers greater control over the details of the synthe-        parallelism to be exploited in an implementation than CREW.
sized outcome. On the other hand, the additional details exposed      However, in the case when only the conﬂict-free optimization is
by state-centric abstractions also place a greater design burden      enabled in the TRAC compiler, TRAC’s conservative static test
on the designers. In a synchronous state-centric framework, a         for conﬂict-free relationships (discussed in Section IV-B) yields
designer must explicitly manage the exact cycle-by-cycle in-          essentially the same scheduled behavior as CREW. Neverthe-
teractions between multiple concurrent state machines. Design         less, our approach further differs from Staunstrup and Green-
mistakes are common in coordinating interactions between two          street in how the statically determined conﬂict resolutions are
state machines because one cannot directly couple related tran-       realized in hardware. Resolving conﬂicting transitions by stati-
sitions in different state machines. It is also difﬁcult to design    cally transforming the predicate conditions is less efﬁcient than
or modify one state machine in a system without considering           the partitioned arbitrator approach in this paper because aug-
its, often implicit, interactions with the rest of the system. The    menting predicate conditions can lead to a lengthy ﬁnal pred-
atomic and sequential execution semantics of the operation-cen-       icate expression if a transition conﬂicts with many transitions.
tric abstraction removes these low-level design issues from the       The complexity of the predicate expressions can directly impact
designer; instead the abstraction allows these low-level deci-        an implementation’s size and critical path delay.
sions to be ofﬂoaded to an optimizing compiler.
                                                                         There is also some tangential relationship between the ATS
   The operation-centric ATS formalism in this paper is similar       formalism and synchronous languages [2], [3], exempliﬁed by
in semantics to guarded commands [7], synchronized transitions        Esterel [4], Lustre [8], and Signal [11]. In both models, state
with asynchronous combinators [13] and the UNITY language             is updated atomically at a discrete times step but the abstract
[5]. ATS extends these earlier models with support for hardware       concept of time is different in the two formalisms. Synchronous
state primitives, such as arrays and FIFOs. In particular, the use    languages are based on a calculus of time and require explicit
of FIFOs simpliﬁes the description of pipelined designs (as ex-       expression of concurrency with deterministic behavior. On the
plained in Section VI-A). ATS serves as an intermediate rep-          other hand, an operation-centric abstraction employs a sequen-
resentation for the compilation of source-level descriptions in       tial execution semantics with nondeterminism. Operation-cen-
the TRSPEC language [9]. TRSPEC is an adaptation of TRS               tric hardware synthesis must automatically discover and exploit
[1] for describing a ﬁnite-state transition system. In addition to    the implicit parallelism that exist in a sequentially conceived
TRSPEC, other language syntax can also be layered on top of           and interpreted description. Hence, as presented in Sections IV
the basic ATS abstraction. For example, the Bluespec language         and V, the key to synthesizing an efﬁcient implementation from
is an operation-centric hardware description language that has a      an operation-centric description lies precisely in how to take ad-
Haskell-like syntax [15]. In addition to a functional language        vantage of the nondeterminism to select an appropriate subset of
syntax, Bluespec also leverages sophisticated functional lan-         enabled transitions for concurrent execution in each cycle. Fur-
guage features in the declaration of state, operations and module     thermore, synchronous languages have been used primarily for
interfaces.                                                           describing the control part of a design and thus, it is difﬁcult to
                                                                      compare the two models using a processor-like example which
   Staunstrup and Greenstreet describe in [17] the synthesis of       employs rich datapaths.
both synchronous and asynchronous (delay insensitive) circuits
from a synchronized-transitions program. In their synchronous                                   VIII. CONCLUSION
synthesis, the entire effect of a transition is mapped into a single
clock cycle, and all enabled transitions are allowed to execute          Ultimately, the goal of a high-level description is to provide a
in the same clock cycle. To guarantee the atomic semantics of         design representation that is easy for a designer to comprehend
synchronized transitions is not violated, they enforce the CREW       and reason about. Although a concise notation is helpful, the
(concurrent-read-exclusive-write) requirement on a synthesiz-         utility of a high-level description framework has to come from
able set of synchronized transitions. Under the CREW require-         the elimination of some lower-level details. It is in this sense
ment, a pair of transitions must be mutually exclusive in their       that an operation-centric design framework can offer an advan-
predicate condition if they have data (read-after-write) or output    tage over traditional RTL design frameworks. In RTL languages,
(write-after-write) dependence between them. If initially two         hardware concurrency must be expressed and managed explic-
transitions violate CREW, one of their predicate conditions must      itly. Whereas in an operation-centric language, parallelism and
be augmented by the negation of the other so the two transitions      concurrency are implicit at the source-level, where they are later
become mutually exclusive. In this way, the ﬁnal synthesized          discovered and managed by an optimizing compiler.
system exhibits a deterministic behavior that is acceptable ac-
cording to the original nondeterministic system. Dhaussy et al.          This paper develops the theories and algorithms necessary
describe a similar approach in their synthesis of UCA, a lan-         to synthesize an efﬁcient synchronous hardware implementa-
guage derived from UNITY, where a program with conﬂicts is            tion from an operation-centric description. To facilitate analysis
transformed into a program without conﬂicts prior to synthesis        and synthesis, this paper deﬁnes the ATS formalism, which is
[6].                                                                  an operation-centric intermediate representation when mapping
                                                                      TRSPEC and other operation-centric source-level languages to
   The Staunstrup and Greenstreet’s CREW relationship is sim-
ilar to our conﬂict-free relationship, but it is more restrictive


1288  IEEE TRANSACTIONS ON COMPUTER-AIDED DESIGN OF INTEGRATED CIRCUITS AND SYSTEMS, VOL. 23, NO. 9, SEPTEMBER 2004

hardware implementations. This paper explains how to imple-                       [12] T. W. S. Lee, C. J. Seger, and M. R. Greenstreet, “Automatic veriﬁca-
ment an ATS as a synchronous ﬁnite-state machine. The crux
of the synthesis problem lies in ﬁnding a valid composition of                          tion of asynchronous circuits,” IEEE Design Test Comput., vol. 12, pp.
the ATS transitions in a coherent ﬁnite-state machine that car-
ries out as many ATS transitions concurrently as possible. This                         24–31, Spring 1995.
paper ﬁrst presents a straightforward reference implementation
and then offers two optimizations based on the parallelization of                 [13] A. P. Ravn and J. Staunstrup, “Synchronized Transitions,” Dept.
conﬂict-free and sequentially-composable transitions. The syn-
thesis results from a pipelined processor design example show                           Comput. Sci., Univ. Aarhus, Aarhus, Denmark, Tech. Rep. AAR-219,
that an operation-centric framework allows a signiﬁcant reduc-
tion in design time and effort while achieving comparable im-                           1987.
plementation quality as traditional register-transfer level design
ﬂows.                                                                             [14] V. M. Rodrigues and F. R. Wagner, “Synchronous transitions and their

                              REFERENCES                                                temporal logic,” in Proc. Workshop Métodos Formais, 1998, pp. 84–89.

   [1] F. Baader and T. Nipkow, Term Rewriting and All That. Cambridge,           [15] A brief description of Bluespec, Sandburst Corporation. Available:
         U.K.: Cambridge Univ. Press, 1998.
                                                                                        http://www.bluespec.org/description.html [Online]
   [2] A. Benveniste and G. Berry, “The synchronous approach to reactive and
         real-time systems,” Proc. IEEE, vol. 79, pp. 1270–1282, Sept. 1991.      [16] J. Staunstrup and M. R. Greenstreet, “From high-level descriptions to

   [3] A. Benveniste, P. Caspi, S. Edwards, N. Halbwachs, P. Le Guernic, and            VLSI circuits,” BIT, vol. 28, no. 3, pp. 620–638, 1988.
         R. de Simone, “The synchronous languages twelve years later,” Proc.
         IEEE, vol. 91, pp. 64–83, Jan. 2003.                                     [17]  , “Synchronized Transitions,” in Formal Methods for VLSI De-

   [4] G. Berry, “The Foundations of Estevel,” in Proof, Language and Interac-          sign. Amsterdam, The Netherlands: Elsevier, 1990, pp. 71–128.
         tion: Essays in Honor of Robin Milner. Cambridge, MA: MIT Press,
         2000, pp. 425–454.                                                                                      James C. Hoe (S’91–M’00) received the B.S. degree
                                                                                                                 in electrical engineering and computer science from
   [5] K. M. Chandy and J. Misra, Parallel Program Design. Reading, MA:                                          the University of California, Berkeley, in 1992 and
         Addison-Wesley, 1988.                                                                                   the M.S. and Ph.D. degrees in electrical engineering
                                                                                                                 and computer science from the Massachusetts Insti-
   [6] P. Dhaussy, J.-M. Filloque, and B. Pottier, “Global control synthesis for                                 tute of Technology, Cambridge, in 1994 and 2000,
         an MIMD/FPGA machine,” in Proc. IEEE Workshop FPGAs Custom                                              respectively.
         Comput. Mach., 1994, pp. 72–81.
                                                                                                                    Since 2000, he has been an Assistant Professor
   [7] E. W. Dijkstra, “Guarded commands, nondeterminacy, and formal                                             of Electrical and Computer Engineering at Carnegie
         derivation of programs,” Commun. ACM, vol. 18, no. 8, pp. 453–487,                                      Mellon University, Pittsburgh, PA. His research
         1975.                                                                                                   interest includes many aspects of computer architec-
                                                                                  ture and digital hardware design. His present focus is on developing high-level
   [8] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud, “The synchronous        hardware description and synthesis technologies to simplify hardware develop-
         data ﬂow programming language LUSTRE,” in Proc. IEEE, vol. 79,           ment. He is also working on innovative processor microarchitectures to address
         Sept. 1991, pp. 1305–1320.                                               issues in security and reliability.

   [9] J. C. Hoe, “Operation-Centric Hardware Description and Synthesis,”                                        Arvind (SM’85–F’95) received the B.Tech. degree
         Ph.D. thesis, Dept. Elect. Eng. Comput. Sci., Massachusetts Inst.                                       in electrical engineering from the Indian Institute of
         Technol., Cambridge, June 2000.                                                                         Technology, Kanpur, in 1969 and the M.S. and Ph.D.
                                                                                                                 degrees from the University of Minnesota, Twin
  [10] G. Kane, MIPS R2000 RISC Architecture. Englewood Cliffs, NJ: Pren-                                        Cities, in 1972 and 1973, respectively.
         tice-Hall, 1987.
                                                                                                                    He is the Johnson Professor of Computer Science
  [11] P. Le Guernic, T. Gautier, M. Le Borgne, and C. Le Maire, “Program-                                       and Engineering at the Massachusetts Institute
         ming real-time applications with SIGNAL,” Proc. IEEE, vol. 79, pp.                                      of Technology, Cambridge, where he has taught
         1321–1336, Sept. 1991.                                                                                  since 1979. He has contributed to the development
                                                                                                                 of dynamic dataﬂow architectures, and together
                                                                                                                 with Dr. R. S. Nikhil published the book Implicit
                                                                                  Parallel Programming in pH (San Francisco, CA: Morgan Kaufmann, 2001).
                                                                                  His current research interest is in high-level speciﬁcation, modeling, and the
                                                                                  synthesis and veriﬁcation of architectures and protocols.
</Text>
        </Document>
        <Document ID="59FC322B-94B2-4671-9E7D-E150DAC7A489">
            <Title>State moving around a chip</Title>
        </Document>
        <Document ID="5AED4086-674A-4BE4-AE84-1B83A0C8AC67">
            <Title>Strange New Worlds</Title>
            <Text>## So what would a “pure” temporal programming language look like?

The _entire_ program state is X
State changes atomically
Type can change atomically
Code can run backwards if F is invertible
Order of expressions is mostly irrelevant. Temporal programs can be “flattened” into a list of “field’ = f(state)” expressions
In a temporal programming language, the physical structure of the code (call trees, etc) is less relevant. Statements in a block are order-invariant. Branches select blocks for evaluation but there is no “program counter” in the usual sense

A ring oscillator can’t be modeled directly in temporal programming as it has no clock and is not a pure function
What could a temporal programming language do that {lang} can’t?






Explicitly referring to past and future state

“The value of X three cycles before Y exceeded 12”

We should be able to write arbitrary statements about past and future events and the compiler should be able to figure it out.


“Is it possible to get to a state with property X from the current state?”
Does property X hold in all possible states?
Tla+ type proof stuff

Speculative execution and runahead
    Some game console emulators improve responsiveness and input latency by implementing “runahead” - given an “old” emulation state, they compute every possible “next” state that could be reached by the user pressing some combination of input buttons. Once the user input is known the emulator can immediately switch to the selected pre-computed state, display the corresponding game image, and then begin computing the next set of possible states.
    This is not right https://docs.libretro.com/guides/runahead/



## Open Questions
 - What do statements like “x@-2 = y@+3” even mean?
 - A sufficiently smart compiler doesn’t need to keep as many intermediate copies
 - Large programs are expression graphs that can be incrementally evaluated in parallel by a “swarm” of worker bees
 - What would a processor designed specifically for temporal programs look like? Something in between a CPU and a FPGA?
 - “Programming Paradigms for Dummies: What Every Programmer Should Know”
 - “discrete synchronous programming”
 - In this paradigm, a program waits for input events, does internal calculations, and emits output events
 - “Waits” is meaningless in TPL
 - Doesn’t discuss internal state change
 - “output events from one subcomponent are instantaneously available as input events in other subcomponents”
     - Well, not exactly. 


</Text>
        </Document>
        <Document ID="5BBBE143-4B44-4CA0-BD38-041D0FC11301">
            <Title>FAQ</Title>
        </Document>
        <Document ID="5D1D0671-72F6-4041-9100-BA0DE15B8CB1">
            <Title>Automata-based programming?</Title>
            <Text>Isn't this just &quot;Automata-Based Programming&quot;?
	Yes, basically, though &quot;Automata-Based Programming&quot; seems to be even deader a term than &quot;Synchronous Programming&quot;.

There’s a lot of research into finite-state automata, particularly in converting regular expressions to FSMs.</Text>
        </Document>
        <Document ID="5F2027F6-9BDD-4339-81C0-CF6B22E65038">
            <Title>Concurrency</Title>
            <Text>## Temporal Programming and Concurrency
“Concurrency” is irrelevant at the language level. 
“Concurrent programming would be much simpler if the nondeterminism were controlled in some way, so that it is not visible to the programmer.” - Van Roy
“For example, if each of two threads assigns a variable cell to a different value, then each of the two values can be observed:”
   This cannot be expressed in a temporal programming language - by definition a variable can have only one future
“concurrency naturally implies nondeterminism.”
   No it doesn’t, not in this context
</Text>
        </Document>
        <Document ID="60367942-E136-45DD-9723-61E8C23BBB80">
            <Title>Sphery Vs Shapes</Title>
        </Document>
        <Document ID="606E2F6A-318D-44EA-A9BC-81093A72CD2F">
            <Title>Introduction</Title>
            <Synopsis>This is the synopsis for the introduction. Can you only edit this in corkboard mode?</Synopsis>
            <Text>



</Text>
        </Document>
        <Document ID="612916C2-0708-407C-8DE3-B3B3B492F281">
            <Title>What would a &quot;temporal CPU&quot; look like?</Title>
        </Document>
        <Document ID="67D0FFB2-16A5-463A-812A-B05271CB45E0">
            <Title>Verilog / VHDL?</Title>
            <Text>Most of the hardware description languages (HDLs) used to design logic for FPGAs and chips also contain aspects of temporal programming - in particular the non-blocking assignment operator in Verilog “x &lt;= y” is equivalent to “x@ = y”.
</Text>
        </Document>
        <Document ID="697C34B9-33DF-4F8A-A81C-1C61F10B71A9">
            <Title>Notes on research papers to be organized</Title>
        </Document>
        <Document ID="6996BE07-7D43-4998-AA16-E3A8C14A8563">
            <Title>A Trivial Example</Title>
            <Text>https://replit.com/@AustinAppleby/SwiftMelodicAbstractions#main.cpp

Examples of &quot;x' = f(x)&quot;-style programs abound - synchronous logic circuits, state machines, transactions - and actually writing a program that &quot;moves through time in discrete steps&quot; is not particularly difficult. Here's a trivial example in C++: 

struct Program {
   int count = 0;
};

Program tick(Program old_p) {
   Program new_p;
   new_p.count = old_p.count + 1;
   return new_p;
}

void main() {
   Program p;
   for (int i = 0; i &lt; 10; i++) {
      p = tick(p);
      printf(&quot;Output %d
&quot;, p.count);
   }
}

At first glance, &quot;constantly overwrite your entire state&quot; seems like a terribly inefficient way to write a program, but it's interesting - this example could be expressed equivalently in Javascript, Python, or just about any other mainstream language. In fact, the &quot;x' = f(x)&quot; model places no real requirements on the host language other than &quot;evaluate functions&quot; and &quot;change state atomically&quot;. We can write the same thing in Verilog, which does _not_ in general follow the execution semantics of C++ despite the similarities in syntax:

module Program(input logic clock);
  int count;
  initial count = 0;

  always_ff(@posedge clock) begin : tick
    count &lt;= count + 1;
  end
endmodule

This example modifies state in place instead of overwriting the whole Program object, but in Verilog doing so is guaranteed to be atomic - the '&lt;=' operator is defined such that the right hand sides of all '&lt;=' expressions are assigned to the left hand sides simultaneously and atomically at the end of the current simulation step. 

</Text>
        </Document>
        <Document ID="70FC08F3-AFEA-441C-9AE1-A4DCF20062BC">
            <Title>Imperative vs Temporal: A Working Example</Title>
            <Synopsis>as;kdjfha;ksjdhfa;ksdj
</Synopsis>
            <Text>















// First you send the start bit, then you send the data bits, then you send the stop bit.

const int bits_per_second = 9600;
const int cycles_per_second = 10000000;
const int cycles_per_bit = cycles_per_second / bits_per_second;

void sleep_cycles(int c);
void set_uart_pin(bool b);

struct ImperativeUart {
  void send_byte(uint8_t send_data) {
    set_uart_pin(0);
    sleep_cycles(cycles_per_bit);
    for (int i = 0; i &lt; 8; i++) {
      set_uart_pin((send_data &gt;&gt; i) &amp; 1);
      sleep_cycles(cycles_per_bit);
    }
    set_uart_pin(1);
    sleep_cycles(cycles_per_bit);
  }
};

void main() {
  const char* message = &quot;Hello World&quot;;
  const char* cursor = message;
  ImperativeUart uart;
  while(*cursor) {
    uart.send_byte(*cursor**);
  }
}

// If data is 0b10011101, &quot;buffer&quot; changes like so:
//
// 0b10011101 0 &lt;-- start bit
// 0b11001110 1 &lt;-- data 0
// 0b11100111 0 &lt;-- data 1
// 0b11110011 1 &lt;-- data 2
// 0b11111001 1 &lt;-- data 3
// 0b11111100 1 &lt;-- data 4
// 0b11111110 0 &lt;-- data 5
// 0b11111111 0 &lt;-- data 6
// 0b11111111 1 &lt;-- data 7
// 0b11111111 1 &lt;-- stop bit

struct TemporalUart {
	int bit_index = 9;
	int buffer = 0;

  bool ready() {
    return bit_index == 9;
  }

  int get_output() {
    return buffer &amp; 1;
  }

  void tick(uint8_t data, bool send) {
    if (bit_index &lt; 9) {
      bit_index++;
      buffer = (output &gt;&gt; 1) | 0x100;
    }
    else if (send) {
      bit_index = 0;
      buffer = data &lt;&lt; 1;
    }
  }
};

void main() {
  const char* message = &quot;Hello World&quot;;
  const char* cursor = message;

  TemporalUart uart;
  while (*cursor) {
    if (uart.ready()) {
      uart.tick(*cursor++, true);
    }
    else {
      uart.tick(0, 0);
    }
    uart_pin = uart.get_output();
  }
}</Text>
            <Notes>Sidf;askdjhkf;jkashdf
</Notes>
        </Document>
        <Document ID="713361D2-1DD1-4362-BC90-8663137DE753">
            <Title>Lustre</Title>
            <Text> - Lustre
   - &quot;The Lustre Language&quot; http://homepage.cs.uiowa.edu/~tinelli/classes/181/Spring10/Notes/03-lustre.pdf
   - is scade defunct too?
   - &quot;order does not matter&quot; but there's no old/new split
   - &quot;Previous operator 'pre'&quot;
   - &quot;Not suitable for complex data types manupulation&quot;


In some ways, we can see Esterel and Lustre as two examples of doing temporal programming &quot;inside&quot; imperative/functional programming


 - Lustre - “pre p: Returns the previous value of p”
</Text>
        </Document>
        <Document ID="727CBC62-66F7-4133-BE83-E5952852FD33">
            <Title>Nesting!</Title>
        </Document>
        <Document ID="74743332-3805-4EC4-8B13-1CDE7C95A938">
            <Title>Others</Title>
            <Text> - Argus
   - Pretty old, has atomic actions, but not globally synchronous?
</Text>
        </Document>
        <Document ID="74811661-76B9-4DFC-A90D-CC3C60FB1277">
            <Title>Compiling_Esterel_into_static_discrete_e.pdf</Title>
            <Text>Compiling_Esterel_into_static_discrete_e.pdf 
Optimizations for Faster Execution of Esterel Programs 
https://www.academia.edu/1622602/Compiling_Esterel_into_static_discrete_event_code?email_work_card=title</Text>
        </Document>
        <Document ID="79DBFDF4-545C-46AC-B8CA-8F4D4CEF2D23">
            <Title>Braindump</Title>
        </Document>
        <Document ID="7C5CAAB6-0CBA-4FF2-B9EE-E5B01CBB4249">
            <Title>Introduction</Title>
            <Synopsis>what is this? notes?</Synopsis>
            <Text>We can have arbitrary text here I guess?
</Text>
        </Document>
        <Document ID="8158F6BD-2B71-415A-9E87-481B0EA848C0">
            <Title>How does Temporal Programming differ from Synchronous Programming?</Title>
        </Document>
        <Document ID="89CCFC49-04A4-4AA9-81AC-D0D7DB598DF1">
            <Title>StateCharts</Title>
            <Text> - StateCharts/SyncCharts
   - SyncCharts and some of the other languages try and do _too_much_

</Text>
        </Document>
        <Document ID="8C5AA09F-3D72-402B-AED9-A8B0F0FFDF68">
            <Title>Defining the Computational Core</Title>
            <Text>Even though TLA+ isn’t executable, there’s a very simple model of computation at the core of Lamport's temporal logic that’s worth digging into - TLA+ models move through time in discrete steps by computing new state from old state. In the paper Lamport calls these steps “actions”: “An action represents a relation between old states and new states, where the unprimed variables refer to the old state and the primed variables refer to the new state”. Paraphrased, “actions” are not functions that return a value, they’re boolean expressions that define whether or not you can get from state A to state B, so to speak.

This will be clearer with an example. The Collatz conjecture is an unsolved problem in mathematics that can be defined like this:

1. Pick an integer x.
2. If x is is even, set x to x/2.
3. If x is odd, set x to 3*x + 1.
4. If x is not equal to 1, go to step 2.

For example, if we start with x = 12 we get the sequence of x’s = { 12, 6, 3, 10, 5, 16, 8, 4, 2, 1 }. The Collatz conjecture asks if these steps terminate for all positive integers, which is currently unknown but has been checked up to x=2^68.

If we want to represent this process using something akin to TLA+ actions, we need some boolean expressions of x and x’ such that one evaluates to true if x and x’ are adjacent in the Collatz sequence. That turns out to be fairly straightforward:

	Action A: (x % 2 == 0) &amp;&amp; (x’ == x / 2)
	Action B: (x % 2 == 1) &amp;&amp; (x’ == 3 * x + 1)

Given these actions, we can “get from” x=10 to x=5 because the pair (x=10, x’=5) makes action A true, and we can “get from” x=5 to x=16 because the pair (x=5, x’=16) makes action B true. The pair (x=17, x’=1) satisfies neither action, so it can’t be in the sequence. To “run” these actions for some arbitrary starting value of x we first find a value of x’ that makes one of our actions true, then replace x with x’ and repeat.

Now for something slightly brain-hurty. If we swap x and x’ in our actions, we get the same state relations except with the time axis reversed. We can run the system “backwards” - we can always get from x to x*2 via backward-action-A, and we can get from x to (x-1)/3 if (x-1)/3 is an odd integer via backward-action-B. We can also refactor our expressions to keep our swapped actions in the same form as earlier:

	Backward Action A: (x’ == x * 2)
	Backward Action B: (x % 6 == 4) &amp;&amp; (x’ == (x - 1) / 3)

Take a moment to plug in some values of x and x’ until you’re convinced that these actions accept the same pairs as the earlier ones, just with the values swapped. There’s a key difference here though - if we want to “run” the reversed program starting with x = 10, we hit a problem - both (x=10, x’=20) and (x=10, x’=3) make an action true, so which x’ do we choose as our “new” x? In this case, the answer is “both” - because this is a _specification_ and not a _program_. If we draw an arrow between x and x’ for all valid pairs, we get a graph where all values lead to 1 in “forward” mode and 1 leads to all values in “backward” mode. It might not initially seem reasonable to have a program with multiple possible “future” states, but it’s perfectly well defined - we’re just used to programs changing state in response to inputs, of which there aren’t any here.

https://xkcd.com/710

**something from the tla paper here**

So how can we summarize the computational model that TLA+ uses?

1. A program is a blob of state. There is no implicit state - no stacks, no registers, no threads.
2. Programs “run” by atomically transitioning between states. Partially-modified states are never externally visible.
3. Transitions between states are pure functions that compute “new” states from “old” states without side effects.
4. The set of all possible states combined with all possible transitions forms a directed graph.

This is roughly equivalent to a “nondeterministic finite automaton” or a Mealy machine, with looser restrictions -  we don’t care about sets of symbols or stopping conditions or if the states or symbols are finite, 

Something something

Let’s look at the same system expressed as an imperative program and a temporal program:

**imperative uart**

**temporal uart**

















We can state that a bit more formally as the simple recurrence &quot;x' = f(x)&quot;, where &quot;x&quot; represents the _old_ state of the program, &quot;x'&quot; represents the _new_ state of the program, and &quot;f&quot; is a pure function that computes the entire new state from the old state. If we add an input and output we get &quot;(x, o)' = f(x, i)&quot;, which is roughly equivalent to a Mealy machine except that our states and in/outputs are arbitrary data structures instead of sets of states and symbols.



</Text>
        </Document>
        <Document ID="8DA5F89E-25C2-4333-A201-B6F254B46CEE">
            <Title>Junk</Title>
        </Document>
        <Document ID="9027B414-C352-4407-ADD9-66DD36C704D6">
            <Title>Temporal Execution Semantics in C</Title>
            <Text>When we’re writing C, we implicitly assume that assigning to a variable changes the value of that variable before the next statement is executed. This can make 



Even if our host language has no '&lt;=' operator, as long as we do some bookkeeping to ensure that our &quot;tick&quot; function _behaves_ atomically we don't really have to overwrite everything each tick.
Back in C++, we don't have to _literally_ write &quot;p = tick(p)&quot; - we can update the program state in place via &quot;p.tick()&quot; as long as it _behaves_ atomically.

struct Program {
   int count = 0;

   void tick() {
      count = count + 1;
   }
};





 Let's look at a trivial program

 int a = 10;
 int b = 20;
 a = b + 1;
 b = a + 1;
 printf(&quot;a = %d, b = %d
&quot;, a, b);
 
 In a procedural language, this will print &quot;a = 21, b = 22&quot;. If we flip the order of assignments, we get 

 int a = 10;
 int b = 20;
 b = a + 1;
 a = b + 1;
 printf(&quot;a = %d, b = %d
&quot;, a, b);

 we now get &quot;a = 12, b = 11&quot;. 

 If we could somehow simultaneously evaluate the two assignments, we might expect to see &quot;a = 21, b = 11&quot;.

 But we can't express simultaneous anything in C, it's always sequential. So let's introduce some new notation

 a' = b + 1;
 b' = a + 1;

 The tick mark indicates the _next_ value of a variable, no tick indicates the _previous_ value of a variable. This may look familiar if you've played around with Mandelbrot sets, which are defined by the recurrence relation &quot;z' = z^2 + c&quot;.

 There's some ambiguity here, however - if I call a function that writes to a variable &quot;foo'&quot;, when does that write actually take effect? If I read from &quot;foo&quot; after calling that function and then I print the value of &quot;foo&quot;, does it print the old or new value of foo? To answer that question, we're going to need some more notation:

 int a = 10;
 int b = 20;
 temporal {
    a' = b + 1;
    b' = a + 1;
 }
 printf(&quot;a = %d, b = %d
&quot;, a, b);

Inside a temporal block, only ticked variables may be written to. Reading from a variable always gives the _old_ value. After the temporal block, reading from a variable gives the _new_ value.

It's perfectly legal to read from a ticked variable in a temporal block, provided that doing so doesn't create an evaluation loop. For example

 int a = 10;
 int b = 20;
 temporal {
    a' = b' + 1;
    b' = a + 1;
 }
 printf(&quot;a = %d, b = %d
&quot;, a, b);

will print &quot;a = 12, b = 11&quot;.

However, 

 int a = 10;
 int b = 20;
 temporal {
    a' = b' + 1;
    b' = a' + 1;
 }
 printf(&quot;a = %d, b = %d
&quot;, a, b);

will not compile - in order to evaulate a' we need to know b', and in order to evaluate b' we need to know a'.
</Text>
        </Document>
        <Document ID="921A916E-D9A4-4535-A4CB-E15D30E375EB">
            <Title>Leslie Lamport's Temporal Logic of Actions</Title>
            <Synopsis>Define TLA
Define &quot;the computational core&quot; of TLA</Synopsis>
            <Text>In order to “reboot” Synchronous Programming, we need to come up with a revised version of “everything happens simultaneously”

Around the same time that the first papers on synchronous programming were being written, Leslie Lamport wrote &quot;The Temporal Logic of Actions&quot; - it's a pretty dense research paper if you're not used to formal logic (I am not), but it lays out a framework for proving the correctness of concurrent systems - these could be threads in a process, nodes in a distributed system, or logic gates in a CPU.

https://lamport.azurewebsites.net/pubs/lamport-actions.pdf

His later works defined the languages TLA+ and PlusCal, which allowed those proofs to be expressed in something more like a programming language. TLA+ and PlusCal let you describe a real-world program in terms of every possible way the state of the program could change in response to an event. Once you’ve built that description, you can prove (in the strong sense) that certain combinations of states are never possible or always possible or will always happen in a certain sequence, etcetera. To be clear, TLA+ and PlusCal are not programming languages, they’re more like “provable specification languages” - statements like &quot;foo will never exceed 10&quot; can be proven or disproven using the formal methods of temporal logic (complicated). You can’t “run” them in the usual sense, but you can use them as a tool for building more reliable code.













</Text>
        </Document>
        <Document ID="950391DE-863C-49CA-A275-0DAF965E1949">
            <Title>Weird Possibilities</Title>
        </Document>
        <Document ID="9542AECB-5210-487C-9BD0-042D7A4F3685">
            <Title>Atom</Title>
            <Text> - https://hackage.haskell.org/package/atom

</Text>
        </Document>
        <Document ID="9AE34A2E-E058-4F0E-927B-CB4D872F032D">
            <Title>Bluespec?</Title>
            <Text>https://github.com/bluespec/Piccolo</Text>
        </Document>
        <Document ID="A9A15308-1D22-4F61-9535-49A91F7E6150">
            <Title>Isn't this going to be terribly inefficient?</Title>
            <Text>&quot;Your definition of temporal programming is going to waste instructions recomputing things that haven't changed&quot;
   Yes and no. The trivial implementation wastes cycles, a &quot;smart&quot; compiler could save cycles.
   But &quot;smart&quot; may not actually be necessary. Simple TP runs fast enough for basic realtime tasks.
Sensitivity lists are an optimization
Synchronous programming seems like trying to cram the synchronous abstraction into an imperative or functional language
The farther you get from pure temporal, the more work it is to translate to hardware
</Text>
        </Document>
        <Document ID="AA975B49-E0E0-40E4-8942-7D898CA9CA08">
            <Title>Extending C - A Syntax Proposal</Title>
            <Text>There is one small modification to existing C syntax that I think would clarify how temporal programs work a _lot_.
Of the many symbols available on a typical keyboard, '@' currently has no meaning in C. I propose the following:
1. A variable with a '@' suffix is a &quot;Temporal Reference&quot;. &quot;foo@0&quot; is a const reference to the _current_ value of &quot;foo&quot;, &quot;foo@1&quot; is a mutable reference to the _next_ value of foo, &quot;foo@-1&quot; is a const reference to the _previous_ value of foo. &quot;foo@&quot; with no index refers to &quot;foo@1&quot; by default.
1. An assignment to a variable with a '@' suffix is a &quot;Temporal Assignment&quot;. Temporal assignments do _not_ take effect immediately.
2. A block of code containing a temporal assignment is a &quot;Temporal Block&quot;.
3. All blocks nested inside a temporal block are temporal blocks.
4. All assignments in temporal blocks must be to either local variables or a @-suffixed state variable.
5. Upon leaving the outermost temporal block, all temporal assignments take effect.
6. For a given top-level temporal block, there can be at most 

This would be a &quot;basic tier&quot; implementation of temporal programming support.

Additional possible features -

1. Reading from a @-suffixed variable returns the 'future' value of that variable, even if it hasn't been written 'yet'.
2. Writing to future values of a variable &quot;foo@2 = 1;&quot; is allowed as long as the assignments don't collide.
3. The compiler is responsible for figuring out the implementation details.


Default Style</Text>
        </Document>
        <Document ID="AE706F88-0353-41C5-B4B5-FF07630D557C">
            <Title>Previous Work &amp; Prior Art</Title>
        </Document>
        <Document ID="B4A726A9-9CE0-44F0-B8C9-51E769D7C17A">
            <Title>Temporal Programming for Hardware</Title>
        </Document>
        <Document ID="BA29C94C-A2B2-4077-80DC-13EE5BB9F13B">
            <Title>Conway's Game of Life on FPGA</Title>
            <Text>https://k155la3.blog/2020/10/09/conways-game-of-life-on-fpga/</Text>
        </Document>
        <Document ID="C314096F-E6D4-4442-92F8-15C3DEF5F054">
            <Text>What does a@3 = b@5 even mean?


We can define arbitrary graphs of computation
	But the graphs can always be reduced back to &quot;x' = f(x)&quot;

A variable's type can change from state to state. The compiler can keep track of it for us.


Embedding the temporal logic in a procedural program guarantees that the evaluation order is a DAG, that it can run efficiently as a procedural program, and that humans can understand it better

What does &quot;a@(b==3) = 1&quot; mean?
Can we have arbitrary predicates as our @ rhs?
	Wouldn't this just be the same as &quot;if (b==3) a@ = 1;&quot;
	Then you start looking FRP-ish with the decimation of inputs and such.


methods that aren't callable unless predicate matches

void doSomething @ state == ACTIVE () {}

@state == ACTIVE {
	doSomething()
}</Text>
        </Document>
        <Document ID="C8A9C4BD-25B1-43D0-B8E1-76792A5D0465">
            <Title>Have you heard of &quot;Synchronous Programming?&quot;</Title>
            <Text>Have you heard of &quot;Synchronous Programming&quot;? It's a programming paradigm first sketched out in the 1980's that &quot;makes the same abstraction for programming languages as the synchronous abstraction in digital circuits&quot; [citation]. To put this in more practical terms, synchronous languages let you describe systems where a bunch of stuff happens &quot;simultaneously&quot;, while also giving you tools to ensure that those simultaneous actions don't collide (so to speak) with each other.

In hardware, 

When writing programs that need to deal with exactly this sort of &quot;lots of things happening simultaneously&quot; environment (industrial machinery seems to come up often), synchronous languages can provide cleaner and (in some cases) provably-correct implementations. Some synchronous languages also include facilities for translating their source code into a form that can be run on FPGAs or etched into chips, meaning that your industrial machine controller might not need a CPU at all - it could &quot;run&quot; your control program directly from the logic circuits it generates.

Research into sychronous programming seems to have peaked from the late 1990s to the early 2000s, and then gradually fallen into obscurity. Some of the languages mentioned in Wikipedia have been lost or abandoned, a few of the research groups seem to be defunct, and Google searches don't turn up any lively forums. There is one project that seems to be active and progressing - http://www.averest.org/#about_quartz - but in general it seems that synchronous programming didn't catch on.

Since the original publications, modern technology has produced CPUs with hundreds of cores, server farms with thousands of CPUs, cheap FPGAs supported by open-source design tools, and a renewed interest in proving the correctness of distributed and/or parallel programs using tools like TLA+. I think Synchronous Programming is due for a reboot.

- https://en.wikipedia.org/wiki/Synchronous_programming_language
 - &quot;the synchronous abstraction&quot;

 - “An implementation can execute several rules concurrently in a clock cycle, provided some sequential execution of those rules can reproduce the behavior of the concurrent execution.”
</Text>
        </Document>
        <Document ID="CDE7D934-F980-4268-9A9C-EB86FFFC4546">
            <Title>Defining Temporal Programming</Title>
            <Synopsis>Defense of the concept
How to define a programming paradigm
Compare/contrast with imperative
Compare/contrast with functional
Unique TP weirdness
</Synopsis>
        </Document>
        <Document ID="D05521FD-70C8-409C-8764-43E45A1773DB">
            <Title>Other Interesting Stuff</Title>
        </Document>
        <Document ID="D2C52523-1A70-4BFF-A807-F090C47750EC">
            <Title>References</Title>
            <Text>&quot;Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs&quot;
	4000+ citations
	TP Foundations: Recurrence relations. Concise and useful.
	TP History sensitivity: Complete, unambiguous history. Is history sensitive.
	TP Semantics: Global atomic state transition. &quot;State&quot; is arbitrary.
	TP Program clarity: Both clear and useful conceptually.


&quot;Applicative State Transition&quot;
	3 pages of results in scholar

&quot;Declarative State Transition&quot;
	6 results in Scholar

&quot;A DECLARATIVE STATE TRANSITION SYSTEM&quot;
	Only referenced by two other papers according to Google Scholar, from 1995 and 1989


&quot;A BLOCK STRUCTURED APPLICATIVE STATE TRANSITION LANGUAGE USING FUNCTIONAL FORMS&quot;
	Lol, example of a/b swap issue in 1980
	Not cited by anything according to Scholar

&quot;In his 1977 ACM Turing Award Lecture [1], John Backus charges that the study and use of high level programming languages has fallen into a mental crevasse.&quot;







FSMs / Automata-based programming
   This computation model is a form of &quot;Deterministic finite automaton&quot;
   &quot;TECHNOLOGY OF AUTOMATA-BASED PROGRAMMING&quot;
   &quot;Programming Language for Automata&quot; by Knuth
   https://en.wikipedia.org/wiki/Deterministic_finite_automaton
   https://en.wikipedia.org/wiki/Mealy_machine
      &quot;although a Mealy model could be used to describe the Enigma, the state diagram would be too complex to provide feasible means of designing complex ciphering machines.&quot;
   &quot;For the transition functions, this monoid is known as the transition monoid&quot;
   if &quot;x&quot; has 20 bits of state and &quot;i&quot; has 10 bits of state, then that's 2^20 states and 2^10 possible input &quot;symbols&quot;




## #############################################################################
## References!

Checking statistical properties of protocols using TLA+
	http://muratbuffalo.blogspot.com/2022/10/checking-statistical-properties-of.html?m=1

&quot;The Semantics of Pure Esterel&quot;
   important, read this
   It seems like Esterel is still trying to jam some imperative semantics in there with &quot;awaiting S&quot; or whatev.

&quot;Globally asynchronous locally synchronous&quot;
    - https://en.wikipedia.org/wiki/Globally_asynchronous_locally_synchronous

&quot;UNIFICATION OF SYNCHRONOUS AND ASYNCHRONOUS MODELS FOR PARALLEL PROGRAMMING LANGUAGES A Thesis&quot; 1989
   - https://web.archive.org/web/20050324021405/http://ece.purdue.edu/~hankd/CARP/XPC/paper.html

ChucK
   - &quot;advance time by 120 ms&quot;

&quot;The Synchronous Approach to Reactive and Real-Time Systems&quot;
   https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.137.2462&amp;rep=rep1&amp;type=pdf
   &quot;Encompass within a single framework all reactive aspects&quot;
      no don't do that
   &quot;Using finite-states machine, also called finite automata. These objects have numerous advantages: they are deterministic, efficient, they can be automatically analyzed by numerous available verification systems. However, they have a severe drawback: they do not directly support hierarchical design and concurrency. &quot;
      yeah no don't do that either


&quot;On The Development of Reactive Systems&quot;
   https://www.wisdom.weizmann.ac.il/~harel/SCANNED.PAPERS/ReactiveSystems.pdf

&quot;Real Time Programming: Special Purpose or General Purpose Languages&quot;
   file:///C:/Users/aappl/Downloads/RR-1065.pdf

&quot;Synchronous Programming of Reactive Systems&quot;
   http://www-verimag.imag.fr/~halbwach/newbook.pdf

&quot;The Synchronous Languages 12 Years Later&quot;
   - &quot;Microsteps&quot;?
   - 

&quot;Blech, Imperative Synchronous Programming!&quot;
   - 


&quot;Another look at real-time programming&quot;
   - where can I find this?
   - doesn't seem to be available

- defunct https://lphrc.org/

 - Ceu
    - http://www.ceu-lang.org/chico/ceu_tecs17_pre.pdf
    - &quot;CEU´ uses an event-triggered notion of time&quot;
    - &quot;await&quot; etc
    - loops

&quot;The Synchronous Hypothesis and Synchronous Languages&quot;
   - 2004, a summary of older work
   - &quot;Signals: broadcast signals are used to propagate information. At each execution instant, a signal can either be present
or absent&quot;
      - You don't actually need this
   - &quot;The key rule is that a signal must be consistent (same present/absent status, same data) for
all read operations during any given instant.&quot;
      - This is fine
   - &quot;The crucial task of deciding whenever a signal can be declared absent is of utter importance in the theory
of S/R systems, and an important part of the theoretical body behind the Synchronous Hypothesis.&quot;
      - Yeah we're ignoring all of that.
   - &quot;Activation conditions and clocks: Each signal can be seen as defining (or generating) a new clock, ticking when
it occurs; in hardware design, this is called gated clocks&quot;
      - Don't need these either
   - &quot;In the first case, the automaton structure is implemented as a big top-level switch between states.&quot;
      - It doesn't have to be.
   - &quot;In essence, one seeks to represent hierarchical (Mealy) Finite State Machines (FSM), but with some data computation and communication treatment performed inside states and transitions.&quot;
      - You don't have to
   - &quot;S/R modeling and programming environments are today marketed by two French software houses, Esterel Technologies for Esterel and SCADE/Lustre, and TNI-Valiosys for Sildex/Signal. The influence of S/R systems tentatively pervaded to hardware CAD products such as Synopsys CoCentric Studio and Cadence VCC, despite the omnipotence of classical HDLs there. The Ptolemy co-simulation environment from UC Berkeley comprises a S/R domain based on the synchronous hypothesis.&quot;
      - This was still 18 years ago
   Synchronous Hypothesis according to this paper
      Instants and reactions
      Signals
      Causality
      Activation conditions and clocks




&quot;Behavioral Specification of a Circuit using SyncCharts: a Case Study&quot;
   encoding using three-value logic levels and avoiding 0000 outputs

&quot;Semantics of SyncCharts&quot;
   &quot;A simple trigger is said to be satisfied when the associated signal is present&quot;

&quot;Behavioral Specification of a Circuit using SyncCharts&quot;

&quot;Structured Synchronous Reactive Programming&quot;

&quot;Semantics of SyncCharts&quot;


</Text>
        </Document>
        <Document ID="D2E48B63-8D07-43D7-9382-7FB6615B60FF">
            <Title>Guarded Atomic Actions</Title>
            <Text>need to add &quot;guarded atomic actions&quot; to the &quot;aren't you just talking about&quot; list. </Text>
        </Document>
        <Document ID="D5DED6CA-4DCD-4BA7-8305-0F3C64D4AF16">
            <Title>Some Background, And A Caveat</Title>
            <Text>## Some Background, And A Big Caveat

A lot of my best ideas started out sounding really dumb.

I’ve been a professional programmer for a bit over 25 years now. In that time I’ve worked at pretty much all levels of both the hardware and software tech stacks, from WebGL to embedded assembly code to PCB design and bringup. About 10 years ago I started thinking about a question I couldn’t find a good answer to - “What would it look like for time itself to be a first-class entity in a programming language?”

Since I am not a computer scientist, I wasn’t quite sure where to start looking for an answer. I skimmed all over the Wikipedia pages for programming languages and paradigms, browsed techy subreddits and various other forums, wrote a few toy programming languages that didn’t go anywhere, and eventually decided that I should learn Verilog and try building things for a FPGA. That led to me writing and testing a few CPU cores, which led to me looking into FPGA-based game console emulators, which led to me writing MetroBoy and GateBoy and LogicBoy and all the other Game Boy stuff that’s up on Github. At some point I realized that I wanted a tool to translate some of that code into Verilog, so I wrote Metron and built a live online demo and tutorial for it (also on Github).

And all that, in turn, led to me rethinking my original question. What if the right way to get “time” into a programming language wasn’t to try and cram it into the syntax or type system, but to define it as a sort of design pattern? We keep seeing the “atomically change old state into new state” pattern repeating across a lot of different programming contexts, so what if a programming language made that pattern easier or clearer to express? Surely someone had already done that, coined a term for it, and written a bunch of papers about it? After more Wikipedia and Scholar searches I still didn’t have a solid answer - many articles seemed to describe things _like_ what I was thinking of, but none of them generalized their ideas into something I could point at and say “Yes, that is the umbrella term for describing how time interacts with a programming language that I’ve been looking for”.

So I’m left with coining a term, something more elegant than “atomically change old state into new state” that can apply equally well to both a game’s state-machine-based AI and a Verilog barrel shifter. In honor of Leslie Lamport’s paper “The Temporal Logic of Actions”, I propose we call it “Temporal Programming”.

Again, I am not a computer scientist. It’s quite possible that what I’m describing is an old research topic hidden in some corner of the internet that somehow I’m unable to find on Google Scholar. I’m not “inventing” a programming paradigm here, just putting a label on something that already exists - if there’s already a term that fits better than “Temporal Programming”, then we should use it instead.
</Text>
        </Document>
        <Document ID="D5E80103-EBD2-45EC-B185-1B3F93F4778A">
            <Title>An Exercise in High-Level Architectureal Description using a Synthesizable Subset of Term Rewriting Systems</Title>
            <Text>¢¡¤£¦¥¨UW§V¨©¡#6G&quot;@§§GP¡¤X)A` Ya&amp;§T!#&quot;%U%$'8@&amp;§)Ya(#b§0§)&amp;16c2Qe©3dg4fD&quot;5§76©§0h 369i28@©4§FABpq&amp;D©3CEr69§FS¡@GH!s©3PUtI@V¨6GuQ#6G§0¡Rhv85 S¡@!TA
            wBxySx'n¨uhSSxohWp'dqfrte5svuulx'qggghyxjilk'm

           wxGy{zu|D}1~gtz9xbvDxxG)DH)

    ¥±t°5Ã¨a½Fh¥Ñ3HÄ)H%Åt¡Òh±½F7Ï­HÊ³vËh¢º7Ó©l¥vÊÂ¥£Æ)«4PÊ³7²³Çº£¿ÈÓ´¥¾Ç¾H¥¶­v¥St¡S¢¡¡©H¿¡e¡uÀ9%7S¢h¡v¢£d¢hÁÂ¥£S£¡¢hr¤´¥¡r¢h§¥9µ¥H½ÆF¨¥¶tµhÇPÇ·§£Ç­P¦uÈP£¨»ÉvÊÌ¢Ëd¯£¢©HÍµ¨¡Ê³¥Î©ª¥Ê¡¢h¢fÈ¤ÏÃ)¨eÈ¥Çt©ª¢¤F£¸3«e¥¢¬e¢h·¬BP¥¹@£d¶G¯¥`­vÐ)§¥¢­©)F¢¡Ã)®v±º±P7­©ª¯vPP££»7PW¤¢¯£¼£d¢­¥©b£¡¥v P7¥¥




   ¢¡¤£¦¥¨§©§¡ !&quot;$#&amp;%(')§102§'34©5#¨765§1689©5@A'CBD§E5©FGH6)IP¡Q8¨R¡¨&quot;S@
        T2U ¡V65#¨§RWX@AY¨')§ T 8¨Y`5§a6bIdcfeC§©Rg h!§1iD©F76¡¨&quot; TpU 65§gq

               r yhWw¨s1t%xur4g¦P vutxw 5wvy%uw
                        doGprHsvu'u

  ¡e6G©4Q9585369PQ#¡

Èiii)i)i)ui)o(~i~Vo¢$tvttt(vwvwtP2mFt)dgdf9(hhFhhdgooFFFwtopdg~py2Éve)dgdo(op|¨dfq(~FhF(hFz9)e)dgd|os)iixie)h¦|rhdgoi)i)dCdgz(opzp)oH~z(dglod¨$(FlF(vo(|r5hµRi)ellRdghdgvt(vtr$o`dglFe¡jo`d¨dewlFRdfzpmvR)zpehFzpi)hj¯v`dg(tÃsnkdiedg~VmF2i)lRtndfz((fRlRdfl³uRndgi)opv({Ãso(dftq(~dhjo(dHthewopope)ti)fhRtvt|r¹v¡ee9dgmo(opmi)mFdgi)ilFeoi)Fmhdfhae)fÂºmFfFe`dg«Hdg(h{e)vwwiªdgddgdf»e&amp;uRd9t|mo(e)ixorlF£sdgdfmdgd`h¼)Ã¦fdgni)Rd3q(È(|remihFm­dg½uRµi)dgosredfdgvtRdgdÉCXfeF¾dgdglo((lFd(i)o(e)tmF(dgi)emÃvww(fo(mkh|rwuj´¶dgdeiPhR¿(£mFiydf~AiP(mdgopdfvte«eifenµi)¼¨qªm¦dghvwvti))ophRÄËe(df(rmFbfdg(i)lÀ9mF£wnfÊ¯ftltopmrfehw¡hjthjV2op~dkdghFdfÆÂdgvwi))opAdpmFhfº¸o¢z(vt£di)i)i)h3|rq(tedgw$i)dfÁi)hfnRdgopti)dg&amp;~lFdgd(ww|rdgFÁPef(e)FoptfF)h(hiy£Xe)opvtth¦dfldVdpÈhkk((e|ho(dgiqªi)dfe)(dgdPhjdfi)h«5ey~(e)dgHwipÉ1o(e(Rf(ht|exi)lRi)opmdgu5dgwfo(«h|)yvw¦ivtd|hyti)i)o(hPhmvdfti)f(lRi)od`|ro(edgilmdgi)i$mklFyXwq(dfi)ftfledgdgoptqwvw´2opfwmF~y¸idgAopd(i)dgfhjopdgie)m3hj~iopvto(e)(i)hwi)v&amp;n¦efhµdg£ao(Ropq(ho((tir´bophdfFiewhdHm©Ami)e)z()dg|ropdddgwe)htzp|rhtd¨opzpdgh~(i)|¨o(hef5m¦h{&amp;fhFttu5|`(duvti)hCs(n3h©¬79y2(lFlFRo(zdgvP|rlwd¤h­n9iR|ri))|xtvtvtlzpue)e)e)dgwdf&amp;hklFytvwvwti)fe)zpvt(d`i&amp;eedfn{e|v)lRopi)n§eeAiPF(dgoi)dgosmdg5dq(ihFvthFF)he)dre(mFmRih((Ãsdgvwq(uo(x¦dgmdgopt5Rdfdri)dgno(Ðdfd3hRzpvwdgXm­i)dghRlvtdfev5vw`d¤|rdgFydfqsh~ttdgedPvwl))mfelmrfo(hm­q(o(ndf)ddtmFmFh(wgwj(mFi)dRti))vtzpyedg«yi)zÒ|rhFdfidgvwtelFullz((mFdgtdgwuRlFvhkunfo{vtdguRhFdgti)zH)VdhAzph|ldgdgmF(itwm3FmFhdgopzple)vthFzp)|dfm{mhFdgn(|vdf(op2whFedrdgo()vw(~Vz(vwixehopzpuRg¡lFddfn(h{thn))d(dz(edgnkhsx~Vz(os9qshx~pzpwwq(ope«R(t¬7(£¡ehjopi)uxdg®RmFidgi)we)d&amp;(dfhhRi(to(hmFiif­ivwo(nsm|evt~Awnsigwtmdgeeo¯ei)nto¨|dgm3vEop£PyPvt(emHeetfhÒ!li)hwvt~°wdgd{m3hRhwg«Rop(t$i)vwi¨dgtFv)li)q(|rmCzphFd(i)oph¡ni)wthlFVhRdgipdPwi)~VmFopdg2)h(u£wzliopimip2topo(thdgh{o(edftdfn{dgi)thF«RhFii·dfh­hFvthFuRPhRh)ymFq(eFy(Âo©o¢o(veopz9mFeixz{wfdgo(lF(vw|zp(i)dg~dex~hFd¨¥f~dyo(dhs±¡dg)(mlF(ymFvwmdgi)iedgmFzpidgÂ(o(Âdfdg$i)h3i)twmFema~duRmdfo(RlR|rwehzpmFq(e)dFh(wi)e)l(z(zple~dq(e(wdVÃstwldHdfwhR(dgd9m3dgv5d(i)|}hRdgh|rm(ii)dg|eegdfz(e)m{ve)5mµwf)£edg)mFhvw(mFdfdgopdy£Feddz(e)(i­nvÌ¢(t59dgoeVi)vtdff~dhR¥fd`pee)~e)v1Íydi)dgetldgldfo(fhFdg²d(e)fi)i)(u$tnsii)d2f)vtm3~$(oÃs|reH£dftfvdgd(iholFe)lFi)newdhopmFFvtii)(£do(mHdg«(£d(de~V~Ae)vwdgi)i)t(hadflFdgvtfdi)yEdgvtRdgh|~AfdgiFFivweRhi)h)ee)lFdk£opmhFn©dg2owmRoHtddgopd2dgie)niti)h|uRhFnsi)tzpdgetdf9godgo(vtdgo(hwhjwdhvwhF~dfe)dg(tz«5lFwltope)£ophdge)pyXhFq(Rfdgii)hÌ¢q(mFz3RiPh1i)hi)vte(~|hdgqsdgHªopmdfi)dflFÍÎi)opwlFydgo(we)dgh(|rÃopwnstdfwvtepo(zpFdploposdgvwdfdglRopvwe)iP$q(videq(hne2$d9)hi)o(ihj(wmFyhfÓ§dg)iiopdgo((5hFdgpe)ideghFvi)tdgi)|dy¸dg|ri)(vthyopmo9hFvtvwd`dg£o(dglvtmz(|rt)idfdX§(h|Ï)z¨Ri)dge(i)mRorohFÓ¤dgosq()z(mRh(wm¦|i)hixFhhlwopdgzpdgmFdg~Fwwlh©opzpÄËdgi2u5d3emi)e)iVvdÔª¦fhk`wlRo((dg(wdp|lmre)mFCi)o¤({dgdgzpÆÂVypo(PvE)fo(«Vi)£Ao($~d)s$y$z(f$Fyuedki)q(i)op2z(ii)i¨fopyd5|`nsuR2xlFd(e)vtnorFd$vt(dfvwd|r2vwhjdgnopt)Re)n¨lF£1edfl~d`evtlFi)dk5|rffni)uRdo(td|r9q(w2&amp;wi9wdre)v¥fi(wªvw(«iopÃsi)hjo(idgdg«dgttop)dgdgpopÃrhjF(mFmFmFdgih3i|fyAii)dgÑv5d5mvf|rehRdgvw`o(iFdfo(opfdgdgdge)Ó§d(leVn¦o(i)idg(mRvt~Vedei)lF)))y¤o¯|dgopli)w)fy1(diww|vwqe))iwyilmFophtwzpwtdgi)idgehi)o(eeÇopdgtod(i)«dgvtoost(hE|rgh¦uRdgttmFy&amp;lFF|hopm¦fdffi&amp;r)tmFdÄdgdgoplRi)hh2eedg²i)i)wdfi)dgdged¤i)wRi)l(lhi)$)wwew£5li)iHhjixtfopopnsi)zpwtttvtl|ipe)wi)~yÌ¢mÅopw(i)hFdghFu5FFvwq(hho(hsdgsoªo(i)i)dg·ÍfvtÆÂhhnozzdddddeyyv£

                             ²


  Functional  Transform      Design
      Spec                     Spec
                Equiv.      InstaInnscteaInn1sctean2ce 3
  Verify        Check
Correctness                           Hardware
                                      Synthesis

              1. TRS Specification      Circuit
              2. Verilog HDL            Design
              3. Synopsys HDL Compiler

              4. FPGA place and route

±¡wzplFe)dr² ´b2wzpvwn´pliop|ridgm32emF~de)d¢¡2dg)wzph3±vto¢~blR)thFz2wzpsxvwdfq(dgva´puRie(i)toph

df~i)dtmdmFFÃseetdgvtfdgdH5lFevtfthjvmdgddf)Âlmi)wdge~siw)vtdg¤wydglFhFdg)nCdgdgdgo¢hie)i)2)eo3~Vd&amp;tlFÌ¢5w)di)Í¦he)m)mFdgFdi)lF~Vdgdfdrtvt(dg)q(opw(lHhi)dghth&amp;)e¨mvwtdgwzpo()(hhlFldhRzi)dgv~tmvtlFop¤opi)z(lF$o(Fldghdgddgte)2drhjfhfÃC(ii5ddfhdgmFedgte)$(hfmgvtdgdglFÒ¦)Òmdgi)dnswe¥2e)op$twho(ophuRh)dgdgi)z(lFt|t9he)hFopdAo(edgdgzz{lyR)dgeHefti)Pf(Fop«RR)dre|`dfet$wse)m`ieosi¨uRdgdgR~iH~Ao(mttophi)i)yVofli)e)hwlFopi)ld&amp;Rfei)$dgh3m(wvtm)oplR2vAni)`Ô¨hRmFtdfCmFh{(dgite&amp;«Rdghd&amp;vde)i)q(mFÃs~V5vwRdgopo(osiPe(vwdftwvtzpdgfwPi)e|rqe)Rt|l¨dfti)thR|qs9i)dg`wpz3opvwlwhjdgdgdf¬7hfopymFi)&amp;hj~VhdfdhVn{i)~vtPyvt&amp;(ste)lFi)hhFopfdgFi)dge)vw|zpeFd&amp;dVopi)wldo()wt2vtopdghReP(hF«5z(h5dgfhF~AÌ¢zVhdvtzpÍlf©jmo(i)e)oplRwmF£EedgtfophChF{|dg¬·~hvz(hkzpm{idd2dgho(Ôe)(vi)y£¡eVdgi)|e)lFdgwopi)o(Ñjeopi)Fo|qhfRyAhlth9dmop5ti)dghi)e)i¨Ê{)dgFvtdg~APdglFthRdr|drhF«RuRokÅrmi)zedg)ttni)hjdgopi|ri`FhjdgÑjii)he)fedg`i)dglFtml¨ªhjvtdgtyeÃCi)X)|hjo(o(§wfiHe9opÓ£y¸ltehhe)op~A)d¤oposdg|r£|qdHidge)onHi)Rdgfi)t)wixFvwopopi)dgddf~dgFhlFhjÃo(ihoddiee

  Q9@§0&amp;S¡@!T A`©¨p A`©§ p76G&quot;Rf i U

«RRo(iieRo($t$)tP|edflFyey¸zpvwFF(Âedo¯vtRelFo(i|d(Ãdhdg~V($df$eveo(tRwwv$eemFmFi)ihdge)wvwo(e)|i)i)dgdg#&amp;dfdfi)emadgePww%vte(i)eVq(5opopmti)i)hjdg)ope)h3hR(ÈtlFtE|}vwwidfhFfhFo(fhivte'i~VRdgmFzddg(dgm3f(ignsV(eÑjvp|$do()yv2q(i)whhlRe)i)2i)ylFdX(0dgopwymv(twopope)o(whFqªh5d2|udg|ri)d`hhe{(iz{fhddfz(ivtl|dgopo(ddgf(tdgm)!fvt$h`hsÃsh(yElFhhknsdgdg(xvtifuFdf)i)dlvwhmF£Vdgiwen(Âhq(vtdgdfe(iddgdglF(u5id&amp;wi|rdfwv1fm&amp;dfi)uRhRdg(dfd2´¢etet)ef|ht«(dhR|rihF)l5|rrmfÃsvadgee|rfzdglRmliidg´£FVuhedgPnsvwm(dHllthi)tdgz(hyeh$lFi)io(e)fi)lmdgi)to9e)dfe$gt&quot;(q(w|¶d9(~§qsophkwdg|ri)!q(¦vtihXwo(Fvwvwudfdgo(nopnviuoyEd¤e¬7dgedfdlFmFwd`yii)ope)(eÃs«e)idoplFdgdfh|v¡)¢dfo(dglf~Vve)dfo(q)mFfe))dgq(£5ty1e)lFtee)ddgi)e3)dfo(opdge)wdg«wmi)i)o(i)i)eope¨hdfwFh5t(op~$hdgfhFiid2tdv1dfhkhjo(ooptdgghµz¨eeyde)irei)|rhXtdgi)fdgelRi)Fe¦mwvtVdf(ti)ldgnvwdhFdgF~$dghfvtFhF)zro($dgy¸d¦q(HidfedgzHeeudfewi&amp;opwe´i(e)e$dfd&amp;lRe)|{d¨i)no(PewdHevw|zp|yddgmFdgruj(iji)$mi)nsosd¦nioPopwiRFiopdfthmFy¸|mdffy¸Ro(e´VdkhRo(dge)(opdge|revtRyd9(vt|r|vvwe)it~tydgvwfvtvqsd¤h&amp;(o¢vdmtt~Vz¨fÃwthuRdg(ey¡i(tR|rmµghmevthnsvti)d(£idgvtvti)mCeFt(ne£(|r~prdgilFdHhjdghi)dg3m)Fd((i)$|mi{tetedfhidgilfFdge)dfoh3shi)$vwdgkd¢(i&amp;Fd(FdfmRi)o(i(hdfegdglFto($eysl~VhjdpPnÐm­khf(eyvwn{(dg(whuRie)i)´pe)i)fÄm¦hdfv5(²o(dfF(eiyme)y¸)£~$z(R|o(ih§d3dgqsdgvteÅdfRedge&quot;e)mt(eÆa|°ehw)vtosi)u5eha|ri)!5tldltmdgopfdfh£vwhFe))dghi)|i)dge)dgld)(zuRl|rd¤dti)vwhRd`(vt£5hFi)o(Fed2osidg(mh3te|rlz$dfdHhmÐmFhensvwedgÔ2zHvtsdglmdgy¸|r(~pf1vto(ifi)vwiythFwd¤oie9dghFge)ydgweo¨zpF|i)nop|£hvz`fl¬·¦lR|dg|((hC(vw2dghh3e)osopvti)opz(fto¯¢opi)i)i)m¨lFmF)|9dguFFFq(q(hsi|i·dgfÈdddddddv

  3'457698)@BA'6&amp;C'DE@BFGDIHPA'57DEQRQS6UTVA'DEWXHYDIQ`Aa@Xb¤6UHdceC'WX8gfihUprqRDiA'5s@Bt7A'5uWBC'QUv2wx6&amp;C'8yDIQSQSDIWH

                         Ô


                                     ¢¡¤£¦¥    § ÄÄÄÄÄÆÆÆÆÆ         p ¨ ©  &quot;!  g½p¿¼ (¾FÁx»Â½¾» ¾FÁx» g»º ¾ #%$
                                                                                                               ¦&amp;'$         )(            10324&amp; 5$
                                                                                           g½p¿¼ ½À9¼ s¾R» ¾FÁx» g»º ¾ #%$
                                                                   ¨ ©46                            8790¦$A@B0   ¦&amp;'$2 DCE0F(            10324&amp; 5$
                                                                                           º»¹À f»º f¼ ·½(»º ¾ ¾Áx» ¢»º (¾ QR0
                                                                     £  ¨ ©HGI6 ¨ ¨8P  ½¾ f¹ ¾FÁx» g»º ¾ `a0 9&amp; b(                          1032U&amp; 1$
                                                                     £  WYX ¨ ¨ P                          SC 5&amp; ¦$T7UCE0 5$ V(

                                                                      ¨ © ¨                                     10324&amp; 5$
                                                                                           g½p¿ ¾FÁ» ¢»º ¾ #%$ c(
                                                                                                                     10T24&amp; 1$
                                                                     £  d ¥  ¨8e ¨     5» ¾FÁx» g»º ¾ f g$0¦Ch(
                                                                            ¨P                                       10324&amp; 5$

±¡opwzphjlFi)(e)td{h$Ô c i)ic d&amp;pm£i)´¶r(FmtmF|eRdg)vwdrErFVyo(¬e$RÓ4i)Fds ¬·hW¤X¤ietlRhi)iweoplRhµi)wopdfhaiff£se)±Fdfzpo(etii)dfFe d ¨ Pophi)((hhmq $di)F¥ d¤¨8euRe(hhieli)i)te)opz(hdffip£(e)mdfmzpe)tdgi)dffe ¨ 

ic o(o(du$|Ãsy¡yVe)dg¨ospo(dgvvwi)o¢mFfz(5$dg£~lFdgetvtof¤H(vtP6vi)A`wd`|Sop|rzp`£t~pe)haw|q(di)|rmF£jw¨dii)Rnsi)dfvi£dgvwFhetd9dde)|htdV6dg((($o()o(¨|rmRe)vtydge)¬)dfzpmFhjn(~Vi)fe)i£XFÓµi`(dgedg£ad9e)vtwma~Vivwi)dgtnhRotdgFhFns¨)dfz$Fidgeei(o¢Feddglh~i)lRdgd|wmµm6vwq(i)dP«l$wdgtqop£ei)vwvwV(n(h9dg¨vtiHm|rlFiAdf(|dgoiAfhfmFe)o¦os(fo(osmmFdghmFevtdgzp¬·dge)dgdg6)thdgum3vt)¨q(Heddi)o(uw3uFopenl3edy dgh)~Vdfm9dgt®5mtx hwm¡gi)tRe)zpuh9q(dgie)vwto(do`hµo±¡e)|dgxedfi)whj|dgzpzposnFo(iplFtmFfdVyposi)e)vtdgo(imFd(ddVvdfe¤Ãs£dg£¡o¢dHeÔvtdg~(hFi)te)fhhFopdglFe)Vzkmkd{hsi)ho(i)FÂdf(wz(opd{y¸|redfe)hw(|eose)e|hFdfmo(dgidg~$yvtdgzFo~|t)£vhF(eÄopwo(tx hdg²o(e)i)lRem¦d£ptewn(hhFÅe2uizkÆwdfi)e)dgi)y¸$egoseo(£5ilo(eA|rgdi)i)dgvwd`qs¤dgF)dftw¨|d¨i)o(9o(Rtegopf$e)dges mFe)£A|(df|odgtht) zp¦h)Ro(tdg)uvw|eRiedfi£newwidfuoszplo(d$(e2mFdgehRRop«mi)dgvtmwhwe)vXvtzptopd(dg)|(ji)Rh£t9FdgiHe)R(i)thjdo¦vwh2o(dgi)ypmko(zp|rdgii)wi)dfixq(Fi)dgwe~opdgFo(hdfdf| hhodieei
ixi)y$)o(~Flopek d¨l o(hjt) $V e)o(idguf(edfF )lRHdfegldfe)vwB  evtd¨(e)d`ip&quot;(d&amp;mR¨¨ htypm2i)e)mRwopi)fd¤|¶wBop¢)e y¸£hadfop5vtR3t$dvt¨dffvt£o¢e£Fe~Vy¸uRd{¨o(6GR vwtieÄ¨d`hed9¨|6lRzi©evwto¨dhFl !¯Äzrvw¨lFdHÆÂi) £o(aÆÂiº£imo6¨dgdf¨&amp;|eÄi6¨dgPt¨osi)hk9Æ w¤mFopi)~VdgÄh¦|vd{f¡dgi)Æop(F¹gh¦m© h¦dHChdgi)0A&amp;di)FCi i)¨ÃsFi)d9tdghd©H !fdrix~flFi)GI ©j qªlFi)woop(w6e)ophµe)vGR lFh¦dg¨op6hjde)lFo(£dfi eo(¨&quot;¨yzpPteHÄhdgd9¨ (ii) e)dfiFÆÂdf£eerfdzplR¨tteÄhµh¨i)dgiPw)dfÆopi)ileFhkefvwlRd{i¤2o(e)¬7i)i2dfydwopzpi)(htuRFvt)idri¨ohdfnje9o(te)hRd(«5ndfpvwee)dVdge|i)wFtofi)opdHdgRhhji)|e)i)dgpdf|i)iri)tR(`wvttd`itho(dgt5mkhFopedfzo(iheokz(i)e(i)eli)w(vwopFh|dghd

lnmovprq sBs                                                                           p ¨ ©  &quot;!
             £ £  º Ä Æ ¨   
                                ¨   6 ¨                      6 ¨    ©
                                     ¨ ¨ © !
(  £ Ä ¯ÆÂ£  
            ¨   Bed                                       6 ¨ 

lnmovp  q FB&quot;
             £ £  º Ä Æ ¨   
                              ¨    6 ¨                        6 ¨    ©          ¨ ©46
(  £ Ä ÆÂ£                                                

            ¨   Bed         ¨ ¨ ©                    6 ¨ 

tvu¤wt BxhyFB&quot;                                                                        £  W¤X ¨ ¨ P               Ä Æ 1 ¨ ¨
             £ £  º ¨                                    Ä Æ 6 ¨    ©
                                ¨  6 ¨                                                                         oz{p
(  Ä ÆÂ£ £                                                                                                                          ©

            ¨  ¨ ¨ P          ¨ 6 ¨ 

 tvu¤w1|Im  t xhs&quot;
             £ £ ¨                                  º  Ä Æ 6 ¨    ©        £  W¤X ¨ ¨8P               Ä  Æ 1 ¨ ¨ a©}
 (           £ ¨   Bed¨  £6 ¨                                                                         oz{p
                                               ¨ 
                                    ¨ 6

                                                                                           Ê


 lnmovp   sBs   £ £  º Ä Æ    ¨   
                                          ¨ 6 ¨              6 ¨           ¨ ©           ¨
(  HH££ d £ ¢¡                                                  6 ¨                                     ¨ ¨
           d £ ¢¡    £ Ä ¨Ä ÆwÆÂ£  ¡¹ Ä  Æ ¨   Bed                    ©

                                          ¨ ¨ © ¡                                  f gCh0AC  ©

uRe)wÇi)dfls1zp£¥dg(¢t¤vt¬·)2dfy¨m§hµie¦dfFfI $e¨i)Â£RF¬·dds Fe)d¥©dg)d¤B¨v££lhtx &quot;£t¢¢d2(¡H¡¨£$w)|relFi£Älotdg|hFvwmd zk©oFt¨mophi)¨vtdgm©ÄvzCi¨£¡e i)lRÆwi)ÆÂF£Fi¨£ dfi)d¨wi)op R£ i)hd¨e)6oi¨i)ddCtdg|rdgBo(hde y&amp;o(ÑjeldwRi¨£dgtlF|ºte)¨¨i)dg Rm{£ (tvw)6vtdg6t)vw¨h|rnlF¨dgi)dgdmvÄFhÃd¤i)dg(Æ`fth©hle)mµdfif¡izpdgi)ed¹gm!tFlR¥CEid0¦tdfi)¨&quot;Che9e)ewopdgie)hh¨edg(lRhR£i©|rdg¨(Pi)|r|rtw¨hopRtz3ÄhhF¨vtfz¦i)ÆDid&amp;(zCh´p(mtPh§¨mFltdgih)o(dg)e)¨iedgewtmluhdgti)mihvweopulRh©i)nFi)dti)wopFehd(dfzpyi)optdgwvtzp|rivwdfo¯hFRe¨~Vdgvtm§t«hFivwzdd

io(e)dgo(ii)uww´ i)i)dgodf|eyPo(2|mFi)((hi)eo(i2dfe)&amp;$Rhvdgi¨eHdgdH(n(wvi)o(o(hdf dgly¸hki)df(ehe)e)ihtee)df(opd|rdf  i(d$zph|wedfidge¨¨vuRe(tmmthF)li)hlsi)e)ii)zFdVopmdflvi)|dfe$hP)dfa B¤d( i)te)tope`e £«dfhFdRF mFdgihaz'·i)vwzo(gÑdd¨td(¢£1Bopq(i)¤«lF£dqªo(e)&quot;£i)(hjd&amp;hdgo((eFo(vR$i)¨e)hz(wtud(¥o(i)o(vi)eÄF¨¤tdftdf¨y(dfophdH£uRdge|d¦oph²©£¨hvwzpy¸o(Å&amp;hdi)opy&amp;(6¥to(e)o(vteopo(i)ÆÂ¨hµidfvty&amp;lee)£c i)to¢h3e)ehFmFdfFvwel~Vtvtdgzpzdgdfdfht¥©(ethH te0e)¨viho)i))sdo(£!idgiz¨Fhey opdfe2 ¥mdgdlRºe¨¤he)i)e)1£ul)¥©Fmde)i)e)o(#¨vnvwdgd$t&quot;%fwdgd¤hF£6ewop)(h£1$qop¨$lzChyhk(i(~p|o(¤vwdf|ri¤vtqe2tulFedixÄhC¨(|rintd&amp;tdg£vthok(opRy¸lFÆ~p¥C{o(zvm|td(©o(efdf©H mDi)t(e)t2t) tF(y¸vti)lFGI o(vt¨df´pw¤(wnki)i)opee96t©H hj|hu5dghF|rtn­o(¨($dfzhdgGR ifvdg(mÄFµt¨i)h©6tie)hRtdgFhjehdgwÆÂi))e)y¡i)d`lR¨d£widPdf(q(iÃs¨iuezpe)£etedei)lihFo(dgÄtt¨lwldg¨)P)opi)dgPuRhivwi)i)lmCÆhdgdfi)lFtwmFvtopopw¤e¨iPi¤o(dgop(hh­£mÐthhHo(hFVo(h dfy¡(6to(e)(opieh¨|rei&amp;(ohC(fhC¥©dgh¦(h¨vd¥©o(t£h§|ropmRh¨ve£|ropV£emFfdg(u5(hwvt|df|¨i)Hlhfd¦m9e)Re)(mmvo(lFdgd¨u5|idhÐe)mdy i)dfo`Ãsn3gdfdgdgopquÑji)i)h¥(f(|rwtoplFd3¨¤q(¤lFft|£dge)vtd(|rid¢dftldgdghÃsRuRwd()m!i)dglF¬·vtvwH9´pi)id((fhi)et£5lFth§tVhFwhÐlhhFdgi)izFmvËzdgt(d(vi)ihdrm§i)vtwwei)uvw£Rop)FlRFn(mÑjin¦hwi)drd$£ ey¤lw5i)ldg)dgezpew(¥dfi)optdgdglF2¨¤vti)e)i)))hvVdr£Fdgwillyophjo(dgdfo(ttvwvwheeiiiy

o(eq$lop(i)FFhjvtvt(dglFddfi)VdR (e`dwtu5!j h¦enldg   i)vwydgi¨¨¨o(F ¤te)po(B~i)y$&quot;Ri)66ezFiHm££&amp;Rt(hF¨¨vw$vtnsz£e £e Fto3hFi)d`F¥¥z{(¨¤¨¤hd9££i))o(Fqªwi)zp(dhCvti)lwopqd`u##&quot;3 &quot;3(hq o¢o(vt$$q(lFyd¥dgi)¨¤¤e£ lPd¨i££vwÄok!5di)¥¥ 4i)t¥©H ©H z{&amp;ÆzpiGR GR i)|fo{{66dgo(&quot;&quot;($i`!!i)hFF32££dfdr!!e&amp;i)i)PPytopz¦hRvtivwo¯tih(~Vevtlvt¥¥¥hF¨¤¨¤¨¤i)z{h££w£ opPP ixi)h3££t~(Hh66o3i(dg¨¨)|edg)l2wRzpvwo(dgvthF¤ydgii)mvdg¤ezo((R¥hRq(mktzphvtlFi)id( ¥dd`¨¤i)£ e)$FP dfdFzpdfe)ded95iddfdge)edfi`e)Ri)dvto(()yi¤dfdgi)q(mk|rdfdgeujg(nndv

   w6ro D  w87 m§¦@9noA¦Yp s&quot;
            £ £ ¨  6               £ (  #&quot;3$                       £  º  ¥©¨v£ P
 (          £ £  ¨  6¨ e ¥¨¤£             ¥ © !                         6 ¨               ¥CB      ¥¨¤£ P
                    ¨ e ¥¨¤£           £ (  #&quot;3$                       Ä ÆÂ£   ¥©¨v£AP !54 ¥
                                                       ¥ © !                                   6 ¨ 

$F (d¤ ywop6rvtvwo o¯ D~V¨¨ thFwDz966m e xc lR££ vwxFd¨¨ EGe)£e Ä ¤ ¨dfi)F ¥© w¨¤e)B£dg!¯&quot;$ÆÂ £ 9 ¥e¨¤dg£h  ( |r¥ thF©z !pi)¥z©(h¥!pm¨¤ £ yP e)£ dfd¤6 ¥¨i)¨¤F£  PdH£ (6))¨ ºo ft¥ i©dgmk¨t hÄ ¨ Æ ieli)wophuRlsdfe

   w6ro D  w8H E EqToA¦Ep s&quot;    £ 7 #&quot;3$        £   ¥©¨v£ P                          º £  ¥PB I ¨  ¥¨¤£ P
            £ £ ¨  6
 (          £ £  ¨  6¨ e ¥¨¤£             ¥ ©                           6 ¨ 
                    ¨ e ¥¨¤£          £   ¥©¨v£ P
                                                      6 ¨ 

                                                                                 Å


i)f|F(o(h{dfe)o($d`z(e)dgdft|iPhdAitdg1dfhjÑeo(ildgo¨yiwqdgi)9thH(hFvwdgzi)hee)io¢dgd&amp;qsdtllumFvwdfdi$tixhF$~tzHPvwdfo(i)dgi)iRh9|d i)ikFtx o(t) de)udXuCt)etuhRlf)(vt(dgwhkzphRfj£ms )i1i)t|¨tx Fthdgwlih{vtop|w|riidod¤ftmi)(dge)FhvtodHx(f)vte(i)o¨h9idHz(uwidfdAdgiide(i)i)e)lFFho¢edfq(dgwe)dgi)1d¤h9wopi)lhu)(n`dhFh¤o(zHFyi)o¢i)txFdA~Vwd(hFtx(zVi)$w©li)(~evjdglRtivt|vwvdgXwfRyVvw(dgh¨VF|rdgo¯dgh~Ad&amp;hwdfi)i)i¨tq(nj(dfi)ve¢wopidg£dfhR$i)efF|o(dy

 @§¡#6Gd V@S¡@! U#6GA¤6G§£ &amp;§hv§0¡e6Gd©Q#h f i U 

¬·i)zp|tf|$hF(hjh©nso((wmosq(idgo(e)hrmFmFodgie)e)i)iV5dgdgdgddghvem{&amp;|f)dg(Phdff5(Ñjy¸hvwdiyo(thoplopvlRthjorhFe)e9()hRtdihdg|e)u5dgi)omwdivwFd&amp;vwi)nsnti)dgFhFd&amp;wh)e))hsnsope)dfz¨dgopi)nhyAz(dg«hhep(hj)eihi(i)9dgdgz(i)dfdfFwwvt)|HFe)eopievt)etno¢|rd|rdgh§¨lRopuRi~4)hFo(fo3Vdgvt&amp;ww~AdA¥ffeAÑjopyE(hFy¸dgttlldC$o(mhhCi)mF`o(m3e!tndge¤qªi)dfid|`hh«#(¢5me)&quot;¡i)(vwh(«q(d&amp;ldrdgt|(hfty¸|rÃsdhj)infdh£¢miPdgd&amp;i¤tÃFtynm(f)mvho(e)tFhj(i)dgeti))e)vti)o¯i)(%¤vwi)dgª$~Veidgn&amp;hiFfÃdmFt|`mdHhÐthmRdAq~ddguRilF|rd¤e)«e)vti)e)vweldgdfd¤he)ns|r(t!(|vwdrdhFwtd¢d9£RihF(zidgo(dt($hRo(z¤|«thyddhFh$yhFi)hhÃs#Vi)dgm{nst`df2t%l|dgFHegvwihdgf|Htdgdr©di)Èh|lFtª±i)Vu)vwV'i)ÃtFdgdgi)Xw¢dfo¯|op2hjdfe¡v)~Aih1Viei)f¦dgeo(dHdf(02df2hjyi)q(Rd(iz(i)w´2dffeopei)&quot;!e¢((vwhauRi)£Ri)th!aw|vw&amp;HiFophF´dfdV)haop|rwio(¬·li)lFdgo3hfo(£¢i$wmvtopyHzp~dgw(egz(h¦e|dX|ropkvtdgdgi)v5hhF~p(dgo$nsihdf¬·tmFdginsehCvt2i!i)emiv(dg(ghlRdg#vvtvÂi)tt&quot;|£1dghF|¬·i`mFBdgzhjte)Hwz(|`~Vfopi)iad(li)hFflRoph{mFw(opdfylFvti)(d¦dfe)le)wuehopd(q(i)d&amp;Vd¤um$mR£|¤ tdgdghF«vwdgth~)n(i)&amp;)zhlm%f£¦£d¢wfildg(i)i¥¨Bqd&amp;Fh(hd`)§dgt)d$o(dg©wdvweopi)fl£'dgpe)yhvtz(|r|ulR&amp;(o(iie&quot;!ivtw)y`dodgdivwo2(nheR|rhR£¦i)o(|i)C|rFm(e)yap¥¨(en3d§$~pmFtVh{©%!~dVVFR{i)hFopt225hFdgFdge)e)tmzdddd

&amp;%! ©} &amp;%£(hm(#&quot;tPho(iV3¿$¾10 » &amp;½B0¦CVth(2£o(e
#&quot;tPth{i)Fd`mFop|r(th{ioop|rRlFid3 %!

o(¬7e)o(iyodgi)opopopopyyHÑ|`|`||dgi)hFii)tlFf¬7¥2mFd`uRuRRRotyEwddg(e)dftthmdg9hhdhjvtvwvamFdgdfvwi)hdgo(|¨4e`hFi)dfw|i)i)de)wyopeoswwoplFne)£fÃopop|rmFdgdgha(di)i·hRhRhjd2xi)hvd£56vt((i)FuR5 lF£8i)fdvEvjopuRdi)vwdg7µd¤yFhqvt(ilhlF(dgmRvtdi¨hi)o()(dghµnjvttdgllFihhFvtii)o(d(tzrÌ¢opd3dHt)zpdgd2Íoph{)itdghlF´¢dfuÌ¢i)mF(2vwEdrR4eÍÎdgdgdfhj||i¨o(qªhixknnj~iry@(¬7i)zp9dgRhRwvtdfw~d«Rhjq(dgnsm3hFy¸i)dgidg56hfi5dgmz569e#dfvt5 (h7Rti)er|d2uji))7m§t¡ÃnhFnietR´hdd9zkdgo(ii)e)vt|ty`tdgFi)|rddi(f{|Ãseo¢d&amp;ehwt|rti)qsopi¥gqmti¨vwevtthtn(njtq(hFhFw((itzCi)zmFvjdghei)d&amp;Fo(¬¨owzi)(dgdopypFifRm3vthf£Aopopdfvie)i)i)drdgdghdgF~Vidgfmk)mv)otdd$mF(Fl{wi¥fh¦z(yeokvtt~Ve)di)Etldgi)ehjoptwu5RihFi)o(q(|Îo&amp;iid¨v(zHydopi)do(t`R)vwieVÈz(3q(dgdgdgopi)z(eÉCdgvw(vtihdgedghm§dfiridgR|(ndgdii£aaywh|¨~Aedgiq(((dglR£idfho(dlvwvtdfei)vtdgi)ve¨evwFig|rm(i)i)i)dgt£adgihi)mkxdghoA'ii)Fdm)hd9Btdge)uwii)zpt|(i)opC¢dfn3mFdg&amp;ddh¦(Devwdgdgi¨dg(|rDhjhhF|ri)dghRo(ti)F)osfvthmfe)wwdgdg¡d9±FmFy¸ie)iophnvofdgo¦o(dg´phRi)i)e)i¤FfeVtdg((h¨thFi)£Xd|¨|rmFvPdvtFopzvPo(i)ÃFdgd{lo(h(hj(optmRdi)i)i)mF|hi2|`i)twt)dghFyt|z(iRlu5hF|ruRnf)z&amp;de£wvtzrd¨(tzpdthi)iv¥gdgRh1fFmFidfvwdfwe£ddgi)dgFi)dge|wf|whi)opop|rope)tvtFi2thRdgdgh©¤de)|hj(Ahjdd(dgvi)fmRlR|ropm¦(~f(mFlFns|HhRt£hfdgoph(fdgevw(ui)lnttvtvt¤uhFhFtFghdfvtmnzzdde 
EFHG CPI@Q  R A'BC¢DDTSVU1W E¢XYYH` C@WW

¬·idSVh`dfopU1A'e|Wi)|ÎB´2ERC¢Xd$h(DvwYmFAdfD9YHegdg&amp;e)`ixfenC'vt)¢5i)WEn{edgd(W{FHi)£o(i)GdpttmFywHCaopdgdgehvw)$dfdgi)Szp|r|e)U8tdgiuWdgRd&amp;Ñjio¯E¢hdfvwlRq(inCXifewdfd($Yee£b(tY§|hFfI@hµ`(z¨QC@Fhfti)htWdf(Fu5e)ihW dgdHdfi)d&amp;Fz((op)mdffdPh5Re9£dgvwixdgfnrmFni¨fvtdgnjuSVf(e)dddvtUvfdgd(y¸EmAge)e¦o(dfBehF(y¬7Cdfz&amp;hDe))dg&amp;Dri)i)h(iixhdfnidgd$ei)5m|Îtdgd&amp;lvti)dg(|hFopethFhRz¦dgSVz¨hU8kiii)eW FliE¢d&amp;dfopXeihjY|So(i)Ye2(`dgt(tfC@hhdtW(hFwWpI@v5i)z2Q$o(vwdg(mgi¨hcdfnjdgq(efdgSVvtAU8dio(Wi)edeFE¢Ãii)dpXRwh1YopmvYphatdgfEg`£Ffwi)qHC@top)vw`WhRnCwopCWh9td`1mF(¬·o(hRmFdgh9hjmrdgi)dgfh'hrvtop«RsghdgeiiCdgo`HeEm(i)i)Qu)FF(tifdd£
YvHEgvxw CyHsHDHC R w Cy'HDHC XH``gvbF SVU Ew CHy¢BCDD'

YvHEgvxw CyBC¢DD R AgBC¢DDSVU E

                                                                


CCCD68GXcdpq68¢¡¤£¦¥¨§©§E'F¤7  ¥!#&quot;%$&amp;'$&amp;¡(!)£(¡¦01£(2¡3&amp;415
                                                 @9(2¡¦01£&amp;0A(B#4C5£(2¡¦0
                                                 EHBIPYEQ$&amp;¥¨C$&amp;§E'F©`7¡(RS`SA£(a(2befe2R¦R¦¡P(3T6i0H0H4167#7#5`5`4AE¨E¨U$¡¤¡¤7((V2FrF¦W¦B2B2¤6)s7#¤F5A5i¡¡0CW)¡¡$&amp;(gg£&amp;§§B¥§72£h£h0£¡¤4(((2S4HBiBi5AR572£&amp;(f(2A60(B`U$(V2ST¤7#@ef0CW)Cu¤£&amp;e2604H4 ta4
                                             ±¡wzplFe)dHÊ $FdItxu)vÈR@w¨xyx)©HthdvtldgdgÌ¢Í nshi)ªÃ

i)´2HiVmF§dgfwopi)vtvtmetPhdgma(d£hvtwltCHhjdgyidfsz(dgbdfDegÌ¢CÍP ¡2Ptdg&amp;i¨fnjvte«dHÃsi)dgwnsmsophxi)dgwo(|¥fydr£Re)mFwedfnsgehn&amp;(e|ro(tytff(w(vCvavwnyiB)eC¢tlR¥fDdgDi)mlFe)idg~Ve$Flfdf(e)i)h3dlFeu5dgd&amp;(d&amp;t$mhFdw«o(ChFi$ydg(BmavtC¢vto¢D~±FDo(dgepmt&amp;dtÃsh(d|i)vtlFivwdgdd dgvwdgdg |Ì¢Ídghj i
YvHEgv p F W E C h                                                                                                                         R p F W E C hTAgC h qb`F I `gq QbC@WW qb` SVU1W E A'C h qH`F

¬·)mFh`lFdgu)i)Reitweuldd2Ãsi)i)(lF|ed¤Yd(vH£uo(vwEgIe)d(zp`¢v£p(qhIQbw`gC'¥giqWelQbWi)wC@qHopi)`Wh3lFW£¢etqbo(dE`yo(()yvi)ixo2R nimdHdd!dgI«vwp`¢dghFF|qdgWQmadgE hjCuI@i)´ph9Q$h~pw(vtwCHo(i)opyz(|rstoph{bl5DEopC )idgonsm`$io(dgy@|AgCz(h eqb(`|rF |£¨I`¢efq £(QbC'wWdfeW qHe` £ª(tfh(m vixSVnU1W dAE AgmFCdh«qHhR`wi)F wopEh´ 

  Qe©3hvA¤6Qed¦A i¢85&amp;§¡&amp;S8@§bI¼§0

iuei)(|qÊ oi)i)(lGd9wdgitvtq(phdoiihji)¬·~Vtx dgg$$$i)d¤dgFi)h¨fhfhFh|duEddg(i#&amp;#&amp;#&amp;z3Ãswo(dfd`vw%%%dgi)hkdgg@)ee)o(Rhji)(|rmFdiDopÈÈÈe)(Fvdi)e|dfe)C`vwi2'''d{dgj(dgÈ`de¡~dhdh')i)iy¸dgXgi))))5wdf)o(iEixi)hjnsftedopen¤(0((i)tAi)xf$|rhFhRi`wwf)op)te)udgmlR(hjd(¤©9d{h¤vdht`io(lFhFt''ydf9!vwhfe)Ôo(e)dgz2$eo(opnsedge&amp;Vhzphdgi)$Ri'(itFvto)i)etndgdg2vlFlVe|oplµiuvw)Ì¢dgdXdg'VhiiÍhRm¦e²g2emfidgdg)l(Ê¡oi)fflF|tih{(nsfwue)i)i)oriy(vthdgnrlFtopdgddv1i)ophr¦i)Èrhe)Fh¦i)(dgi)'d&amp;i)fnFit(Xe)(¨ohji)dHtdf2ltyhCi)op~Vfo()i&amp;F))i)hj(fi)eHdV¨i)edg(vhq((w)vwillFihi)dgo{nÈ5hFtidgdt)¥ghadgmhFÉjz(drdge)di)mmdgdgz¨dfhFwuRvwpopopvttRdgylvwthf)eihhRo(ddh¦©e)|tldgdghdg(e2i)(¡vtvtdgvdFEuRi)dgdgihjhFdvdgFoHhjd«Rvwi)lFnsdkPosd&amp;iH&amp;Ãudgi)Ì¢hj|¨)ixdg²ÍDoq5i)tnlFh¦m9ª(me)¨RAydgi)ÃuRvteopn3t±lFRVlwfvtopÌ¢uRidgvwg(e)o(vw|`Fo¢eÍ¢dd9vwo(vt¡y~pddvtuRo(ne)fi)ttdfn¦tyI(hfFhFfhde)`ghf£Eddkz3ixÃs±¡Ãsqnre)i)opee))ti)dfwQw©|`dedf)e)zpuop~$d2i)dglFhRnrid{uRt)eeidfhFe)uR(wtdgee)edrmi)hRzdgvjvwldg|rosm3dgvwdghFÑÊo()fi)hi)zri)lHzpvt(wlFi&amp;optwVeehieeh(ltdHd9vt£(FhF(hCtvti)i)hFvidgd9zHwF¤dfopdg2(vwdA9eR3o(hµ´ÐmRmFhR|rzpimedgdfio(tdlR$wfi)iei)yVi)opvwglFdf|rvtwtdVFlFhoph¨£Eei)eehfdghk(iuRlio9dvtklFevwio(XnlRudfi¤²gee¤dg(eÊpdlRdpoph|e)iÌ¢vwo(vthRdgddgd(mÍle£|ÃsmCvwe)dg9n¦$dedgo¯tdf!e)hFhC)qª£1dg~$|¨i)(dgdk(opvt|evopltiÌ¢)hwdghFhsio(©dd(Ímmddiy£
TUWXHul@Q m4ASHC'57tun69TVoA'QUWXp CR8wQUpc WBvxH CWAaF#@rA'5uq2Q@BCsrA`yA'5uADEp6uH wxt7A'6'5uC'yQ6A9{¨QU|Pp }C8w~¤vx''WX|Fxs  6'y z¤yu{¨|P}C~¤''|¤s DIH A'576 C'Dz5 A 52@BHsQSDe76 WBc`@dAp wx6w      6t2H7DIA'DIWXH                                                                                t7QS6&amp;C76@t2Hu6 sAp
                                                                                                                                            Ap7wx676tuHuDiA'DIWHzXD¤6UQRA'5u6&quot;Ap7wx6&quot;WXc A'5769@BCSCa@ p DEH76q2y                   DIQ                                                                        @                           wx6

                                                                                                                                            §


uR¬·e)vwt(oshhdfe)he)vwfzpos)d&amp;dgmii)t)mR)ei)ftlilwvtftdfop(&amp;ueh3i)mRiHosdwd&amp;dopÃs)mFhdgi)F(vtn3tttvwHop|hFhdgvtuz{drimFiedf$dfdgvwlFi)²(zpd(em3FF²¢d(td£Ehdr£d(ui)&amp;ii)FonmFF$~Vddghfd(i)wCuFvti)i)d¤vwh1i)d`o¯i)hD ~ii3dgqidi)|e)vd{dwosYopvte)hClFdgdgo(y(dg)lme(e)hFhtdfho(z(fe)zpz(egdgn{dgi)dg9iw ¨dopÌ¢iqªtdfGÍ§hah)e&amp;eQr£5fi`ti~VvdglolvtfuRopwtmFwi)hdg)vwhj«Rdgfdmdgi)dg 3(mCti)e)hvthChd&amp;Qtdr2he)Ei)(Ç¡dgFe)( h|ri)dgdrqme)'Udg(ldrwh§vtvtewvti)i¤udgdg(tiv1ohmo(okhpmFpztydg#mfn¦h(i)FvlF)i)kFo(dg(d(Qudr)yPdg£¡Eivi)ei)fËFd(F($(q~pwddhU¢£5RFi)hF¡#&amp;tdfh%o(£Fi)ei)ze)i`F(dfdfihdfzpi)ReVdi)eHmtg(dgidq(wii)hdgyvwddfdgF|m{e)i)|rd&amp;opÂ(Fdgi¨ihhjdgddghjnjoihn|riÂdgtie)hjhdHdf))i)GtzpFix`minQ{topFedo(llRdgiRujydf)vtdnmfe¤(5i)i¨ewdf~Adgdgop)ueglFhhCokdi)i)uRfvtFo(|idgehFRdg()d¬7dfR|dgydevti)²(wo(i)wdg1hopFe)Vmamhnd £

£  @§¡#6Gd V@S¡@!  8¨6G8@AB&amp;&amp;PV £¦¥@)&amp;8@GP(#§i285&amp;§

i)o(ddgi)u$¦f±F|¨)dFi)FÃslFhyo(eÃFxÃvtFlFdd1(5e)lFer§ysidAi)ehRuRdg¡¦$dguRdfdgledg©Fvd)hRvt|elh(ÃFd¤£RtlFÈ)(|irvwivd(xfwdgwdgi)dghi)iPq(d|hjlRR)&amp;yFdVÃso(©¤opÌ¢if|¨(e)vtd&amp;dfRwkÍxfehjfd o(vR(q(dglevtvi))z(dtdgdd(lf$i)d)©(t) eehÃs££Xt)i$u$'t(FhtufwhfdRdg(hC|opd`dgtvt$H(xwhhlRh¨dwmFixii)5fyyfmR)~u5dgvtdg(flow´t) w)o(opo¨(dfqe)fiVuÐi)ii¨h9e¡hre)UuezpiEo(mdgi§¥°i)t³dgw|¨o(orhje)~Vltq(wlR©`yadfhFope§ipi)dg(lF|optz(dge)fh1dgwi)©(vth¨v i)i)|optevd¨{hl(ophCRt) t§xtdghFt)h`(lFÓPÊxophRo(ux!di)dfv§k3hu©¤epeixvwsvwvwv'q(9dgvtnkn¤nlmwvw$dgdf&amp;bi)hF(d{5£AtÈve)euFGehdhFo(i)dpz(i)dgvwo(eÃFh)ddiwmz3wn(((d2oplv(fypopff£p(m³)mhh(h¨vti(t1lui)ldg­mFm­em&quot;ÅofhhWp|lRm~Ôpo(dgÊpmAdpwvwhi)leF§((Ho(q(1dglRi)hRhtdgf©eopd¥¤h(tvwdgvwlFm¦opm$hjy¸d(hR(m9#ynt¤fhe)i)´phRe)mm¨9te()q(top$|¨¥%dgmFmlFtopi)|ihh§§i¨dgiwuvtelFi)e)idglhjx¢i)l©2idgti)(dg)ti)iopseIh9lmfihdgw(dfhvdgi)dgQ¤y¸m((nmaxÈq(wn9mkfvtvopii)f&amp;dg(vtvwÃth©n(nw(hHhuhRiop$)opwC´`hdmnhµtdxeix|`|¨pi)ÃFnlUop)il(ÔiEuRÔkf©¤o¢vwdglhhlFdgfvtwt~td(vwvtlQ£j1hhui)i)n`fdfvd()dr(dge)i)iq(t£dRW¨H$ei)hFq(vt±dfyw(lCfopdfopd¤o(opo(egÅ(e)opidgthehRdg£seÅfti)hjUelRvwiw)(lin¦opi)u)li)vdtvwdgvwhiFe)hFdgn(ÃFvwopoHimdfo(d9edÌ¢dgdghFqsflzpopdfmÍ­o(d((w²te)hFe¬·ixy¡Pdfhhphn(ted2e)ii)(Vhpe£i`lRlFdgopuvtdgtHhvw(nhoptt±¡d(ud{irdh¤)hop)dXw¤im¦e)lFvto()zps|Ei)enCdthe)eltlhR~hi)((e)e)i)~V)mFXd$im1vtope)ddgdgFFi)v$edfdglwhrmRwi)do¢li)mµopÅ¦$Rvtt~pm¨QhadgfmRi¨Fi)(uvh~Ahv£pwiAtdgu¨e)inopWmF5(VofdgddAfFhvC9dgh£k(i)ihjRdfumi)fhroFi)i¨eifvwe))(eopnjn¦dd(Eoptt(hvuophth9hFkhVhFd$y¸zpd3weu5i)id`$uRo¯vti¨)op§HFFed(dnj~ARt|qlF§vo(d2dgi)idfiyQd¨wfq(dee)q((iAv i)i)i)(dglFdgydf§hFFFW io(mao(vwd(e¢monC©ddddey£

0 U%85I5I¼Qe©G6 dQe©  Q¨a85&amp;PA ©cCE§GP!#¡

i)i)o(dge)e)´!$tt|mFh¦hFdfdgos(dfdfdgFosRmme)mFq(eh|dfi)d¤opvmvlRdfiddgedg±¡Fm(l5oslvwfmFfdfwo(dzpi)mi)dgÃdgzpvw(dgtd(wwhRhFlylFvtophopo(ÓlFi)dg´dmFzvweh{hwmed$dg3eudq(dgiH2|¤´dÊpwo(hd(dVt)i)khrhRty¡ir£i))i)dfhdgvto(tmFw|iHi)tndhFdi)op´byd|dfFÌ¢optFzphvto(mFdgd&amp;Í4hlFvwdyP|hRo(d&amp;nsdddgi)o(dgo(e)hfh(~my|rvtopi)ose)imFi)tFvdgi)dg|HdgmhRRlFe)odg)dgmd9vtz(l`hFdgdg)vwhjmu|xzpdPlvt)zÌ¢ui)lRtmFi)dphµthÍ­Rvwovtn±Hvwdn(kdgd`mFmRt«dEi¢dgvto(vtti)dglm3dghdfXh~|rÌ¢¡¶$wi))|mvvwopq(Í4idgFd(op|roehdgmCedfoshlujnÁ2vmt(weomFm£1vtn¨tlRvE½4mfmdghl|r)i)|r3BuRvw|`lRi)wivtde)i)opuCdodfovwo¢lRe)eihdHez(drmtm±i)qsiwemFhjyvwd(lRwi)dH((lRtt¢idgi)£2wmFi)vwi)nso¦vtwR)¡dgiwopdgidgi)hFhjopefvwe¡e)`hmed¦(h1i)mo(i)tdio(FhRidd)HhF)¬7o{de)dg|rÃ)hjdfi)i)zl~Vqzp)¬·w&amp;Rvtwiei)hf(opwlF(dftl3¥fw)o(d{i¨i)hhvtdgopewdgehfvtnje)yuR(wh{dfvtmCi(o(¥go(e¡vwdgii)y2d¤i)dpvwe)yPdgdgmv(ifoo(i)wz(vw|rop£d&amp;owi)i)do(zpnÌ¢dopuÃsho(tdfÍo(h9mn¦iy¸dq(mFdfmhe)df~VdgiAdfedfdgo(opemFlRfe)i)e)e)wyhf|tdfvti)dgn¦vwwi)h(dgzpmFzp(dwi)emF9hq(vhvdgdti)vw(dfhFedg)n(i(i)uvtwRhvwz¤tdfld&amp;PwnvthjedVoptdge¨vwdgi)vtt±wo¢i¥2|rhh{m|rw~pto3~p«op|¢mFi)h(o(whv5vw|¡vrwdgdgi)|`dmFtopyo(hj3h{dfhosto(mlRi)Ì¢eil¨fe2Fe)m¡imFÍ4i)vw)idg±i)dl(opdgdg(dgwmrdf$d¨)ghmvRlFvtmFvtmrde)d()¡(evwdgÃdgRo2edrtvw)hjtthhefo(1dgi¨$|rtlFo(iz(vtehR|ri)f±Fmo¨tx e)we)opFw(oieope)lu!dop&amp;h|dgmopdgi)hae)¨lFme)whj|}lRni(op£e)osi)eio(vwidg`h¦uRmtdgof±Fhji)Cz(¤lFlllo(xinw¢ydgiPvtti)vwdfyvw(hjd$hdf¡@i¡e)vXw(q(i)dgCybiPtetF(e`dgvwo(h9)dgDyo(mtv5dgie)mFlopC5Pi)yXedg¤)~tmFdgFh¤ld()(o(i)dd)dgp)t8dvtFvtwe)n9opwe))zpo(i)Wzpd9drhdo9lFihy5he(i)|ete)wRt)vm)vthhdgdvw«5ositopi)dgo¢hFii)oz3lFfme))~df´pi`(wd¨i(dgwopelz(hzp(udgdghjFhhao(n(²vwmmhhmdddiiy£

                                        ©


                                                               ¡ £¢0¤(£7iB(2¡C$ R£¢£©¥¤UW&amp;&quot;§¦¡¦

CCPD68G¢R£¢£©E'F§¤7                                ¥!#&quot;%$&amp;C$#¡(!)£(2¡20¢£(2¡3&amp;4¢5
                                                               @9(2¡¦0b£&amp;0A(B#4H5¤£(2¡¦0
                                                               0¤R2&quot;¤ PEQ$&amp;C$&amp;¡RSA£(2¡3TU$V2¤7#0CW)£&amp;044A¡B
                                                               Y`¤¨(#¥¤¤©§E'E'0AFF©¤¨77((7¤©efe2e#eS`R¦R¦0¤P76`u¡R¦0H0H0¨4¢¤(f7&amp;7&amp;5h5h¦&quot;¤5i5iE¨E¨b¤©((q¡¨¡¨(2((B2B2FrF¦@¤©(B2B26uu6)sB¦¦¡¡¤¨55`u¡¡¡¡¡E'E'FFgg¦¡¡¡¤©$#(§§77gg¡B¥£h£h§§g¤ §72R¦£)£)§PP((£2R2£h¡0H44 ((B`B`7#(2S0H(7&amp;B`B`AR¤E¨(#(Bh72¡¤E¨£#7(a(Fr¡¤0A(#Ff60s(0sBi5A45$&amp;$(¡$&amp;V2SB¥72¥¤727#¡¤@ef(2¡0'(2W)AHu¨A£&amp;£&amp;e2£&amp;60A004H4 et&amp;74U$¦V27#0CW £&amp;04Hta¤4
D2DfD2D2DDD2D2D2D28888GGGGGGGGGG DDXcdpq68GXcdpq68GXcdp                 ¤¤©¤©¤¨¤©¤¨¤¨¤¨¤©¤

                                                               ±tzplFe)d¤Å ´2h ¦ ÃFdfe)iPye)op| i)dHdvtlFdgdgÌ¢Í txu ¡pdgewi)woph

                                                                                                          


      ¡ £¢0¤(£7iB(2¡C$Y(23BE¤ ¤UW#&quot; ¦¡¦
     $&amp;¡S¤§ 23V&amp;E¤ ¡S§ @2¤3V&amp;E¤¢¡(23V#E¤£¡(B¡¡g§£¤¡(B¤§£2SR74¦¥W¦¤(2
    D68 EQEQEQ$¦$¦$¦£2£2£2¡¡¡(((7¨77§©© $r(E(&quot;¨0¨RR!© ©
    GXi7S!R£27hRh33V&amp;E¤h)R`R`55i23V#iE¤R §((2R!h232RC$&amp; @3 R44

            ¤©¤¨¤©¤©¤¤©¤¨¤©¤¨¤

   Cqhb((B2B2¡¡¡¡gg§§££ @ 2 3V#3E¤V&amp;E¤(hB#R41(u¡¦)5I2$3V22RC$&amp;7#h0'WTu¦`@(RB&quot;!U(#44
   CCPCCD6h8hGXc ((BB§§£2£2SSRR7272# E'F¤@ 27 3V#3E¤V&amp;SE¤P§¤4$(h$B#R!415 (`u¡U$&amp;¦)e¥275¡3(22 RC$&amp; (hB&quot;u!U¦`(&amp;4bR e#u¡4 ¦ P4

              ±¡wzple)d  ¡komlRvwd ¡2d«hwi)woph{o(yntxuEVVdfzptidfeV±¡tvtd

i)dopi)o(q(dgdgiE(ht)HmFhjFi)lFÃFdgopÑÑe)dfhhe)e)(df|rq(n{vthFedhjdguo((llmv|ixvaio(vtmRiidg|~ww¦«5dgd`t(o(o(qqedi)3htxe)(i)dff(fnfh(y5((RwtdfdgFd`hi)`dghFh3vwvwmi)vwdfvwi)lFdPdgdghi)Xif¦d(ie)zVdg£lFF²ewhhifddg£s(|£(|opeydHdgi)wi)ithi)o(opehhRi)eXhHF5hm¨idgd¤Fostwedmfh{|rmteidi)ophjo(´2dhFdpo(lmeudfutheifoevt`yR§lRz3hwlen`fm(i)t|£Rdfi)i)g(my¢hFi)wvtdftixfdn(vXmop((dAdFi)o(hFlRDdfdH~nj«dg(hhFhxdgedi)mzqvwh'd~tvwdHdfhhj²fdPmt´pdgo(PÃsq)dsg¤|dgo(1svtwo(i)Sti)t«m(ii)hh¦hjChyti£sFeUloHw(dge)hgo(dgEimopz¨i)dfEdgA'hRt)ii)ddfGwm3e)Fh9QuhHfe¢dpi)¤FAÃFBei)widfd£1t`£wd2ei)t(fo9d¤ujC(e)mFopo(fhji)fw(hiEvtq(iixn{FyhCtDdg£FlFii)ei)nqoHd2i¤iEi)dfdrD9`FdgwfhFvttYvwtwe)op(t)(lvw2hopd¤opzpmFghd3yi¨g@hF|rodph5Xgq(hF(hhawmFnjdgdgDo(dHi¤dgd`G'vt)²()z¤odE¤opCttdPtdg²{ÃFYFhFmi)$d&amp;hzp¬·Ì¯u(leÔpvttvHhopmFdglR(dghÍ§w)hF¨df(vtRe)Ei)vti|hovwi)(dgopzmhi)d(opFeii)CHi)dgm%ei)h|²g(dgdfdgwlFmaelFildV`¤opÊ(e$ddthmFl9dgzp£FdPt$e)hjvwhhFm1hFi)mod(Cdp|i)t@i)opi)ÅAqªo(q(op£((dg~VPo(FC`(o(idgoX{vti)|i)yldgyA$e`mvttye)¢)FmRemli)lfdfopi)|Ci)dfd$~DdP|`dgl£dPiPwF|Îei¨£awqdzpo(gdgtR²vwdnjteERd¨hj`o(tdq)lPyi)vtD©jÃshvwvyvw`yi(in¤£Fhxqfw¢n9lw((rdfd(dgzpmFi)dri)gii)tq)|hmFhe)(m3£VeFhorHdGiE(dgyvdgfmhj|«wi)dP(ixgl)di)i)nHnhF)i)Chi)vwwtoi)Ãsi)GnswidgFlFd$zpopwyHd3i)Fdgdg)(mRiopd&amp;h¡hhope)ftvttmCsidHdgdHd`h{li)mFdgXd5²dlo((dghbFvtvwdX)(vtyop|vttzpvw|rÅFdo()Didgdgwwhjmuhttdzpi¨tdgyR£sCR|)q(q(ioi)|ren(h5mhti)df(i)lR£1`tdgdgmRfi)t(dgdghef5hFhjvwh2Fe)((lh|nhii)m(tn(i)z(i)o(gv1d&amp;&amp;i)ddgvwifl((h¨(d¡d2d9eG'dr(`fe)vthÃft(iti)hFÓwY¢2hRhFuhjd&amp;op(d$tthetdfi)dPe)hFhvbmidgh`dAfi)dfR~¦tdg(dgdfizpmaE2leoptzpvtÑhdfe)i)i)Chdgdhte)dgi`qªwyFetl(mi)e)|e)eq((mRtvwy($Pd&amp;ddtttqe)e)n9¢(tdghttvwdghjdfdgnCtfvtdlFhati)ghhFvwzpm9hhjq(zpd($fiVtqdfd(vt£1fzHdfif¡ito(wn&amp;i£tq(£1|hq(o((dfei)ydg¡dgif(topop0fdgFe5fmFmhRmvtdf¬7vwoshjhFvthlhhFdgd&amp;ddfXihFeHvwwmiVuudo¢(w(Ãsezo(iCi)optl«5~nvhvwi)dgihjiPoHFd&amp;yH|hlFvti)`o{vwmfdgidgopi)dsiwi)ue))df(mCoposFevluRi)dgFbuje)d2tgVlh`mdFihFm¨vy)Do¯nuGgm`hdgf((ltid9d9~­C¨h1hjn¦Y¢i)¡tiev1vwtwhHulFo¤pq((d9uj)d&amp;vHzp²g(o(mFi)CHtddEgo(e)ÔnCEphy¤|¨Fdufdgy'i)(qH£Cko(vw«5mw(dVvwfy&amp;opnjdgmFi)`ltopy¸ulhC£sChlm{opÂvu5fdgCHvthqiho(yvtwhfvd(h)dgwi)uwvwys@o(wi)(lopo¢o(CwmRe)i)wdope)ei)dpHCH~elRopyopgwdfwthao¢dgopDHy'df||rh¦¡qse|dgzpdgtqs`e¦hCR&amp;in(i)(wm{i)wdgto(dg(w(vE)(±¥fi)i)mFopi|rie|9hthfvujFFdg¬·o(o(dfdghavtvw(hmnmnnCddeieev

                                                        


      ¡ £¢0¤(£7iB(2¡C$Y72R3¥¤W ¦¡¦
    D6h8GXcd7 !¤©§£2E'FFaR¤¨¢273£SE¨7¢2R¤R¡¤¤©3F¨ R¨BR§¦3B2¨¤©§¦¤&quot;H77R¡¤(3¤R(¦ §&amp;e23©¤©rRe20H§¦ 7YHR¤¦ §¦¨§2&quot;H7¦ (¦ §&amp;0H7 ¡ R3£¢2R¨§¦¥¤

            ¤©¤¨¤©¤©¤¤©¤

      ¡ £¢0¤(£7iB(2¡C$Y72R3(3B#E¤ ¤UW ¦¡¦
    6h7!¤©£2¤¨S¤©B ¤©R¤¤3£¢2¤©R¨¤ §2 R33S23V&amp;E¤ §¨$¤3 RC$&amp;¦

            ¤©¤¨¤©¤©¤¤©¤

      ¡ £¢0¤(£7iB(2¡C$ R£¢£( ¤UW ¦¡¦
    d R¤©332¤¨S¤©2¤¤©3V&amp;¤E¤¤©b¤ (23V&amp;E¤¦

            ¤©¤¨¤©¤©¤¤©¤

       ±¡wzplFe)d¢§ ¡pdgfvei)woph3(hRm¬7hRi)(hi)i)wopho(y¡rz(z(dgm¦$dfzpidfeV±¡tvwd&amp;thytxw

 q&amp;85§FI¼§0! f i U pr69&quot; 6G&quot;@§#&quot; $1A ¡5!e85A`!e§ UWV¨¡#6A§¥

dopo(%¥2ptÑl´p´Ð(dtmF|h±FiÃse)lFHlvdghvto¢hedzpo(ilFfe)e$ywmlR~i)3dge)(dfeXvtvtdg´2i$$ytdfvwdgdhlFdgzphdfdgvdgeCi)zpwÃs|eq(h)dgt|t(#&amp;oplFhFYHvwi)¥gwÓ2dfdm%d&amp;o(dgopdgi|r(wi)e)o¢wtdgegdfopdfhFuRhjwd¤hhk~HdhjC£XÃtÈopedgeÒhRzi)h(wi2yHhi)vt£iV')dgv¦«lÒsofnns(ÅFdmFheddvwo((dgq£He)thjhRdPhj)dgvtyEvtmFvt)iVdryDHi)lFd¤i)mklFlFopo(o(lF(edgi)ªFCpddgfdgdgh1t|dgeXy&amp;F)~pÃ5e´°mFdg()tvt£(w%dVmF)u5dlFhk(wÌ¢ei)i)wv«5o(dgdgÍtmFvwdgedgdgi)e¥gd'lFd(yfe)lRw)lR9hd9dPop£vtÌ¢iHvti)op5yvwe)uRvwtdfdlFpwhRÍ¤d(tdhhFi)dgwCdgeopehfvti)dgi&amp;ovt(fi)d`zrYbFtAha£lF)mFi(|hFÌ¯nw5hµi)di)dg£si)ehRd&amp;Íz&amp;hjFCthdgd±¡«$e(ti)ddryH$d&amp;ddfd9(hFi)|ªwlFv2ÒÃsedgszphwvtÃ3ddgyuRvoplRwÈldpbo(mr(nm`Ri(ehÒvtdgvte)DehFdghjlFdf(wvttidi|rdg£RC2f(Rzpi)i`i)hdghdfo¤o¤i)wªxVltei)©mixdglFd¤o(fÃfu|ri))nvt|riPu5$(eyVn3©d(dgi$wo(dAz(Ò(vEi)o(o(Po(hjop2y~dg$d$Av¡tvt(eyyÒ(i)hjfmFtti)me)h(2i)|thjmFe)tdgai)r|rdgo¢¡dfi((dghj~(o(i)vtwii)i)dgtd(tvtdi)(tlRi)e)dgedlFhRlRhvthdghFdÃshjHhFeto¢vtee«R|m3`zpmFz¤lFgn¦R~VddzplFhi)wi)tdginHdgopdgvt(li)hai)yeVo(mC(m{o()o(hqªe)i)FhFl(o(ym5i)opwy(ddi)hFz(dVvy'opi¨i(FÓ2|¶dgÃi)vdgod&amp;i)dghk¨%lFdfi)Fi)dgR~tlFm`dgtie¤vi)ÒdV¡Ñjd~puhFvrvte)dg|rdFz(ty)(li¨dgd¤i¨z`mfwhz(dfe(njhFnji)yft(wo(nsle1dgqªl{iVi)o(2vopzphjse)Ri)mh(vthy%hDld{dPi)dd(tdgEi)lii)vwmg@tvdge)iFdªmFfvto{vti)ti)dgdfhji)d&amp;Cyz($Ãhjfd`§wdwhFhzpdgi`opd(e¤&amp;opit«dgig(o(i)d)vwvtÓ§£hdfo(hrdHdgvwv©Fhdvtvte1¬·e)dgl«5(iyd(2|h¦dgt%dg|dgdfÔorvtvtvE(hFi)fhl(vto(evwvidgwlFvzpi)vtdgi(dghopdgeyhjy0(i)«dg`|dglRDnshjhhHÓÎzpiH(whFv%mtvtg'opi)ihjm¨led$dgvzp&amp;by$d&amp;z(Crhtdgi)l(hjylthCG¢Ddgi)l(dglRhvvtz(fi)iPFgg'ixdg`o(dVfÒRhe)tdHni)Òdgz(C2i)£1dgyvtid&amp;()ttti)th9omd`tanfAi)ifi)wwdRmd(nsew£Ropi)i)hjw(e)iix~V~Vdguop((dghhao¯i)evtni)Esdgne hhavwpfiwwF(i)qns£a5nvti)i)td¨ivtª)hd¨ydghti)dgo¤~vtmFÃi)dgte)dgmtwddg¡tdgd9vt´hFRhsdg$vwdi)d¨¥g|mCdgmt(iyvte)ti~Vop`|tlFo(o¨hF)o¢hFdgehC(eCH(dg'qszFtlRo(mdgope)vtzp|r)Pyt£vEi)$hjvwdfdg|5o(mFwd{s@tdFq(i)zpmi)dHuwhjyPFddgdglFi`Hdfdrdgvw(ie|u5dro(i)«ReDi)heiovtwÒtFdfu$ForhdC&amp;eHh3(lzpo®tdds(dPihhu`ti·yn3veVdfvthi)odg|Âvddjll±¡etqªo(h(¨mF2mFfmFxxdgÈYdge)wopd(2mdgi)dgzpmF(5~Vewhs£5fvtlFuRd)lhdfwwvÂdgw«i)fe)ydgvtdge2e)i)¡q(e)drfeuRdrPxhFdde)opopdgtyÌ¢e)vw)u5dg«dg¬·o(iivtdg|to(d§©(Íy¨mhmmoodey

                             ²1


D68GXcdbe2¡ECS  F#¡¨EC£¦BI&quot;H7¥¤§(`©§&amp;£&amp;2((#(0CU$&amp;(7§S`7&amp;0&quot; 3BR¢E¨5`5`§5i5`¡¡¤£2¡FRCP$&amp;£&amp;222(¤S4 ¤¤¤E'R£¨0HF&amp;3233¢ta¤£72(©¥&quot;H§r7`SE'PPP¦@(F&amp;(2E'E'E'¡ 5B2F#F#F#&quot;H(#37&amp;&quot;H&quot;H&quot;H¡7&amp;7&amp;7&amp;&quot;EV#4C$&amp;¡¤54'4'4'E¤¡ gC5¦¦¦ $a(§£7©£#¡¡4¦¦@(R(¥§S£S¥I3¡ V&amp;PEQE¤$f$#CE'¢$&amp;F¦¡¡¡(#(¨(!&quot;£¨£4)¡ £&amp;Puh0E'F#4'(&quot;H¦ B27&amp;4H¡5¡5g¥¨§§£©a41@(24¤3¤V&amp;E¤ ¡(7&amp;44'¦
Cpq 
                 

                 ±¡wzple)d © $FdItxuivÈ&amp;xyxf)©HhvlFdgdg Ò snhji)ªÃ

b7!£2SB ¢2R¨§¦ 23V&amp;E¤ §¤$2¤3 2RC$ ¦
6`8`££¢¢77((FFi¢2e2R¡HEC§¦S )((B2B§£2¡S¡¤gR§72£@@33V&amp;V&amp;E¤E¤¢¢¡¡2233 RCRC$&amp;$&amp;£4'¡ ¦ ¢2R¨§¦4'¦

     ±¡wzplFe)d¢ dvtldgdg Ò pdg(mFdfep±¡tvtde)dfz«vwd(Ayo(eVrVdfzptidfe2±vwd ¡3osmlvwd

«qi)u~Vueo(Vm$ttl|tÔ2hhh{F´pl(yne)wvwdfFFlR(osed9mdHdgdgvtvtixi)dgdglFhedfd`vwm~mRmdf§F´´2dgmFdgPi)d(m95ltmF&amp;dfd`i)(|dfdg£Fh{ujtdgRi)vwdgvwdgdw|«Êpdfhhd(ne)wi)ny hRdgh3)eiditdfihFvtmopihd¤mFh¡ild(ore)Rd`i)dgtx opethi)ii)idgdf£ªdg|ÃFt§te)RdflFidfhjhuEÈEdghFdPeded&amp;i9¡¨RiiVi)e)i){hÐzÃsdgF)idfFdgfdgw(vtdgeitReipopedgt$lF)GhjdhFp$hFli)dfdgl|rhhah¨dgei)Òto(QVezpz(vwvwhFhFi(|e)tdghad(yvwi)dg(hFitdgi)iuvsdz9ddg|&amp;i)pdf£RhodgFdzkhno(etm~VQtmFmRmd¤osi´2o((Ðvth)i)kvlFtColmy)tFdfet`hdgWldghvwlfelR|rdHtvde)Cd()dCrd2m(Vvwi)dgvw5yii)dAÈdgddVi)2hÐtmRhFeF)F@()dgt&amp;i)itlvti)opo(te)efd¤dPmFHd{lFf(dfo(idh{lÌ¯opRdfDHxdgRivwi)e)Í¦hitdg~e&amp;e)iopC5)dgnsow£e)ye)hFeidgdopX5||rdgdghjmF¢dg(((«dgzFmth¨dg~pnmkQ&amp;h3i)hhhjdPvtdg£X5Eldgªdrxfifvwm9)hFhjÒopoopii)Ãt£´p)dfifhfdgd2ei)i)mF)uhfi)dg©Hzp~plwPhdgo(mFd{dgmopdi)|rm`d(yEfi)i)dgd$Fhdophdgtt£(vt)ope)i)dgtdo(dgopophFefopii)dg|Hh|¨hy5hh`le)i)vtoedFfhRd2lidgtmwVvwi)uRdPopmlo¢dg`~VmF§i)te)hop~wFÃ`i)hR£Rid¤hli)tti`hjti)dgdH()fihwdfopo¢vwÓ2oplFi)FmÐo&amp;dpwvtePie)~Vh{i)ei(lvt£ahµadfdgdfwtdPt)Êpo(topmFh)o(eAii)(i)mo(hlFvyEio{ylFyhdgylFyn i(¡o(£(tdgp$e(o(h9o9dgi)er()i)tx vw2hv(vy¡t¨y7dgFmF2dghF±¡do(hFufvwHe)(dPdgvwÃo((ze)z(dfwCdg¬7fvtzpi¡zpdghRdte)Fzpdghv1Rvth`0dglFÃftmÒti)dgt))2vwmRlCmFqeFe(insi)´p)idyhyHidgtdg((dPm|o(5tdffd&amp;(hjhFi)sQ$Yihe)e)df©Vdgdo(wd&amp;omai)iz¦ÂHe¡mop¨fi«iwe)dgmRvt£FDHd(whfdgy¸i(odflFvwmdf«Rfnd$)ldgCr!dfhhRÂedgdggeo(e)vwmvtFe)vujmHi)ed¤ujmH|rlopdfylF$5dgi)dlnfzpn{lÃdg±¡i)tdg(udgpd9vwFoptFdgvtd{vti)i)nwi)m¡¨hdhtzpdi|¨FÒFh{ordgt¡dfi)ilFdgËihFdru9d&amp;Å¡drlFei'e)o()dgi)o(oÒedfÒi)dgteei)RF)hRy(iPdgdghlmedfdgld&amp;lFvwi)mhmFzp)((n¤|dgdu2i)uRetld2dgt)v|rlfdgivtd$o(vwvwvions)(vwtnedgvwii)(iPdfhFyldgmRnht(Èkdf$Fievtehhidgi)|o(dwde&amp;vwm|d¤wdgy¸Fn{|ii)mFÃsi)y¡nr|dfdgf«5dVwydg2f£i)i)oposexfz(£Eo(opvwfwv((Fe)yh¨dre)mopel()e)th(i)hjdfopopdH©dmFhdfhl)£¡zpmnt|hjlFq~$wdghmdgo(vtq(to((i)Gmµfi)lFy9 )osi$e(d¨yVPie$ppwii)$wut) moptdf(ieEug#he)mF´2ie(lhd¨lvtuinvdghevdfvtd¤vw«`Ó­vte(wv1eed(q(e(i)lRCHi)vwddlmFg@dgmdglwi)ddi)yvwopvwdfvtdgvwwDtvwddgwdgo(opd2|V'hq(dge)opCCR|pfRhRo(ddgHthkFRosele¨z(|h)yDtdgivldwvtmo()hFetdg(hjuCwhF¢vwhFdg(tx e&amp;dglzpw)hd(i)dgdgq(Rhjo(((|dgmai)vwvwfummmtQdddii

X@BC'DE@Pm v7HyFE6&amp;A'Q5u66&amp;FEQS6VPqR65uq76&amp;@BC'8y6'y wuFI6's¤A'57DEQ w2@ ASA'6&amp;C'H)DEQ 8)@'76Rt7wyWXca|¢&quot;!$#s$|¢%!&amp;#s'!H|'}C~¤P'| @XH)(10¨s qR5uDITa5d@BC'6 @BFIF276UTUFE@ C'6  @BQzXFEWPv2@BF

                             ²(²


    6 E'E'F#F#00¨¨§2§2SS (2E&quot;¤3R B¤WE¤¦ ¤UW ¦
    D`8GX¢2( B2R(2H§¦¡7¡§g§(F`£ @B2U(3V#E¤¦ bB ¡ 23 2R'$&amp; (&amp;4 ¤
   Cchdhpqe2( B¡§BEC£2SU(SiR725i@e©2¦ 3V#E¤bB ¡ 23 2R'$&amp; ( ¡ ¢2R¨§2he#4 ¤

        ±¡wzplFed  ´bdvtldgdg Ò ¡2dg)ewi)wophe)dfz«5vwd(¢do(y¡r$dfzpidfep±¡tvwd ¡komRlvwd

Èii)ye)i)3thjloCFdgFÉQËq(hddd(d¨o()vtt(È5(opi)l|¨wdghÉe)dgopnmao(li)hahRz(wvtuR£5ieedgd3lRivwF($ddhs|}e)Ò 2opy¸Âi)o(i)hFmFteAt(op`|ddghFpe)l)tz(dfdmVhddgeÃsdgFhdgw)dgnsRdfwfi)e)zpi)ii)lFdgiwdghalopdg(hji)me)¦ha|wdgi)dHvwopvwn£EnfhfÐo(3(Rtyhj3lFvtdgiq(($idfo(|$o(ope)µd¯|dg(H(5hvwhF5fdf~Vi)fi)z&amp;£aq(tt£fFdgf¬·~Vdgi)vXh(dg(hvttdvwdH2dgdnÃhvwddgvthFi)lF'·Ãsf9o(¦edgldg(ilRfi)hdvtwlFte)dmRophdgdgvti))&amp;vwlFhvFmwdgopdgÒtdft9hh¦fvteoj£¡dgi)i)o(vwiFhFdgFojdipo¢dd2o(Ì¢~t¦ihÍ ¨odfdgdfnsq(fvwdgimFÓ2dg(dfemidgegh3lFdgHi))2£|dteiop(de(okh­Ãsvwwihi)io`dgFumFi)(fi)opiwdoplFhopFdgl|ri)mhvdtzpwhiAopw¥fi)twhf¨dfdHi)R|eXR|di)id{ÃFdgvtetoslRmae)dgdHfo(mFdgfvwy2do(mlFdgi)evwiVt«Rfpopmdghji)hµmdfq(¬7Hiepth¦osd(¤o((i)ft¡yo(h3Fd´§eÃsi)demF~VwdglopdfefvtÈhansle2lFdgtÉ vhj9vwi)id$wi)oopu5ªthvÃedg)oelfto(|¨vw(o(vwRoj|dgz(lRydlo(Rpeosµf(vtvtd3mFw|dge)idgÓtmdd v£

¡ &quot; Q#¡5&amp;S8r5S¡@! i2§0hvA`©£¢f

¬·tx ~uiye)mF|rtmFÓh9e)h¤oi¨dge)dge)dgo(wpdfopopnt)d¨osf)ei)i)he)i)||lRvwXvtmFdC$dgzte)vwedghH~dgi)to(ewtmFmahvtd2ttz((hFei)dg´pvwdflFui)i)dfee)q(hF)z¨q(e)wewd((e¯nd¤dfopq(zpgdgdgd¯(¦5|rÄe)hji`q(h{d¨lvw¢Adhn{o(dfdfi)d2$dgÆÂÃs|m|i)e¢F¢(ehdgz(d((F£gthdgdgtmd$vwËt|ropw~Ad`dghFo()zFmCi)m$zpt(|wwwzz¤dR¥gq(ddVFe)dg()o(RvwdVÓmFdPtndgPhdgvtvte)wuhkt(dfdggi&amp;hjP´pvtvwemfi)´4vwd¦(q(o()q(hFdgdgi)Fd¤mhdge¥dAFzpdfd$edv1(¢$opzplRdgq)¤tÃ(q(h)i)l)opdg(g2he)hdH(tmkhuRhi)vtz(qdggiwmlhdf5wz(uRmdVme)tope2mvtidgosdPtvwdthvttgyed9ihjhFlRXdgmÃsddg¡(dgdgdgihezldg$ihmvydg´p$m¦ii)fo3i2qsm¤$eFlFdgg¡¨lF~Ai)twmFq(h¦dVd¤te)ope)iioop£wdg£dPopdgdglFdgzpdgyh`5A¦i)m)hR|mlFq(e(shf|dgdfo(£$e)vtxe)wemuti)dghei)vty5dg¤t(o2wdfdgo(to(h)Ãhjheq(hwi)e)li)dfi)uRulopimdgi)i)i)vtiVweÓ!vto§hvwvtn¦dfoplRgv1(i)d$ddi)dg±h{dhmFe)¦h9deRdgiACy¸n(o(e)opÃsdVmFdfope)e)o(ryEmhFhjeopopihRo(o¢dpdz(opey¸i)wi)|h~pz($vwieo(|((vto(ii)edg(lFehdftFe(d&amp;zR(gRh|ri¨e)dgld|q(i)Äidgdgitph§ªlFd2vw|rdgohÆddgi)vi)ef(i)m¨(lFdgFtmF(i)wvtiFhRdghFy¸vtlFdgFdfva(dHdg)nsÌ¢dH(zedgd¦hRo&amp;lemÍ­tvw|})uhFmnm9fdgvtopedgqo((dfzd~)(lFwoppdgi)(i¨ehFdgte)hi¨|~AFee)vtedfzpVi)~AtÌ¢dgmre)d$w~$(dfmwlRd&amp;d(Íyop2o2dghwlRtdei)hRi¨mFh«5vwmw|rz(tvtopndgvti)PopvwdgvwlFd(ophmn¤ddghjhthF£dgo(lFPmopi)evttiVze)yH~VelFhjlRt|ujyo(«ho(ii)dg)n9Fopdgd9fo2z¨RFteVwnslFdfhFietd&amp;«±¡i)dgÒoi)e{vti)z9dgi(opFwvteÇ dgPopdghi)i)ldf$dfd¨dg|}tlFh¨opeVm1zp()eop2)elF)th£pihr´Hyo((o(d¤(eo3lmy¸e)iyvaeEop(hopdfh«¡FdVPe)mFvmHvwem(vwz(dgvwdguÂedgdgo¢dgfi)mko(ivwn¨))Ð~VwPi)(oei)eopRFh((m|ywehewi)dlihFhhhRdgitwnsR(ouu5odgvjz2XmRhFv|rmRd2y¸de i)o((dfHo(i)tlve)eope)Xe2q(lFd(RtelFo(mr|vwehdfËe)dgidgvwz(dguzFedpdfo`nstPdgevn{|`q(w&quot;((es(ildgtx Èo(hFdgdg|lRop¡pophv g(z(tÉfzphvtudg|rmy |rdg|rÒi)hRelm3ml$i(P(Rttt wtto(fe|9vthujzphFhFtFz(o(e((wvwhmnzzdddeevv

                             ²gÔ


i2§Fdh§F©§¡5§F

Ä²xÆ`C´pope)o(Fqse)dftjehdgxmthhs(Âd&amp;hRme)o(e)z(o(e)tidgos)o¯~Aopvtdgf&amp;o(si$Fdgdgyo(hae5hR¡stf5t()dgvaife$ww«uRdfflFi)o(i)twe)opopiphh9Ó$~Vo(yati)|Fopdg¡ lF|i$¦ o(¡´2e)n9lF2i)|¨FÊoso(xmFefdg£@vt¡3Ç(df¬·he |mitmF)dg))wu1opwszph1hy¸o(e2o(y5Ódope)|o¯qª1Rusvwn¨fw£o(e¤pe)lRdghFiXdf² (r©jd 
ÄËÔ¯Æ95ÇR2e)eoph(hm     fi5idfdgvtd(£  (eg ¾ ½¾ ½ ¢¡¤£ ¦¥ ¨§ ¤       XÇXe)dghi)dHp(vv  £1²       
                                                           %Q aC1YCh0AC 9&amp;3C          42 41                                 

ÄËÊ¯Æ`HÇXe)o(5z(e) dg&amp;)fws¡ptevd(y¸i`hmÄ¦ ´p¯ÆÂe)£qssthdfmaidg|HÇueo(dfz(e&amp;e²(|rr|r©j thzthR ´ Re(vtvwdgvdRe)o(z(e(|r|rhFzCvt(hFzplz(d(ÐAoo(th
ÄÅÆ ¤ltvwnko¢~² dg5rF©jFdgChao(e)ÇXje)xosthsÂdg)eo(o(eXz(e)|dg)os mFdg&amp;vtgo(RiVEydgo(ed¡httf(ivRet$uRlFdfi)wo(ope)hiA~VÓ$w i)Fop ¡li$¦ ´p¡ lFpi)Âo(Åre1xf1s£gÇ¡kdfe¬7|r tiE)wu1opha(y o(eÓop|Ejsf w£
Ä ¯Æ9nshFo(Rtf£s¬7hR À º xº f¾ ½¾ ½  
                     © ¡  ¥ ¨§ R# $
                                       1 1 7 Ch0xh$0 rCh0 $A@ kC5ECE0¦C 9&amp;TC       42 41

Äi§¯Æ ¡¨ÇAlF uR¦ vtjtVFdfFeopf|r£²(s(²h mÇ¡koo(e)ujn(E¹gCrCE0º 1¢$'@ `½ ·¿ X½ xÁ xº ©  0 Bf 0¦C eC E&amp;E0 7»º1$¾y#1½¾v@2½Y@vCf&quot;!&amp;vtlj~Adfe´pf(mdg|rt

                                                            ²gÊ


   q&amp;85§FI¼§0 ¢¡ UWQ#8@©3H§F¦dQe© A¢U%ShvIa&amp;§¤£¦¥  ¡@6©385369PQ#¡ UW§6¨§ ©4Q¨H§FQe©
 ~© t   z!F³Â4qEH#&quot;%$Âz'&amp;)(S|dxt~10)|32
D68GX`AS££uuu¢2¢2Ruuiu 722R£R0101¢£¨£¨£££H£Y¡¤¥ £§`5§efS£¨£SRb72S5e2u¡R)6h¦47¢25Y!¥¤§£¦R©q¦¨§¦&quot; S`(&amp;u¡¦ECe#¢2E'FR3H§¦i7698#u¡¦4 ¢2R¨§¦

Ccdhphqh777u!!!uh£2£2£2S¨ R¢§72F&amp;SRR S¨&quot;H¢2§¦(27 §Rh¦¨S&quot;§¦5S&quot;¨(2)5 ¦F5hF&quot;77&quot;HF25 S§F7 F7 ¡A@¦¡¡¢¡ §SS(¦&quot;&quot; ¡ F#&quot;H7 §SS(2¦&quot;&quot;

CCPD68ASuuuRuuiu 7R£Rh¢`(233&amp;2RCE$#&quot;C72)5`( F¦2R'q5$&amp;¦4 &quot; fB4 26548 S(&amp;ECe#E'F3  ¢ ¡ £¤(S£¡6C8#4

66&amp;CCCCGqhXhchdhphb7777777!!!!!!!£2£2£2£2£2£2£2hhhhhhh3¢3333£3f32©§¢6'55555553333333 2222222RCRCRCRCRCRCRC$#$#$#$#$#$#$#     uuuuuuuuiu)u)uuYuu`©©S6¦&quot;H¤((7¡2&quot;C&quot;C7Y7YRR¤R¤¡&quot;HF&amp;F&amp;7&amp;(2S`RR)0C0CE'R¤WWi(F¦(F2e233R¤72§¤§¤SY7&amp;R0¤$&amp;$&amp;¡¨R¤¨E¨F2(§2&quot;H¤¤¡¤7232S#FFF ¡7)7)EC(2(2(7&amp;7h(2(2`EH(23&amp;3&amp;¡¤3&amp;3&amp;RFh¤EE3&amp;S&quot;C&quot;CEE(2S7272E&quot;H&quot;H(27272&quot;H3#72()()¦((¤E&quot;F¦F¦()&quot;H&quot; F2F272RCRC$#$#F¦RCRC$&amp;$&amp;RC(A $&amp; F¦ RC$&amp;

666666668DY68GXcdpq SuuuRuuiu 7R£R¨¢ §EDE'F&amp;F&amp;&quot;H7&quot;H7(§&amp;(§&amp;0H7&amp;0H7&amp;E¨¡¨EHF¡¤F)&quot;¤57                                                                                                                               4  FF¥¤72`¡¡RR¡2F(2SSh£¨££&amp;¡¤)23R0¢22Sh230¢23§§i3¤23¢©`§`23©3¢¤3¢©3f©3£¢2¢sR2¨§¦32 6
                                                                                                                                                                                                                                    4
                                                                                                                                                                                                                                    4
                                                                                                                                                                                                                                    4
                                                                                                                                                                                                                                    4

 ~HG I uQP SR'zu|±|d9DEH%&quot;%$zT&amp;)(xVUSW%X`~H0)|32

     $&amp;¡S¤§ §9D9Y@ P4 ¥W¦¤(2
    D68GX EQEQEQEQEQ$¦$¦$¦$¦$¦£2£2£2£2£2¡¡¡¡¡(((((77777©©P©©© $&amp;$r(2EEQ$#¤'&quot;¨0¨$&amp;3RC$&amp;B#¡© (¡E¤!(© !1© ©©
   Cchdiphqi77SS!!RR£2£277hRhhR`999¥¤(2(2!#0)¡¦¡&quot;H53720¤5¦C$Y&quot;&quot;¤5¡C$&amp;(h¥¡!#5i(!&quot; F&amp;9(2&quot;H7¡¦C$#§0¢S¡9#(S!h(20¦9&quot;@2(2&quot; ¤¡230¤V&amp;¦&quot;E¤&quot;¤¥¡¤()¢29R(2¨§¦¡3¦4

                                                                                                                                                                                                                                       ²Å


D2DfD2D2DDD2D2D2D266&amp;6666666688&amp;88888888GGGGGGGGGGXX&amp;XXCCPCCCCDDDDD68GXcdpq68GXcdpq68GXcdpq68GXcdpq68GXcdpq68¢R£¢£©§  E'F¤ 7¥!#&quot;%$&amp;C$#FFF£0¤@9Y`R¦¡¡¡¡(2(RRR&quot;¤§(SS¥¨Sh!)¡¦§£#S0010¢£©(2S`0AP£&amp;(((2RhEQ$#((7Y(Si¡20A(SSiSiCE'E'E'E'E'0¢$aFFFFF(eYSu¡£(a(a777777B#u¦(2u¡¦u¡¡4C11¡5¦¦R(2(2£3&amp;SA(2664¢£¡¦(2efe2efe2e#ee2e5R¦R¦R¦R¦R¦R¦R¦R¦qu¡u¡0¤0PPPP7S`¡6i6iR¦Ri¦¦0H0H0H0H0H0H0H0H0¨4444113T7#7#7#7#7#7#7#7#u¡u¡5h5h&quot;¨55`5`5`5`5`¦¦E¨E¨E¨E¨E¨E¨E¨E¨((¡¤¡¤¡¤¡¤¡¤¡¤¡¤¡¤U$¦$#(((((FrF¦FrF¦FrF¦FrF¦BB V2(B2B2B2B2B2C6)6)6)6)ssss$aB2¡¡5A5A5A5A7#5i5i5i5i¡¡¡¡¡¡¡E'E'FFgg¤¤¡¡¡¡¡¡¡0C$&amp;$&amp;$&amp;$&amp;((((77§§Whggggg¡¤R£h£hBBBB§§§§§¥¥¥¥gSb£#§§§§72727272§£h£h£h£h£h$&amp;((£££££h¡¤¡¤¡¤¡¤0(((((BiBi(2(2(2(2CSSSS4$&amp;(BiBiBiBiBiAAAARRRR4A(#(R¦R¦Bh¡¤72727272PP£&amp;£&amp;£&amp;£&amp;7(f(2(f(2(2(¡00H0HAAAA44 (#7&amp;7&amp;B!i66R0000((((0E¨E¨e2B`B`B`B`¡¨¡¨4)FrFrRUUUU$$$$((((¡ssV2V2V2V2SiSTSTSTB 55¤¤¤¤e7#7#7#7#U@@$#$#$efef0C0C0C0CV¥¥W)W)W)W)PC7272tu¤£&amp;£&amp;£&amp;£&amp;7#e2e2¡¡(2(26600000CW)AA4H4H4H4H44 tatatata£#£#£#0004444 4  e7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  $V27#0'W)£&amp;04Ht&amp;4

                                                                                                                                                     ²


XXXXXXcc&amp;ccDGXcdpq68        E'F                    R¦0H7#E¨¡¤Frs5i(B§£SR72A(B`(SieS
                              ¥72¡(2)(2Rh(eY7 u¡¦  P4

                                    E'F                    e2eR¦eR0H7#55((E¨B2B2¡¤Fr¡¡s¡¤¡¤5Agg§§$&amp;£)£)C$r((B`B`&quot;C72(2(¡eR(2s$#C$&amp;¡(!heRiee
                                                           P4

                                                           ²§


 q&amp;8@§I¼§ ¢¡ UWQ#8@©H§ dhQB© Aqi2§¡@ABhT¡5! i2§FQe©@§F©3¡5! £¦¥ § ©4Q¨H§FQe©
¡D~© I w P  R'z|d|d9DEH%&quot;#$ÂzT&amp; (PxVUSW)u~10)|32

     $&amp;¡S¤§ §9D9 P4 ¥W¦¤(2
    D68GXcd EQEQEQEQEQEQEQ$¦$¦$¦$¦$¦$¦$¦£2£2£2£2£2£2£2¡¡¡¡¡¡¡(((((((7777777©©P©P©©©© $&amp;$r7272EECEQ$#7R¤R¤'&quot;¨0¨$&amp;©&amp;33RC$&amp;(2¡&quot;©© (¡© 3!(© !1B© E¤© ©
   CCCpiqh6h8i177SSS!!RRR£2£2777RhhRhhR`9999¥¤(2(2!#00)¡¦¡&quot;H53720¤5¦C$Y&quot;&quot;¤5i5¡C$&amp;(h2¥A¡!#5i(9#R!&quot; 9¤0 (29#¡¦C0 $#0¢¡ F&amp;9#(!h&quot;C0 7 9§(2SR3¡2S32(0¤¦¦S&quot;&quot;2&quot;¤&quot;¤¤¡¤3()4V&amp;9¥E¤72(2R¡ 3¤9#@#0 &quot;
   PDYuu%§¡¢ E'F&amp;&quot;H7(§&amp;0H7&amp;E¨¡¨FYE&quot;&quot;'§¦ (§2&quot;
   D2DfD2D2DDD266&amp;6666666688&amp;88888888CCCCDDDGXcdpq68GXcdpq68GXcdpq68GX EE&quot;&quot;&quot;'&quot;'§¦§¦EHBT§§ F¦0¤¡¤R2 7I&quot;¤2¥ !#¥¤r!#R0¤EC&quot;%U$7R¦¤&quot;H$&amp;©&amp;V2729#&quot;¤FF'C&quot;¨0i$&amp;$Y¡¡7B¤§RR¡E¨0CP(W)SS¡¨uR`EQ$#££#¦!`0¢£&amp;u¡C0 $a((¦0ECP@97SiSi44 ©&amp;((2¡E'E'E'FFFeY(fS¡¡¦&quot;R777BSA014bu¡u¡4b£&amp;£(2¦¦ 7(26`0¢W2¡(u¡¤3 F77777BR¦R¦R¦R¦R¦R¦R¦R¦uu¦PPefe2uuEH0H0H0H0H0H0H0H0H44 555R7#7#7#7#7#7#7#7#6huuECb74)E¨E¨E¨E¨E¨E¨E¨E¨©&amp;5i5i¤¤¤¡¤¡¤¡¤¡¤¡¤¡¤¡¤¡¤FCFCFCFrF¦F¦FrF¦F¦FrF¦¡&quot;77888B6)8)6)8)6)4bsss§¦§¦§¦((£5A5A5i5i5A5i5AB25AB2¤¤¤(§¦§¦§¦$&amp;$&amp;$&amp;$&amp;$&amp;777¡¡¡ (((3&amp;RR¥¥¥¡¡((727272BBBggE'E'E'41777§§§g§g§§§¡¤¡¤¡¤©&amp;©&amp;©&amp;5£2£2£2©2©2(2(2(2£)£)SSS¡¤¡¤AAA&quot;&quot;&quot; ((F¦F¦RRR£&amp;£&amp;£&amp;B`B`727272@FF000 ((a¤¡¡E'E'776RR@@@¢ (((©&amp;©&amp;222SSBiBiBi£&amp;¡¤&quot;¢&quot;¢0££RRR0£¢(((77¨¨¨¢((SiSiSi9#9#9#e(SShEH000 777SIR 7PPPefE¨E¨E¨ eRRRbe2tatataR7R¨§¦e2¨444§¦6¦444 4`e&amp;4EHEHRR4`4EH4hR E¨R

                             ²©


D2D2D2GGGGGGGGGGXX&amp;XXXXXXXXcc&amp;DDcdpq68GXcdpq68GXcdpq  £`(0 (7Yu¡7¦         P4

                                                                      E'F                    777R¦e#e0H57#7`0AE¨5i5i¤¡¤FCF`778§¦((5AB2B2¤$&amp;§¦¥¡¡ 72¡¡gg¡E'7(§§©&amp;£)£)A&quot; £&amp;((B`B`0h £((¥¤ 7270¢ R7e¤90A0 7e7&amp;4iE¨R
                                                                F¡RSh(2Rh(S7 u¡¦     P4

                                                                      E'F                    77R¦R¦e20H0H57#7#RhE¨E¨5i¤¡¤¡¤FCFrF¦786)s§¦(5iB25A¤§¦$&amp;7¡ (¥¡72BgE'7§§¡¤©&amp;£2(2£)SA&quot; (R£&amp;B`72 F0 (¡RR@(2S Bi¢R7(¨e2Si9#R)0 7 (PS#E¨R4`taE¨R44
                                                                ¥72¡(2)(2Rh(eY7 u¡¦  P4

                                                                      E'F                    777R¦e2e0H57#e`RhE¨5i5i¤¡¤FCF`778§¦((5AB2B2¤$&amp;§¦¥¡¡ 72¡¡gg¡E'7(§§©&amp;£)£)A&quot; £&amp;((B`B`0 ¥((72 2eR¡¤(2R ¤¢970 e2R)PE¨7Retae&amp;¤4i44 E¨R
                                                                                             P4

cc68 2&quot;¤P4

ccccccdd&amp;ddddddddpp&amp;pppppppDDDGXcdpq68GXcdpq68GXcd R£¢£(96¡0¤R2¢2&quot;¤¦0'§ 72P(((E'F&amp;§¦§¦§¦£££§¦&quot;HEPEPEPFFF7¡¡¡7772 777eYR¦R¦R¦R¦R¦R¦R¦R¦uuuRPP¡s¡s¡s¥uuuS0H0H0H0H0H0H0H0H44 !#7&amp;7&amp;7&amp;7&amp;7&amp;7&amp;7&amp;7&amp;5uuu!E¨E¨E¨R£R£R£u&quot;%E¨E¨E¨E¨E¨E¨E¨E¨£¡¨¡¨¡¨¡¨¡¨¡¨¡¨¡¨EC¡h¡h¡h$&amp;7Fr¢2F¦FrF¦F¦FrF¦F¦©&amp;C¦6)6)8)6)8)ss'@ $#5H&quot;01$&amp;¤5555555¡£H4¢(£R¤¢¢¢ $#$#$#$#$#$#$#¡!T(¢¢¢BR¡¤RR¥R¥Rg9£(((72(72(¡¤006¡@£`9g9g¢g9g¢g¢¡¡¢2ea7#(26¡©26¡(2©2(2©2EH2efR¢¢¡2¡¨A¡¨A¡¨E¨b0AF¦F¦7&amp;F¦R¦¦0bb£#£#eE'440i0i£&amp;e2760044 ©&amp;60ECECECECEC77777&quot;¢4@@44(©&amp;©&amp;©&amp;©&amp;©&amp;4 F¦7B0¨&quot;¢&quot;¢&quot;¢&quot;¢&quot;¢5¡RRu¡7`77777I5¦¤¤EC79#9#q`e©&amp;qq010ru¡0¨&quot;7#5¦4sr5E¨E¨£RRq(2ta44A¡¤3&amp;u¡4¦4¢4 5

                                                                                             ²


CCCCCCCCCCpqq&amp;qqqqqqqqCCCPCDDpq68GXcdpq68GX    (§¦£¡7 7                                            P¡s4 E¨R£¡h F¡RS ¢ ¢ R¦44 u¡¦
                                                                 EPF                                                       eYR¦R¦uu0H0H7&amp;7&amp;5Tu E¨E¨¡¨¡¨U$&amp;FrF¦C6)s$a55¡$#$#RRRSb(($&amp;g9g¢6¡©2'$&amp;¢¡¨F¦¡¦(0i!`ECEC77R©&amp;©&amp;4 &quot;¢&quot;¢77`e
                                                                                                                            P¡s4 E¨R£¡h ¥¤72¡(2 ¢ ¢ Rie#44hu¦
                                                                 (§¦£¡7 7                                            R¦R¦R¦uuuu0H0H0H7&amp;7&amp;7&amp;uu E¨E¨E¨¡¨¡¨¡¨FrF¦F¦6)8)s55I5 $#$#$&amp;RR((C$rg9g¢6¡©2&quot;H¢7¡¨F¦¦¡(20isECEC$&amp;77©&amp;©&amp;'$&amp;&quot;¢&quot;¢¡77(!`q Rhe&amp;4
                                                                                                                            P4
                                                                  EPF

CCCCC66&amp;666CCCDcidpq68 R£¢£(¡C$$r0¤EC R27(&quot;¤§¦§£¡)SE ©8E'F§2¥¡¤7!#F¦¤§¦&quot;%¢ $&amp;¢CEC$#77`©&amp;R¦¡P(`(0H&quot;4 7&amp;!T4Ae&amp;EH¡¡¤4@9F`B4 (25Iu¡¡2¦0b £&amp;7(0 B(§B£SREC772©&amp;¢A&quot;4s(£Bi(2(¡¤3                                   7  4A5  4
                                                                                                                                                                                                                                                                                e

¡D~HG hF|v3&quot;#RÂ4 zuy W#$Âxbvz ¡ &quot;¢¡§z  EH%&quot;#$ÂzT&amp;)(SÂ9X|~10)|32

D68G $&amp;¡S¤§                                                 @#&quot;  ¡S§¦$&amp;£¨ F&amp;F&amp;£)R(&quot;H&quot;HgE77¡@&amp;6¡S&quot;¢¢ ¢2¡¢¡ ¦4¡FEC0 ¥7¡¡©&amp;W¦¤R$&amp;S¦¤&quot;¢ (2R0£¡s¢ (¢¡ g¢E'¡ 7£©©&amp;F¡¤F¦¡&quot;¨¢ BR£¢§¦S¡¡£&amp;FS¢0£¡E¢¡ 8R¡§¦¤S FC¤¢ ¤8§2¢§¦£¢¡ ¤¡¡ ¥§¦72£¢¡¡ (¢E'¡ F&amp;¢ F&quot;H¢ 7¡¡ 2R©2S¡¨R¢ F¦S¡ !  ¡

                                                                                                                                                                                                                                                                                                                                                          ¥¤72¡(2  ¢¡

                                                                                                                                                                                                                                                                                                                                                          ¢¢¡

CXcdpq EQEQEQEQEQ$¦$¦$¦$¦$¦£2£2£2£2£2¡¡¡¡¡(((((7¨7777§©©P©© $r(728HE$f(R¤&quot;¨0¨3RR0¤!©© © ©

CCPCCD6i8GXcASuRu 7R                                     @&amp;F&amp;&quot;`&quot;H7¤E'F¢ 725(BR20¤                                SR7Rh7!£¦FF¤¡¡¦RR&quot;¢ SS£&amp;£¨0££0£¢¢223§3§3¢©© ©     ¢    ¢26
                                                                             4                                              F¥£72¡R¡¤¢ (2S ¢  ¢        §`¢ 23¢©
                                                                             4                                                                                                                              ¢f¢
                                                                             4                                                                       ¢        ¢§ ¢¢
                                                                             4                                                                             ¢
                                                                             4

CCdip SR7R F&amp;&quot;H7¤¢ ¢ 5 4                                                                                                 ¤¢  ¢¦¢ ¢£H£ R¨¢§¦R ¨§¦F# &quot;H¢27 §RSH§¦S(2 ¦&quot;&quot;

                                                                                                                            £ ¢

                                                                                                                                                                                                        ²


66&amp;66q68                                   4                  ©22F¥72¡¡¤¡¤F2£¤R¡¤(2S¢   ¢  ¢  ¢  §§SRS3iS(2S2(2¦¤¦&quot;3¢&quot;&quot; ©&quot;                                                                                                                                                            ¢2¢2RR¨¨§¦§¦
                                              4                                                   ¢  ¢
                                              4                                                   ¢  ¢
                                              4

66666688&amp;DGXcdpq SR7R £H£)¡S)5  4                  ©2FFF¥£7726C¤¨¡¡¡¡¤F28RRR¡¤£H£H££(2SSS¨4 £&amp;£¨£¨01£££H£¨£¨01££££¨£
                                              4
                                              4
                                              4
                                              4

                                              S4 (&amp;ECe#E'F3

86iSR7R`¥¤72R7§&amp;&quot;¢5 FeR¦EHS 4 ¢2R¦ECS 4 6¡¢220C§7&amp;E'F3 4 ©¡¤F¦hS(&amp;E'e&amp;E'F3 6C8#4

8888DY8iGX SuuuRu`u`u 7Ru`u R¨R¨FF2S@&amp;¢S`R&quot;A(¡¡ (25SR!`S¦¢¨&quot;C@&amp;¡7`£ B&quot; ¥¤FWa¤F7§E7(&amp;(0CW(#(EHR¦E¨!¦E'&quot; F&quot; S¡R££¦3¢i¨§&amp;7@W¦&quot; §2)B!24 ¡¤§FS¢32¦&quot;H7 S¢¨£

D2Df888cidiphqhb777SS!!!RR£2£2£277RR @SSS§2¢`¢¢¤Bi£)5)555 5 @SS§2¢¢B  R3   F&amp;£H&quot;H£)7§S¡SS(2¦24 &quot;&quot; 4 A23¢ ©&amp;4  )¥7R 7§&amp;¢a&quot;44   ¢264

D2D2DDD2D2D2D2G D6`8`GXcdpq ¡¤¡¤££ ©©¦¦0¤0¤¡¡SS#`0¤R2E' F&amp;&quot;¤ Y&quot;H7`F&amp;E'F&amp;5&quot;H7¤&quot;H7@¢kFFF¥£72¤¡¡¡¡u¡B¡RRR¦¢¢ (S¦S¤S £&amp;¡¤£¨0£¢ £)£0£¢¢ ©¢ ¡¨¨¨4)S© ¨u4)¦¨4h4hu¡4h£u¡u¡¦4 ¦u¦iFu¡¦£¨£F¡¥¦)F72¡R¡SR¡¤¤(2SR£¨£S£¨01£&amp;££¨£¨££0'¡¤£¨££

GGGGGGG D6h8GXcb((S§S§©©¦¦0¤0¤¡¡SS`#0¤R2E' F&amp;&quot;¤ Y&quot;H7`F&amp;E'F&amp;5&quot;H7¤&quot;H7@¢kFFF¤¡¡¡¡u¡BRRR¦¢ S¦S¤S 2£&amp;0£¢ 0£¢3(¢(2S ((SRC$&amp;SS¨ 4h4h44 uuu¡u¡¦)¦)¦)¦)((((SS SS

GGXX&amp;XXXXXDdhphq68GX 77efef&quot;&quot;©2©2¦¦0¤0¤¡¡SS0¤R2E'&quot;¤ F&amp;Y &quot;H7`E'F&amp;F&amp;5&quot;H&quot;H77¤@ FFF¥£¢ 72¤¡¡¡¡Bu¡RRR¢¢ (¦S¦S¤S 7£&amp;0£¢ e0£¢¢¢7¢ 7e¨ 7e4)e 7u¡4h4he&amp;¦h4hu¡u¡44 7¦¦)ueu¡u¡¦)7¦)¦) 7e 77eeeeR¨§¦hq4

                                                                                                                                                                                                                  Ô21


XXXcc&amp;cccc Dchdhpq68G 77e2e26'6'©2©2¦¦0¤0¤¡¡SS0¤R2E'&quot;¤ F&amp;Y &quot;H7`E'F&amp;F&amp;5&quot;H&quot;H77¤@ FFF¥£¢ 72¤¡¡¡¡Bu¡RRR¢¢ (¦S¦S¤S £&amp;0£¢ 0£¢¢ ¢7©©¢ e&amp;¨ ©4 74)7e&amp;u¡4he&amp;¦hu¡4h4hu¡¦4 7¦uueu¡¦¦) ¦) 7e2 7eeRe2eR¨§¦R¨§¦¨h§2hqhq4 q4 4

ccccdd&amp;dddddDXcdpq68GX ECEC77©#©#&quot;&quot; 5 @#@&amp;&quot;UU$$&quot; 22 ¦¨¨££E&quot;H7R¦R¦§0¤0¤( (2RUU$$!@(2¨ £ q£¦@E¡PP§0¤44BT8¦R¤44 724 A$$qqD2244 ¤¤££R¦R¦0¤0¤$$UU$$2222¤¤UU$'$'££¨¨££R¦R¦R¦R¦0¤0¤0¤0¤rr44UU$'$'44bUU$$qF4 e2Rrr¦44PPEH4444 S4s4 ©24 ¡¤4 F2qe4e2R44 R£¨¨£a§¦¨§2)4 hq¦q44444

dddpp&amp;cdpq  ECEC77©#©#&quot;¨&quot;¨BB§§i0¤ R2EC 7u¡&quot;¤ ©&amp;@&amp;Y¦ &quot;A&quot; EC@&amp;75( ©&amp;§¦&quot;)EH&quot; Su¡¢¡¦ B  @¦¡¡        F2£¢7  R¤3       U$V2¤7#0CW                                                                                                                                   EHS¢  44155TU$V2¤7#0CW  EHS¢¨£¦4Au¡¦)V2R2&quot;¤
                                                                                                                EHS¢¨£¦4B4A

CCCCCCCCCCppppppppqq&amp;qqqqqqqqCDD6`8`GXcdpq68GXcdpq ¤¤¤FFu 8¤8¤§¦§¦¤¤§¦§¦ 0¤EC 7R2 ©&amp;&quot;¤Y&quot;`@#ECE' F&amp;7&quot; ©&amp;&quot;H@&amp;u¡7E'&quot; F@&amp;¦&quot;i7¡0&quot; BEPE¨F&amp;©Rh§2&quot;H57¤BEHS£¢k6¢R¦R¦R¦R¦R¦R¦R¦EHEHEH SSSu¡0H0H0H0H0H0H0H@¢¢7&amp;7&amp;7&amp;7&amp;7&amp;7&amp;7&amp;¢¤¦ §£¨EHEHEHEHEHEHEHEHSBC¡¤¡¤¡¤¡¤¡¤¡¤¡¤C$¦$¦F&amp;¢¤FrF¦F¦FFF¦F¦)EHS££`£DiG£¦6)8)X)c)&quot;HEH©s@¢¤¡¤7R4 £§25A5A5A5A5A5A5A5A§£¦BSE44A$$&amp;$&amp;$&amp;$&amp;$&amp;$&amp;$&amp;(BS0¤V2S`¥¥¥¥¥¥¥u¡(2¤ F¦72727272727272(¦277#¡¡¡£¡¡¡¡&quot;ef£¤(((¢((((0'&quot;¢e2W7h&quot;Hs72u¡7(77¡¤(R¤¦&quot;HREHEHE¨£e272efe2SISS7RB23 ¢¢§&amp;6R67R¤¡0&quot;i4H$3(§#¥¡¤5E¨@@77£V2S§R4H&quot;E© F¦efe2©25#©20¤¢27#6'¦¦EP&quot;©©2©2¢R0¨0'0¨§2W7¦¦¦¡¡ B&quot;SSEH0¤0¤SR¡¡EH! S3SSEC¢SE'E'F#F#¢EHSE'E'&quot;H&quot;H4F&amp;F&amp;¢7&amp;7&amp;C41$2&quot;H&quot;H44 57#7#'£ $¦544 £a4U$V270CW EHSu£¢¤ £24)u¦

CCPD6h8GbSSEE8¤8¤§¦§¦¤¤§¦§¦ 0¤EC 7R2 ©&amp;&quot;¤@&amp;Y&quot;A&quot;i@#5EC7E'&quot; ©©&amp;§u¡&quot;@V2B¦ ¡RB2EC @¦S&quot;¨¢¡£¡¡ ¢2EH¡ S¡¤£¢¤F&amp;£2¢ &quot;H4¦¢r7¤4 ¢4¢¢Q4U$V7#0CW EHS£¢ 4155TU$V2¤7#0CW EHS¢¨£¦4Au¡¦

                                                                                                                                             Ôs²


CCCCCCCCCCCCC66&amp;6666666688&amp;8CCCCDXcdpq68GXcdpq6    @&amp;&quot;iE'©§B 7 ECS¢                 EHS¢¤£24)u¦
                                                                      E'F                                 R¦ 0H@7&amp;§EHB¡¤FC Di  5AE(0¤$&amp;S`¥772`e¡(&quot;H72 R4H75&quot;H72§&amp;ER0¤&quot;74H§#5#&quot;EP©§2FB&quot;e2!¨R2U$EHSV¤7#0'W`EHS¢¨£¦44
                                                                                                          EHBT2&quot;¤U$VE'@FV27#7R0CWY2&quot;¤£&quot;C72¡ R27R¦EH §&amp;S£¡¨0C£¢7&amp;e2(&quot;§¦RE¨4¢ ¡¤C£¨4H¢r$¦F2§¦54¡)£5C¢5§$&amp;5© e&amp;©¥¡¤U$¡¤72F¦4HF¦5HV2¡$(¤4kV7#i¢ 70C¢kW¦7#W`EH F2S£¨EH0CF¢¤S£WhEH¢S¢£ 7¢¤7 e'£2$¦R¤4 £T3YEHU$S¢V2¤7#C$¦0C£aWi4 (S#41e&amp;44

CCCCCCCPPPPPPPPPPD2DfD2D2DDD2D2D2D28888888GGGG DD8iGXcdpq68iGXcdpq68 ¤¤¤¤F¦F¦F&amp;F&amp;R¨R¨0¨0¨©©¡¡SS SSY EE'E' FF¤¤0¨ 77)5¡¤h£hu¡0¤0¤ (R¦R¦¦u¡e2e2Si¦&quot;¤&quot;¤RR1@¦F&amp;7HH$ef§¦§¦¡&quot;HU$V27¤¡sV¤©¢ 7efe27#F¥£¢ e2¤727#¨6¡0C Wu6¡R£¨£¨0C4H4H7££Wie(¦h5C5CS4¢$$ef¡¤R£¨7V2££5V2V2¡¤¨£¨s£ea§¦£R7¡27#7#1e2B&quot;¤0'0'¡ 6WhWh $44CV2775¡efe2 7#6Ee0¤0'WiRu¡¨7§¦¦ e2 64Au¡4¢ ¡¦©4¢ Bu¡u¡¡¤u¡£¦¦h£¦ F¥¢ ea7¡¢ (R¡1§¦ef(2S e2b¢ 6¢¢ e2¢ef6 ea1e26

CCCCCCCCGGGGGGXX&amp;XXXXXXDhDGXcdpq68GXc F¦F¦¡¡            ¡¤¡¤§§FF3232¤¤(( ¤7CC$$ £H£H££  EC 7 ©&amp;&quot;¢7@#&quot;h5 u¦ R3 u¦ @2¡¡
                                                                   E'F                                     @@&amp;§2B&quot;`E'©§2 B EHS¢)¡¤£EHS(¢¨S`£¦4H75#efEC7s©&amp;7&quot; e264h&quot;H72R¤7§&amp;&quot;4H5E'©§2B&quot;!7
                                                                                                          EHBI22&quot;¤&quot;¤YU$EHV2BTF¦V27 (R¡0CF2§¦W2 ¡¡¨&quot;¨7§&quot;H 72F32R`$$7V2V2§&amp;(U$&quot;V7#7#C4H$50'0'7#W`W`5£¨£0C¡¤¡¤WF£a£ae2EC7&quot;H4H4HR©#7552595R&quot;EC7F¥S#§&amp;72¡4k £R¡&quot;7(2(S4CW¦5£¨e¨£a5§£¨F£a©24 R¡¤4 3)F24E4 7&amp;4144 4 ¥¢¥7W¦¨F

                                                                                                          Ô(Ô


6666666666CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCXXcc&amp;ccccccccdd&amp;ddddddddpp&amp;ppppppppqq&amp;qqqqqqqqDDDDdYpYq68GXcdpq68GXcdpq68GXcdpq68GXcdp E'E'F&amp;F&amp;&quot;C&quot;C7722EPFRR7SS!!Y0¤EHS£R2¢2EC&quot;¤ 7Y¥h ©&amp; 5¡EC&quot;A7©&amp;@&amp;@&amp;@&amp;5 E'E'&quot;&quot;)&quot;`&quot;`FF77¡u¡E'E'©©B¦§§EH R¦BIBB2@@¦V20H&quot;¤7#¡RqECECSS¡2E'E'E¨U$FF¢¢¡¤¢&quot;¤@77FV2£¡ §¡ 5R¦R¦B7EHEHEHEH@V2SSSBR2)0H0H0C3¢¤8¢¤7&amp;¢7&amp;q¢WYR&quot;¤EH¡¤R£2£2EHEH¡k¡ £F¦¥¡¤C¡¤&quot;HEH&quot;¤44A@$¦72V272q¢F`F`BT¡22£EUU$¦$¦F&amp;(7Tu¡£iR¤R¡0¤&quot;¨&quot;¨¡¡4AS`755V2V2(¦2&quot;H27§&amp;5TEHEH&quot;¤UU$¦$7§88BTBT¡¨q¢7#7#¨£EC&quot;£F¦efV2(BIVS&quot;¤&quot;¤EH0C0C4H¡¡ §¦SS¥¥WWR¤5&quot;Hs¢ F¦F¦¢272©87#7272(2q£7#£5¢r7¥R¤q¢¡¡&quot;H&quot;H¡¡¦0C40C@@¡¡$e27272V2V27V2((WW`((F&quot;¡k2§&amp;§¦§¦V26RRRR¡¤¡¤Se2EH&quot;U$¦77§§S£¡¨¡¨7#q¢22££EC&quot;4HR¡ ££aV2¢S§#§#FF57#EHEHE&quot;¨&quot;¨0C41¦¡¡¡¢SSWY££330¤4H&quot;&quot;E0'EH¢ F&amp;¢2¢2257#5W`CEHEH0¤4H4HS¢r¡¡ $¦S£S£¥¥¡¨5955((EH&quot;C0C4144k£7¤S¢¢¡¤£W¦F5§5EE'©£a75¢2q£q£©6¡4iCC¢¢¡)W2§25T$$¥¢2CCREC¡¤4H¡¡¢r¢r$¦$¦S¤B¤5F¦S¨4A¦444£¨£¨UU$$F¦F¢¤q£q££5££`£`4£¨0CU!¨$7V2V2££¦£&amp;¥§4¡¡¡¡ W2V¢72ECEC7#44% 7722¤7778¡E'UU49$$©&amp;©&amp;F77#¡¤¡¤(F0C0C4 W¦££V2V2WWV2R&quot;&quot;0C3&amp;W3Y¨¤¤£¨4¢¢ F7#7#£a7#EHE¨¢r¢r££SREHEH0C0C440C449¢¨((S£S£WWW44 7¢¤¢£¦¡iW¦ee£¦EHE¨E¨4 SR¤RC4A$¦F¢¤RR44 F&amp;£&amp;u¡¥33¡i¡i¦0¤44 ¡ECEC4SS¤¤SF&amp;F&amp;¢¢ 0¤0¤C¡C¡E$2$2SS0¤£a£a 442EE4%4%0¤0¤4774 W¦W¦¤¤¦¦FF4444

6&amp;6&amp;CqhbBB¡¡(( ¥¦¥¦RR((SSYEC 7 ©&amp;&quot;¢7@#&quot; e u¡5¦ BR¡3(¥¦uR(¦ S¢2R£¨¢§¦7 `EC7u¡©&amp;¦ &quot;¢P7`4 e q

6&amp;6&amp;6&amp;6&amp;6&amp;6&amp;6&amp;CCPCCCDG6h8hXcd BB¡¡(( ¥¦¥¦RR((EPFSS7R¦££EHBT¢¢0C7&amp;77 E¨U$&amp;¡¤E'7F`¡¤ ©&amp;(25`&quot;¢B@&amp;7B¡R(¡3&quot;)e`¥¦(7¤¥2u¡R¤7¤(¦R¢r(S41¢ 2SE75R62£W¦3¢R2¤7Y0CFu¡WY¦EC7EC7©&amp;¢©&amp;R&quot;1¨&quot;¢7§¦7ie e`u¡¦ 7¤F¦£¢ ¢R37  u¡¦ P4
                                                                                                                                                                                                                                                             R3)7¤¢r4

Ô(Ê


6&amp;66Cqp      &quot;¤ P4

666666666666666666666666D2DfD2D2D6&amp;6666666688&amp;88888888DDD6h8GXcdpq68GXcdpq68bBB¡¡(( ¥¦¥¦RR((EPFSESE766R¦R¦0¤R20C0CWWY&quot;¤YE'7E ©&amp;@0¤@&amp;§2&quot;¢BE'E'&quot;`FF7@&amp;)U$77&quot;)E¨E'e`©V2¡RYB§u¡¨¨¨¤E'PP7¤F7#B¦E44 70¤0C¢ WiEC7775SR¦R¦Re27e2e23¢0H0H7&amp;7&amp;e2qhqhqhu¡q¦&quot;HEHEH72777R¦R¦¦¡¤¡¤EH4HPefefF2efF2SR50H0H4 ¢¢¤77&amp;7&amp;555§#R£2EHEH444UU$#$#¨¡¤¡¤&quot;4H4b4b§¦FrF¦5#72¥¥4H4 i5#72726REC'7355¡¡E'UU$$u¡©#©(2(27#$&amp;$&amp;V2V2¦§2bb&quot; ¤¤4B&quot;¥¥777#7#72724!Ue2efR7¤0C0C¡¡¥¢3WhWhq((¢ ¥bb77u¡ 77eea¦e2efe2e2qU$qRR4H4HPV255¨¨4 §¦§¦55 7 e2e20Ce#e#WhRR7272HHRR447§¦§¦3A3A44 ef 7&amp;7&amp;¤e&amp;e&amp;444H54)4)44544 u¡u¡ ¦¦ 72R3 7#44hu¦

66666666666666666666DD2D2D2D2GGGGGGGGGGXX&amp;XXXDDAGX1cdpq68GXcdpq68 $&amp;$&amp;$&amp;$&amp;RRRR((((g9g9g¢g¢6¡6¡©2©2¢2¢2¡¤¡¤F¦F¦¦¦#`00)E'E'FF¤¤ECEC 7777 ©&amp;©&amp;&quot;¢&quot;¢@&amp;7@&amp;7`&quot;)&quot;)eY5R¦R¦R¦R¦PPu¡u¡0H0H0H0H44 @@7&amp;7&amp;7&amp;7&amp;5¦¦ @&amp;§2@&amp;§2E¨E¨E¨E¨BB¡¨¡¨¡¨¡¨&quot;`&quot;`FCFrF¦F¦RR 33Di©6)8)E'E's©© §2§25555u¡u¡E(BB¦¦0¤$#$#$#BSi&quot;C72¢2¥¥¡¥¨¨P72772(72RR4 ¥¦7ef¡¡¡¨§¦§&amp;(2(2(2R&quot;C4A4A72(i&quot;55RSY4177u&quot;C&quot;C4A72ef725§&amp;¦ECECEC7775RR&quot;©&amp;©&amp;©&amp;77E'4bP©§&amp;§&amp;&quot;4&quot;E&quot;¢ §250¤&quot;&quot; 7`e2B&quot;©2RE'!Ue©7¡¨¨ 6¡F¦§2§2¢2B&quot;A¦!Ue&amp;70'§4 7&amp;E'F3

¡D~ x¢¡£¡9zu  xbvx ¥¤ W¤z  z!0)³4 t#&quot;%$zT&amp;)(Pvx¢¡)~10)|32
6 $&amp;¡S¤§  R3  ¡S§  q£R3¡ ¡       6£e2¡ R¨§¦8¢¢¡¡ $#¡72(2R 3 R¤¡ 3 ¡¢ F¦ £¡ ¢7 ¢ §R3¡ ¡£¢ (2¡ e                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ¢£R¤¢3&amp;4¦¡ ¥W¦¢f¤(2¡   ¢26£¡
                                            ¢¡
                                           1¡

                                                ÔªÅ


CCCPDYD`8GXcidpiqh6h8hGb777777SSuuuEQ$¦!!!!!!RRuu%u £2£2£2£2£2£2£277§9¡RR D(97¢¢¢¢¢£¢f¢2R23§¢6u2©'S55555555E&quot;C£¦¤&quot;¨(&amp;R¢¢¢¢¢¢¦e2q5 EC©0e&amp;REHHB#E'4 §¦FE30A¢2E' FR4 ¢72¨§2¤¡(65 £¤F¦(SR44 A¡6972S88#RuuuuuuR¤4 723u)u)u)uYuu`R)©©©62&quot;C¨772(2(2(2R&quot;H&quot;H!773`¡R¤R¤R¤£¦F&amp;F&amp;F&amp;(2SRR20C0C0C((WWiW&quot; e2(&amp;337§¤§¤R0¨0¨EC$#$#¡¤¡¤e#R¨F2F2§¦(¤¤E'F32FFS#S#)37)7)ECEC727#7#7h7272RE¨E¨76973R¤R¤¡¤¡¤338#RFhFh3e24 7272e2e2Re2R¤R¤RR¨33§¦RHH§¦§¦¨ e2e2§¦ RR HH§¦§¦

   CCX¢c¢$&amp;$&amp;¡¡(( RR33h7  5iF2R32¡7Tu¡¦ @¦@7¡5¡5 84
   CCd)p)F¦F¦££¢¢77 RR33h7  5`7R32u¡¦ R3
   66&amp;q)s££(2(2¤¤ee RR33h7  5`7R32u¡¦ R3

D~¡ ¢¡ x¢¡£¡9zuqDz ¡4|vz ¤£#$zgEH%&quot;#$ÂzT&amp; (7vx ¡9z ¡ $z9~10)|32

    6 $&amp;¡S¤§ R332S2¤3V&amp;E¤ ¡S§2  7(R3B§3£2SS2R723 V&amp;E¤¡ 7(£B¤¡§72£2R¤S3R3272 S¢#4 ¥3W¦V&amp;E¤(2£¡ 7(B2¡¡¤g§£¤¡
    D8GXc EQEQEQEQEQ$¦$¦$¦$¦$¦£2£2£2£2£2¡¡¡¡¡(((((7¨7777§©©©P©P$r(72(2E(R¤¤&quot;¨0¨33RR!B#©© E¤© ©
    dh7!£2 R332S23V&amp;E¨¢5i23V&amp;E¤ ¢
   Cphqh7272RR333232SS22¤¤33V&amp;V&amp;E¤E¤15i  (23R3V&amp;3E¨S 2 3e2V&amp;RE¤¨§¦ hq4
   C6hb77((BB¡¡¡¡gg§§££h( Bi ( R35T32@(SB22¡3¡V#gE¤§£)A(u¡B`¦h(#4 3 2RC$#hu¡¦ ¢

CPCCCD`8hGXcd 77((B¤B¤§§£2£2SSRR77E'F¤7  ( Bh (`R7Y3325S2¤3V&amp;E¤ u¡¦ 23 RC$&amp;iu¡¦ R3  u¡¦  P4
                                                              R¦0H7&amp;E¨¡¨F25(B§£2SR72b(Bi(  72R3h7&amp;4
                                                              P4

66&amp;6Cphqh6 77((B¤B¤§§£2£2SSRR770¤ R2¢¢)72&quot;¤(R 3hBh @7¦(`(RB273R232¡&quot;He7&amp;¡Sg4 52§£h¤4 3(V&amp; 7¦BiE¤(#R¦ 4)&quot;Hu¡7i¡¦ B525i7#3 4hRC$&amp;u¡¦iu¡¦ R3 u¡¦ ¢2R¨§2iu¡¦ r4

                                                          Ô


666 D8G  u ¡¦  (B§£2SR72 (Bi(  e2R¨§2Ae&amp;4
                  P4

                  Ôx§


&quot; q&amp;S8@§FI¼§0 ¢¡ UWQ#8@©H§ dQe© $DY5©4A ©9V  Q¨58a&amp;P§ G&quot;@A`©§TYWV ¢¡ AB¡r ¢£
}~© Dz xG¥¤4%$ ¤ hF|h±¢&quot;%RÂ4Ezuy{9 ¤ EH%&quot;#$ÂzT&amp;)(Sy zy 4 ¤ ~10)|32
        $&amp;¡S¤§ '$&amp;¡(!  C$&amp;¡¤(! ¡rE $&amp;'$&amp;¡¤(! ¡ EQ$#C$&amp;¡R¤S#4 ¥W¦(2

D68 EQEQEQ$¦$¦$¦£2£2£2¡¡¡(((7¨77§©© $r(E(&quot;¨0¨RR!© ©

G SR7R C$&amp;¡(!i5 C$&amp;¡(!  §((2R! F&amp;&quot;H7 §SS(2¦&quot;&quot;   §9D F#&quot;H7(§&amp;0C7&amp;E¨¡¤Fa44

CXcdpq  EQEQ$&amp;$&amp;''$&amp;$&amp;¡¡((!!i5                    C$#'$&amp;¡(¡(! !  ¦E&quot;H7 §((R!  C¡84      ¨UUUU$¦$¦$¦$222¤¤¤¤££££R2R2R2R¦0¤0¤0¤0¨ UUUU$$$$PPPP44444444    FFFF¡¡¡¡RRRRSSSS010101012222q`q`q`q`qqqq44444444  ¡
                                                                                                                                                                                                                                                                                                                                                     ¡

                                                                                                                                                                                                                                                                                                                                                     #¡ 4

C6hEQEQ$&amp;$&amp;''$a$a¡¡RRSS  C$#C¡$&amp;(!¡(!EQ$&amp;u¡'$f¦ 4¢F&amp;R`&quot;H5I7 §SU$SV2(2¤¦7#&quot;0C&quot;1W u¡¦PE $&amp;§9DC$ F#! R¦&quot;H74(4 §&amp;0C7&amp;E¨¡¤F

}~HG Dz xG¥¤§¦ Â±z¦Ezuy{9 ¤ EH%&quot;#$ÂzT&amp;)(Sy{zuy{9 ¤ ~H0)|32

        $&amp;¡S¤§ C$#¡(!  C$&amp;¡(! ¡$&amp;C$¡(! ¡$#C$#¡RS£¡$&amp;P$r&quot;H7¡¤(4 ¥W¦¤(2

D68 EQEQEQ$¦$¦$¦£2£2£2¡¡¡(((7¨77§©© $r(E(&quot;¨0¨RR!© ©

G SR7R C$&amp;¡(!i5 C$#¡(! §((2R! §SS(¦&quot;&quot;   ¢2R¨§¦44

X¢c¢$&amp;$&amp;CC$#$#¡¡((!!i5  C$&amp;C$&amp;¡(¡¤!(!  ¦E&quot;H7§((2R! C1¡84  $fP4 ¡$P4 ¡$fr4 ¡$fP4 #4

d¢p¢$&amp;$&amp;CC$&amp;$&amp;¡¡RRSS   C$&amp;C¡$#(¡!b($&amp;! C$fu¡¦4A§R S5TS(2¦U$&quot;V&quot; 7#u¡¦0CW ¢2R$&amp;H§¦C$ ! R¦44

CCCPDq¢68G $&amp;$&amp;CC$f$f&quot;H&quot;H7272¡¡(2(2# E'F¤ 7  C$&amp;C¡¤$&amp;(!¢¡($&amp;! C$fu¦¨4A§RhSeS(25¦&quot;&quot; u¦  ¢R¨§¦`u¡¦      P4
                                                              S§¤$$!`5TU$&amp;¥7¡(2                          U$&amp;'$ ! R4be&amp;4
                                                              P4

}~ ¨ zuz R Dz ¡|hvz  £#7$Âzgt#&quot;%$zT&amp;)(z ¡ $Âz9~H0)|32

     $&amp;¡S¤§ 23V&amp;E¤ ¡S§ @2¤3V&amp;E¤¢¡(23V#E¤£¡(B¡¡g§£¤¡(B¤§£2SR74¦¥W¦¤(2

   D68 EQEQEQ$¦$¦$¦£2£2£2¡¡¡(((7¨77§©© $r(E(&quot;¨0¨RR!© ©

                                                                                                                 Ôr©


GXi7S!R£27hRh33V&amp;E¤h)R`R`55i23V#iE¤R §((2R!h232RC$&amp; @3 R44
chdhp (2(233V&amp;V&amp;E¤E¤ E' F&amp; EC7`R 5`u¡¦ 22¤33V&amp;V&amp;E¤E¨ h R¦@(2E¤&quot;H£¦7 §¦(E(20¤RR7!A@D2q£¡ $28¤4 £R¦0¤U$'r44)E'FaE'7&amp;444
Cqhb((B2B2¡¡¡¡gg§§££ @ 2 3V#3E¤V&amp;E¤(hB#R41(u¡¦)5I2$3V22RC$&amp;7#h0'WTu¦`@(RB&quot;!U(#44
CCPCCD6h8hGXc ((BB§§£2£2SSRR7272# E'F¤@ 27 3V#3E¤V&amp;SE¤P§¤4 $(h$B#R!415 (`u¡U$&amp;¦)e¥275¡3(22 RC$&amp; (hB&quot;u!U¦`(&amp;4bR e#u¡4 ¦ P4

                          Ôx


C &amp;S8@§bI¼§0  U%Qe85©H§ dQe©2A U%ShvIa&amp;§ £¦¥ § ©QfH§QB©

~ © t C  z!0)³4 gz xGzu £#7$ÂzT&amp; (S|dxt~10 2
68 b7 !£2F¡R¢SR¡S¡(¨Bi0 £¨¡ £¤FF¦ §¤¡$RS£#¤F0 §¤¡$                                                               R¢¡¡(¨£¨£
                                                                                                                                                           F¤¡RS  ¡  ¥72¡(£¡       §¤$  R¢¡¡(¤£H£
                                                                                                                                              ¡ £ ¡

D`GX7 !§£2SE'F¦SS¡¡ (¨Bi¥¤£¨§£¤F©¦ §¤¡ $ §¤¤$F§¤$E'F2 ¡(¤E'F¦£¨£¡(¨£¨£ ¤

chdhph777!!!£2£2£2SSSBYBYBYE'E'E'FFF777 ¢§F&amp;SRS¨&quot;H§¦(27 §¦S&quot;¦ S&quot; (2¦ ¦&quot;&quot;'¦

Cqh7!£2SBi¤F§¤$ ¤F§¤$  23 2R'$&amp; ¤h2q£¡ f1¡ 26¢¡ 28¢¡ §¤$232RC$&amp; b23 RC$&amp;¦

CCPCCCD68GXcd b7 !§2£2 FaF&amp;R¢3S¡&quot;H&quot;H&quot;HE¨7727¡¤¡EPF&amp;((F¨ (¨(BR'$&amp;§&amp;§&amp;§&amp;£¨&quot;H£7¤&quot;H0H0H0H777(7&amp;(§#E¨$&amp;§&amp;2¤Y¤)¡¨0HR¢7&amp;F0H23§7Y¡E'E¨¦ F©¡¡¤73(¤F&quot;H72£¨ (£R'B$&amp;§&amp;EQ¡ $0H(¨$#67$D©¨R¦ 2S#7©¦ F&amp;¤E¨¦ 32R&quot;H¥77( §&amp; 0Hb67&amp;'EC¦ X¡¤2F¦!3¤ 2RC$&amp;E $ $&amp;S#EH3R72    EP6F&amp;&quot;H¦ 7(E'§F¦0H¡7#(¤EH£H¡¤£F©¦    $fE'F¦¡¤(¤£¨£  D©¦     ((  E'F&amp;&quot;C7(§&amp;0H7#E¨¡¤F¦

                                                                                                                                                                                                                                                                                                                                              

6Cpq SSB#B#E'E'F¦F¦b $&amp;2R§¤3¢¡©¡(¤ R£¨£4  R4 R4¤ R 24 ¤ 3¢ $&amp;©#R¢4 ¡¡(¨£¨£a4

6&amp;666D68 SSSSB#B#B#B#E'E'E'E'F¦F¦F¦F¦b$f22EQ$¤¤EP$&amp;F¦323 ¥¡(¤S# RR£¨E¨£R¤44 72 R4 RRR444¤¤ R4E'E' F&amp;F&amp;R¦¤ 4&quot;H&quot;H77E'¤ F&amp;(( §&amp;§&amp;E'&quot;HF#70H0H(7&amp;7&amp;&quot;H7§&amp;EHEH(¡¤¡¤0H§&amp;FF7&amp;0CE¨7&amp;BB¡¨F¡¤¡¤E¨(¨(¨¡¤ $$FBRR¡ 7¥7¥(¨B$#¡¤¤¤ (HR¤ $#((7 ((R¤ 7 (E'E'¤ F&amp;F&amp;( &quot;C&quot;CE $77EP$#F#((§&amp;§&amp;&quot;H7S#0H0H77(¤EC§&amp;RE¨E¨7¡¨¡¨0CF¥F¥7# E¨¤¤ ¡¨EPFF&amp;22¨¨&quot;'¤ 3237 $r(¥¦§#44EPF¦0H7#¡¤(¤E¨¡H£CF£a4¤  EQ$$&amp;¤S#E¨R¨72¦4

66666GXcdp SSSSSB#B#B#B#B#E'E'E'E'E'F¦F¦F¦F¦F¦ 22222¤¤¤¤¤3f323£33¢i§ih6)s2222232332332¥¥¥

8q`£¢7(F F&amp;&quot;C7(§&amp;0H7#E¨¡¤F1$#Rg2 F#&quot;H7(§&amp;0C7&amp;E¨¡¤F  R¢¡¡(¤£H£ ¡3 2RC$#£¡232RC$&amp;£¡23 2R'$&amp;£¡E'F7 ¡ E'F¦¡(¤£H£a4'¦

~ HG t C  z!0)³4 t#&quot;%$zT&amp;)(S|dxt~1R 2
E'F#0¨§2S E&quot;¤R ¤W ¦

D68GXcd F&amp;$&amp;$f222&quot;CF&amp;7R¢E'F¦33¢32(¡&quot;H§&amp;27©¡¥¡(¨((¨R'0Hrr$&amp;§&amp;7#£¨£¨EE££0H4141E¨7&amp;¡¤PP(5`5`F1EEE¨S¡¨4s4s$#((FY¡ 55SR&quot; 2g2E'¦¦ $&amp;$f¦ 3R§EPF¦2F#¡RC¡¡&quot;H$&amp;(2(27(¡¤¡¤£©£©§&amp;(#0C¦¦ 7&amp;&quot; E¨¡ ¡¤F  3 2R¢RC¡$#¡(¨£¨(£%7 $&amp;¡%R§¡E'F¡7(2¡¤£EQ$¡ $&amp;S ¡ E'F¦¡¤(¤£¨£A$fE'F2¡(2¡¤£a4 ¤

                                                                                                                                                                                     Ô


CCCPD¨ pq68               2EHBI3EQ$$&amp;$&amp;rR¢ES#¡41¡E¨5`(R¤72¡¤(£i7©P5E¦ 54%F5 ¡RE $S¦$&amp;04 S ¤¦
                            (2 7§(F PE4'¦

 ~ I uQP SR'zu|±|d9Dzux)z  £#$zT&amp;(x `~USW#X 10 2

    6`8`¢£££¢¢¢777(((FiFF 2$&amp;C$#3'$&amp;V&amp;¡(¡E¤!¢(! $&amp;(2CEQ$#$#¤3¡C$&amp;V&amp;(!©¡E¤(¦ !&amp;¦¦

~ ¢¡ I uQP SR'zu|±|d9DEH%&quot;#$ÂzT&amp;)(xVUSW%X ~1R 2
                            E'E'E'E'E'F#F#F#F#F#00000¨¨¨¨¨§2§2§2§2§2SSSSS  $&amp;$&amp;(2EEQ$&amp;CR&quot;¤$&amp;3RCE'$#F¥B¡¤¤W(¡E¤¤UW!¥(¦ !¥¦¤UW¤U¤UWW¦
D 6 8 G                                                                                                                                                                 ¦
                                                                                                                                                                        ¦

Xhcdp¨2§$&amp;SC$#3S'$&amp;V&amp;(2¡(¡¦E¤(!&quot;!&quot;b$&amp;£&amp;(2EQ$#¤'0'$&amp;3C¦ $&amp;V&amp;¡(¡E¤!©(!&amp;¦ ¦¦

CCCPCCCCDqh68GXcdpb(e2§¡&quot;EECF&amp;¥aS¦50¤&quot;H&quot;rEC7#7R2P2¢2(e(&quot;¤EQ0'4 $&amp;WT§&amp;SiR35¤C¨0H$aF5§¦27&amp;U$&amp;¡R'EQE¨$$&amp;2R¢R¡¡¨$&amp;eS¡FYAR3§¡¤S0#¦ (©(¤S#E'PS£¨E¨E¦P $&amp;£RE¦ ¤72C4'P$&amp;E¦ ¡4P(4E!4'¤¦¡£&amp;04'¦

66&amp;66666Dq68GX         £&amp;©((2B0A§5`£2RgS£&amp;R¦ 720¨t&amp;§@(¦ 3V&amp;E¤¤£¡(S ¡ e&amp;4'¦
                            &amp;0¤R2¦ 2(&quot;¤Si3 F52¡R'$&amp;2RSA£#3§(©0 S
                                                                                                ¤

                                                                                               PE¦ 4'¦

66688&amp;8888 Dcdpq68G  £&amp;©((2B0A§5`£2RgS£&amp;R¦ 720¨t&amp;§@(¦ 3V&amp;E¤¤£¡(S ¡ £&amp;04'¦
                            &amp;0¤R2¦ &quot;¤&quot; ¥a)0¤EC7#R22(&quot;¤0'WTS`%3 §5`U$fS¤RC$&amp;2S¤E'F¦¤ 3¢¡¤(©(¤¤ S£¨P£E¡ 4P(#E¦ &quot;44¡
                                                                                                                                                                           ¤

                                                                                                                                                                           (7©¦

                                                                                                                                                                                                                                              Ê21


D2DfD2D2DDD2D2D2D28888GGGGGGGGGGXX&amp;XXXXXXXXcc&amp;ccDDDXcdpq68GXcdpq68GXcdpq68GXcdpq68      £&amp;©(#((7(2B&quot;0 §5`5`£5iR¤g©S£&amp;22R¦ ¤¤720H323ta¥§ (2PP¦ EE344 V&amp;¦¦ E¨¢¡(S ¡ (B2¡¡g§£ @(23V#E¤¢¡(#&quot;4 ti(B2¡¡g§£  (23V&amp;E¨¢¡(7&amp;44'¦
                                                                                                        &amp;0¤R2¦ £&amp;©2((#((&quot;¤7(2S`Bi&quot;0 §35`5`5`£5i¥¤R¤§g©SRC$&amp;£&amp;©222R¦ ¤¤¤720H 3¢323ta(©¤¥§ S(2PPP¦ EEE¡ 3444 (#V&amp;¦¦¦ &quot;E¨¡ ¢(¡7©(¦ S ¡ (B2¡¡g§£ @(23V#E¤¢¡(#&quot;4hu)(B2¡¡g§£  (23V&amp;E¨¢¡(7&amp;44'¦

                                                                                                           &amp;¦

                                                                                                      © (2Rg ¦
                                                                                                     0¤R22¢2(#(e#e`&quot;¤EH7`7`B©R0A0A£&amp;£&amp;3¨5555§¦£200@e#¤R'&quot;¤$&amp;22((5i5h0 eB2B2A£&amp;e533¤¤0(#7©5`¡¡0¨¡ ta¡¡0PP¦ eqggEE§¡ 7©§§44'4'¦ (££¦¦¦ 7©¤@@(2(2¦ 33V#V#E¤E¤££¡¡(#(7#04'4'¦¦

                                                                                                      © (2Rg ¦
                                                                                                     &amp;0¤R2¦ 2¢2((2e&quot;¤SiRRh35A¨5F5§¦2$&amp;¡R' $&amp;22RC$aeSA3§3¦ (©§¡ SRPP¤SEE¡ 4'4'U(2$#¦¦ RC$&amp;¦ ¡(! ¡(B2¡¡g§£ @(2¤3V&amp;E¤¢¡(R44'¦

ccccccdd&amp;DGXcdpq                                                                                £&amp;©((2B0A§5`£2RgS£&amp;R¦ 720¨t&amp;§@(¦ 3V&amp;E¤¤£¡(S ¡ e&amp;4'¦
                                                                                                     &amp;0¤R2¦ 2(2(&quot;¤e`iRh3 55¥272R'$&amp;22¡(2A33(2§¢ R£PP EE¡ ¤4'4'(¦¦ e©¦

ddddddD68GXc                                                                                     $&amp;£&amp;©(2C0A$r5`R&quot;H7g £&amp;¡¦ (20¨t&amp;§U$#¦ C$&amp;¡(!£¡  (B2¡¡g§£             @(2¤3V&amp;E¤¤£¡(2R4 ¡  (B2¡¡g§£  @(23V#E¤¢¡(e&amp;44'¦

                                                                                                        &amp;¦
                                                                                                     &amp;¦

                                                                                                                                                                                                Ês²


ddpp&amp;pdhpq6he2EQEQ$&amp;$&amp;¡¡R''EC$&amp;$&amp;SSS ¡¡$&amp;((RSY!!C$# 0Hq¡!(!05H5H$&amp;$&amp;P¦R¤R¤4 g2g2&quot; ¤  F#F#&quot;H&quot;H77((§§0H0H7&amp;7&amp;ECEC¡¤¡¤FF                          FF¡¡RRS2S200           ¡  22q£q£¡¡           22q£q£¡¡       22q¢q¢¡¡       q£q£¡¡     qq44                 ¦
                                                                                                                                                                                                                         ¡                                                                                           ¦

ppppD8GX   EQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;0¡¡¡(((!!!R¤(hD68 (25H5H5H3&amp;$&amp;$&amp;$&amp;ER¤R¤R¤g2g2g2&quot;C72 (#F#F#F#&quot;&quot;H&quot;H&quot;H777(((§§§0H0H0H7&amp;7&amp;7&amp;ECECEC¡¤¡¤¡¤FFF    FFF¡¡¡RRRS2S2S2000  ¡  f226£8£1¡¡¡       222q£q£q£¡¡¡  222q¢q¢q¢¡¡¡  q£q£q£¡¡¡  qqq444              ¦
                                                                                                                                                                                                                         ¡                                                                                           ¦
                                                                                                                                                                                                                         ¡                                                                                           ¦

CpppqcdpqYEQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;B#¡¡¡E'F2(((S)!!! ©GXc (R¤5H5H5HF&amp;$&amp;$&amp;$&amp;0CR¤R¤R¤Wig2g2g2 72R¤F#F#F#(&quot;H&quot;H&quot;H32777(((7§§§0H0H0H7&amp;7&amp;7&amp;ECECEC¡¤¡¤¡¤FFF @FF¡¡RR¡S¨S2f£&amp;0 10¡ ¡¡ 22f8£8£¡¡ ¡ 2f2q£1q¢¡¡ ¡ 2q£q¢¡ q£¡ §¡ Sc£q£S¡ 4'¡ q¦ q¦4 4'¦ ¦

CCCq&amp;qq6Y8YEQEQ$&amp;$&amp;''$&amp;$&amp;&quot;H72¡¡((¡(!! Adp ©(25H5H$&amp;$&amp;R¤F&amp;R¤R¤g2g20'Wi 72F#F#R&quot;H&quot;H(7732((¤§§7`0H0H7&amp;7&amp;7ECEC¡¡¤¡¤FF E $&amp;F¥¤C7¡$&amp;¡R¡(S2(£0 ! ¡¡ QC22q 8£q£ ¡¡ 22q£8£¡¡ 2fq¢¡¢¡ q£Cq¢¡ ¡kqq¦4 4'¦ ¦

CCCqqqDGXYEQEQ$&amp;$&amp;''$&amp;$&amp;¡¤§¤¡¡$¦((£`!!  72C¡Yq 0¤5H5H$#$#¡¤§RRFg2g27h 72F&amp;F&amp;¡&quot;C&quot;C77C(¤(¤q`§&amp;§&amp;0H0HB¤77§E¨E¨F&amp;¡¨¡¨FF0H7&amp;7 FEH¡¤¡FR¤¡ S0 ¡ q£¡ 28¢q£¡ ¡ 22q¢8£¡ ¡ q£q£¡k¡bq4'PD¦ ¡ q4'¦

CCCqqqcdYpYEQEQ$&amp;$&amp;''$&amp;$&amp;©(2¡¡((R¤F#!! 0C WhCC68 ©¦R¦5H5H$#$#0HgiRRg2g272 ¡iF&amp;F&amp;B&quot;C&quot;C§77F#(¤(¤§&amp;§&amp;0H7&amp;0H0H77E¨¡¤E¨E¨F¡¨¡¨FF 0¤7 RF¡R¤¡ S0 ¡ q£¡ 28¢q£¡ ¡ 22q¢8£¡ ¡ q£q£¡k¡bqCq£4'¡k¦ q4'¦

CCCq6Y8Y)EQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;0¡¡¡(((!!!R¤(h (2PCDGX 3&amp;E5C5C5C$&amp;$&amp;$&amp;&quot;C72RRRggg(# &quot; F#F#F#&quot;H&quot;H&quot;H777(((§&amp;§&amp;§&amp;0'0'0'7&amp;7&amp;7&amp;EHEHEH¡¤¡¤¡¤FFF  £££¡¡¡               f226£8£1¡¡¡       222q£q£q£¡¡¡  222q£q£q£¡¡¡  q£q£q£¡¡¡  §§§SSSS#S#S#444     ¦
                                                                                                                                                                                                                                                                                                                        ¦
                                                                                                                                                                                                                                                                                                                        ¦

PCDGXYEQEQ$&amp;$&amp;''$&amp;$&amp;E'F&amp;¡¡((0H(!! C $&amp;¤CCFcd 7A5C5C©$&amp;$&amp;!RRgg F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF 7 F£¡R¡ S¦0 f¡ 1¡ f8£1¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡ §1S¡kS#q4 4'¦ ¦

CCCcdYpYEQEQ$&amp;$&amp;''$&amp;$&amp;0¤¡C¡¡$¦((£2!! R (2C6Cpq 72¡5C5C$&amp;$&amp;CRRqgg                                 F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF                            7 F£¡R¡ S¦0             2¡ 6£¡         28£8£¡ ¡           2fq£1¡ ¡       2q£q£¡1¡k¥¤C§q£©a¡ 4               q4'¦

                                                                                                                                                                                                                                                                                                                        ¦

CCC66&amp;6q6Y)EQEQ$&amp;$&amp;''$&amp;$&amp;EHBi¡¡(((f!! ' 5CC5a6&amp;66'q5C5C7$&amp;$&amp;W¦RR¤ggF` (2F#F#&quot;H&quot;H777§(((§&amp;§&amp;F0'0'7&amp;7&amp;EHEH¡¤¡¤FF 7 F£¢¡R¡ S¦0 2¡ q£¡ 28£6£¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡kqC64'G¦ ¡ q4 ¦

CCC666 D8G  EQEQ$&amp;$&amp;''$&amp;$&amp;2¡¡((&quot;¤!!    ¡¤CC§¨66$¦D8 £i5C5C©¦$&amp;$&amp;R¦RR0Hggg                        F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF 7 F£¢¡R¡ S¦0 2¡ q£¡ 28£q£¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡kq4'Cc£¦ ¡                                                                                 q4 ¦
                                                 

CCCC6666XcYdYpYEQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;B§¡¡¡F&amp;(((!!!0C7&amp; E¨CCC¡¤666FhGXc (5C5C5C$&amp;$&amp;$&amp;7RRR§ggg( F F#F#F#&quot;H&quot;H&quot;H777(((§&amp;§&amp;§&amp;0'0'0'7&amp;7&amp;7&amp;EHEHEH¡¤¡¤¡¤FFF 77 FF£¢¡¡RR¡ S¦S£0¡ 2¡ q£2¡ 8¢28£¡ q£¡ 2¡ 28¢2q£¡ 8£¡ ¡ 2q£q£q£¡ ¡1¡kq£qC¡ q£4'q¦¡¦ 4'q¦ 4'¦

                                                                                                                                                                                                                                            Ê(Ô


CCC88&amp;8qY6)EQEQ$&amp;$&amp;''$&amp;$&amp;¡¡((!!    CC66dp  5C5C$&amp;$&amp;RRgg                    F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF  ££¡¡  22q£q£¡¡       22q£q£¡¡  22q£q£¡¡  q£q£¡¡  §§SSS#S#44  ¦
                                                                                                                                                                                                                       ¦

CCCCCC888888D81GXcd $&amp; R¥EPWaF¡(RE¤P§¦S4 $&amp;¦¤CC&quot;r$&amp;4P¡4 ¤(¦ ! P4'¦

 ~ ¨ zuz R Dz ¡|hvz  £#7$Âzggz xGzu £#7$ÂzT&amp;(z ¡ $z9~10 2
b7!£2SB ¢2R¨§¦ 23V&amp;E¤ §¤$2¤3 2RC$ ¦

6`8`££¢¢77((FFi¢2e2R¡HEC§¦S )((B2B§£2¡S¡¤gR§72£@@33V&amp;V&amp;E¤E¤¢¢¡¡2233 RCRC$&amp;$&amp;£4'¡ ¦ ¢2R¨§¦4'¦

~ ¢¡ ¨ zuz R Dz ¡|hvz  £#7$Âzgt#&quot;%$zT&amp;)(z ¡ $Âz9~HR 2
6 E'E'F#F#00¨¨§2§2SS (2E&quot;¤3R B¤WE¤¦ ¤UW ¦

D`8GX¢2( B2R(2H§¦¡7¡§g§(F`£ @B2U(3V#E¤¦ bB ¡ 23 2R'$&amp; (&amp;4 ¤

Cchdhpqe2( B¡§BEC£2SU(SiR725i@e©2¦ 3V#E¤bB ¡ 23 2R'$&amp; ( ¡ ¢2R¨§2he#4 ¤

                                                                                                                                                                   Ê(Ê


£ &amp;S8@§bI¼§0  UWQ#8@©H§ dhQe© A i2§¡@ABhT¡5! i2§FQe©@§F©3¡5! £¦¥ § ©4Q¨H§FQe©
 ~© I w P SR'zu|±|d9Dzux)z  £#$zT&amp;(x USWF ~10 2

    6`8`¢£££¢¢¢777(((FFF $&amp;RC$#3'$&amp;32¡(¡!¢(S2! $&amp;¤C3EQ$#$#V&amp;¡CE¤$&amp;(!©¡b(¦ (2! ¦ 3V&amp;E¤¦

 ~HG I w P SR'zu|±|d9DEH%&quot;#$ÂzT&amp;)(xVUSW) ~HR 2

D 6 8 G X c                E'E'E'E'E'E'E'F#F#F#F#F#F#F#0000000¨¨¨¨¨¨¨§2§2§2§2§2§2§2SSSSSSS  $&amp;$&amp;72(2EEQEC$&amp;7RCR&quot;¤$&amp;©&amp;3¥3RCE'$#F¥B¡¤&quot; ¤¤WW(¡E¤¤U¤UWW!¥(¦¦!¥¦¦ ¤UW ¤U¤UWW¦  ¦
                                                                                                                                                                                                                        ¦

CCCdpq68 §E'$&amp;F7SRC$#©#37S'$&amp;32(2¡&quot; (¡¦&quot;H7!(SE'&quot;7R2!&quot;b©&amp;¤$&amp;£&amp;3EQ&quot; $#'V&amp;0'¦ $&amp;CSE¤¦ $&amp;¡¦ (¡b!©((2!¦ ¦ 3V&amp;E¤¦

PCCCD`GXcd e2E¡&quot;&quot;'ECF&amp;§¦SRC$¦3`&quot;H£77©§(§&amp;R¦ 72¦0H7&amp;&quot;rE¨P7¨¡¨4 $¦FY£©¤ E'¦ ¦

66&amp;66666CDpq68GX      7EHBI5EHBT 7&quot;ECE ¥a7'©&amp;50¤EC!!57#R2&quot;C&quot; 2(72¤EQ&quot;¤0'$&amp;2§WTS`R 3(¡C$&amp;F5`(2U$&amp;¡RRC¤$&amp;23&amp;R¢RS#F¡S¤¡7R44¥3¢S¡¤0P(©(¤¤¤ECrS£¨7EQP $&amp;£©E¦ ¤C4&quot;P$&amp;E4'¦ ¡¤4¦ (4 ! ¤ ¡£&amp;04'¦

6668cdpq 72&quot;¤C$¦7 £F#R&quot;H727 §72&quot;¤S¥CS¤$¦7£7(2£¦¢2¦R&quot;R¨3¢&quot;r§¦72© 7¨@$2¥¥7H$¦£¤@77¨£¡U$¦£&amp;¡ £¤(R¢0¡S¦4§¡ ¡4'¦ EQ(¨¦ $£¨$#£  S#7¨$E¨£¤R7¡ FP¡ER4S4 0¦ 4'¦

8&amp;8888888D68GXcd    £&amp;©7¤F((20¨8B5§¦§£&amp;R£g¨0H§¦Sta¦ R§72P¦ EC7©&amp;@(2&quot; ¡ 7¨3$2V#£aE¤4 £¦ ¡(S ¡7&amp;4 ¦

                                                                                                                        0¤R22(&quot;¤S` 3 F5`¡RC$&amp;2RS¤ 3¢£#(©0 S                                                  !¤     ¦

                                                                                                                                                                                                                           PE¦ 4

                                                                                                                                                                                                                                                      ÊªÅ


D2DfD28pq6                         72&quot;¤C$¦7 £F#R&quot;H727 §72&quot;¤S¥CS¤$¦7£7(2£¦¢2¦R&quot;R¨3¢&quot;r§¦72© 7¨@$2¥¥7H$¦£¤@77¨£¡U$¦£&amp;¡ £¤(R¢0¡S¦4§¡¡4'¦ £&amp;(¨¦ 0£¨£4   7¨$£¤¡  F¡RS£#04'¦

                                                                                                                                                                                                 ¦

D2DDD2D2D2D2GGGGG DD8GXc dpq68   £&amp;©7¤F((20¨8B5§¦§£&amp;R£g¨0H§¦Sta¦ R§72P¦ EC7©&amp;@(2&quot; ¡ 7¨3$2V#£aE¤4 £¦ ¡(S                                               ¡7&amp;4 ¦

                                    &quot;0¤¥aR¦2((#(&quot;¤EC77#S`¤%&quot; 30'§WT25i5i5iSRC0¤$&amp;222SR2U$f&quot;¤ 3¢323)E'F¦(©¤¥S¡¤rrr(¤EEE¡ (#£¨4'4'4'£&quot;¦¦¦  P¤E44  ¤
                                                                                                                                                                          ¡ (7©¦

GGGGGXGXcdpq                      727272&quot;¤&quot;¤&quot;¤¤'''¤¤$¦$¦$¦777 £££F&amp;¢2¢RRR¥&quot;H7777 §7¨7¨$¦$¦S¥¥¥£¤£¤S777(2¡¡ 277R¢&quot;E'((F¦3¢¡&quot;rB2B2©¡¡@7¨(¤(¤@$¡¡7C£C£C$¦¡¡£¤££ gg£¤@@¡ §§£7C7C¡$¦$¦££(0££S4 (2(24'¦¡¡ ¦ §33&amp;SV&amp;V&amp;S#4'E¨E¨4¦ ¢¢¦ ¡¡ ((7#&quot;444§4§¦¦

X&amp;XXXXXXXXcD68GXcdpq         £&amp;©7¤FC((0H8B5§¦§£&amp;R£2g©¤0¨§¦Sta¦ R¤72P¦ EC7©&amp;@(&quot; ¡ 7¨3$¦V&amp;£aE¤¤4§£¦ ¡ (S ¡ 7&amp;4 ¦
                                    0¤R¦2((#(&quot;¤7S`¤i&quot; 3 25i5i5i¥¤§RC$&amp;222©&quot; 3¢323 (©¤¥SrrrEEE¡ (#4'4'4'&quot;¦¦¦ ¡ (7©¦

c&amp;cccccD68GX                    727272&quot;¤&quot;¤&quot;¤¤'''¤¤$¦$¦$¦777 £££F&amp;¢2¢RRR¥&quot;H7777 §7¨7¨$¦$¦S¥¥¥£¤£¤S777(2¡¡ 277R¢&quot;E'((F¦3¢¡&quot;rB2B2©¡¡@7¨(¤(¤@$¡¡7C£C£C$¦¡¡£¤££ gg£¤@@¡ §§£7C7C¡$¦$¦££(0££S4 (2(24'¦¡¡¦ ¥¤33§&amp;V&amp;V&amp;©a4'E¨E¨4¦ ¢¢¦ ¡¡ ((7#&quot;444§4§¦¦

cccdd&amp;dddddD¨ cdpq68GX 0¤R¦©2&quot;¨(2¨£&amp;©73¤FC((2R0H8B5¤gR'$&amp;§¦§£&amp;R¦ £2g©¤0¨§¦¤Sta¦ (#R¤720P¦ EC¡ 7(©&amp;@7©(&quot; ¦¡ 7¨3$¦V&amp;£aE¤¤4§£¦ ¡ (S ¡ 7&amp;4 ¦

                                                                                                                                                                                                            Ê


dddpp&amp;cdpq (#(777e#eR0)3£70 5i5i¢25`5`R22¨77§¦33(( B2B27PPe#¡¡EE¡¡04'4'gg¡¦¦ §§7££ e@@7©(2(2¤¤¦ 33V&amp;V&amp;E¤E¤¤¤££¡¡(#(7&amp;04'4'¦¦

pppp D68G 72&quot;¤&quot;¤&quot;¤C$¦777 £F#¢¢R¥&quot;H727@@7¨7¨§$¦$¦S¥££S¤7(2¡¡¦77R¢&quot;e#e¡&quot;r7#0¡¤ 7¨(¤4'4'$2£H¦¦ £¤£ ¡U£&amp;7¨$¦0£4§¡¦ #4 '¦

CCCCCppppqq&amp;qqqDXcdpq68   £&amp;©¤&quot;HF72(20¨85R§¦£&amp;Rg¨0H§¦ta¦ S§5aP¦ EC§7¦ ©&amp;&quot; ¡ 7¨$2£a4  ¦
                                 0¤R¦2¢2(&quot;¨SR 3¨§¦F5i2¡)R'$&amp;2Re©S 3§¦ (©!SP¤E¡ 4'(2¦ R¦

CCCCqqqqGXcd 7272&quot;¤&quot;¤CC$¦$¦77 ££F#¢RR¥&quot;H72727@7¨§$¦S¥¥£S¤¤77(2¡2¦7R¢&quot;(3¢¡&quot;rB©¡¤ 7¨(¤@$2¡7H£H$¦¡£¤£ g£¡U§£&amp;7¨¡ £$¦(0£S¦4§@(24'¡¦ ¦ F3¡V&amp;RE¤S#4' ¦¡ (R44 ¦

CqCCCPCCCDpq68GXcd     £&amp;©7¤F((20¨8B5§¦§£&amp;R£g¨0H§¦Sta¦ R§72P¦ EC7©&amp;@(2&quot; ¡ 7¨3$2V#£aE¤4 £¦ ¡(S  ¡7&amp;4  ¦
                                 &amp;0¤R¦¦ 2(2(&quot;¨eR``3 5i5i2¥¤72R'$&amp;22¡(2 33(2§¢ R£PP EE¡ ¤4'4'(¦¦ e©¦

CCC66&amp;6Cpq6                      72&quot;¤&quot;¤&quot;¤C$¦777 £F#¢¢R¥&quot;H727@@7¨7¨§$¦$¦S¥££S¤7(2¡¡¦77R¢&quot;((¡&quot;rBB¡¤ 7¨(¤$2¡¡£H¡¡£¤£ gg¡U§§£&amp;7¨££$¦0£4§@@(2(2¡¦ ¥¤3372V&amp;V&amp;¡E¤E¤(2 4  ¡  ((¦ e&amp;R4444  ¦
                                                                                                                                                                                                                                       ¡                    ¦

CCCCCCCC66666668D8GXcdpq    £&amp;©¤F(20¨85§¦£&amp;Rg¨0H§¦ta¦ §P¦ EC7©&amp;&quot; ¡ 7¨$2£a4 ¦
                                 
                                       
                                   

CCC8&amp;886i8se2£¢2¡2ECRS0C§3`727©¦ §¦&quot;rr4 ¤

                                                                                                                                                                                                                                                               Êx§


CC88 DG ©&amp;F&amp;E&quot;H&quot;C£¦7(R¤§&amp;7#0C0HW7&amp;E¨'¡¨$¦FY£E'R¦ 7b7H$¦£¦

CCCCPPPPPPPPPPCCCCCCCCCCCCCCCCCCCCCCCCD2DfD2D2DDD2D2D2D28888GGGGGGGGGGXX&amp;XXXXXXXXcc&amp;ccccccccdd&amp;ddDDDDXcdpq68GXcdpq68GXcdpq68GXcdpq68GXcdpq68     7¨$¦£25#EPF&amp;&quot;H72RS! PE'7©#&quot;4§¦

                                                                                                                                                                          &quot;0¤¥aR¦&quot;0¤&quot;¤EC¥&amp;7#R2)$&amp;©¢2&quot;¤EC0'WT7#(2%RR&quot;(¨0C§WI§¦g¢R S#S©g S¤¤¡¤E¦ eS#F¦&quot;C £25E¤R&quot;CP£¦S#7#E'R7E0CW7#©&amp;&quot;C£¦0'&quot; WRC¡@$¦7#S¦£C0'E$¦W&quot;C£¦£R¤72CR$¦7R¤£¦720CWR§ R¡72¡CE'$F(¡£¢2¡£¨£(¨RR¨£¨@§2£7H7$2 £a7¨¥$R¨4 £a7¨34 $¦4@¤£&amp;7H4 $24C¤£&amp;tS#4 E¤¡e&amp;&quot;C£¦4'R¤¦ 70'W P$¦£¦R7¢RH§2                                       @7C$¦£a4§¦
                                                                                                                                                                           0¤R2$&amp;©¢2&quot;¤(2iRR(¨¥¤§¦g¢R§©g ©¡¤¦ eF¦ 5¤PS#E'7E©&amp;&quot;C£¦&quot; R¡@7#S¦0'EW&quot;C£CR$¦7£¦0CWR72C$¡£¢2RR¨§27 ¥R¨ 7¨3 $¦@£&amp;7H$24¨£&amp;u¤S#4 E¤¡e&amp;&quot;C£¦4'R¤¦ 70'W P$¦£¦R7¢RH§2                                                                                                                                                                                     @7C$¦£a4§¦

                                                                                                                                                                             

                                                                                                                                                                           © (Rg©¦

                                                                                                                                                                          

                                                                                                                                                                          0¤R¦`&quot;¤EHBT©$&amp;$&amp;£&amp;£&amp;&quot;H&quot;H7272£RR20¨0¨¤S#((55RR&quot;¤g¢g¢S#S#E ©©&quot;CEE£¦¤¤¡¤¡¤&quot;C&quot;C£¦F¦£¦F¦RSS7#55RR7#7#qq0'PPW0'0'E'E'¦¦ WW77©&amp;©&amp;C$¦CC&quot;&quot; $¦$¦£¦¡@¡@£2£2S¦S¦REE72RR&quot;C&quot;C££77¡¢2RR7¢7RF&amp;R¨0C0CWW§2H&quot;C§27§¥CC$$S ££7¨S@$27H($¦£a¦RR£&amp;77&quot;4&quot;f44 @¦ ¤7CR¨R¨$¦33 £a@@7H7H4C$2$2t&amp;£&amp;£&amp;44¦  ¡  q4'¦
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ¡  q4'¦

                                                                                                                                                                          © (Rg©¦
                                                                                                                                                                          0¤R¦¢2&quot;¤R ¨§¦F¡)ReS¤5H $&amp;¤'$a¡RSU$&amp;C$&amp;¡¤(! ¡@SE&quot;C£R70CW C$£R¤7 ¢2R¨§¦¥ 7¨$¦£#44 ¦

                                                                                                                                                                           $&amp;©(R¤(g¢R©2g©¡¤¦ F2PEC7©#&quot; ¡@S#E&quot;P£¦R7¦0CW '$2£¤R7 R¤3  7¨$¦£&amp;4 ¡ e&amp;4§¦
                                                                                                                                                                          0¤R¦§¢2&quot;¤SRiS¨§¦(2¥72¦)¡¤&quot;e(2&quot;A5 RS# 5ES#¤&quot;C£¦ER&quot;C£27#R0'7#W 0CWC$¦£¦C$¦£R¤72R¤ 7¢R¢C§¦RH§¦ 7H¥$¦@£#7C$¦4'£a¦ 4 ¦

                                                                                                                                                                          $&amp;'$r&quot;H72¡(U$&amp;C$#¡(! ¡R ¡ e&amp;4§¦

                                                                                                                                                                           $&amp;©(R¤(g¢R©2g©¡¤¦ F2PEC7©#&quot; ¡@S#E&quot;P£¦R7¦0CW '$2£¤R7 R¤3  7¨$¦£&amp;4 ¡@q4§¦

                                                                                                                                                                          
                                                                                                                                                                          

                                                                                                                                                                       

CCdd DiG e20¤¡¡C$EC$fS EC7§¦P4 ¤

                                                                                                                                                                                                                     Êr©


CCddXc 7¨$¦¡C$£2$f5SE'7E8§¦C$¦¤£¦§2RP72EC7b©#7¨&quot;$¦4 £¦ ¦

CCCCCCCCddpp&amp;pppp Ddpq68G  EHBI2¢2¤R¤RQ33¨0¤§¦2¡C$7©RC)$&amp;$f¦ e©E'7¦  (  C$¦£¦R72                                  R3  7¨$2£a4 !U5¡                                                                         R3#4           ¤

                                                                                       ¦

                                 (7e5¦5¦5¦0¤0¤0¤¡C¡C¡C$$$$f$f$fE'E'E'777 CCC$¦$¦$¦£¦£¦£¦RRR727272¢RR33¨§ 7¨7¨$2$2 £a£a7¨$244 £&amp;¦¦ 4'¦

CCCCppppXcdp   7(2('$&amp;B§¡£2e2SR¤r72EC7©&amp;¢ &quot;@(¡ 7&amp;34'V&amp;¦ E¤¤£¡( ¡ 7 ¡ e#4'¦

66666qq&amp;qqqDq)68Y¢e2EQEQ$&amp;$&amp;¡¡R''EC$&amp;$&amp;SSS ¡¡$&amp;((RSY!!C$# 0H¡q !(!05H5H$&amp;$&amp;P¦R¤R¤4 g2g2&quot; ¤  F#F#&quot;H&quot;H77((§§0H0H7&amp;7&amp;ECEC¡¤¡¤FF                      FF¡¡RRS2S200           ¡  22q£q£¡¡           22q£q£¡¡       22q¢q¢¡¡       q£q£¡¡     qq44                 ¦
                                                                                                                                                                                                                                 ¡                                                                                           ¦

6666qqqqGXYcYdYEQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;0¡¡¡(((!!!R¤(hD68 (25H5H5H3&amp;$&amp;$&amp;$&amp;ER¤R¤R¤g2g2g2&quot;C72 (#F#F#F#&quot;&quot;H&quot;H&quot;H777(((§§§0H0H0H7&amp;7&amp;7&amp;ECECEC¡¤¡¤¡¤FFF    FFF¡¡¡RRRS2S2S2000  ¡  f226£8£1¡¡¡       222q£q£q£¡¡¡  222q¢q¢q¢¡¡¡  q£q£q£¡¡¡  qqq444              ¦
                                                                                                                                                                                                                                 ¡                                                                                           ¦
                                                                                                                                                                                                                                 ¡                                                                                           ¦

66&amp;6&amp;6&amp;qCCpqY6Y)EQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;B#¡¡¡E'F2(((S)!!! ©GXc (R¤5H5H5HF&amp;$&amp;$&amp;$&amp;0CR¤R¤R¤Wig2g2g2 72R¤F#F#F#(&quot;H&quot;H&quot;H32777(((7§§§0H0H0H7&amp;7&amp;7&amp;ECECEC¡¤¡¤¡¤FFF @FF¡¡RR¡S¨S2f£&amp;0 10¡ ¡¡ 22f8£8£¡¡ ¡ 2f2q£1q¢¡¡ ¡ 2q£q¢¡ q£¡ §¡ Sc£q£S¡ 4'¡ q¦ q¦4 4'¦ ¦

6&amp;6&amp;6&amp;CPDG8 EQEQ$&amp;$&amp;''$&amp;$&amp;&quot;H72¡¡((¡(!! Adp ©(25H5H$&amp;$&amp;R¤F&amp;R¤R¤g2g20'Wi 72F#F#R&quot;H&quot;H(7732((¤§§7`0H0H7&amp;7&amp;7ECEC¡¡¤¡¤FF E $&amp;F¥¤C7¡$&amp;¡R¡(S2(£0 ! ¡¡ QC22q 8£q£ ¡¡ 22q£8£¡¡ 2fq¢¡¢¡ q£Cq¢¡ ¡kqq¦4 4'¦ ¦

6&amp;6&amp;6&amp;CCCXcYdYEQEQ$&amp;$&amp;''$&amp;$&amp;¡¤§¤¡¡$¦((£`!!  72C¡Yq 0¤5H5H$#$#¡¤§RRFg2g27h 72F&amp;F&amp;¡&quot;C&quot;C77C(¤(¤q`§&amp;§&amp;0H0HB¤77§E¨E¨F&amp;¡¨¡¨FF0H7&amp;7 FEH¡¤¡FR¤¡ S0 ¡ q£¡ 28¢q£¡ ¡ 22q¢8£¡ ¡ q£q£¡k¡bq4'PD¦ ¡ q4'¦

6&amp;6666&amp;CqYp)EQEQ$&amp;$&amp;''$&amp;$&amp;©(2¡¡((R¤F#!! 0C WhCC68 ©¦R¦5H5H$#$#0HgiRRg2g272 ¡iF&amp;F&amp;B&quot;C&quot;C§77F#(¤(¤§&amp;§&amp;0H7&amp;0H0H77E¨¡¤E¨E¨F¡¨¡¨FF 0¤7 RF¡R¤¡ S0 ¡ q£¡ 28¢q£¡ ¡ 22q¢8£¡ ¡ q£q£¡k¡bqCq£4'¡k¦ q4'¦

66666666 D68YG EQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;0¡¡¡(((!!!R¤(h (2PCDGX 3&amp;E5C5C5C$&amp;$&amp;$&amp;&quot;C72RRRggg(# &quot; F#F#F#&quot;H&quot;H&quot;H777(((§&amp;§&amp;§&amp;0'0'0'7&amp;7&amp;7&amp;EHEHEH¡¤¡¤¡¤FFF  £££¡¡¡               f226£8£1¡¡¡       222q£q£q£¡¡¡  222q£q£q£¡¡¡  q£q£q£¡¡¡  §§§SSSS#S#S#444     ¦
                                                                                                                                                                                                                                                                                                                                ¦
                                                                                                                                                                                                                                                                                                                                ¦

666666XcYdYEQEQ$&amp;$&amp;''$&amp;$&amp;E'F&amp;¡¡((0H(!! C $&amp;¤CCFcd 7A5C5C©$&amp;$&amp;!RRgg F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF 7 F£¡R¡ S¦0 f¡ 1¡ f8£1¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡ §1S¡kS#q4 4'¦ ¦

                                                                                                                                                                                                                                                    Êx


666688&amp;pqY)EQEQ$&amp;$&amp;''$&amp;$&amp;0¤¡C¡¡$¦((£2!! R (2C6Cpq 72¡5C5C$&amp;$&amp;CRRqgg        F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF  7 F£¡R¡ S¦0  2¡ 6£¡     28£8£¡ ¡      2fq£1¡ ¡  2q£q£¡1¡k¥¤C§q£©a¡ 4  q4'¦

                                                                                                                                                                                                                                    ¦

666888D68YEQEQ$&amp;$&amp;''$&amp;$&amp;EHBi¡¡(((f!! ' 5CC5a6&amp;66'q5C5C7$&amp;$&amp;W¦RR¤ggF` (2F#F#&quot;H&quot;H777§(((§&amp;§&amp;F0'0'7&amp;7&amp;EHEH¡¤¡¤FF 7 F£¢¡R¡ S¦0 2¡ q£¡ 28£6£¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡kqC64'G¦ ¡ q4 ¦

666888GXYcYEQEQ$&amp;$&amp;''$&amp;$&amp;2¡¡((&quot;¤!!    ¡¤CC§¨66$¦D8 £i5C5C©¦$&amp;$&amp;R¦RR0Hggg  F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF  7 F£¢¡R¡ S¦0 2¡ q£¡ 28£q£¡ ¡ 22q£8£¡ ¡ 2q£q£¡1¡kq4'Cc£¦ ¡                q4 ¦
                                                   

6666D2Df88dpYqY)EQEQEQ$&amp;$&amp;$&amp;'''$&amp;$&amp;$&amp;B§¡¡¡F&amp;(((!!!0C7&amp; E¨CCC¡¤666FhGXc (5C5C5C$&amp;$&amp;$&amp;7RRR§ggg( F F#F#F#&quot;H&quot;H&quot;H777(((§&amp;§&amp;§&amp;0'0'0'7&amp;7&amp;7&amp;EHEHEH¡¤¡¤¡¤FFF 77 FF£¢¡¡RR¡ S¦S£0¡ 2¡ q£2¡ 8¢28£¡ q£¡ 2¡ 28¢2q£¡ 8£¡ ¡ 2q£q£q£¡ ¡1¡kq£qC¡ q£4'q¦¡¦ 4'q¦ 4'¦

666D2D2DD6Y8YEQEQ$&amp;$&amp;''$&amp;$&amp;¡¡((!!         CC66dp  5C5C$&amp;$&amp;RRgg                F#F#&quot;H&quot;H77((§&amp;§&amp;0'0'7&amp;7&amp;EHEH¡¤¡¤FF  ££¡¡         22q£q£¡¡       22q£q£¡¡  22q£q£¡¡  q£q£¡¡  §§SSS#S#44  ¦
                                                                                                                                                                                                                                   ¦

6666DD2D2D2GXcd $&amp;R(2E'EPFF¡¦7`R&quot;¤PS4 (27$&amp;2¤¡¤§C$&amp;F23&amp;S¡E5(&quot;C72!q¦P(#4'&quot;r¦  (2¤3VE¤24'¦

666666 D2GGGGG Dpq68  ¥Wa(2£0¤EE¤¢¡¨¡'&quot;$§¦&quot;C$f§¦F20CC§SEC727t4 §¦t¤§¤¦ §¦&quot;r¦PP&quot;f44 P¦¦ 4'¦

666 GGG GXc   (§¦27#EC(2PE'7©&amp;&quot;4'¦

~ h)|hv3&quot;#Rv4 zy W $Âxbvz ¡ &quot;¢¡§z  z xG)z ¤£#7$ÂzT&amp;(SÂ9X|~10 2

  b7!£2SBi¤F§¤$ ¤F§¤$  ¥72R7§#&quot;¥¤ Fe2R2EHS ¡ ¢2R¦EHS ¡A6¡¢¦0C§7&amp;EPF3 ¡ ©2¡¨F¦£¡ §¤$#¥72R7§#&quot; `¥¤72R7§&amp;&quot;'¦
  D6h8GX7¨!2¢2£2RR¡C$33S¨$f§¦2BR'E'$&amp;727 R&quot;H7e3©C$¦(R¦ §&amp;(2£¦¨§¦0H37YR72¦¦ &quot;H7¦ (§&amp;0H7  ¡C$$fE'7 C$£R7 ¤
  cdp SSSB#B#B#E'E'E'F¦F¦F¦ 0¤0¤0¤¡'¡'¡'$$$$f$f$fECECEC777 CCC$¦$¦$¦£££R¤R¤R¤727272¥¥¥¨¨¨777£¢RR33H§2@@SS¡¡S e&amp;e&amp;¡44 e&amp;4S#S#44S#¤¤ 4 72(2¤ R e233 R55¨§¦¢@@e#e#5I4444  e&amp;44
 CCq6 SSSB#B#B#E'E'E'F¦F¦F¦ 0¤0¤0¤¡'¡'¡'$$$$f$f$fECECEC777 CCC$¦$¦$¦£££R¤R¤R¤7272722¢2¨RR¨33¨§2@@S#S#44@S4@@S#S#44S#¤¤ 4 7(¤ R e23&amp;3&amp;R44 H§¦4

                                                                                                                                                                               Ê


6CPCCCCD8hGXcdpq7 !¢2¢2©&amp;£2F&amp;RR¢RRE'EF¦3S¡¨¨&quot;H&quot;C§¦§¦£¦7¡¡(¨(¨§BR¤727#S£¨£¨££RS&quot;H0Cee73©W(2(RR¦¦ $&amp;$f§&amp;¨¨'&quot;$¦§¦§¦R¢0HE'&quot; F27Y£¡ ¡¡¥&amp;(¤(¤&quot;HE'R¦¦ F#7£¨£¨7(££&quot;H§&amp;7¦¦¦ §0H7SS ©&amp;(2¦E&quot;C&quot;£¦&quot; R¤¦ 7#0CW C$2£R¤72¥¤

6&amp;666D68 SSSSB#B#B#B#E'E'E'E'F¦F¦F¦F¦))))S#S#S#S#EEEE&quot;C&quot;C&quot;C&quot;C£¦£¦£¦£¦RRRR7#7#7#7#0'0'0'0'WWWW CCCC$¦$¦$¦$¦£¦£¦£¦£¦RRRR72727272 F#R¤R§EPF¦3¡&quot;H7¡¤¡¤@(¨(¨§SS£¨£¨4 ££S¤(2SS2S#&quot;44 4&quot;f¤@S#72S#S#4 R44 3#¤¤ 4$&amp;$fSR¢4E'F2¡¤ ¡¡(¤(¤E'F#£¨£¨£a£a&quot;H744 §SS(2¦&quot;&quot;4

6666GXcd SSSSB#B#B#B#E'E'E'E'F¦F¦F¦F¦))))S#S#S#S#EEEE&quot;C&quot;C&quot;C&quot;C£¦£¦£¦£¦RRRR7#7#7#7#0'0'0'0'WWWW CCCC$¦$¦$¦$¦£¦£¦£¦£¦RRRR72727272¥¥¥¥¤¤¤¤7777 F#R¤R§EPF¦3¡&quot;H7¡¨¡¨ (¤(¤§S S£H£H¡££Se&amp;(@@4S£S£2&quot;¡¡&quot;ae&amp;e&amp;S#44S 4¡¤ e&amp;S#S#724 R44 3h¤¤ $&amp;$f5TS#R¢4E'F¦¡@¤ e&amp;¡¤¡¤(¤(¤4E'F&amp;4£¨£¨££&quot;C7 55§SS@@e&amp;e&amp;(44¦44&quot;&quot;5I e&amp;44

68pq   SSB#B#E'E'F¦F¦))S#S#EE&quot;C&quot;C£¦£¦RR7#7#0'0'WW  CC$¦$¦£¦£¦RR7272¥¥¤¤7£7£¢¢RR¨¨§§ ¥S£S£¡¡e#e#44@@S#S#44                                                                                                                                                                                      ¤    eeRR¨¨§¦§¦ ¥15T5T@@e&amp;e&amp;4444
                                                                                                                                                                                                                                                                                                                                                       ¤  

8&amp;86    SSB#B#E'E'F¦F¦))S#S#EE&quot;C&quot;C£¦£¦RR7#7#0'0'WW  CC$¦$¦£¦£¦RR7272¡¡¢2¢2RR¨¨§2§2 ¥ S#S#44                                                                                                                                                                                                     S#S#44  ¤    e2e2RR¨¨§2§2 ¥44
                                                                                                                                                                                                                                                                                                                                                 ¤  

D2Df8888888D8hGXcdpq 7 !2£2¥F&amp;72R¢RRCE'$¦F¦33£3£SR¡&quot;H£772¢2¢2¡¡§#(¨(¨§BR'RR$&amp;SR£¨£¨¨¨&quot; ££§¦§¦72S&quot;H7(2 (&quot;H¦¦ $&amp;$f§&amp;272&quot;7272R¢R0HE'&quot; F23§77Y¡R¤R¤§&amp;©3£3£¡¡(¤(¤¢2¢2&quot;HE'&quot; F#7RR£¨£¨¦ (££&quot;H¨¨§&amp;7§2§2 §0H67S¥D©D©S¡¦¦¦ (2¦¦ C¦$¦&quot;£&quot; ¦ R72¥¤

D2D268 SSB#B#E'E'F¦F¦ &quot;HE'F#7R&quot;H77§&amp;§S&quot;rS 7&amp;(2¦4 &quot;&quot;r@ 7#7&amp;44Y¤ &quot;H@7&amp;7R4 7¤ §&amp; E'&quot;F&amp;4 &quot;H7 §SS(2&quot;&quot;4

DD DG SSB#B#E'E'F¦F¦ &quot;¤&quot;¤¤¤772¥F&amp;72R&quot;H77§&amp;§S&quot;rS@7(22¡ e&amp;&quot;&quot;r4Y@7£@¡ 7&amp;e#44 ¤ &quot;H@7&amp;72R4 7¤ §# E'&quot;sF&amp;5T&quot;C7 §@e&amp;S4S(4 2&quot;&quot;5T@e&amp;44

D2D2D2Xcd SSSB#B#B#E'E'E'F¦F¦F¦ 727272'''$¦$¦$¦£££RRR7772R¢E'F¦3¢¡©¡¤¡¤(¤(¤@7&amp;£¨£¨££4  7&amp;7&amp;44@7&amp;4@@¤ 7&amp;7&amp; 244 ¤¤ 3§ $&amp;$f©&amp;R¢E'4 F¦¡¡¤¡¤(¤(¤£¨£¨£a£a44

D2GG pq  SSSB#B#B#E'E'E'F¦F¦F¦  727272'''$¦$¦$¦£££RRR777¥¥¥777R¢E'F¦3¢¡©¡¡((   7£¨£¨££ ¡  e&amp;@@774  ¡  e&amp;e&amp;44  7&amp;4@@¤ 7#7# 44 ¤¤ 3¢ $&amp;$f©hR§EP5TF¦¡¡¡(¤(¤@e&amp;£¨£¨££44                                                                                                             5T5T@@e&amp;e&amp;4444
                                                                                                                                                           ¡

GG 68 SSB#B#E'E'F¦F¦ EE&quot;&quot; ¢2RR32¨§¦¥ 7¥e&amp;@74 e&amp;E4¢&quot; ER&quot; ¢3 R 7¨§¦e¥¤  77e¥R3£¤ ¢2 7RRH§23£¢2¥2R¨4 §¦¥¦4

G D SB#E'F¦ &quot;¤¤7 ¢2¥ 7 ¡7e&amp;4  7&amp;4 ¤  7R3£¢2RH§¦¥5¤7e&amp;4

                                                                                                                                                                                                                                                                                                                                 År1


GG SB#E'F¦ &quot;¤¤7 ¢  7 ¡7e&amp;4  7&amp;4 ¤  7R3£¢2RH§¦ 5¤7e&amp;4
GG Xc SSB#B#E'E'F¦F¦ &quot;¤&quot;¤¤¤77£¢2RR32¨§2¥@7¥e@7¡ e 7&amp;¡ 4`7&amp;&quot;¨4i7&quot;¤7R¢23 R@7¨§¦e¥¤ @772e¥R3£¤ ¢ 72RR¨§23 ¢¥¢R¨¡§ 7&amp;¥£44¡ 7#44
GG dp SSB#B#E'E'F¦F¦ 3232¤¤77£¢2RR32¨§2¥@7¥e&amp;@74e#324327 ¤7£R¤¢23 R@7¨§2e¥¤ @772e¥R3£¤ ¢ 72RR¨§3¢2¥RH4 §2¥4
XX&amp;q SSB#B#E'E'F¦F¦ EE&quot;&quot; ¢2RR3¨§¦ 7e&amp;@74 e&amp;E4¢&quot; ER&quot; ¢3 R 7¨§¦e¥¤  77e¥R3£¤ ¢2 7RRH§23£¢2 R¨4 §¦ 4
XX68 SSB#B#E'E'F¦F¦ &quot;¤&quot;¤¤¤77£¢2RR3¨§2@7e@7¡ e 7&amp;¡ 4`7&amp;&quot;¨4i7&quot;¤7R¢23 R@7¨§¦e¥¤ @772e¥R3£¤ ¢ 72RR¨§23 ¢ R¨¡§ 7&amp; 44¡ 7#44
XX DG SSB#B#E'E'F¦F¦ 3232¤¤77£¢2RR3¨§2@7e&amp;@74e#324327 ¤7£R¤¢23 R@7¨§2e¥¤ @772e¥R3£¤ ¢ 72RR¨§3¢2 RH4 §2 4

XXXXcXhcdpq7 !£2&quot;H7CRR$¦33(S£§&amp;B0C!27¡R72¡¤&quot;H7§S7 (F©&amp;¦ §&amp;3©&quot; 720H¦¡ 7Y'$¦7£&quot; ©#¨R&quot;77Q©&amp;¦&quot;&quot;¦ ¤§¨$ R3£¦

c&amp;cc68 SSSB#B#B#E'E'E'F¦F¦F¦h72!2¡'¡¨¤$¦§S £FP3ER4P7E4rPEE'©¤4¤Pu¡E¡Q¦4¨E'u¡F2 ¡¦S !2S#¢&amp;¡¨44 §F3&amp;4PE'©&amp;4¤u¡¦  7C$¦£R¤7¦&quot;4&amp;¨rEPFS£¢4 4

cc DG SSB#B#E'E'F¦F¦ &quot;¤&quot;¤¤¤77¤£¡¤§S Fr3E P¡ e&amp;E 4Y¡ e#4YPE4¤ruE¦4¤u¡ ¡¦ !2SA¡¤5I§F3 e&amp;5I44  e&amp;44

cccXcd  SSSB#B#B#E'E'E'F¦F¦F¦        ECECEC777©&amp;©&amp;©&amp;&quot;H&quot;&quot; V6¨$¦§§£((27!¤PFEP74YE4rE F¦4Y@!2£¢¡¨r§7ECF7©&amp;3R3&quot;HPVE@§!4b¡¤5§5FP3E¡4rES44P2E5¡454  ¡S rE44    PE44
                                                                                                                                                                                                                       R¤3 !2¡¤§F3

cdd&amp;phq e2©&amp;¡¡CE$&quot;'EC$f£¦S`RECB7#7 ¡0C(W'$¦¥¦£RC$¦(S£R7 R¢772S©#)Y&quot;)8E'F&amp;§¦E ¤&quot;H¡ 7§¦2R 3`RS77!©&amp;&quot;¡ ¢27ER©&amp;4'¨&quot;A¦ §2E4'e&amp;¦ 4'¦

~¢¡ h)|hv3&quot;#Rv4 zy W $Âxbvz ¡ &quot;¢¡§z  EH%&quot;%$zT&amp;)(S³CX|~HR 2
           E'E'E'F#F#F#000¨¨¨§2§2§2SSS  72EEC7R&quot;¤©&amp;3¥R &quot;¤¤WW
6 8                                                                             ¦    ¦

                                                                               ¤UW¦

D`GX e2¤F¡8¤EC§¦SR3`¤§¦!©¦ 7©&amp;&quot; E ¡ C$¦£R72 7&amp;4 ¤

Ccdpq     !&quot;  ¥a5`0¤0¤EC7#R2R2!2&quot;¤&quot;¤&quot;H0'WT72¡¤§RFFF7@72§#¡¡3 CRR&quot;rP$¦SSE@£¦£#7&amp;04'0¢4%¦ R 572¤  R¢¡¡(¤£H£   7&amp;44                 ¤
                                                                                                                          ©2¡¤F2¦

                                                                                                                                                                                  Å²


66&amp;6666CCPCCCCDD68GXcdpq68G        ©&quot;¤(27£¢2RgR¨¦ §¦  7 ¡q¦4'¦
                                      0¤R2&quot;¤&quot;¤7£F¢2¡RR¨S¤§¦ ¤ 7 ¡q¦4'¦
                                      S ©B&quot;H72(2R¤§R7R¤§#7¤g &quot;r¦ @¤7&amp;4%5¢2R2EHS ¦

                                        

                                     !272 ¡¤C$¦§F£3RP72E41P5hE ¡ F¦!&amp;£4¢57 7©R3¦ @!&amp;4 ¦

66668Xcidpq S¡CE$8¤$f§¦CR¡C$$¦3¤EC$f£§¦7 ¡E'7R'¦ $¦72£7C$¦©&amp;7©£¦R&quot; 7¦ ER 724 )¤ 0 ¦

D2DfD28&amp;88888888D68GXcdpq6  7¡``EHBI(2(255`0¤0¤0¤0¤¡'¡'¡'¤¡'¤Q$$$$7277¡&quot;H&quot;¤$f$f$f$f§§72C$¦((SRECECECEC£FF7777¤7P§#ERCCCC00&quot;r4'$¦$¦$¦$¦72¦¦@¦ ££££7&amp;4%PR¤R¤R¤R¤E 572727272¡5¡¥¥¥¥4'©¦ ¡¤7777 F¦¢22RRR4333C§¦rrr¤000 r¡¡¡ 0 722¡¡C¡4'$¦3¦ £¦R¤7£3&amp;¢2R4'72R¦ H§¦3¢¥©@7#@7#44'44'¦ ¦

                                     

D2DDD2D2D2D2D`8hGXcdpe2(2 ¡C$#¡`&quot;¤&quot;¤ECRS¡35727¤e2¥£¡¡7¤ SR¦ S77P§&amp;©&amp;EPE&quot;r&quot;)¡4' F272E¦ £4C¢$¦7¤£R¤R37 ¡Q4E 4  ¡¡24  ¡  Fe2R2EHS#4'¦
                                                                                                                                                           ¦

GGGGG Dqh68be2(§¡ECCRS¡C$$¦32$f£¡7&amp;E'7RE'¦ 72(2C$¦ 7©£¦7¦ ©&amp;R72&quot;¢)E04 ¦ ¤

GGGGGXGXcdpq                     7¡`EHBI(255`'$&amp;72¡'C¡! $¦e2SEC£7P©#ErR&quot;4'E726¨4'¦ $¦¦ £P7E !¡¡P4'E4¦ 4  ¥¢¥Ir&quot;H7R7§&amp;&quot;r 7&amp;4s55                    FeR¦EHS#44¥¤

                                     

                                                                                                                                                                                     ÅÔ


X&amp;XXXXXXXXcc&amp;ccccccccdd&amp;ddddddddDDD68GXcdpq68GXcdpq68GXcdp©&amp;E'F&amp;E©&amp;B`E'EH&quot;'&quot;CF£¦7BIR¡E7¨(2(273`(IS#2R&quot;CEH$2£¦BT7#'¤¤E@$¦£Y777©BBR¤R&quot;¤&quot;CEH0C@£§§£¦7`7#BW¡¤¡¤S¦ §§5i((BS#S#S#S#S#S#!R0C'5YFFF2F2W¤7#¡¨RCEEEEEE!U72§$¦B7ShS&quot;C&quot;C&quot;C&quot;C&quot;C&quot;C0'@7£¦£¦£¦£¦£¦£¦F2SWSCq¡¤£7'4@$¦$¦5§72ShRRRRRR©#¦¦¦ 7¨£¦5F27#7#7#7#7#7#¤£'CR&quot; $¦$¦7$¦5q5`S720'0'0'0'0'0'££WWWWWWR£¦ER4¦ ¡727§4¦ ¥¢RCCCCCCR1¦ ¥I$¦$¦$¦$¦$¦$¦S¤772r§¤S£¦£¦£¦£¦£¦£¦EP$E¥r¦¡ 7&amp;&quot;HR¢4RRRRRR72R7272727272727¡44'3©R4¡¤¦ 7(¤¥¥¥¥¥¥R¦§&amp;¤3¤¤¤¤¤¤£H7£77777£7£&quot;rt¢¢S£@ t#7¨F#7HR¤R§RREP¡ $2$¦F¦34¡¨¨&quot;H£a§§£#7¡¨¡¨ ¤¡(¤§(¤S4%4S¥£H£H¡5R££S!U7&amp;553&amp;(S£S£@@4'S£S£24¡¡¢2F&quot;¦¦¡¡33¡R&quot;a7272R¦7£7£S#CCEHS $¦$¦¢2¢2S#4¡ £¦£¦RR4 ¥¢HE'H¥¢F&amp;¥T§¦§¦RR¥7272&quot;H7¥@72§E@@CS&quot;7H7HR¢E'$2¢$¦$¦F¦S¡£R(2£a£a¡¡¨(¤(¤244§¦R&quot;£H£H4'4'72££&quot;r¦¦ @@@7¨7H7H@$2$2$27¨R¢$¦£a£a£a¡£a¡444(¨4¦4'4'4'£¨¦¦¦ ¥¢£ ¥  7H$¦E&quot;£&amp;¢24 R¨!§¦5 ¥¥72 ¡7¨$¦(£a4444  ¤

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        494

pp&amp;ppqh68$&amp;e2 ¡R(&quot;¤ECg9S726¡¢2¥7¦R0f7 §&amp;7&quot;r©&amp; 72&quot;AC$¦E £¡ RR73iQ7&amp;E 4¡7&amp;¤ 4 ¡ 6¡¢2¦0'§7&amp;E'F3#4'¦

CCCCCCCppppppqq&amp;qqqqqD`DGXcdpq68GX $&amp;e2 ¡R7¨(`EHEC$¦g¢BISC$¦£B©2&quot;¤&quot;¤&quot;¤£¤¤¤¡¤¡¤72727£(5`F¦&quot;¤@@¥¦7272¢2¥¥R72727272CCRR $¦$¦¤('RR¨$¦£¦£¦§277S77¨£§&amp;§&amp;©&amp;P$¦RR¥&quot;r&quot;rE&quot;A£©7272R@@@¡7727272E¦ 7'''¡ $¦$¦$¦R¢R¢¡P£££¡¡E e&amp;R¡¡¡ 3i(¤(¤4'RRR7&amp;777£C£C¦ 7££4'¡¦PP@@P7C7CE1E1E1¢2$¦$¦¡¡¡R£&amp;£&amp;7#7#7#¨44§2444 55h¡¡¡ 5`5¨e#©e#F¥£¡¤44'72F¦#e2¦ ¤¡R4(¦44'EC¦ ¤S#4 4'49¦ 4

CCCqqqCc)dhpq e2B¡¡(EC¥¦RS 3R(S0    7©&amp;&quot;  E¡  R3`7 ¡ ¢R¨§¦ e&amp;4 ¤

                                            ¦

                                                                                   ÅÊ


CCCC66&amp;66CCPCCCCD68GXcdpq68     B¡7¨(IEH$2BT'$¦£YEHr£B0Ar5i&quot;¤&quot;H5Y7¤RP727£7RE¢27Cq&quot; $¦§&amp;R¦7¨£¦R¤¨&quot;r$¦32§20 £7¨R¥$¦72¥@¦ 7¨£a@$2724%r§¤£a'E $5$¦4¡Q5£0¥¢R4'¢¥I3©R¨¦ R72¦k¦@320HEHPtS#¤E t#74¡ 40¤R41¤32¡¥e#@7¨4'$¦¦ £a455i7&amp;44  ¤
                                                EHB &quot;¤¤P7£E¢2&quot; RR¤¨3§2 @7¨@$272£a'$¦4 £¥¢¥IR¨72@32P¤E 7 ¡ 0R413¡e#@7¨4'$¦¦ £a455i7&amp;44                                                                                                                                           ¤

                                                   
                                                
                                             

                                          

~ x ¡ ¡4zu  xbvx ¥¤ W¤z  z!F³Â4qgz xGz  £#$zT&amp;(Pvx¢¡)~10 2

b7!£2SBi¤F§¤$ ¤F§¤$ ¡ R3 ¤ q£¡ 1¡ 6£¡ 8¢¡ §¨$ R3 ¡ 2¡ R3  R3©¦

D6h8GXcd7 !§£2E'FFaR¢273£SE¨7¢2R¤R¡¤3F¨ R¨BR§¦3B2¨§¦¤&quot;H77R¡(3¤R(¦ §&amp;e23©rRe20H§¦ 7YHR¦ §¦¨§2&quot;H7¦ (¦ §&amp;0H7 ¡ R3£¢2R¨§¦¥¤

Cpq SSB#B#E'E'F¦F¦ EE&quot;&quot; ¢2RR3¨§¦@7e&amp;@74 e&amp;4Y@7'e&amp;!¨4@¤ 7 e&amp;B4 R¤ 3&amp; B4 R3&amp;44

CCPCD68 GX                              SB#@7E'F¦e&amp;4  ¤  &quot;¤ ¤B27R¤R3)3 5 7e4'¡¦i7#4@7¤ e&amp;4          ¤    72R3                                   ¡(    eR¨§  ¤    7R¤35@7&amp;44 ¦
                                             SB#@7E'F¦e&amp;4  ¤  &quot;¤ ¤B27£¢2R¤R3)¨5§2q@74'e¦i¡e&amp;@74 e&amp;¤4  ¤    72R3                                   ¡(    eR¨§  ¤    eR¨§5  e#44'¦

CCcd SSB#B#E'E'F¦F¦ 3232¤¤77£¢2RR3¨§2 7e&amp;@74 e&amp;4@7e&amp;@74 e&amp;¤ 4 72¤ R 73 R 3¡( ¡ (e2Re2H§¦RC§¦¤  7¤ R¤ 3#eR4 C§¦4

66&amp;Cqp SSSB#B#B#E'E'E'F¦F¦F¦bAA$&amp;F¦£(¡¤(2¢7e RRR333 @@@7&amp;7&amp;7&amp;444 @7&amp;@7&amp;4#@7&amp;4Ht&amp;4C!5Tt4¢§¤¡$§¤§¨$$R3&amp;RR4¤3¦3&amp;u#u#4¤4£¡4¤4 §¤$ R¤3#4

~¢¡ x ¡ ¡4zuqDz ¡4|hvz ¤£#$Âz¦zux)z  £#$zT&amp;(P±x ¡9z ¡ $z9~10 2
6hb77!!£2£2SSBB ¢2RR¤3£¨§¦¢2R¨2§2 3V&amp;RE¤33 S§¤2$32V&amp;¤3E¤2RC$  §¨$¦ ¤3 RC$&amp;¦

D8`££¢¢77((FFi¢2e2R¡HEC§¦S )((B2B§£2¡S¡¤gR§72£@@33V&amp;V&amp;E¤E¤¢¢¡¡2233 RCRC$&amp;$&amp;£4'¡ ¦ ¢2R¨§¦4'¦

G £¢7(Fie2¡ECS 7(B§£SR72¢  R33S3V&amp;E¨bB ¡ 23 2R'$&amp; ( ¡ R3i7 ¡ ¢2R¨§¦ e#4'¦

X`£¢7(Fie2¡ECS 7(B§£SR72  R33S3V&amp;E¨£¡232RC$&amp;£¡ R3&amp;4'¦

                                                                                                                                                                                     Å(Å


c`£¢7(F R3 ¢2R¨§¦¢7(B2¡¡g§£  R332S3V#E¤¤£¡23 2R'$&amp;4'¦

~ x ¡ ¡4zuqDz ¡4|hvz ¤£#$Âz¦EH%&quot;#$Âz¢¡¡9I w &amp;)(Pvx ¡9z ¡T $Âz4~1R 2

  68 E'E'E'F#F#F#000¨¨¨§2§2§2SSS 72(2ER&quot;¤3¥3R B¤¤WWE¤¦¦  ¤UW ¦

DGXc¢2( B2R(2H§¦¡7¡§g§(F`£ @B2U(3V#E¤¦ bB ¡ 23 2R'$&amp; (&amp;4 ¤
Cdhphq e2( B¡§BEC£2SU(SiR725i@e©2¦ 3V#E¤bB ¡ 23 2R'$&amp; ( ¡ ¢2R¨§2he#4 ¤

CCPD68hG 7 (R(23B¢27R¡§¡¨(§¦gF`§ £ B  U(  R332S3V&amp;EHbB  ¡     23 2R'$&amp;  (&amp;4       ¤

                                                                ¦

66&amp;CCCCXhchdpq e27 (¡B¤EHEC§BIS £2&quot;¤¤S 327£R¢277R¢¨§2R¤ 3R¤BB332UU(£(£#S24H¡ e&amp;5¤354'V7¦ E¤4 ¤bB ¡ 23 RC$&amp;A( ¡ R3i7 ¡ ¢2RH§¦)e&amp;4 ¤

6666 D6h8hG e27 (¡B¤&quot;¤EC§S7£2SR¤R37B U(£R¤3¡ 7&amp;324'S¦ 2¤3VE¤bB ¡ 23 RC$&amp;A( ¡ R3i7&amp;4 ¤

66Xhc e2¡2ECSi3 (2¦R'$&amp;&quot;¤ 7E'¦ 3&amp;E&quot;H7(#&quot;r R33S2¤3V&amp;EHbB#4 ¤

6688&amp;dpq     B¡(&quot;¤¤P7£EC¢25Rq¨¦r§2E §¤B $ 2E ¤3¡qRC4'$¦ ¦rE'tt4  ¤

                

             

                                                                                                                    ÅH


 &amp;S8@§I¼§  UWQ#8@©H§ dQe© $1Y5©A`©9V  Q9585&amp;§F G&quot;@A ©4§d¤YWV                                                                     ¡ AB¡r ¢£
¨~£ © Dz xG¥¤4%$ ¤ hF|h±¢&quot;%RÂ4Ezuy{9 ¤ zux)z  £#$zT&amp; (y{zuy{9 ¤ ~10 2

      SB#E'F¦h¥E  $&amp;'$&amp;¡(!)q£¢fCqqqq
    6h7!£2SB F#&quot;H7(§&amp;0C7&amp;E¨¡¤F $&amp;C$&amp;¡¤(!  ¥E  $&amp;'$#¡(!  ¦
    8`£¢7(F F&amp;&quot;C7(§&amp;0H7#E¨¡¤FYE $&amp;C$a¡RS  $#C$&amp;¡(! ¡ F&amp;&quot;H7 §SS(2¦&quot;&quot;4'¦

¨~£ HG Dz xG¥¤4%$ ¤ hF|h±¢&quot;%RÂ4Ezuy{9 ¤ EH%&quot;#$ÂzT&amp;)(Sy zy 4 ¤ ~1R 2

    6 E'E'F#F#00¨¨§2§2SS EEQ$&amp;&quot;¤RC$#¤W¡(¦ !¥¤UW ¦
    D8GXEQ$&amp;F&amp;(2'&quot;C$a77(§§&amp;¡(R0HFA7#SE¨ $¡¤$&amp;F RC$# ¡¦ (!$ ¡ F&amp;&quot;H7 §SS(2¦&quot;&quot;1R4 ¤

£¨~ Dz xG¥¤§¦ Â±z¦Ezuy{9 ¤ z xG)z  £#$Âz'&amp;(y{zuy{9 ¤ ~10 2

      SB#E'F¦h¥E  C$#¡(!hq¢fCqqqq
    6h7!£2SB ¢2R¨§¦ C$#¡(!  ¥¦E  '$&amp;¡(!  ¦
    D8`££¢¢77((FFi¢2e2R¡HEC§¦S 1$&amp;$&amp;CC$a$r&quot;H7¡R¡(2S   '$&amp;C$&amp;¡(¡(! !¡ ¡ §§SSS(2S(2¦¦&quot;&quot;&quot;&quot;4'¦¡ ¢2RH§¦4'¦

¨~£ ¢¡ Dz xG¥¤§¦ Â±z¦Ezuy{9 ¤ EH%&quot;%$zT&amp;)(Sy{zuy{9 ¤ ~1R 2

    6 E'E'F#F#00¨¨§2§2SS $&amp;EC&quot;¤$&amp;R ¡¤¤W(!¥¦ ¤UW ¦
    D8GX$&amp;¢2 RC$&amp;(2H§¦7¡§R(S FA $C$&amp; R¡(!s¦ $ ¡ §SS(2¦&quot;&quot;¢R¦4 ¤
   Cchd¢pq$&amp;e2 ¡C$$fECS&quot;H 72R i¡(25i e©C¦ $&amp;¡¤(!$ ¡ §SS(2¦&quot;&quot;AR£¡ ¢R¨§¦ e&amp;4 ¤

Å§


      &quot; Q#¡e6G§¡#6

      ¡£¢¥¤§¦©¨¤©¨¥¢

    !¨#&quot;%$&amp;&amp;¢')(102¦354602¦3&quot;147¤38@9BADCEGF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

   H ¡I#&quot;%¢¥¤©PRQ&amp;¢'SC¥¤§0T¤§&quot;1UV$W&quot;%XY&quot;`¢¥¤§FaPR¦©¨bXc9dA1C#EGF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              e

f g5¨2¦hXi0p¤q¨bPr0sAt#$&quot;u&amp;¢@va$&amp;5&quot;wF£xy&quot;w                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

   e ¡I#&quot;%¢¥¤©PRQ&amp;¢')!¤3502$&amp;$QSUw$W5F§b&quot;uAt5$W&quot;%F                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

    Cx#x¨b¦§¤P¨2¦!¨##$W0T¦&quot;wF§W'¥¢                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

   Ò  va$&amp;&quot;%F£x&quot;% d9BADC47¤38S¤38&quot;id02¢'¥02'2&quot;iC¥Q¢¥¤§0T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               we

   f B¨¥¢w$W5W¢5')A7&quot;`Xi02¦3gF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       %

   Ì¢Í  va$&amp;&quot;%F£x&quot;%                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     lf
     ´`t² ¬)s´ pd«5hwi)woph komRlvwd t)sR ²Å icp
     ´` Ô ¦ÇXe)odgo(e komlRvwd ªÃRu1 ²Å txu
                               ¡C¨b5¦3h&quot;%FP¨2¦0CWXYx$&quot; i p ¡£¢F£¤§¦©5¤3W¨¥¢iC&quot;w¤qjk¦3¨l&quot;wF£F§¨2¦(¡
                                                                       535 5 53535 53535 5 53535 53535 5 53535 53535 5 535 5
                               e¡
                                                       5 53535 5 53535 53535 5 53535 53535 5 53535 53535 5 535 5
      va2222tË$&amp;Å¤ÔQÊ²&quot;%tx ¬·F£hxw¦&quot;%z(z(iz(z(eÇlÌ¢dgdge)Ímmkosi)¡VtCopdgdf)h¨bzpi)5o(Ete¦3dgiAhdf|¡3&quot;%epnFos5±¡vtmdPt¨2lvti¡2ddH¦vwd d¡kd0s«lsoshRAªmwÃsi)ldf&quot;%wopeevw¢5egdh(¡302¡kX)xosi)moW¢5lz(me)'vt5lRddfm`vw53zd A7«553wvw&quot;%id(5i)uR¨2f¦©5 zF#53&quot;wx5353¦h&amp;555¢'
v                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           i                                                                                                                                           p     jk¦©¨h&quot;wF§F£¨2¦                              pÔªÔ²² Å©

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535 53535        5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535 53535        5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535 53535        5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535 53535        5  53535  53535  5  535  5
      vaÓ2Ó2Ó2t$&amp;ÔÊ²S&quot;%F£$$ xdgdgdg&quot;%((hFmFmFdfÌ¢eÂÂÍopCt&amp;hevw$Cn{wi¨bdfd4¬7zp5hR¡k¦3hiidgdfe&quot;%|eVlFo(±¡i)Pe)t¨2wn(vwopd3¦hc¡k¡kd¡koWon#mRdgmR|l¦3l02vwo(dvw¦§de)Q@n(|! ¡ke)dfdgoz¨|«mo(vwlRd(5e)vwn(d$WR&quot;%RFtF§|855353dg0T|5353¦©&quot;w55o(o e5353n(np5353Q55 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          t  u 02¢5 t w                                    ¥ÔrÔrÔr©©©

      va¡¨¡¨¡¨¡¨¡¨¡¨tËE$&amp;ÅÔÊ§²&quot;%ic ic tx tx F£ xu¦u¦dgdgpp &quot;%hFhFÇXÇXdfdf¬)¬)Òq eee)e)ssttoo&amp;&amp;´´ Cdgdg$$¨b¡p¡pdfdf5ddzpzpo(o(¦3«5«5eVeelhh&quot;wiip¡kwwdfdfF7i)i)dgeVeVwwoopop(PRm±¡±¡¨2hh(mFlRtt¦dfvwvwp¡kvwepd&amp;d3d 0dg±¡op¡k(mRCtdgmFvwoªld(&amp;dfÃmRXivwmFepdRldfx±¡u1vwepªd $WtÃs¢vt±¡&quot;td) tsu1ic vte)ddf53¢5pzt)5«se)vw5353jkd(dfz535353¦©¢ «¨ 555vwhd(55555&quot;%F£5353535353F£¨b5353535353¦ 555555                                                                                                                                                     5  53535 53535        5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5  53535 53535        5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              53535 53535        5  53535  53535  5  535  5

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            TÔÔÊ2Ê2Ê(Ê(r11ÊÊ

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        53535                                                                                                                                              5  53535  53535       5  53535  53535  5  535  5
      va¦¦¦¦¦¦¦ tËE$&amp;ÅÔÊ¤§¤©²&quot;%tx t¬·¬·F£hhxw¦w &quot;%z(z(z(iiz(z(z(eeÇÇlldgdgdgÒqe)e)mmkmkososi)i)C¡VVttopopdgdg¨bdfdf))hh5zpzpi)o(o(¦3EEtte2eldgdgiiA&quot;wdfdf||V¡3F7epepndgos5±¡±¡PR(vtvtm¨2dmFttl¦vtvtiidf¡2dddHdHvwe2d0sdp¡kdd±¡«dgAlslsoshRt(vwªmwd&quot;%mFÃsi)ldfdf¢5wdfopeVeevwe202egd¤hªV¡3X) ±¢Ãypo(dgRos&amp;vw(ek dgegd¢mm(53tx l'dfmFvt5wm%epddfi)Aep5353±¡z(±¡&quot;wt5353e)vwwi)¨bditdf55vwuR¦3zdz(f#«55e)wdfvw&quot;w¢i5353d(zi)¦hu«55353&amp;f¢zFvwd(555' 5¢53535353ic5353535353p 5555555
U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          jk¦©¨h&quot;%F£F£¨b¦                                 HTÅÅ(Å(ÅHÊªÊªÊfÅÅÅÅ²

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           5 53535 53535         5  53535  53535  5  535  5

                                                                        ÅG©


g  va±±±±tË$&amp;ÅÔÊ²&quot;%F£$$$$xdgdgdgdg&quot;%((((mFmFmFmFÒq ÂÂÂÂopopCChhCeevwvw¨bn{n{wwii5d4d4¬7¬7¦3hRhR¡k¡kl&quot;wiidgdgeeF7||llPRo(o(¨2i)i)e)e)ww¦nn(opophchcp¡k¡k¡kdgn#o(mRdgdg¦©mF||0Tldf¦§vwepo(o(d Q@e)e)±¡nn(! tvt|p¡kd ¨dgdgo|(m|rmF5o(lRdfe)$Wdgvwep&quot;%n(d|F±¡¢o(tF§e)vwt85n(d|530Tdg¦©|53&quot;w|55o(oedg5353n(|np5353¢Qo( e)55 tx n(555u535353 02535353¢55555   txw                               fbÅÅÅÅ   §
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         §
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            53535  5  53535  53535  5  535  5            §
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            53535  5  53535  53535  5  535  5            §
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            53535  5  53535  53535  5  535  5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            53535  5  53535  53535  5  535  5

   Å
</Text>
        </Document>
        <Document ID="D72822A0-E7E0-48ED-9CFD-4E4FF650FAC8">
            <Title>What would a &quot;pure&quot; temporal programming language look like?</Title>
            <Text>

No implicit state

	A temporal program should have no “implicit” state - 

Current state is always well-defined
	Pausing a multi-threaded program is not guaranteed to produce consistent results.

	If I pause a temporal program at cycle N, I should always end up with the same program state. 

## Can we go over the whole “atomic change old state into new state” in more detail?

### Atomic: 

From the code’s point of view, a program’s state can never be “partially modified”. A temporal programming language must enforce that every line of code sees the same consistent view of the universe during evaluation, even if 

This has some knock-on effects: A temporal programming language compiler _must_ be able to prove that all possible evaluation graphs contain at most one assignment 

### Change:

Unlike pure functional programming languages, state _does_ change. Unlike most imperative programming languages, “change” can include things like type changes - it’s perfectly valid to say that X’s old type is “apple” and its new type is “orange”.

Flip a coin and lock/unlock the door example

### Old/New:
A temporal program’s operations must form a directed acyclic graph - the “old” state is always read-only and “new” state must always be computed from the old state plus external inputs. Because the “direction” of computation is always explicit, the lexical ordering of statements in a block has no effect on the computation. You can read the new value of X “lexically before” you’ve assigned it, as long as you don’t create a feedback cycle. Branch statements don’t “change control flow”, they select or deselect blocks of statements for evaluation. Similarly, “calling” a function doesn’t immediately execute it, it just marks the statements in that function as belonging to the current moment’s evaluation graph.

### State
A temporal program’s state must persist even if no changes are currently being evaluated. “State” can refer to both data stored in memory and data implicitly stored in the type system (UnlockedDoor/LockedDoor). 

The phrase “compute new state from old state” sounds so generic that it’s more like a design pattern than a paradigm. Why call it a paradigm?

From the software world viewpoint it does seem to It seems much broader than a pattern, and saying that the entire FPGA/ASIC industry follows a “design pattern” sounds incongruous.

Temporal programming is not just about “computing new state from old state”, it’s about how that computation is expressed in the language - does the compiler enforce that all state changes are atomic?





A recurrence is a mathematical function that defines a sequence of values {x0, x1, x2...} given a starting value x0 and a recurrence relation &quot;x' = f(x)&quot; that defines how to compute each element in the sequence from the previous values.

Temporal programming is a paradigm in which programs are expressed solely as recurrences. In the above definition, &quot;x&quot; represents the entire state of the program and &quot;f(x)&quot; computes the next state of the program as a function of the previous state.
 
 The ideas behind temporal programming have been around for decades, but &quot;pure&quot; temporal programming languages still don't exist yet. Once they do, they should allow us to do some very interesting things.

Temporal programming is a generalization of the exceedingly common &quot;new_state = f(old_state)&quot; pattern that appears in...

We call a program &quot;temporal&quot; if it relies on the ability to atomically change &quot;old&quot; state into &quot;new&quot; state.

A temporal program advances from state to state like a ticking clock, with each new state being a pure function of the previous one.







</Text>
        </Document>
        <Document ID="D86ADE51-B5C9-4C0B-852C-F8AC53751FB2">
            <Title>Synthesis of Operation-Centric Hardware Descriptions</Title>
            <Text>Synthesis of Operation-Centric Hardware Descriptions

                   James C. Hoe                                                   Arvind
Dept. of Electrical and Computer Engineering                      Laboratory for Computer Science
                                                                Massachusetts Institute of Technology
           Carnegie Mellon University
                jhoe@ece.cmu.edu                                           arvind@lcs.mit.edu

Abstract                                                        the form of rules. Typically, a rule is deﬁned by a predicate
                                                                condition and an effect on the state of the system. In an exe-
Most hardware description frameworks, whether schematic         cution, a rule “reads” the state of the system in one step, and
or textual, use cooperating ﬁnite state machines (CFSM) as      if enabled, the effect of the rule updates the state in the same
the underlying abstraction. In the CFSM framework, a de-        step. If several rules are enabled at the same time, any one
signer explicitly manages the concurrency by scheduling the     of the rules can be nondeterministically selected to update
exact cycle-by-cycle interactions between multiple concur-      the state in one step, and afterwards, a new step begins with
rent state machines. Design mistakes are common in co-          the updated state. The atomicity requirement simpliﬁes the
ordinating interactions between two state machines because      task of hardware description by permitting the designer to
transitions in different state machines are not semantically    formulate each rule as if the rest of the system is static.
coupled. It is also difﬁcult to modify one state machine with-
out considering its interaction with the rest of the system.        Describing the instruction reorder buffer (ROB)1 of a
                                                                modern out-of-order microprocessor poses a great chal-
    This paper presents a method for hardware synthesis from    lenge if concurrency needs to be managed explicitly. An
an “operation centric” description, where the behavior of a     operation-centric description captures the behavior of an
system is described as a collection of “atomic” operations in   ROB more perspicuously as a collection of rules for oper-
the form of rules. Typically, a rule is deﬁned by a predicate   ations like dispatch, complete, commit, etc. [1]. For exam-
condition and an effect on the state of the system. The atom-   ple, the dispatch operation is speciﬁed to take place if there
icity requirement simpliﬁes the task of hardware description    exists an instruction that has all of its operands and is wait-
by permitting the designer to formulate each rule as if the     ing to execute, and furthermore, the execution unit needed
rest of the system is static.                                   by the instruction is available. The effect of the dispatch op-
                                                                eration is to send the instruction to the execution unit. The
    An implementation can execute several rules concur-         rule speciﬁcation of the dispatch operation does not have to
rently in a clock cycle, provided some sequential execution     include information about how to resolve potential conﬂicts
of those rules can reproduce the behavior of the concurrent     arising from the concurrent execution with other operations.
execution. In fact, detecting and scheduling valid concurrent
execution of rules is the central issue in hardware synthe-         The sequential and atomic interpretation of a description
sis from operation-centric descriptions. The result of this     does not prevent a legal implementation from executing sev-
paper shows that an operation-centric framework offers sig-     eral rules concurrently in a clock cycle, provided some se-
niﬁcant reduction in design time, without loss in implemen-     quential execution of those rules can reproduce the behavior
tation quality.                                                 of the concurrent execution. In fact, detecting and schedul-
                                                                ing valid concurrent execution of rules is the central issue in
1 Introduction                                                  hardware synthesis from operation-centric descriptions.

1.1 Operation-Centric Hardware Descriptions                     1.2 Comparison to Other High-level Frameworks

Digital hardware designs inherently embody highly con-          Behavioral descriptions typically describe hardware, or hard-
current behaviors. Any non-trivial design invariably con-       ware/software systems, as multiple threads of computation
sists of a collection of cooperating ﬁnite state machines       that communicate via a message-passing or shared-memory
(CFSM). Hence, most hardware description frameworks,            paradigm [13, 4, 14, 17, 5]. As in CFSM frameworks, de-
whether schematic or textual, use CFSM as the underly-          signers of behavioral descriptions still need to manage the
ing abstraction. In a CFSM framework, a designer explic-        interactions between concurrent computations explicitly. In
itly manages the concurrency by scheduling the exact cycle-     reconﬁgurable computing, both sequential and parallel pro-
by-cycle interactions between multiple concurrent state ma-     gramming paradigms have been used to capture function-
chines. Design mistakes are common in coordinating inter-       alities for hardware implementation. Transmagriﬁer-C [6]
actions between two state machines because transitions in       and HardwareC [16] are speciﬁcation languages based on C
different state machines are not semantically coupled. It is    syntax plus additional constructs to convey hardware-related
also difﬁcult to modify one state machine without consider-     information such as clocking. Sequential C and Fortran pro-
ing its interaction with the rest of the system.                grams have been automatically parallelized to target an ar-
                                                                ray of conﬁgurable structures [3]. Data-parallel C languages
    This paper presents a method for hardware synthesis from
an “operation centric” description, where the behavior of a         1Refer to [9] for background information.
system is described as a collection of “atomic” operations in


have been used to program an array of FPGA’s in Splash 2 [8]                    or if the pipeline encounters an exception. The Add Exec
and CLAy [7]. More formal representations have also been                        rule, on the other hand, processes the next pending instruc-
used to describe hardware for veriﬁcation. Windley uses                         tion in bf as long as it is an Add instruction. Next, consider
the language from the HOL theorem proving system to de-                         the two possible executions of a Bz (branch if zero) instruc-
scribe a pipelined processor [19]. Matthews et al. have de-                     tion:
veloped the Hawk language to create executable speciﬁca-
tions of processors [15].                                                            Bz-Taken Exec Rule:
                                                                                            Proc(pc, rf, bf, imem, dmem)
Paper Organization: This section introduced the concept                                             if (rf[rc]=0) where (Bz(rc,ra)=ﬁrst(bf))

and advantages of operation-centric hardware description.                            ! Proc(rf[ra], rf, clear(bf), imem, dmem)
The next section presents an example. Section 3 explains the
synthesis of operation-centrically described hardware, while                         Bz-Not-Taken Exec Rule:
Section 4 explains the concurrent scheduling of conﬂict-
free rules. Section 5 presents a comparison of designs syn-                            = Proc(pc, rf, bf, imem, dmem)
thesized from operation-centric descriptions vs. hand-coded                                         if (rf[rc]6 0) where (Bz(rc,ra)=ﬁrst(bf))
RTL descriptions. Section 6 summarizes the key contribu-                             ! Proc(pc, rf, deq(bf), imem, dmem)
tions of this paper.
                                                                                The Fetch rule performs a weak form of branch speculation
2 An Operation-Centric Example                                                  by always incrementing pc. Consequently, in the execute
                                                                                stage, if a branch is resolved to be taken, besides setting pc
2.1 Description of a Pipelined Processor                                        to the branch target, all speculatively fetched instructions in
                                                                                bf need to be discarded.
We describe a two-stage pipelined processor where a
pipeline buffer is inserted between the fetch stage and the                         In this pipeline description, the Fetch rule and an exe-
execute stage. We use a bounded FIFO of unspeciﬁed size                         cute rule can be ready to ﬁre simultaneously. Even though
to model the pipeline buffer. The FIFO provides the isola-                      conceptually only one rule should be ﬁred in each step, an
tion to allow the operations in the two stages to be described                  implementation of this processor description must carry out
independently. Although the description reﬂects an asyn-                        the effect of both rules in the same clock cycle. Without con-
chronous and elastic pipeline, our synthesis can infer a legal                  current execution, the implementation does not behave like
implementation that is fully-synchronous and has stages sep-                    a pipeline. However, the implementation must also ensure
arated by simple registers.                                                     that a concurrent execution of multiple rules produces the
                                                                                same result as a sequential execution. In particular, consider
    Our operation-centric description framework borrows the                     the concurrent ﬁring of the Fetch rule and the Bz-Taken Exec
notation of Term Rewriting Systems (TRS) [2]. A two-stage                       rule. Both rules affect pc and bf. In such a case, the imple-
pipelined processor can be speciﬁed as a TRS whose terms                        mentation has to guarantee that these rules ﬁre in some se-
have the signature Proc(pc,rf,bf,imem,dmem). The ﬁve                            quential order. The choice of ordering determines how many
ﬁelds of the processor term are pc the program counter, rf                      bubbles are inserted after a taken branch, but it does not af-
the register ﬁle (an array of integer values)2, bf the pipeline                 fect the processor’s ability to correctly execute a program.
buffer (a FIFO of fetched instructions), imem the instruc-
tion memory (an array of instructions), and dmem the data                       2.2 State-Transformer View
memory (an array of integer values).
                                                                                In a TRS, the state of the system is represented by a collec-
    Instruction fetching in the fetch stage can be described                    tion of values, and a rule rewrites values to values. Given a
by the rule:                                                                    collective state value s, a TRS rule computes a new value s’
                                                                                such that
     Fetch Rule:
            Proc(pc,rf,bf,imem,dmem)                                                s’=if π(s) then δ(s) else s

     ! Proc(pc+1,rf,enq(bf,imem[pc]),imem,dmem)                                 where the π function captures the ﬁring condition and the δ
                                                                                function captures the effect of a rule. It is also possible to
The execution of the different instructions in the execute                      view a rule as a state-transformer in a state-based system. In
stage can be described by separate rules. First consider the                    this paper, we are going to concentrate on the synthesis of
Add instruction:                                                                state-based systems with three types of state elements: reg-
                                                                                isters (R), arrays (A) and FIFOs (F). The state elements are
     Add Exec Rule:                                                             depicted in Figure 1. A register can store an integer value
            Proc(pc,rf,bf,imem,dmem)                                            up to a speciﬁed maximum word size. The value stored in
                    where Add(rd,r1,r2)=ﬁrst(bf)                                a register can be referenced using the side-effect-free get()
                                                                                query and updated to v using the set(v ) action. The en-
     ! Proc(pc,rf[rd:=v],deq(bf),imem,dmem)                                     try of an array can be referenced using the side-effect-free
                    where v=rf[r1]+rf[r2]                                       a-get(idx) query and updated to v using the a-set(idx,v ) ac-
                                                                                tion. The oldest value in a FIFO can be referenced using
The Fetch rule fetches instructions from consecutive instruc-                   the side-effect-free ﬁrst() query, and can be removed by the
tion memory locations and enqueues them into bf. The Fetch                      deq() action. A new value v can be added to a FIFO using
rule is not concerned with what happens if a branch is taken,                   the enq(v ) action. In addition, the contents of a FIFO can
                                                                                be cleared using the clear() action. The status of a FIFO can
    2In an expression, rf[r] gives the value stored in location r of rf, and    be queried using the side-effect-free notfull() and notempty()
rf[r:=v] gives the new value of the array after location r has been updated by
the value v.


D   R                        (write addr) WA    A                               AT S = hS, So, X i
                             (write data) WD                 RD1 (read data)        S = h R1,...,RNR, A1,...,ANA, F1,...,FNF i
LE                         (write enable) WE            R...D2 (read data)         So = h vR1 ,...,vRNR, vA1,...,vANA vF1,...,vFNF i
                       Q                                     RDn (read data)        X = f T1,...,TM g
    Clk                      (read addr) RA 1
                                                Clk                                  T = h π, α i
                           (read addr) RA... 2                                       π = exp
                                                   first
                             (read addr) RA n      _full                          ] α = h aR1 ,...,aRNR, aA1 ,...,aANA, aF1,...,aFNF i
                                                   _empty
    (enq data) ED                                                                  aR = ε set(exp)

    (enq enable) EE    F                                                         ] aA = ε a-set(expidx, expdata)
    (deq enable) DE                                                              ] ] ] ] aF = ε enq(exp) deq() en-deq(exp) clear()
                                                                                ] exp = constant Primitive-Op(exp1, ..., expn)
    (clear enable) CE
                                                                                     ] ] R.get() A.a-get(idx)
                                          Clk                                        ] ] ] F.ﬁrst() F.notfull() F.notempty()

    Figure 1: Synchronous state elements                                                           Figure 2: ATS summary

queries. A rule is restricted to perform at most one action on                3.1 Abstract Transition Systems (ATS)
each state element per rewrite.
                                                                              ATS is the formalization of a state-based intermediate rep-
    In the state-transformer view, the applicability of a rule is             resentation of operation-centric descriptions. An ATS is de-
determined by computing the π function on the current state.
However, the next-state logic consists of a set of actions that               ﬁned a triple hS, So, X i where S is a list of state elements,
alter the contents of the state elements to match δ(s). The                   So is a list of initial values for the elements in S, and X is a
processor rules in Section 2.1 can be restated in terms of
actions:                                                                      list of operation-centric transitions where each transition is
                                                                              represented by a pair, hπ, αi. The components of an ATS
          πFetch = notfull(bf)                                                is summarized in Figure 2. Besides registers, arrays and FI-
       aFetch pc = set(pc+1)                                                  FOs, ATS includes register-like state elements for input and
       aFetch bf = enq(imem[pc])                                              output. An input state element (I) is like a register but with-
                                                                              out the set() action. A get() query on an input element returns
           πAdd = (ﬁrst(bf)=Add(rd,r1,r2))                                    the value of an external input. An output state element (O)
                                        ^notempty(bf)                         supports both set() and get(), and its content is visible from
                                                                              outside of the ATS.
         aAdd rf = a-set(rd,rf[r1]+rf[r2])
         aAdd bf = deq()                                                      3.2 Reference Implementation of an ATS

       πBzTaken = (ﬁrst(bf)=Bz(rc,ra))^(rf[rc]=0)                             One straightforward implementation of an ATS is a FSM that
                                        ^notempty(bf)
                                                                              executes one transition per clock cycle. The elements of S
    aBzTaken pc = set(rf[ra])                                                 are the state of the FSM. The transitions in X are combined
     aBzTaken bf = clear()
                                                                              to form the next-state logic of the FSM in three steps.
  = πBzNotTaken = (ﬁrst(bf)=Bz(rc,ra))^(rf[rc]6 0)
                                        ^notempty(bf)                         Step 1: All value expressions in the ATS are mapped to
 aBzNotTaken bf = deq()
                                                                              combinational signals on the current state of the state el-
Null actions, represented as ε, on a state element                            ements. In particular, this step creates a set of signals,
are omitted from the action list above. The com-                              πT1,...,πTM , that are the π signals of transitions T1,...,TM of an
plete list of actions implied by the Add Execute rule                         M-transition ATS. The logic mapping in this step assumes
is αAdd=hapc,arf,abf,aimem,admemi where apc, aimem and                        all required combinational resources are available. RTL op-
admem are ε’s.                                                                timizations can be employed to simplify the combinational
                                                                              logic and to share duplicated logic.
3 Hardware State Machine Synthesis
                                                                              Step 2: In the second step, a scheduler is created to gener-
Implementing an operation-centric TRS description as a
ﬁnite-state machine (FSM) involves combining the actions                      ate the set of arbitrated enable signals, φT1 ,...,φTM , based on
of all rules to form the FSM’s next-state logic. The actions of               πT1,...,πTM . (The block diagram of a scheduler is shown in
a rule need to be qualiﬁed by the rule’s π signal. For perfor-                Figure 3.) Any valid scheduler must, at least, ensure that for
mance reasons, an implementation should carry out multiple                    any s,
rules concurrently while still maintaining a behavior that is
consistent with a sequential execution of the atomic opera-                     1. φTi ) πTi (s)
tions that the rules represent. We will describe such a con-                    2. πT1 (s)_..._πTM (s) ) φT1 _..._φTM
current scheduler in the next section.                                        The reference implementation scheduler asserts only one φ
                                                                              signal in each clock cycle, reﬂecting the selection of one ap-
                                                                              plicable transition. A priority encoder is a valid scheduler
                                                                              for the reference implementation.


Step 3: In the ﬁnal step, one conceptually creates M inde-            π1                           φ1

pendent versions of the next-state logic, each corresponding          π2                           φ2
to one of the M transitions in the ATS. Next, the M sets of
next-state logic are merged, state-element by state-element,                         Scheduler
using the φ signals for arbitration. For example, a register
may have N transitions that could affect it over time. (N M           πM                           φM
because some transitions may not affect the register.) The
register takes on a new value if any of the N relevant tran-          Figure 3: A monolithic scheduler for an M-transition ATS.
sitions is enabled in a clock cycle. Thus, the register’s latch
enable is the logical-OR of the φ signals of the N relevant           φφ21           latch enable
transitions. The new value of the register is selected from the
N candidate next-state values via a multiplexer controlled by                 φ1 φ2             LE
the φ signals. Figure 4 illustrates the merge circuit for a reg-      δ1
ister that can be affected by the set actions from two transi-        δ2                           RQ
tions. The scheme assumes at most one transition’s action
needs to be applied to a particular element in a clock cycle.                                   D
Furthermore, all the actions of a selected transition should be
enabled in the same clock cycle to achieve the appearance of          Figure 4: Circuits for combining two transitions’ actions on
an atomic transition.                                                 the same state element.

    The merge circuit for the three state element types are           tion, the reference implementation is deterministic. In other
given next as RTL equations. For each R, the set of transi-           words, the implementation can only embody one of the be-
tions that update R is fTxi j aRTxi =set(expxi )g where aRTxi is the  haviors allowed by the ATS. Thus, the implementation can
action by Txi on R. R’s data (D) and latch enable (LE) inputs         enter a livelock if the ATS depends on non-determinism to
are                                                                   make progress. The reference implementation can use a
                                                                      round-robin priority encoder to ensure weak-fairness, that
  + + D = φTx1 expx1 ... φTxn expxn                                   is, if a transition remains applicable for a sufﬁcient number
                                                                      of consecutive cycles then it is guaranteed to be selected at
    LE = φTx1 _..._φTxn                                               least once.

For each A, the set of transitions that write A is                        Although the semantics of an ATS require an execution
fTxi j aATxi =a-set(idxxi , dataxi)g. A’s write address (WA),         in sequential and atomic update steps, a hardware imple-
data (WD) and enable (WE) inputs are                                  mentation can exploit the underlying parallelism and execute
                                                                      multiple transitions concurrently in one clock cycle. For a
  + + WA = φTx1 idxx1 ... φTxn idxxn                                  pipelined processor, it is necessary to execute transitions for
  + + WD = φTx1 datax1 ... φTxn dataxn                                different pipeline stages concurrently to achieve pipelined
                                                                      execution.
    WE = φTx1 _..._φTxn
                                                                      4 Concurrent Scheduling of Con ict-Free Transitions
The set of transitions that enqueues a new value into F is
fTxi j (aFTxi =enq(expxi ))_(aFTxi =en-deq(expxi ))g.                 In a multiple-transitions-per-cycle implementation, the state
                                                                      transition in each clock cycle must correspond to a sequen-
  + + ED = φTx1 expx1 ... φTxn expxn                                  tial execution of the ATS transitions in some order. If two
                                                                      transitions Ta and Tb become applicable in the same clock
    EE = φTx1 _..._φTxn
                                                                      cycle when S is in state s, πTa (δTb (s)) or πTb (δTa (s)) must
The set of transitions that dequeues from F is
fTxi j (aFTxi =deq())_(aFTxi =en-deq(expxi ))g.                       be true for an implementation to correctly select both tran-
                                                                      sitions for execution. Otherwise, executing both transitions
    DE = φTx1 _..._φTxn                                               would be inconsistent with any sequential execution in two
                                                                      atomic update steps.
Similarly, the set of transitions that clears the contents of F
is fTxi j aFTxi =clear()g.                                                There are two approaches to execute the actions of Ta and
                                                                      Tb in the same clock cycle. The ﬁrst approach cascades the
    CE = φTx1 _..._φTxn                                               combinational logic from the two transitions. However, arbi-
                                                                      trary cascading does not always improve circuit performance
3.3 Correctness of the Reference Implementation                       since it may lead to a longer cycle time. In our approach, Ta
                                                                      and Tb are executed in the same clock cycle only if the cor-
The reference implementation is said to implement an ATS              rect ﬁnal state can be reconstructed from an independent and
correctly if                                                          parallel evaluation of their combinational logic on the same
                                                                      starting state.
  1. The implementation’s sequence of state transitions
     corresponds to some execution of the ATS.

  2. The implementation maintains liveness.

A correct implementation is not necessarily equivalent to the
source ATS. Unless the scheduler employs true randomiza-


  &lt;&gt; &lt;&gt; This section develops a scheduling algorithm based on     &lt;&gt; Theorem 1 (Composition of CF Transitions)

the conﬂict-free relationship ( CF). CF is a symmet-              Given a collection of n transitions applicable in state s, if
rical relationship that imposes a stronger requirement than       all n transitions are pairwise conﬂict-free, then the following
                                                                  holds for any ordering Tx1 ,...,Txn:
&lt;&gt; necessary for executing two transitions concurrently. How-
                                                                  πTx2 (δTx1 (s)) ^ ... ^
ever, the symmetry of CF permits a straightforward im-
plementation that concurrently executes multiple transitions      == πTxn (δTxn;1 ( ... δTx3 (δTx2 (δTx1 (s))) ... )) ^

&lt;&gt; if they are pairwise CF. An analysis based on the Sequen-      (δTxn (δTxn;1 ( ... δTx3 (δTx2 (δTx1 (s))) ... )) δPC(s))
&lt; tial Composibility ( SC) relationship can further increase
&lt; hardware concurrency [10]. The intuition behind SC, an          where δPC is the functional equivalent of the parallel compo-
                                                                  sitions of αTx1 ,...,αTxn , in any order. A proof for Theorem 1
asymmetrical relationship, is that concurrent execution does

not need to produce the same result as all possible sequential

executions, just one.

                                                                  can be found in [10].                                      2

4.1 Con ict-Free Transitions                                      4.2 Static Deduction of &lt;&gt;CF

The conﬂict-free relationship and the parallel composition        The scheduling algorithm given in this section can work with
function PC are deﬁned in Deﬁnition 1 and Deﬁnition 2.
                                                                  &lt;&gt; a conservative test for CF, that is, if the test fails to iden-
Deﬁnition 1 (Conﬂict-Free Relationship)                           &lt;&gt; tify a pair of transitions as CF, the algorithm might gen-
                                                                  &lt;&gt; erate a less optimal, but still correct implementation.
&lt;&gt; Two transitions Ta and Tb are said to be conﬂict-free
                                                                      A static determination of CF can be made by compar-
(Ta CF Tb) if                                                     ing the domains and ranges of the transitions. The domain

    8 s. πTa (s) ^ πTb (s) ) πTb (δTa (s)) ^ πTa (δTb (s)) ^      of a transition is the set of state elements in S “read” by the

                    == (δTb (δTa (s)) δTa (δTb (s))               expressions in either π or α. The domain of a transition can
                             == δPC(s))                           be further sub-classiﬁed as π-domain and α-domain depend-
                                                                  ing on whether the state element is read by the π-expression
2 where δPC is the functional equivalent of PC(αTa, αTb ).        or an expression in α. The range of a transition is the set of

    The function PC computes a new α by composing two             state elements in S that are acted on by α. For this analysis,
α’s that do not contain conﬂicting actions on the same state
element.                                                          the head and the tail of a FIFO are considered to be separate

Deﬁnition 2 (Parallel Composition)                                &lt;&gt; elements. Using D(T) and R(T), a sufﬁcient condition that

PC(αa,αb)= hpcR(aR1 ,bR1),..., pcA(aA1 ,bA1),...,                 ensures two transitions are CF is given by the following
                                pcF (aF1,bF1),...i                theorem.

where αa=haR1 ,...aA1,...aF1,...i,                                &lt;&gt; Theorem 2 (Sufﬁcient Condition for CF)
               and αb=hbR1 ,...bA1,...bF1,...i
                                                                  Given Ta and Tb,

                                                                  (D(πTa) D(αTa ))                   RR((ααTTba  )  )
                                                                  R(D(α(πTTab))6 \DR((ααTTbb)))                  )  )
                                                                  &lt;&gt; (                           6\                    ^
                                                                                                                       ^
                                                                  (                              6\
pcR(a, b)=case a, b of a, ε ) a                                   (
                           ε, b ) b                                                              )

                                                                             ) (Ta CF Tb)                                    2

... ) undeﬁned                                                    If the domain and range of two transitions do not overlap,
                                                                  then the two transitions do not have any data dependences.
pcA(a, b)=case a, b of a, ε ) a                                   Since their ranges do not overlap, a valid parallel composi-
                           ε, b ) b                               tion of αTa and αTb must exist.

... ) undeﬁned                                                    Deﬁnition 3 (Mutually Exclusive Relationship)

pcF (a, b)=case a, b of a, ε ) a
                           ε, b ) b

enq(exp), deq() ) en-deq(exp)

deq(), enq(exp) ) en-deq(exp)                                     If two transitions never become applicable on the same state,

... ) undeﬁned                                      2             then they are said to be mutually exclusive, i.e.,

  &lt;&gt;Suppose Ta and Tb become applicable in the same state s.      &lt;&gt; Ta ME Tb if 8 s. :(πTa (s)^πTb (s))                     2

Ta CF Tb implies that the two transitions can be applied in       &lt;&gt; Two transitions that are ME satisfy the deﬁnition of
                                                                  &lt;&gt; &lt;&gt; CF trivially. An exact test for ME requires deter-
&lt;&gt; either order in two successive steps to produce the same ﬁnal  mining the satisﬁability of the    expression (πTa (s)^πTb (s)).
                                                                  Fortunately, the π expression is   usually a conjunction of re-
state s’. Ta CF Tb further implies that an implementation
could produce s’ by applying the parallel composition of αTa      lational constraints on the current values of state elements.

&lt;&gt; and αTb to the same initial state s. Theorem 1 extends this

result to multiple pairwise CF transitions.

                                                                  A conservative test that scans two π expressions for contra-

                                                                  dicting constraints on any one state element works well in

                                                                  practice.


                          Scheduling Group 1 Scheduling Group 2

         T1       T2                 T1       T2                         πT1 πT4 πT6 φT1 φT4 φT6
T6                                                                        000000
                      T3     T6               Scheduling Group 3          001001
                                                    T3                    010010
                                                                          011010
T5                T4             T5           T4                          100100
                                                                          101101
             (a)                         (b)                              110100
                                                                          111101

Figure 5: Scheduling Conﬂict-free Rules: (a) Conﬂict-free                Figure 6: Enumerated encoder table.
graph (b) Corresponding conﬂict graph and its connected
components

4.3 Scheduling of &lt;&gt;CF Transitions                                 Enumerated Scheduler: Scheduling group 1 in Figure 5

Using Theorem 1, instead of selecting a single transition per      &lt;&gt; contains three transitions fT1, T4, T6g such that T1 CF T6
                                                                   &lt;&gt; but neither T1 nor T6 is CF with T4. Although the three

                                                                   transitions cannot be scheduled independently of each other,

clock cycle, a scheduler can select a number of applicable         T1 and T6 can be selected together as long as T4 is not se-

transitions that are pairwise conﬂict-free. In other words, in     &lt;&gt; lected in the same clock cycle. This selection is valid be-

each clock cycle, the φ signals should satisfy the condition:      cause T1 and T6 are CF between themselves and every
                                                                   transition selected by the other groups. In general, the sched-
&lt;&gt; φTa ^ φTb ) Ta     CF Tb
                                                                   &lt;&gt; uler for each group can independently select multiple transi-
where φT is the arbitrated transition enable signal for transi-
tion T. Given a set of applicable transitions in a clock cycle,    tions that are pairwise CF within the scheduling group.
                                                                       For a scheduling group with           transitions Tx1 ,...,Txn,
many different subsets of pairwise conﬂict-free transitions        φTx1 ,...,φTxn can be computed by a 2n    n lookup table indexed

could exist. Selecting the optimum subset requires evaluat-        by πTx1 (s),...,πTxn (s). The data value d1,...,dn at the table en-

ing the relative importance of the transitions. Alternatively,     try with index b1,...,bn can be determined by ﬁnding a clique

an objective metric simply optimizes the number of transi-         in an undirected graph whose nodes N and edges E are de-

tions executed in each clock cycle.                                ﬁned as follows:

                                                                   N                     is  assertedg
                                                                   E                     j)
                                                                                             j (Txi 2N )
Partitioned Scheduler: In a partitioned scheduler, transi-            =  &lt;&gt; fTxi j   bi                   ^  (Tx  j  2N  )  ^
                                                                      =              Tx
tions in X are ﬁrst partitioned into as many disjoint schedul-           f(Txi ,
ing groups, P1,...,Pk, as possible such that                                                 (Txi          CF Tx j )g

  &lt;&gt; (Ta 2 Pa) ^ (Tb 2 Pb) ) Ta CF Tb                              For each Txi that is in the clique, assert di. For example,
                                                                   scheduling group 1 from Figure 5 can be scheduled by an
Transitions in different scheduling groups are conﬂict-free,       enumerated encoder (Figure 6) that allows T1 and T6 to ex-
                                                                   ecute concurrently. The construction of an enumerated en-
and hence each scheduling group can be scheduled inde-             coder is not necessarily unique. For example, in this exam-
                                                                   ple, row “011” in Figure 6 could also contain the data value
pendently of other groups. For a given scheduling group            “001”.
containing Tx1 ,...,Txn , φTx1 ,...,φTxn can be generated from
πTx1 (s),...,πTxn (s) using a priority encoder. In the best case,  4.4 Performance Gain
a transition T is conﬂict-free with every other transition in
                                                                   When X can be partitioned into scheduling groups, the par-
X . Hence, T is in a scheduling group by itself, and φT=πT
                                                                   titioned scheduler is smaller and faster than the monolithic
without arbitration.                                               encoder used in the reference implementation. The parti-
                                                                   tioned scheduler also reduces wiring cost and delay since
   X can be partitioned into scheduling groups by ﬁnd-             π’s and φ’s of unrelated transitions are not brought together
                                                                   for arbitration.
ing the connected components of an undirected graph
                                                                     &lt;&gt; The property of the parallel composition function ensures
&lt;&gt; whose nodes are transitions T1,...,TM and whose edges are
                                                                   that transitions are CF only if their actions on state ele-
f(Ti, Tj) j :(Ti CF Tj)g. Each connected component is a
                                                                   &lt;&gt; ments do not conﬂict. Hence, the state update logic from the
&lt;&gt; scheduling group. For example, the undirected graph (a) in
                                                                   reference implementation can be used with a CF sched-
Figure 5 depicts the CF relationships in an ATS with six           uler without any modiﬁcation, and consequently, combina-
transitions. Graph (b) in Figure 5 gives the corresponding
                                                                   &lt;&gt; tional delay of the next-state logic is not increased by this
&lt;&gt; &lt;&gt; conﬂict graph where two nodes are connected if they are not
    CF , i.e. two unconnected nodes Ti and Tj imply Ti CF          optimization. All in all, the CF-scheduled implementa-
                                                                   tion achieves better performance than the reference imple-
&lt;&gt; Tj. The conﬂict graph has three connected components, cor-      mentation by allowing more transitions to execute in a clock
                                                                   cycle without increasing the cycle time.
responding to the three CF scheduling groups. The φ sig-
nals corresponding to T1, T4 and T6 can be generated using
a priority encoding of their corresponding π’s. Scheduling
group 2 also requires a scheduler to ensure φ2 and φ5 are not
asserted in the same clock cycle. However, φT3 =πT3 without
any arbitration.


5 Synthesis Results                                              _full?                     _full?                     _full?
                                                                                deq                        deq                        deq
The synthesis procedures in the previous section have been
implemented in the Term Rewriting Architectural Compiler                             Logic                      Logic                      Logic
(TRAC). TRAC accepts TRSPEC descriptions and outputs
synthesizable structural descriptions in the Verilog Hard-       empty?                     enq  empty?                enq  empty?                enq
ware Description Language [18]. The TRSPEC language
is an adaptation of TRS for operation-centric hardware de-                                  1-deep FIFO
scription [11]. This section discusses the synthesis of a ﬁve-
stage pipelined implementation of the MIPS R2000 ISA (as         Stage K                         Stage K+1                  Stage K+2
described in [12]). The TRSPEC description implements
all of the MIPS R2000 integer ISA except: multiple/divide;       Figure 7: Synchronous pipeline with combinational multi-
partial-word or non-aligned load/stores; coprocessor inter-      stage feedback ﬂow control.
faces; privileged and exception modes. The delay semantics
of the memory load and branch/jump instructions have also        version                       CBA tc6a                          LSI 10K
been removed. The TRSPEC description can be compiled by          TRSPEC                     area speed                       area speed
TRAC into a synthesizable Verilog RTL description in less        Hand-coded RTL             (cell) (MHz)                    (cell) (MHz)
than 15 seconds on a 266 MHz Pentium II processor. The                                      9059 96.6                       34674 41.9
TRAC-generated Verilog description can then be compiled                                     7168 96.0                       26543 42.1
by Synopsys Design Compiler to target both Synopsys CBA
and LSI Logic 10K Series technology libraries.                   Figure 8: Summary of MIPS core synthesis results

5.1 Input and Output                                             vance synchronously on each clock cycle. A stall in an inter-
                                                                 mediate pipeline stage causes all up-stream stages to stall at
The example from Section 2.1 described a simple proces-          once. If a pipeline stage never stalls, i.e., always dequeues,
sor whose instruction memory and data memory are storage         its feedback can be removed by combinational logic opti-
arrays internal to the system. The description can be synthe-    mization.
sized, as is, to a processor with an internal instruction ROM
and an internal data RAM. However, as a realistic design         5.3 Analysis and Discussion
for synthesis, the MIPS processor accesses external memory
through input and output ports. TRSPEC allows I/O seman-         The table in Figure 8 summarizes the pre-layout area and
tics to be assigned to terms as part of the type deﬁnition for   speed estimates reported by Synopsys. The row labeled
a term.                                                          “TRSPEC” characterizes the implementation synthesized
                                                                 from the TRSPEC description. The row labeled “Hand-
5.2 Synchronous Pipeline Synthesis                               coded RTL” characterizes the implementation synthesized
                                                                 from a hand-coded Verilog description of the same microar-
As in the processor from Section 2.1, the MIPS processor is      chitecture. The data indicates that the TRSPEC description
described as an asynchronous and elastic pipeline. The de-       results in an implementation that is similar in size and speed
scription of the processor does not depend on the exact depth    to the result of the hand-coded Verilog description. This sim-
of the pipeline FIFOs. This allows TRAC to instantiate one-      ilarity should not be surprising because, after all, both de-
deep FIFOs, i.e. a single register, as pipeline buffers. Flow    scriptions are describing the same microarchitecture, albeit
control logic is added to ensure a FIFO is not overﬂowed         using very different design abstractions and methodologies.
or underﬂowed by enqueue and dequeue actions. In a naive         The same conclusion has also been reached on comparisons
construction, the one-deep FIFO is full if its register holds    of other designs and when we targeted the designs for im-
valid data; the FIFO is empty if its register holds a bubble.    plementation on FPGAs [10].
With only local ﬂow control between neighboring stages, the
overall pipeline would contain a bubble in every other stage         The TRSPEC and the hand-coded Verilog description are
in a steady-state execution. For example, if pipeline buffer     similar in length (790 vs. 930 lines of source code), but
                                                                 the TRSPEC description is developed in less than one day
+ + K and K 1 are occupied and buffer K 2 is empty in some       (eight hours), whereas the hand-coded Verilog description
+ clock cycle, the operation in stage K 1 would be enabled       required nearly ﬁve days to complete. The TRSPEC de-
+ to advance at the clock edge, but the operation in stage K is  scription can be translated in a literal fashion from an ISA
                                                                 manual. Whereas, the hand-coded Verilog description has a
held back because buffer K 1 appears full during the clock       much weaker correlation to the ISA speciﬁcation. The hand-
                                                                 coded RTL description also requires circuit implementation
+ cycle. The operation in stage K is not enabled until the next  information, which the RTL designer has to improvise. This
                                                                 does not only create more work for the RTL designer but
clock cycle when buffer K 1 has been emptied.                    also creates more opportunities for error. In a TRSPEC de-
    TRAC creates a ﬂow control logic that includes a combi-      sign ﬂow, the designer can rely on TRAC to correctly supply
                                                                 the implementation-related information.
national multi-stage feedback path that propagates from the
last pipeline stage to the ﬁrst pipeline stage. The cascaded
feedback scheme shown in Figure 7 allows stage K to ad-

+ vance both when pipeline buffer K 1 is actually empty and
+ when buffer K 1 is going to be dequeued at the coming

clock edge. This scheme allows the entire pipeline to ad-


6 Conclusion                                                   [9] J. L. Hennessy and D. A. Patterson. Computer Archi-
                                                                    tecture: A Quantitative Approach. Morgan Kaufmann,
The operation-centric view of hardware has existed in many          2nd edition, 1996.
forms of informal hardware speciﬁcation, usually to convey
high-level architectural concepts. This research improves     [10] J. C. Hoe. Operation-Centric Hardware Description
the usefulness of an operation-centric hardware description         and Synthesis. PhD Thesis, Massachusetts Institute of
by developing a formal description framework and by en-             Technology, June 2000.
abling automatic synthesis to an efﬁcient circuit implemen-
tation. The result of this paper shows that an operation-     [11] J. C. Hoe and Arvind. Hardware synthesis from term
centric framework offers signiﬁcant reduction in design time        rewriting systems. In Proceedings of X IFIP Interna-
and effort without loss in implementation quality.                  tional Conference on VLSI (VLSI 99), Lisbon, Portugal,
                                                                    November 1999.
7 Acknowledgements
                                                              [12] G. Kane. MIPS R2000 RISC Architecture. Prentice
This paper describes research done at the MIT Laboratory            Hall, 1987.
for Computer Science. Funding for this work is provided in
part by the Defense Advanced Research Projects Agency of      [13] L. Lavagno and E. Sentovich. ECL: A speciﬁcation
the Department of Defense under the Ft. Huachuca contract           environment for system-level design. In Proceedings
DABT63-95-C-0150 and by the Intel Corporation. James C.             of the 36th ACM/IEEE Design Automation Conference
Hoe is supported in part by an Intel Foundation Graduate            (DAC’99), New Orleans, LA, June 1999.
Fellowship during this research.
                                                              [14] S. Liao, S. Tjinag, and R. Gupta. An efﬁcient imple-
References                                                          mentation of reactivity for modeling hardware in the
                                                                    Scenic design environment. In Proceedings of the 34th
 [1] Arvind and X. Shen. Using term rewriting systems to            ACM/IEEE Design Automation Conference (DAC’97),
      design and verify processors. IEEE Micro Special Issue        Anaheim, CA, June 1997.
      on Modeling and Validation of Microprocessors, May
      1999.                                                   [15] J. Matthews, J. Launchbury, and B. Cook. Micro-
                                                                    processor speciﬁcation in Hawk. In Proceedings of
 [2] F. Baader and T. Nipkow. Term Rewriting and All That.          the 1998 International Conference on Computer Lan-
      Cambridge University Press, 1998.                             guages, Chicago, IL, 1998.

 [3] J. Babb, M. Rinard, C. A. Moritz, W. Lee, M. Frank,      [16] Stanford University. HardwareC – A Language for
      R. Barua, and S. Amarasinghe. Parallelizing appli-            Hardware Design, December 1990.
      cations into silicon. In Proceedings of the 7th IEEE
      Symposium on Field-Programmable Custom Comput-          [17] D. E. Thomas, J. K. Adams, and H. Schmit. A
      ing Machines (FCCM’99), Napa Valley, CA, April                model and methodology for hardware-software code-
      1999.                                                         sign. IEEE Design and Test of Computers, September
                                                                    1993.
 [4] G. Berry. The foundations of Esterel. In Proof, Lan-
      guage and Interaction: Essays in Honour of Robin Mil-   [18] D. E. Thomas and P. R. Moorby. The Verilog Hardware
      ner. MIT Press, 1998.                                         Description Language. Kluwer Academic Publishers,
                                                                    3rd edition, 1996.
 [5] D. D. Gajski, J. Zhu, R. Do¨mer, A. Gerslauer, and
      S. Zhao. SpecC Speciﬁcation Language and Methodol-      [19] P. J. Windley. Verifying pipelined microprocessors. In
      ogy. Kluwer Academic Publishers, 2000.                        Proceedings of the 1995 IFIP Conference on Hard-
                                                                    ware Description Languages and their Applications
 [6] D. Galloway. The Transmogriﬁer C hardware descrip-             (CHDL’95), Tokyo, Japan, 1995.
      tion language and compiler for FPGAs. In Proceedings
      of IEEE Workshop on FPGAs for Custom Computing
      Machines (FCCM’95), Napa Valley, CA, April 1995.

 [7] M. Gokhale and E. Gomersall. High level compila-
      tion for ﬁne grained FPGAs. In Proceedings of the
      IEEE Symposium on FPGA-based for Custom Com-
      puting Machines (FCCM’97), Napa Valley, CA, April
      1997.

 [8] M. Gokhale and R. Minnich. FPGA computing in a
      data parallel C. In Proceedings of IEEE Workshop on
      FPGAs for Custom Computing Machines (FCCM’93),
      Napa Valley, CA, April 1993.
</Text>
        </Document>
        <Document ID="DC0C35B7-427A-47E6-864A-78BCB38B0578">
            <Title>Is this really worth calling a &quot;paradigm&quot;?</Title>
            <Text># That seems too simple to call a &quot;paradigm&quot;, shouldn't there be more _stuff_ to it?
   Nobody was willing to do something as stupid as claim that &quot;x' = f(x)&quot; is a paradigm, so it didn't happen.

## Wait a second - the phrase “atomically change old state into new state” is so generic as to be meaningless. Of _course_ we change old state into new state, we do it all the time. That isn’t a paradigm, it’s just regular programming.

OK, so it's not exactly any of those things. Still, your definition of &quot;temporal programming&quot; sounds rather simplistic - why call it a programming paradigm?
    Think about the lack of loops in some functional languages - at first that limitation seems like a annoyance, but once you've gained familiarity with recursion and map/reduce it starts to feel less annoying and more elegant. Going back to a procedural langauge, you might then find yourself annoyed at having to write loops again for something that would be a one-liner in your preferred functional language.




## I can already do what you’re talking about in {language} using {feature}, so why coin a new term?

</Text>
        </Document>
        <Document ID="DD3EF510-C5BF-4390-9589-4B4569DC1E30">
            <Title>Bluespec SystemVerilog Reference Guide</Title>
            <Text>  BluespecTM SystemVerilog
        Reference Guide

       Revision: 24 November 2008
Copyright c 2000 – 2008 Bluespec, Inc.

                              1


Reference Guide                                             Bluespec SystemVerilog

Trademarks and copyrights

Verilog is a trademark of IEEE (the Institute of Electrical and Electronics Engineers). The Verilog
standard is copyrighted, owned and maintained by IEEE.

VHDL is a trademark of IEEE (the Institute of Electrical and Electronics Engineers). The VHDL
standard is copyrighted, owned and maintained by IEEE.

SystemVerilog is a trademark of Accellera, Inc. The SystemVerilog standard is owned and maintained
by Accellera.

Bluespec is a trademark of Bluespec, Inc.

2                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Contents

Table of Contents                                                  3

1 Introduction                                                     12

1.1 Meta notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2 Lexical elements                                                 12

2.1 Whitespace and comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.2 Identiﬁers and keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.3 Integer literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.3.1 Type conversion of integer literals . . . . . . . . . . . . . . . . . . . . . . . . 14

2.4 Real literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.5 String literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.6 Don’t-care values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.7 Compiler directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.7.1 File inclusion: ‘include and ‘line . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.7.2 Macro deﬁnition and substitution: ‘deﬁne and related directives . . . . . . . 16

2.7.3 Conditional compilation: ‘ifdef and related directives . . . . . . . . . . . . . . 17

3 Packages and the outermost structure of a BSV design             18

3.1 Scopes, name clashes and qualiﬁed identiﬁers . . . . . . . . . . . . . . . . . . . . . . 19

3.2 The Standard Prelude package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

4 Types                                                            20

4.1 Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

4.2 Provisos (brief intro) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

4.2.1 The pseudo-function valueof (or valueOf) . . . . . . . . . . . . . . . . . . . . 22

4.3 A brief introduction to deriving clauses . . . . . . . . . . . . . . . . . . . . . . . . . 23

5 Modules and interfaces, and their instances                      23

5.1 Explicit state via module instantiation, not variables . . . . . . . . . . . . . . . . . . 24

5.2 Interface declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

5.2.1 Subinterfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

5.3 Module deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

5.4 Module and interface instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

5.4.1 Short form instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

5.4.2 Long form instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

5.5 Interface deﬁnition (deﬁnition of methods) . . . . . . . . . . . . . . . . . . . . . . . . 31

                        c 2008 Bluespec, Inc. All rights reserved  3


Reference Guide                                             Bluespec SystemVerilog

         5.5.1 Shorthands for Action and ActionValue method deﬁnitions . . . . . . . . . . 33
         5.5.2 Deﬁnition of subinterfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
         5.5.3 Deﬁnition of methods and subinterfaces by assignment . . . . . . . . . . . . . 35
   5.6 Rules in module deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
   5.7 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
   5.8 Synthesizing Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
         5.8.1 Type Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
         5.8.2 Module Interfaces and Arguments . . . . . . . . . . . . . . . . . . . . . . . . 40

6 Static and dynamic semantics                              41

   6.1 Static semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

   6.1.1 Type checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

   6.1.2 Proviso checking and bit-width constraints . . . . . . . . . . . . . . . . . . . 41

   6.1.3 Static elaboration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

   6.2 Dynamic semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

   6.2.1 Reference semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

   6.2.2 Mapping into eﬃcient parallel clocked synchronous hardware . . . . . . . . . 43

   6.2.3 How rules are chosen to ﬁre . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

   6.2.4 Mapping speciﬁc hardware models . . . . . . . . . . . . . . . . . . . . . . . . 45

7 User-deﬁned types (type deﬁnitions)                       46

   7.1 Type synonyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

   7.2 Enumerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

   7.3 Structs and tagged unions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

8 Variable declarations and statements                      51

   8.1 Variable and array declaration and initialization . . . . . . . . . . . . . . . . . . . . 52

   8.2 Variable assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

   8.3 Implicit declaration and initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

   8.4 Register reads and writes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

   8.4.1 Registers and square-bracket notation . . . . . . . . . . . . . . . . . . . . . . 55

   8.4.2 Registers and range notation . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

   8.4.3 Registers and struct member selection . . . . . . . . . . . . . . . . . . . . . . 57

   8.5 Begin-end statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

   8.6 Conditional statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

   8.7 Loop statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

   8.7.1 While loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

   8.7.2 For loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

   8.8 Function deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

   8.8.1 Deﬁnition of functions by assignment . . . . . . . . . . . . . . . . . . . . . . . 62

   8.8.2 Function types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

4                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

9 Expressions                                                        63

9.1 Don’t-care expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

9.2 Conditional expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

9.3 Unary and binary operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

9.4 Bit concatenation and selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

9.5 Begin-end expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

9.6 Actions and action blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

9.7 Actionvalue blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

9.8 Function calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

9.9 Method calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

9.10 Static type assertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

9.11 Struct and union expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

9.11.1 Struct expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

9.11.2 Struct member selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

9.11.3 Tagged union expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

9.11.4 Tagged union member selection . . . . . . . . . . . . . . . . . . . . . . . . . . 73

9.12 Interface expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

9.12.1 Diﬀerences between interfaces and structs . . . . . . . . . . . . . . . . . . . . 75

9.13 Rule expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

10 Pattern matching                                                  77

10.1 Case statements with pattern matching . . . . . . . . . . . . . . . . . . . . . . . . . 79

10.2 Case expressions with pattern matching . . . . . . . . . . . . . . . . . . . . . . . . . 80

10.3 Pattern matching in if statements and other contexts . . . . . . . . . . . . . . . . . . 81

10.4 Pattern matching assignment statements . . . . . . . . . . . . . . . . . . . . . . . . . 82

11 Finite state machines                                             83

12 Important primitives                                              83

12.1 The types bit and Bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

12.1.1 Bit-width compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

12.2 UInt, Int, int and Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

12.3 String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

12.4 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

12.5 Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

12.6 FIFOs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

12.7 FIFOFs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

12.8 System tasks and functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

                          c 2008 Bluespec, Inc. All rights reserved  5


Reference Guide                                             Bluespec SystemVerilog

   12.8.1 Displaying information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
   12.8.2 $format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
   12.8.3 File data type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
   12.8.4 Opening and closing ﬁle operations . . . . . . . . . . . . . . . . . . . . . . . 89
   12.8.5 Writing to a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
   12.8.6 Formatting output to a string . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
   12.8.7 Reading from a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
   12.8.8 Flushing output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
   12.8.9 Stopping simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
   12.8.10 VCD dumping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
   12.8.11 Time functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
   12.8.12 Real functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
   12.8.13 Testing command line input . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

13 Guiding the compiler with attributes                     93

   13.1 Verilog module generation attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

   13.1.1 synthesize . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

   13.1.2 noinline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

   13.2 Interface attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

   13.2.1 Renaming attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

   13.2.2 Port protocol attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

   13.2.3 Interface attributes example . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

   13.3 Scheduling attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

   13.3.1 fire_when_enabled . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

   13.3.2 no_implicit_conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

   13.3.3 descending_urgency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

   13.3.4 execution_order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102

   13.3.5 mutually_exclusive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

   13.3.6 conflict_free . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

   13.3.7 preempts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

   13.4 Evaluation behavior attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

   13.4.1 split and nosplit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

   13.5 Input clock and reset attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105

   13.5.1 Clock and reset preﬁx naming attributes . . . . . . . . . . . . . . . . . . . . . 106

   13.5.2 Gate synthesis attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

   13.5.3 Default clock and reset naming attributes . . . . . . . . . . . . . . . . . . . . 107

   13.5.4 Clock family attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

6                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

13.6 Module argument attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
      13.6.1 Argument-level clock and reset naming attributes . . . . . . . . . . . . . . . . 109
      13.6.2 clocked_by= . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
      13.6.3 reset_by= . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
      13.6.4 port= . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

13.7 Documentation attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
      13.7.1 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
      13.7.2 Module instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
      13.7.3 Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

14 Advanced topics                                                 113

14.1 Type classes (overloading groups) and provisos . . . . . . . . . . . . . . . . . . . . . 114

14.1.1 Provisos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

14.1.2 Type class declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

14.1.3 Instance declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

14.1.4 The Bits type class (overloading group) . . . . . . . . . . . . . . . . . . . . . 118

14.1.5 The SizeOf pseudo-function . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

14.1.6 Deriving Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

14.1.7 Deriving Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120

14.1.8 Deriving Bounded . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120

14.1.9 Deriving type class instances for isomorphic types . . . . . . . . . . . . . . . 121

14.2 Higher-order functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

15 Embedding Verilog in a BSV design                               123

15.1 Parameter statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

15.2 Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

15.3 Port statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126

15.4 Input clock statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

15.5 Default clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

15.6 Output clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

15.7 Input reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

15.8 Default reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

15.9 Output reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

15.10Ancestor, same family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

15.11Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

15.12Path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135

15.13Inout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135

                        c 2008 Bluespec, Inc. All rights reserved  7


Reference Guide                                             Bluespec SystemVerilog

16 Embedding C in a BSV Design                              136

   16.1 Argument Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

   16.2 Return types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138

   16.3 Implicit pack/unpack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138

   16.4 Other examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

A Keywords                                                  141

B The Standard Prelude package                              145

   B.1 Type classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

   B.1.1 Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

   B.1.2 Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

   B.1.3 Literal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

   B.1.4 RealLiteral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

   B.1.5 Arith . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

   B.1.6 Ord . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

   B.1.7 Bounded . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

   B.1.8 Bitwise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

   B.1.9 BitReduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

   B.1.10 BitExtend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

   B.2 Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

   B.2.1 Bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154

   B.2.2 UInt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154

   B.2.3 Int . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155

   B.2.4 Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155

   B.2.5 Bool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

   B.2.6 Real . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

   B.2.7 String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

   B.2.8 Fmt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

   B.2.9 Maybe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

   B.2.10 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

   B.2.11 Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160

   B.2.12 Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160

   B.2.13 Inout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161

   B.2.14 Action/ActionValue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161

   B.2.15 Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

   B.3 Operations on Numeric Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163

   B.3.1 Size Relationship/Provisos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163

8                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

      B.3.2 Size Relationship Type Functions . . . . . . . . . . . . . . . . . . . . . . . . . 164
      B.3.3 valueOf and SizeOf pseudo-functions . . . . . . . . . . . . . . . . . . . . . . . 164
B.4 Registers and Wires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
      B.4.1 Reg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
      B.4.2 RWire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
      B.4.3 Wire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
      B.4.4 BypassWire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
      B.4.5 DWire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
      B.4.6 PulseWire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
      B.4.7 ReadOnly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
B.5 Miscellaneous Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
      B.5.1 Compile-time Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
      B.5.2 Arithmetic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
      B.5.3 Operations on Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
      B.5.4 Bit Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
      B.5.5 Control Flow Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
B.6 Environment Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174

C Foundation Libraries                                             176

C.1 Storage and Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176

C.1.1 Register File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176

C.1.2 FIFO Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179

C.1.3 FIFO and FIFOF packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179

C.1.4 FIFOLevel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186

C.1.5 ConﬁgReg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

C.1.6 DReg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194

C.1.7 RevertingVirtualReg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195

C.1.8 BRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196

C.1.9 BRAMFIFO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

C.2 Aggregation: Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199

C.2.1 Creating and Generating Vectors . . . . . . . . . . . . . . . . . . . . . . . . . 200

C.2.2 Extracting Elements and Sub-Vectors . . . . . . . . . . . . . . . . . . . . . . 202

C.2.3 Vector to Vector Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205

C.2.4 Tests on Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207

C.2.5 Bit-Vector Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210

C.2.6 Functions on Vectors of Registers . . . . . . . . . . . . . . . . . . . . . . . . . 210

C.2.7 Combining Vectors with Zip . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210

                        c 2008 Bluespec, Inc. All rights reserved  9


Reference Guide                                             Bluespec SystemVerilog

          C.2.8 Mapping Functions over Vectors . . . . . . . . . . . . . . . . . . . . . . . . . 212
          C.2.9 ZipWith Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
          C.2.10 Fold Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
          C.2.11 Scan Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
          C.2.12 Monadic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
          C.2.13 Converting to and from Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 222
          C.2.14 ListN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
    C.3 Aggregation: Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
          C.3.1 Creating and Generating Lists . . . . . . . . . . . . . . . . . . . . . . . . . . 223
          C.3.2 Extracting Elements and Sub-Lists . . . . . . . . . . . . . . . . . . . . . . . . 224
          C.3.3 List to List Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
          C.3.4 Tests on Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
          C.3.5 Combining Lists with Zip Functions . . . . . . . . . . . . . . . . . . . . . . . 230
          C.3.6 Mapping Functions over Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
          C.3.7 ZipWith Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
          C.3.8 Fold Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
          C.3.9 Scan Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
          C.3.10 Monadic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
    C.4 Math . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
          C.4.1 Real . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
          C.4.2 Complex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
          C.4.3 FixedPoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
          C.4.4 OInt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
    C.5 FSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
          C.5.1 StmtFSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
    C.6 Connectivity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
          C.6.1 GetPut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
          C.6.2 Connectable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
          C.6.3 ClientServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
          C.6.4 CGetPut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
    C.7 Utilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
          C.7.1 LFSR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
          C.7.2 Randomizable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
          C.7.3 Arbiter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
          C.7.4 GrayCounter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
          C.7.5 Gray . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
          C.7.6 CompletionBuﬀer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277

10               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

      C.7.7 UniqueWrappers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
      C.7.8 FShow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
      C.7.9 Assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
      C.7.10 Probe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
      C.7.11 Reserved . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
      C.7.12 TriState . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
      C.7.13 ZBus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
      C.7.14 OVLAssertions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
C.8 Multiple Clock Domains and Clock Generators . . . . . . . . . . . . . . . . . . . . . 308
      C.8.1 Clock Generators and Clock Manipulation . . . . . . . . . . . . . . . . . . . . 310
      C.8.2 Clock Multiplexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
      C.8.3 Clock Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
      C.8.4 Bit Synchronizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
      C.8.5 Pulse Synchronizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
      C.8.6 Word Synchronizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
      C.8.7 FIFO Synchronizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
      C.8.8 Asynchronous RAMs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
      C.8.9 Null Crossing Primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
      C.8.10 Specialized Crossing Primitives . . . . . . . . . . . . . . . . . . . . . . . . . . 332
      C.8.11 Reset Synchronization and Generation . . . . . . . . . . . . . . . . . . . . . . 335
C.9 Special Collections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
      C.9.1 ModuleCollect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
      C.9.2 CBus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
C.10 AzureIP Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
      C.10.1 TLM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
      C.10.2 AXI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
      C.10.3 AHB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369

Index                                                              376

Function and Module by Package                                     387

Packages provided as BSV source code                               392

                        c 2008 Bluespec, Inc. All rights reserved  11


Reference Guide                                             Bluespec SystemVerilog

1 Introduction

Bluespec SystemVerilog (BSV) is aimed at hardware designers who are using or expect to use
Verilog [IEE01], VHDL [IEE02], or SystemVerilog [Acc04] to design ASICs or FPGAs. BSV is
based on a synthesizable subset of SystemVerilog, including SystemVerilog types, modules, module
instantiation, interfaces, interface instantiation, parameterization, static elaboration, and “generate”
elaboration. BSV can signiﬁcantly improve the hardware designer’s productivity with some key
innovations:

    • It expresses synthesizable behavior with Rules instead of synchronous always blocks. Rules
       are powerful concepts for achieving correct concurrency and eliminating race conditions. Each
       rule can be viewed as a declarative assertion expressing a potential atomic state transition.
       Although rules are expressed in a modular fashion, a rule may span multiple modules, i.e., it
       can test and aﬀect the state in multiple modules. Rules need not be disjoint, i.e., two rules
       can read and write common state elements. The BSV compiler produces eﬃcient RTL code
       that manages all the potential interactions between rules by inserting appropriate arbitration
       and scheduling logic, logic that would otherwise have to be designed and coded manually. The
       atomicity of rules gives a scalable way to avoid unwanted concurrency (races) in large designs.

    • It enables more powerful generate-like elaboration. This is made possible because in BSV,
       actions, rules, modules, interfaces and functions are all ﬁrst-class objects. BSV also has more
       general type parameterization (polymorphism). These enable the designer to “compute with
       design fragments,” i.e., to reuse designs and to glue them together in much more ﬂexible ways.
       This leads to much greater succinctness and correctness.

    • It provides formal semantics, enabling formal veriﬁcation and formal design-by-reﬁnement.
       BSV rules are based on Term Rewriting Systems, a clean formalism supported by decades
       of theoretical research in the computer science community [Ter03]. This, together with a
       judicious choice of a design subset of SystemVerilog, makes programs in BSV amenable to
       formal reasoning.

This manual is meant to be a stand-alone reference for BSV, i.e., it fully describes the subset of
Verilog and SystemVerilog used in BSV. It is not intended to be a tutorial for the beginner. A reader
with a working knowledge of Verilog 1995 or Verilog 2001 should be able to read this manual easily.
Prior knowledge of SystemVerilog is not required.

1.1 Meta notation

The grammar in this document is given using an extended BNF (Backus-Naur Form). Grammar
alternatives are separated by a vertical bar (“|”). Items enclosed in square brackets (“[ ]”) are
optional. Items enclosed in curly braces (“{ }”) can be repeated zero or more times.

Another BNF extension is parameterization. For example, a moduleStmt can be a moduleIf, and an
actionStmt can be an actionIf. A moduleIf and an actionIf are almost identical; the only diﬀerence
is that the former can contain (recursively) moduleStmts whereas the latter can contain actionStmts.
Instead of tediously repeating the grammar for moduleIf and actionIf, we parameterize it by giving
a single grammar for &lt;ctxt&gt;If, where &lt;ctxt&gt; is either module or action. In the productions for
&lt;ctxt&gt;If, we call for &lt;ctxt&gt;Stmt which, therefore, either represents a moduleStmt or an actionStmt,
depending on the context in which it is used.

2 Lexical elements

BSV has the same basic lexical elements as Verilog.

12               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

2.1 Whitespace and comments

Spaces, tabs, newlines, formfeeds, and carriage returns all constitute whitespace. They may be used
freely between all lexical tokens.

A comment is treated as whitespace (it can only occur between, and never within, any lexical token).
A one-line comment starts with // and ends with a newline. A block comment begins with /* and
ends with */ and may span any number of lines.

Comments do not nest. In a one-line comment, the character sequences //, /* and */ have no special
signiﬁcance. In a block comment, the character sequences // and /* have no special signiﬁcance.

2.2 Identiﬁers and keywords

An identiﬁer in BSV consists of any sequence of letters, digits, dollar signs $ and underscore char-
acters (_). Identiﬁers are case-sensitive: glurph, gluRph and Glurph are three distinct identiﬁers.
The ﬁrst character cannot be a digit.

BSV currently requires a certain capitalization convention for the ﬁrst letter in an identiﬁer. Identi-
ﬁers used for package names, type names, enumeration labels, union members and type classes must
begin with a capital letter. In the syntax, we use the non-terminal Identiﬁer to refer to these. Other
identiﬁers (including names of variables, modules, interfaces, etc.) must begin with a lowercase letter
and, in the syntax, we use the non-terminal identiﬁer to refer to these.

As in Verilog, identiﬁers whose ﬁrst character is $ are reserved for so-called system tasks and functions
(see Section 12.8).

If the ﬁrst character of an instance name is an underscore, (_), the compiler will not generate
this instance in the Verilog hierarchy name. This can be useful for removing submodules from the
hierarchical naming.

There are a number of keywords that are essentially reserved identiﬁers, i.e., they cannot be used by
the programmer as identiﬁers. Keywords generally do not use uppercase letters (the only exception
is the keyword valueOf). BSV includes all keywords in SystemVerilog. All keywords are listed in
Appendix A.

The types Action and ActionValue are special, and cannot be redeﬁned.

2.3 Integer literals

Integer literals are written with the usual Verilog and C notations:

intLiteral              ::= ’0 | ’1 | decLiteral | hexLiteral | octLiteral | binLiteral

decLiteral              ::= [ - ] decDigits
                        | [ bitWidth ] ( ’d | ’D ) decDigits
hexLiteral              ::= [ bitWidth ] ( ’h | ’H ) hexDigits
octLiteral              ::= [ bitWidth ] ( ’o | ’O ) octDigits
binLiteral              ::= [ bitWidth ] ( ’b | ’B ) binDigits

bitWidth                ::= decDigits

decDigits               ::= 1 or more consecutive characters from the set 0...9
hexDigits               ::= 1 or more consecutive characters from the sets 0...9, a...f, A...F
octDigits               ::= 1 or more consecutive characters from the set 0...7
binDigits               ::= 1 or more consecutive characters from the set 0...1

With the exception of plain decimal literals (that have neither a bit width or a base), there is no
leading + or - in the syntax for integer literals. Instead, we provide unary preﬁx + or - operators

                        c 2008 Bluespec, Inc. All rights reserved                               13


Reference Guide                                                 Bluespec SystemVerilog

that can be used in front of any integer expression, including literals (see Section 9). An optional -
is part of the syntax for plain decimal literals so that it is possible to construct negative constants
whose negation is not in the range of the type being constructed (e.g. Int#(4) x = -8; since 8 is
not a valid Int#(4), but -8 is).

Examples:

 125
 -16
 ’h48454a
 32’h48454a
 8’o255
 12’b101010

2.3.1 Type conversion of integer literals

Integer literals can be used to specify values for various integer types and even for user-deﬁned
types. BSV uses its systematic overloading resolution mechanism to perform these type conversions.
Overloading resolution is described in more detail in Section 14.1.

In an integer literal, if a speciﬁc width w is given (e.g., 8’o255), the literal is assumed to have type
bit [w − 1:0]. The compiler implicitly applies the overloaded function unpack to the literal to
convert it to the type required by the context. Thus, sized literals can be used for any type on which
the overloaded function unpack is deﬁned, i.e., for any type in the Bits type class.

If a speciﬁc width is not given, the literal is assumed to have type Integer. The compiler implicitly
applies the overloaded function fromInteger to the literal to convert it to the type required by
the context. Thus, unsized literals can be used for any type on which the overloaded function
fromInteger is deﬁned.

The literal ’0 just stands for 0. The literal ’1 stands for a value in which all bits are 1 (the width
depends on the context).

2.4 Real literals

Support for real (Verilog 2001) and shortreal (SystemVerilog) will be added to BSV in the future.

2.5 String literals

String literals are written enclosed in double quotes &quot;· · ·&quot; and must be contained on a single source
line.

    stringLiteral  ::= &quot; · · · string characters · · · &quot;

Special characters may be inserted in string literals with the following backslash escape sequences:

\n     newline
\t     tab
\\     backslash
\&quot;     double quote
\v     vertical tab
\f     form feed
\a     bell
\OOO   exactly 3 octal digits (8-bit character code)
\xH H  exactly 2 hexadecimal digits (8-bit character code)

14                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Example - printing characters using form feed.

       module mkPrinter (Empty);
            String display_value;

    display_value = &quot;a\nb\nc&quot;;            //prints a

    rule every;                           //    b
         $display(display_value);
                                          //    c     repeatedly
    endrule
endmodule

2.6 Don’t-care values

A lone question mark ? is treated as a special don’t-care value. For example, one may return ?
from an arm of a case statement that is known to be unreachable.

Example - Using ? as a don’t care value

module mkExample (Empty);                       // don’t care is used for the
    Reg#(Bit#(8)) r &lt;- mkReg(?);                // reset value of the Reg
    rule every;                                 // the value of r is displayed
         $display(&quot;value is %h&quot;, r);
    endrule

endmodule

2.7 Compiler directives

The following compiler directives permit ﬁle inclusion, macro deﬁnition and substitution, and condi-
tional compilation. They follow the speciﬁcations given in the Verilog 2001 LRM plus the extensions
given in the SystemVerilog 3.1a LRM.

In general, these compiler directives can appear anywhere in the source text. In particular, they do
not need to be on lines by themselves, and they need not begin in the ﬁrst column. Of course, they
should not be inside strings or comments, where the text remains uninterpreted.

2.7.1 File inclusion: ‘include and ‘line

compilerDirective       ::= ‘include &quot;ﬁlename&quot;
                        | ‘include &lt;ﬁlename&gt;
                        | ‘include macroInvocation

In an ‘include directive, the contents of the named ﬁle are inserted in place of this line. The
included ﬁles may themselves contain compiler directives. Currently there is no diﬀerence between
the &quot;...&quot; and &lt;...&gt; forms. A macroInvocation should expand to one of the other two forms. The
ﬁle name may be absolute, or relative to the current directory.

compilerDirective       ::= ‘line lineNumber &quot;ﬁlename&quot; level
lineNumber              ::= decLiteral
level                   ::= 0 | 1 | 2

A ‘line directive is terminated by a newline, i.e., it cannot have any other source text after the level.
The compiler automatically keeps track of the source ﬁle name and line number for every line of
source text (including from included source ﬁles), so that error messages can be properly correlated to
the source. This directive eﬀectively overrides the compiler’s internal tracking mechanism, forcing

                        c 2008 Bluespec, Inc. All rights reserved               15


Reference Guide                                                         Bluespec SystemVerilog

it to regard the next line onwards as coming from the given source ﬁle and line number. It is
generally not necessary to use this directive explicitly; it is mainly intended to be generated by other
preprocessors that may themselves need to alter the source ﬁles before passing them through the
BSV compiler; this mechanism allows proper references to the original source.
The level speciﬁer is either 0, 1 or 2:

    • 1 indicates that an include ﬁle has just been entered

    • 2 indicates that an include ﬁle has just been exited

    • 0 is used in all other cases

2.7.2 Macro deﬁnition and substitution: ‘deﬁne and related directives

    compilerDirective ::= ‘define macroName [ ( macroFormals ) ] macroText

    macroName     ::= identiﬁer

    macroFormals  ::= identiﬁer { , identiﬁer }

The ‘define directive is terminated by a bare newline. A backslash (\) just before a newline
continues the directive into the next line. When the macro text is substituted, each such continuation
backslash-newline is replaced by a newline.

The macroName is an identiﬁer and may be followed by formal arguments, which are a list of
comma-separated identiﬁers in parentheses. For both the macro name and the formals, lower and
upper case are acceptable (but case is distinguished). The macroName cannot be any of the compiler
directives (such as include, define, ...).

The scope of the formal arguments extends to the end of the macroText.

The macroText represents almost arbitrary text that is to be substituted in place of invocations of
this macro. The macroText can be empty.

One-line comments (i.e., beginning with //) may appear in the macroText; these are not considered
part of the substitutable text and are removed during substitution. A one-line comment that is not
on the last line of a ‘define directive is terminated by a backslash-newline instead of a newline.

A block comment (/*...*/) is removed during substitution and replaced by a single space.

The macroText can also contain the following special escape sequences:

    • ‘&quot;       Indicates that a double-quote (&quot;) should be placed in the expanded text.

    • ‘\‘&quot;     Indicates that a backslash and a double-quote (\&quot;) should be placed in the expanded
       text.

    • ‘‘       Indicates that there should be no whitespace between the preceding and following

    text. This allows construction of identiﬁers from the macro arguments.

A minimal amount of lexical analysis of macroText is done to identify comments, string literals,
identiﬁers representing macro formals, and macro invocations. As described earlier, one-line com-
ments are removed. The text inside string literals is not interpreted except for the usual string
escape sequences described in Section 2.5.

There are two deﬁne macros in the deﬁne environment initially; ‘bluespec and ‘BLUESPEC.

Once deﬁned, a macro can be invoked anywhere in the source text (including within other macro
deﬁnitions) using the following syntax.

16                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

compilerDirective ::= macroInvocation

macroInvocation         ::= ‘macroName [ ( macroActuals ) ]

macroActuals            ::= substText { , substText }

The macroName must refer to a macro deﬁnition available at expansion time. The macroActuals,
if present, consist of substitution text substText that is arbitrary text, possibly spread over multiple
lines, excluding commas. A minimal amount of parsing of this substitution text is done, so that
commas that are not at the top level are not interpreted as the commas separating macroActuals.
Examples of such “inner” uninterpreted commas are those within strings and within comments.

compilerDirective       ::= ‘undef macroName
                        | ‘resetall

The ‘undef directive’s eﬀect is that the speciﬁed macro (with or without formal arguments) is no
longer deﬁned for the subsequent source text. Of course, it can be deﬁned again with ‘define in the
subsequent text. The ‘resetall directive has the eﬀect of undeﬁning all currently deﬁned macros,
i.e., there are no macros deﬁned in the subsequent source text.

2.7.3 Conditional compilation: ‘ifdef and related directives

compilerDirective       ::= ‘ifdef macroName
                        | ‘ifndef macroName
                        | ‘elsif macroName
                        | ‘else
                        | ‘endif

These directives are used together in either an ‘ifdef-endif sequence or an ifndef-endif sequence.
In either case, the sequence can contain zero or more elsif directives followed by zero or one else
directives. These sequences can be nested, i.e., each ‘ifdef or ifndef introduces a new, nested
sequence until a corresponding endif.

In an ‘ifdef sequence, if the macroName is currently deﬁned, the subsequent text is processed until
the next corresponding elsif, else or endif. All text from that next corresponding elsif or else
is ignored until the endif.

If the macroName is currently not deﬁned, the subsequent text is ignored until the next corresponding
‘elsif, ‘else or ‘endif. If the next corresponding directive is an ‘elsif, it is treated just as if it
were an ‘ifdef at that point.

If the ‘ifdef and all its corresponding ‘elsifs fail (macros were not deﬁned), and there is an ‘else
present, then the text between the ‘else and ‘endif is processed.

An ‘ifndef sequence is just like an ‘ifdef sequence, except that the sense of the ﬁrst test is
inverted, i.e., its following text is processes if the macroName is not deﬁned, and its ‘elsif and
‘else arms are considered only if the macro is deﬁned.

Example using ‘ifdef to determine the size of a register:

‘ifdef USE_16_BITS
    Reg#(Bit#(16)) a_reg &lt;- mkReg(0);

‘else
    Reg#(Bit#(8)) a_reg &lt;- mkReg(0);

‘endif

                        c 2008 Bluespec, Inc. All rights reserved  17


Reference Guide                                             Bluespec SystemVerilog

3 Packages and the outermost structure of a BSV design

A BSV program consists of one or more outermost constructs called packages. All BSV code is
assumed to be inside a package. Further, the BSV compiler and other tools assume that there is
one package per ﬁle, and they use the package name to derive the ﬁle name. For example, a package
called Foo is assumed to be located in a ﬁle Foo.bsv.

A BSV package is purely a linguistic namespace-management mechanism and is particularly useful
for programming in the large, so that the author of a package can choose identiﬁers for the package
components freely without worrying about choices made by authors of other packages. Package
structure is usually uncorrelated with hardware structure, which is speciﬁed by the module construct.

A package contains a collection of top-level statements that include speciﬁcations of what it imports
from other packages, what it exports to other packages, and its deﬁnitions of types, interfaces,
functions, variables, and modules. BSV tools ensure that when a package is compiled, all the
packages that it imports have already been compiled.

    package      ::= package packageIde ;
                      { exportDecl }
                      { importDecl }
                      { packageStmt }
                      endpackage [ : packageIde ]

    exportDecl   ::= export exportItem { , exportItem } ;
    exportItem   ::= identiﬁer [ (..) ]
                 | Identiﬁer [ (..) ]
                 | packageIde :: *

    importDecl   ::= import importItem { , importItem } ;
    importItem   ::= packageIde :: *

    packageStmt  ::= [ attributeInstances ] moduleDef
                 | interfaceDecl
                 | typeDef
                 | varDecl | varAssign
                 | [ attributeInstances ] functionDef
                 | typeclassDef
                 | typeclassInstanceDef
                 | externModuleImport

    packageIde   ::= Identiﬁer

The name of the package is the identiﬁer following the package keyword. This name can optionally
be repeated after the endpackage keyword (and a colon). We recommend using an uppercase ﬁrst
letter in package names. In fact, the package and endpackage lines are optional: if they are absent,
BSV derives the assumed package name from the ﬁlename.

An export item can specify an identiﬁer deﬁned elsewhere within this package optionally followed by
(..). The identiﬁer then becomes accessible outside this package. An export item can also specify
an identiﬁer from an imported package. In that case, the imported identiﬁer is re-exported from
this package, so that it is accessible by importing this package (without requiring the import of its
source package). It is also possible to re-export all of the identiﬁers from an imported package by
using the following syntax: export packageIde::*.

If there are any export statements in a package, then only those items are exported. If there are
no export statements, by default all identiﬁers deﬁned in this package (and no identiﬁers from any
imported packages) are exported.

If the exported identiﬁer is the name of a struct (structure) or union type deﬁnition, then the
members of that type will be visible only if (..) is used. By omitting the (..) suﬃx, only the

18               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

type, but not its members, are visible outside the package. This is a way to deﬁne abstract data
types, i.e., types whose internal structure is hidden.

Each import item speciﬁes a package from which to import identiﬁers, i.e., to make them visible
locally within this package. For each imported package, all identiﬁers exported from that package
are made locally visible.

Example:

package Foo;
export x;
export y;

import Bar::*;

... top level deﬁnition ...
... top level deﬁnition ...
... top level deﬁnition ...

endpackage: Foo

Here, Foo is the name of this package. The identiﬁers x and y, which must be deﬁned by the top-level
deﬁnitions in this package are names exported from this package. From package Bar we import all
its deﬁnitions.

3.1 Scopes, name clashes and qualiﬁed identiﬁers

BSV uses standard static scoping (also known as lexical scoping). Many constructs introduce new
scopes nested inside their surrounding scopes. Identiﬁers can be declared inside nested scopes. Any
use of an identiﬁer refers to its declaration in the nearest textually surrounding scope. Thus, an
identiﬁer x declared in a nested scope “shadows”, or hides, any declaration of x in surrounding scopes
(however, we recommend that the programmer avoids such shadowing, because it often makes code
more diﬃcult to read.)

Packages form the the outermost scopes. Examples of nested scopes include modules, interfaces,
functions, methods, rules, action and actionvalue blocks, begin-end statements and expressions,
bodies of for and while loops, and seq and par blocks.

When used in any scope, an identiﬁer must have an unambiguous meaning. If there is name clash
for an identiﬁer x because it is deﬁned in the current package and/or it is available from one or more
imported packages, then the ambiguity can be resolved by using a qualiﬁed name of the form P :: x
to refer to the version of x contained in package P .

3.2 The Standard Prelude package

The Standard Prelude is a predeﬁned package that is imported implicitly into every BSV package,
i.e., it does not need an explicit import statement. It contains a number of useful predeﬁned entities
(types, values, functions, modules, etc.). The Standard Prelude package is described in more detail
in appendix B. Reusing the name of Prelude entity when deﬁning other entities, which would require
the entity’s name to be qualiﬁed with the package name, is strongly discouraged.

                        c 2008 Bluespec, Inc. All rights reserved  19


Reference Guide                                                       Bluespec SystemVerilog

4 Types

Every variable and every expression in BSV has a type. Almost all variables must be declared with
their type.

The syntax of types (type expressions) is given below:

    type             ::= typePrimary

                     | typePrimary ( type { , type } )                   Function type

    typePrimary      ::= typeIde [ # ( type { , type } ) ]
                     | typeNat
                     | bit [ typeNat : typeNat ]

    typeIde          ::= Identiﬁer
    typeNat          ::= decDigits

Examples of simple types:

Integer                    // Unbounded signed integers, for static elaboration only
int                        // 32-bit signed integers
Bool
String
Action

Type expressions of the form X#(t1,· · ·,tN ) are called parameterized types. X is called a type
constructor and the types t1,· · ·,tN are the parameters of X. Examples:

Tuple2#(int,Bool)              // pair of items, an int and a Bool
Tuple3#(int,Bool,String)       // triple of items, an int, a Bool and a String
List#(Bool)                    // list containing booleans
List#(List#(Bool))             // list containing lists of booleans
RegFile#(Integer, String)      // a register file (array) indexed by integers, containing strings

Type parameters can be natural numbers (also known as size types). These usually indicate some
aspect of the size of the type, such as a bit-width or a table capacity. Examples:

Bit#(16)                   // 16-bit wide bit-vector
bit [15:0]                 // synonym for Bit#(16)
UInt#(32)                  // unsigned integers, 32 bits wide
Int#(29)                   // signed integers, 29 bits wide
Vector#(16,Int#(29)        // Vector of size 16 containing Int#(29)’s

Currently the second index n in a bit[m:n] type must be 0. The type bit[m:0] represents the
type of bit vectors, with bits indexed from m (msb/left) down through 0 (lsb/right), for m ≥ 0.

4.1 Polymorphism

A type can be polymorphic. This is indicated by using type variables as parameters. Examples:

List#(a)                   // lists containing items of some type a
List#(List#(b))
RegFile#(i, List#(x))      // lists containing lists of items of some type a

                           // arrays indexed by some type i, containing

                           //         lists that contain items of some type x

The type variables represent unknown (but speciﬁc) types. In other words, List#(a) represents
the type of a list containing items all of which have some type a. It does not mean that diﬀerent
elements of a list can have diﬀerent types.

20                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

4.2 Provisos (brief intro)

Provisos are described in detail in Section 14.1.1, and the general facility of type classes (overload-
ing groups), of which provisos form a part, is described in Section 14.1. Here we provide a brief
description, which is adequate for most uses and for continuity in a serial reading of this manual.

A proviso is a static condition attached to certain constructs, to impose certain restrictions on the
types involved in the construct. The restrictions are of two kinds:

• Require instance of a type class (overloading group): this kind of proviso states that certain
   types must be instances of certain type classes, i.e., that certain overloaded functions are
   deﬁned on this type.

• Require size relationships: this kind of proviso expresses certain constraints between the sizes
   of certain types.

The most common overloading provisos are:

Bits#(t,n)   // Type class (overloading group) Bits
             // Meaning: overloaded operators pack/unpack are defined
             // on type t to convert to/from Bit#(n)

Eq#(t)       // Type class (overloading group) Eq
             // Meaning: overloaded operators == and != are defined on type t

Literal#(t)  // Type class (overloading group) Literal
             // Meaning: Overloaded function fromInteger() defined on type t
             // to convert an integer literal to type t. Also overloaded
             // function inLiteralRange to determine if an Integer
             // is in the range of the target type t.

Ord#(t)      // Type class (overloading group) Ord
             // Meaning: Overloaded order-comparison operators &lt;, &lt;=,
             // &gt; and &gt;= are defined on type t

Bounded#(t)  // Type class (overloading group) Bounded
             // Meaning: Overloaded identifiers minBound and maxBound
             // are defined for type t

Bitwise#(t)  // Type class (overloading group) Bitwise
             // Meaning: Overloaded operators &amp;, |, ^, ~^, ^~, ~, &lt;&lt; and &gt;&gt;
             // and overloaded function invert are defined on type t

BitReduction#(t)// Type class (overloading group) BitReduction
                       // Meaning: Overloaded prefix operators &amp;, |, ^,
                       // ~&amp;, ~|, ~^, and ^~ are defined on type t

BitExtend#(t) // Type class (overloading group) BitExtend
                       // Meaning: Overloaded functions extend, zeroExtend, signExtend
                       // and truncate are defined on type t

Arith#(t)    // Type class (overloading group) Arith
             // Meaning: Overloaded operators +, -, and *, and overloaded
             // prefix operator - (same as function negate), and
             // overloaded function negate are defined on type t

                        c 2008 Bluespec, Inc. All rights reserved                       21


Reference Guide                                             Bluespec SystemVerilog

The size relationship provisos are:

Add#(n1,n2,n3) // Meaning: assert n1 + n2 = n3

Mul#(n1,n2,n3) // Meaning: assert n1 * n2 = n3

Div#(n1,n2,n3) // Meaning: assert ceiling n1 / n2 = n3

Max#(n1,n2,n3) // Meaning: assert max(n1,n2) = n3

Log#(n1,n2)      // Meaning: assert ceiling(log(n1)) = n2
                 // The logarithm is base 2

Example:

module mkExample (ProvideCurrent#(a))
    provisos(Bits#(a, sa), Arith#(a));

    Reg#(a) value_reg &lt;- mkReg(?); // requires that type &quot;a&quot; be in the Bits typeclass.
    rule every;

        value_reg &lt;= value_reg + 1; // requires that type &quot;a&quot; be in the Arith typeclass.
    endrule

Example:

function Bit#(m) pad0101 (Bit#(n) x)
    provisos (Add#(n,4,m)); // m is 4 bits longer than n
    pad0101 = { x, 0b0101 };

endfunction: pad0101

This deﬁnes a function pad0101 that takes a bit vector x and pads it to the right with the four bits
“0101” using the standard bit-concatenation notation. The types and proviso express the idea that
the function takes a bit vector of length n and returns a bit vector of length m, where n + 4 = m.
These provisos permit the BSV compiler to statically verify that entities (values, variables, registers,
memories, FIFOs, and so on) have the correct bit-width.

4.2.1 The pseudo-function valueof (or valueOf )

To get the value that corresponds to a size type, there is a special pseudo-function, valueof, that
takes a size type and gives the corresponding Integer value. The pseudo-function is also sometimes
written as valueOf; both are considered correct.

    exprPrimary  ::= valueof ( type )
                 | valueOf ( type )

In other words, it converts from a numeric type expression into an ordinary value. These mechanisms
can be used to do arithmetic to derive dependent sizes. Example:

function ... foo (Vector#(n,int) xs) provisos (Log#(n,k));
    Integer maxindex = valueof(n) - 1;
    Int#(k) index;
    index = fromInteger(maxindex);
    ...

endfunction

22               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

This function takes a vector of length n as an argument. The proviso ﬁxes k to be the (ceiling of
the) logarithm of n. The variable index has bit-width k, which will be adequate to hold an index
into the list. The variable is initialized to the maximum index.

Note that the function foo may be invoked in multiple contexts, each with a diﬀerent vector length.
The compiler will statically verify that each use is correct (e.g., the index has the correct width).

The pseudo-function valueof, which converts a numeric type to a value, should not be confused
with the pseudo-function SizeOf, described in Section 14.1.5, which converts a type to a numeric
type.

4.3 A brief introduction to deriving clauses

The deriving clause is a part of the general facility of type classes (overloading groups), which is
described in detail in Section 14.1. Here we provide a brief description, which is adequate for most
uses and for continuity in a serial reading of this manual.

It is possible to attach a deriving clause to a type deﬁnition (Section 7), thereby directing the
compiler to deﬁne automatically certain overloaded functions for that type. The most common
forms of these clauses are:

deriving(Eq)            // Meaning: automatically define == and !=
                        // for equality and inequality comparisons

deriving(Bits)          // Meaning: automatically define pack and unpack
                        // for converting to/from bits

deriving(Bounded) // Meaning: automatically define minBound and maxBound

Example:

typedef enum {LOW, NORMAL, URGENT} Severity deriving(Eq, Bits);
// == and != are defined for variables of type Severity
// pack and unpack are defined for variables of type Severity

module mkSeverityProcessor (SeverityProcessor);
    method Action process(Severity value);
         // value is a variable of type Severity
         if (value == URGENT) $display(&quot;WARNING: Urgent severity encountered.&quot;);
         // Since value is of the type Severity, == is defined
    endmethod

endmodule

5 Modules and interfaces, and their instances

Modules and interfaces form the heart of BSV. Modules and interfaces turn into actual hardware.
An interface for a module m mediates between m and other, external modules that use the facilities
of m. We often refer to these other modules as clients of m.

In SystemVerilog and BSV we separate the declaration of an interface from module deﬁnitions.
There was no such separation in Verilog 1995 and Verilog 2001, where a module’s interface was
represented by its port list, which was part of the module deﬁnition itself. By separating the
interface declaration, we can express the idea of a common interface that may be oﬀered by several
modules, without having to repeat that declaration in each of the implementation modules.

                        c 2008 Bluespec, Inc. All rights reserved         23


Reference Guide                                             Bluespec SystemVerilog

As in Verilog and SystemVerilog, it is important to distinguish between a module deﬁnition and
a module instantiation. A module deﬁnition can be regarded as specifying a scheme that can be
instantiated multiple times. For example, we may have a single module deﬁnition for a FIFO, and
a particular design may instantiate it multiple times for all the FIFOs it contains.

Similarly, we also distinguish interface declarations and instances, i.e., a design will contain interface
declarations, and each of these may have multiple instances. For example an interface declaration
I may have one instance i1 for communication between module instances a1 and b1, and another
instance i2 for communication between module instances a2 and b2.

Module instances form a pure hierarchy. Inside a module deﬁnition mkM , one can specify instantia-
tions of other modules. When mkM is used to instantiate a module m, it creates the speciﬁed inner
module instances. Thus, every module instance other than the top of the hierarchy unambiguously
has a single parent module instance. We refer to the top of the hierarchy as the root module. Every
module instance has a unique set, possibly empty, of child module instances. If there are no children,
we refer to it as a leaf module.

A module consists of three things: state, rules that operate on that state, and the module’s interface
to the outside world (surrounding hierarchy). The state conceptually consists of all state in the
sub-hierarchy headed by this module; ultimately, it consists of all the lower leaf module instances
(see next section on state and module instantiation). Rules are the fundamental means to express
behavior in BSV (instead of the always blocks used in traditional Verilog). In BSV, an interface
consists of methods that encapsulate the possible transactions that clients can perform, i.e., the
micro-protocols with which clients interact with the module. When compiled into RTL, an interface
becomes a collection of wires.

5.1 Explicit state via module instantiation, not variables

In Verilog and SystemVerilog RTL, one simply declares variables, and a synthesis tool “infers” how
these variables actually map into state elements in hardware using, for example, their lifetimes
relative to events. A variable may map into a bus, a latch, a ﬂip-ﬂop, or even nothing at all. This
ambiguity is acknowledged in the Verilog 2001 and SystemVerilog LRMs.1

BSV removes this ambiguity and places control over state instantiation explicitly in the hands of
the designer. From the smallest state elements (such as registers) to the largest (such as memories),
all state instances are speciﬁed explicitly using module instantiation.

Conversely, an ordinary declared variable in BSV never implies state, i.e., it never holds a value
over time. Ordinary declared variables are always just convenient names for intermediate values in
a computation. Ordinary declared variables include variables declared in blocks, formal parameters,
pattern variables, loop iterators, and so on. Another way to think about this is that ordinary
variables play a role only in static elaboration, not in the dynamic semantics. This is one of the
aspects of BSV style that may initially appear unusual to the Verilog or SystemVerilog programmer.

Example:

       module mkExample (Empty);
            // Hardware registers are created here
            Reg#(Bit#(8)) value_reg &lt;- mkReg(0);

            FIFO#(Bit#(8)) fifo &lt;- mkFIFO;

    1In the Verilog 2001 LRM, Section 3.2.2, Variable declarations, says: “A variable is an abstraction of a data storage
element.· · ·NOTE In previous versions of the Verilog standard, the term register was used to encompass both the reg,
integer, time, real and realtime types; but that term is no longer used as a Verilog data type.”

   In the SystemVerilog LRM, Section 5.1 says: “Since the keyword reg no longer describes the user’s intent in many
cases,· · ·Verilog-2001 has already deprecated the use of the term register in favor of variable.”

24               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

    rule pop;
         let value = fifo.first(); // value is a ordinary declared variable
                                                    // no state is implied or created
         value_reg &lt;= fifo.first(); // value_reg is state variable
         fifo.deq();

      endrule
endmodule

5.2 Interface declaration

In BSV an interface contains members that are called methods (an interface may also contain subin-
terfaces, which are described in Section 5.2.1). To ﬁrst order, a method can be regarded exactly
like a function, i.e., it is a procedure that takes zero or more arguments and returns a result. Thus,
method declarations inside interface declarations look just like function prototypes, the only diﬀer-
ence being the use of the keyword method instead of the keyword function. Each method represents
one kind of transaction between a module and its clients. When translated into RTL, each method
becomes a bundle of wires.

The fundamental diﬀerence between a method and a function is that a method also carries with it a
so-called implicit condition. These will be described later along with method deﬁnitions and rules.

An interface declaration also looks similar to a struct declaration. One can think of an interface
declaration as declaring a new type similar to a struct type (Section 7), where the members all
happen to be method prototypes. A method prototype is essentially the header of a method deﬁnition
(Section 5.5).

interfaceDecl           ::= [ attributeInstances ]
                              interface typeDefType ;
                                    { interfaceMemberDecl }
                              endinterface [ : typeIde ]

typeDefType             ::= typeIde [ typeFormals ]

typeFormals             ::= # ( typeFormal { , typeFormal })

typeFormal              ::= [ numeric ] type typeIde

interfaceMemberDecl ::= methodProto | subinterfaceDecl

methodProto             ::= [ attributeInstances ]
                              method type identiﬁer ( [ methodProtoFormals ] ) ;

methodProtoFormals ::= methodProtoFormal { , methodProtoFormal }

methodProtoFormal ::= [ attributeInstances ] type identiﬁer

Example: a stack of integers:

interface IntStack;            (int x);
      method Action push
      method Action pop;
      method int top;

endinterface: IntStack

This describes an interface to a circuit that implements a stack (LIFO) of integers. The push method
takes an int argument, the item to be pushed onto the stack. Its output type is Action, namely it
returns an enable wire which, when asserted, will carry out the pushing action.2 The pop method

    2 The type Action is discussed in more detail in Section 9.6.

                               c 2008 Bluespec, Inc. All rights reserved               25


Reference Guide                                                 Bluespec SystemVerilog

takes no arguments, and simply returns an enable wire which, when asserted, will discard the element
from the top of the stack. The top method takes no arguments, and returns a value of type int,
i.e., the element at the top of the stack.

What if the stack is empty? In that state, it should be illegal to use the pop and top methods.
This is exactly where the diﬀerence between methods and functions arises. Each method has an
implicit ready wire, which governs when it is legal to use it, and these wires for the pop and top
methods will presumably be de-asserted if the stack is empty. Exactly how this is accomplished is
an internal detail of the module, and is therefore not visible as part of the interface declaration. (We
can similarly discuss the case where the stack has a ﬁxed, ﬁnite depth; in this situation, it should
be illegal to use the push method when the stack is full.)

One of the major advantages of BSV is that the compiler automatically generates all the control
circuitry needed to ensure that a method (transaction) is only used when it is legal to use it.

Interface types can be polymorphic, i.e., parameterized by other types. For example, the following
declaration describes an interface for a stack containing an arbitrary but ﬁxed type:

interface Stack#(type a);

    method Action push (a x);

    method Action pop;

    method a         top;

endinterface: Stack

We have replaced the previous speciﬁc type int with a type variable a. By “arbitrary but ﬁxed” we
mean that a particular stack will specify a particular type for a, and all items in that stack will have
that type. It does not mean that a particular stack can contain items of diﬀerent types.

For example, using this more general deﬁnition, we can also deﬁne the IntStack type as follows:

typedef Stack#(int) IntStack;

i.e., we simply specialize the more general type with the particular type int. All items in a stack of
this type will have the int type.

Usually there is information within the interface declaration which indicates whether a polymorphic
interface type is numeric or nonnumeric. The optional numeric is required before the type when
the interface type is polymorphic and must be numeric but there is no information in the interface
declaration which would indicate that the type is numeric.

For example, in the following polymorphic interface, count_size must be numeric because it is
deﬁned as a parameter to Bit#().

interface Counter#(type count_size);
    method Action increment();
    method Bit#(count_size) read();

endinterface

From this use, it can be deduced that Counter’s parameter count_size must be numeric. However,
sometimes you might want to encode a size in an interface type which isn’t visible in the methods,
but is used by the module implementing the interface. For instance:

interface SizedBuffer#(numeric type buffer_size, type element_type);
    method Action enq(element_type e);
    method ActionValue#(element_type) deq();

endinterface

26                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                         Reference Guide

In this interface, the depth of the buﬀer is encoded in the type. For instance, SizedBuffer#(8,
Bool) would be a buﬀer of depth 8 with elements of type Bool. The depth is not visible in the
interface, but is used by the module to know how much storage to instantiate.

Because the parameter is not mentioned anywhere else in the interface, there is no information
to determine whether the parameter is a numeric type or a non-numeric type. In this situation,
the default is to assume that the parameter is non-numeric. The user can override this default by
specifying numeric in the interface declaration.

The Standard Prelude deﬁnes a standard interface called Empty which contains no methods, i.e., its
deﬁnition is:

   interface Empty;
   endinterface

This is often used for top-level modules that integrate a testbench and a design-under-test, and for
modules like mkConnection(C.6.2) that just take interface arguments and do not themselves oﬀer
any interesting interface.

5.2.1 Subinterfaces

Note: this is an advanced topic that may be skipped on ﬁrst reading.

Interfaces can also be declared hierarchically, using subinterfaces.

subinterfaceDecl        ::= [ attributeInstances ]
                              interface type identiﬁer ;

where type is another interface type available in the current scope. Example:

interface ILookup;

interface Server#( RequestType, ResponseType )            mif;
                                                          ram;
interface RAMclient#( AddrType, DataType )

method            Bool initialized;

endinterface: ILookup

This declares an interface ILookup module that consists of three members: a Server subinterface
called mif, a RAMClient subinterface called ram, and a boolean method called initialized (the
Server and RAMClient interface types are deﬁned in the libraries, see Appendix C). Methods of
subinterfaces are accessed using dot notation to select the desired component, e.g.,

ilookup.mif.request.put(...);

Since Clock and Reset are both interface types, they can be used in interface declarations. Example:

interface ClockTickIfc ;
    method Action tick() ;
    interface Clock new_clk ;

endinterface

5.3 Module deﬁnition

A module deﬁnition begins with a module header containing the module keyword, the module name,
parameters, arguments, interface type and provisos. The header is followed by zero or more module

                        c 2008 Bluespec, Inc. All rights reserved              27


Reference Guide                                                          Bluespec SystemVerilog

statements. Finally we have the closing endmodule keyword, optionally labelled again with the
module name.

    moduleDef    ::= moduleProto
                             { moduleStmt }

                       endmodule [ : identiﬁer ]

    moduleProto  ::= module [ [ type ] ] identiﬁer
                       [ moduleFormalParams ] ( [ moduleFormalArgs ] ) [ provisos ];

    moduleFormalParams ::= # (moduleFormalParam { , moduleFormalParam })

    moduleFormalParam ::= [ parameter ] type identiﬁer

    moduleFormalArgs ::= type
                                  | type identiﬁer { , type identiﬁer }

As a stylistic convention, many BSV examples use module names like mkFoo, i.e., beginning with
the letters mk, suggesting the word make. This serves as a reminder that a module deﬁnition is not
a module instance. When the module is instantiated, one invokes mkFoo to actually create a module
instance.

The optional moduleFormalParams are exactly as in Verilog and SystemVerilog, i.e., they represent
module parameters that must be supplied at each instantiation of this module, and are resolved at
elaboration time. The optional keyword parameter speciﬁes a Verilog parameter is to be generated;
without the keyword a Verilog port is generated. A Verilog parameter requires that the value is a
constant at elaboration. When the module is instantiated, the actual expression provided for the
parameter must be something that can be computed using normal Verilog elaboration rules. The
bluespec compiler will check for this. The parameter keyword is only relevant when the module is
marked with the *synthesize* attribute.

Inside the module, the parameter keyword can be used for a parameter n that is used, for example,
for constants in expressions, register initialization values, and so on. However, n cannot be used
for structural variations in the module, such as declaring an array of n registers. Such structural
decisions (generate decisions) are taken by the Bluespec compiler, and cannot currently be postponed
into the Verilog.

The optional moduleFormalArgs represent the interfaces used by the module, such as clocks or wires.
The ﬁnal argument is a single interface provided by the module instead of Verilog’s port list. The
interpretation is that this module will deﬁne and oﬀer an interface of that type to its clients. If
the only argument is the interface, only the interface type is required. If there are other arguments,
both a type and an identiﬁer must be speciﬁed for consistency, but the ﬁnal interface name will not
be used in the body. Omitting the interface type completely is equivalent to using the pre-deﬁned
Empty interface type, which is a trivial interface containing no methods.

The arguments and parameters may be enclosed in a single set of parentheses, in which case the #
would be omitted.

Provisos, which are optional, come next. These are part of an advanced feature called type classes
(overloading groups), and are discussed in more detail in Section 14.1.

Examples

A module with parameters and an interface.

module mkFifo#(Int#(8) a) (Fifo);
...
endmodule

A module with arguments and an interface, but no parameters

28               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

module mkSyncPulse (Clock sClkIn, Reset sRstIn,
                               Clock dClkIn,
                               SyncPulseIfc ifc);

...
endmodule

A module deﬁnition with parameters, arguments, and provisos

module mkSyncReg#(a_type initValue)
                          (Clock sClkIn, Reset sRstIn,
                            Clock dClkIn,
                            Reg#(a_type) ifc)

           provisos (Bits#(a_type, sa));
...
endmodule

The above module deﬁnition may also be written with the arguments and parameters combined in
a single set of parentheses.

module mkSyncReg (a_type initValue,
                            Clock sClkIn, Reset sRstIn,
                            Clock dClkIn,
                            Reg#(a_type) ifc)

           provisos (Bits#(a_type, sa));
...
endmodule

The body of the module consists of a sequence of moduleStmts:

moduleStmt              ::= moduleInst
                        | methodDef
                        | subinterfaceDef
                        | rule
                        | &lt;module&gt;If | &lt;module&gt;Case
                        | &lt;module&gt;BeginEndStmt
                        | &lt;module&gt;For
                        | &lt;module&gt;While
                        | varDecl | varAssign
                        | varDo | varDeclDo
                        | functionDef
                        | functionStmt
                        | systemTaskStmt
                        | ( expression )
                        | returnStmt

Most of these are discussed elsewhere since they can also occur in other contexts (e.g., in packages,
function bodies, and method bodies). Below, we focus solely on those statements that are found
only in module bodies or are treated specially in module bodies.

5.4 Module and interface instantiation

Module instances form a hierarchy. A module deﬁnition can contain speciﬁcations for instantiating
other modules, and in the process, instantiating their interfaces. A single module deﬁnition may be
instantiated multiple times within a module.

                        c 2008 Bluespec, Inc. All rights reserved  29


Reference Guide                                                               Bluespec SystemVerilog

5.4.1 Short form instantiation

There is a one-line shorthand for instantiating a module and its interfaces.

    moduleInst    ::= type identiﬁer &lt;- moduleApp ;

    moduleApp     ::= identiﬁer
                       ( [ moduleActualParamArg { , moduleActualParamArg } ] )

    moduleActualParamArg::= expression
                                  | clocked_by expression
                                  | reset_by expression

The statement ﬁrst declares an identiﬁer with an interface type. After the &lt;- symbol, we have a
module application, consisting of a module identiﬁer optionally followed by a list of parameters and
arguments, if the module is deﬁned to have parameters and arguments. Note that the parameters
and the arguments are within a single set of parentheses, the parameters listed ﬁrst, and there is no
# before the list.

Each module has an implicit clock and reset. These defaults can be changed by explicitly specifying
a clocked_by or reset_by argument in the module instantiation.

The following skeleton illustrates the structure and relationships between interface and module
deﬁnition and instantiation.

interface ArithIO#(type a);          //interface type called ArithIO
                                     //parameterized by type a
    method Action input (a x, a y);  //contains 2 methods, input and output

    method a      output;

endinterface: ArithIO

module mkGCD#(int N) (ArithIO#(bit [31:0]));

    ...                              //module definition for mkGCD

    ...                              //one parameter, an integer N

endmodule: mkGCD                     //presents interface of type ArithIO#(bit{31:0])

//declare the interface instance gcdIFC, instantiate the module mkGCD, set N=5
 module mkTest ();
       ...
       ArithIO#(bit [31:0]) gcdIfc &lt;- mkGCD (5, clocked_by dClkIn);
       ...
   endmodule: mkTest

The following example shows an module instantiation using a clocked by statement.

interface Design_IFC;
      method Action start(Bit#(3) in_data1, Bit#(3) in_data2, Bool select);
      interface Clock clk_out;
      method Bit#(4) out_data();

endinterface : Design_IFC

module mkDesign(Clock prim_clk, Clock sec_clk, Design_IFC ifc);
      ...
      RWire#(Bool) select &lt;- mkRWire (select, clocked_by sec_clk);
      ...

endmodule:mkDesign

30                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                         Reference Guide

5.4.2 Long form instantiation

A module instantiation can also be written in its full form on two consecutive lines, as typical
in SystemVerilog. The full form speciﬁes names for both the interface instance and the module
instance. In the shorthand described above, there is no name provided for the module instance
and the compiler infers one based on the interface name. This is often acceptable because module
instance names are only used occasionally in debugging and in hierarchical names.

moduleInst              ::= type identiﬁer ( ) ;
                              moduleApp2 identiﬁer ( [ moduleActualArgs ] ) ;

moduleApp2              ::= identiﬁer [ # ( moduleActualParam { , moduleActualParam } ) ]

moduleActualParam ::= expression

moduleActualArgs ::= moduleActualArg { , moduleActualArg }

moduleActualArg         ::= expression
                        | clocked_by expression
                        | reset_by expression

The ﬁrst line declares an identiﬁer with an interface type. The second line actually instantiates
the module and deﬁnes the interface. The moduleApp2 is the module (deﬁnition) identiﬁer, and
it must be applied to actual parameters (in #(..)) if it had been deﬁned to have parameters.
After the moduleApp, the ﬁrst identiﬁer names the new module instance. This may be followed
by one or more moduleActualArg which deﬁne the arguments being used by the module. The
last identiﬁer (in parentheses) of the moduleActualArg must be the same as the interface identiﬁer
declared immediately above. It may be followed by a clocked_by or reset_by statement.

The following examples show the complete form of the module instantiations of the examples shown
above.

module mkTest ();                   //declares a module mkTest
    ...                             //
    ArithIO#(bit [31:0]) gcdIfc();  //declares the interface instance
    mkGCD#(5) a_GCD (gcdIfc);       //instantiates module mkGCD
    ...                             //sets N=5, names module instance a_GCD
                                    //and interface instance gcdIfc
endmodule: mkTest

module mkDesign(Clock prim_clk, Clock sec_clk, Design_IFC ifc);

...

RWire#(Bool)            select();

mkRWire                 t_select(select, clocked_by sec_clk);

...

endmodule:mkDesign

5.5 Interface deﬁnition (deﬁnition of methods)

A module deﬁnition contains a deﬁnition of its interface. Typically this takes the form of a collection
of deﬁnitions, one for each method in its interface. Each method deﬁnition begins with the keyword
method, followed optionally by the return-type of the method, then the method name, its formal
parameters, and an optional implicit condition. After this comes the method body which is exactly
like a function body. It ends with the keyword endmethod, optionally labelled again with the method
name.

                        c 2008 Bluespec, Inc. All rights reserved              31


Reference Guide                                                   Bluespec SystemVerilog

    moduleStmt         ::= methodDef

    methodDef          ::= method [ type ] identiﬁer ( methodFormals ) [ implicitCond ] ;
                                   functionBody

                             endmethod [ : identiﬁer ]

    methodFormals      ::= methodFormal { , methodFormal }

    methodFormal       ::= [ type ] identiﬁer

    implicitCond       ::= if ( condPredicate )
    condPredicate      ::= exprOrCondPattern { &amp;&amp;&amp; exprOrCondPattern }
    exprOrCondPattern  ::= expression
                       | expression matches pattern

The method name must be one of the methods in the interface whose type is speciﬁed in the module
header. Each of the module’s interface methods must be deﬁned exactly once in the module body.

The compiler will issue a warning if a method is not deﬁned within the body of the module.

The return type of the method and the types of its formal arguments are optional, and are present
for readability and documentation purposes only. The compiler knows these types from the method
prototypes in the interface declaration. If speciﬁed here, they must exactly match the corresponding
types in the method prototype.

The implicit condition, if present, may be a boolean expression, or it may be a pattern-match
(pattern matching is described in Section 10). Expressions in the implicit condition can use any of
the variables in scope surrounding the method deﬁnition, i.e., visible in the module body, but they
cannot use the formal parameters of the method itself. If the implicit condition is a pattern-match,
any variables bound in the pattern are available in the method body. Omitting the implicit condition
is equivalent to saying if (True). The semantics of implicit conditions are discussed in Section 9.13,
on rules.

Every method is ultimately invoked from a rule (a method m1 may be invoked from another method
m2 which, in turn, may be invoked from another method m3, and so on, but if you follow the chain,
it will end in a method invocation inside a rule). A method’s implicit condition controls whether
the invoking rule is enabled. Using implicit conditions, it is possible to write client code that is not
cluttered with conditionals that test whether the method is applicable. For example, a client of a
FIFO module can just call the enqueue or the dequeue method without having explicitly to test
whether the FIFO is full or empty, respectively; those predicates are usually speciﬁed as implicit
conditions attached to the FIFO methods.

Please note carefully that the implicit condition precedes the semicolon that terminates the method
deﬁnition header. There is a very big semantic diﬀerence between the following:

     method ... foo (...) if (expr);
           ...

     endmethod

and

     method ... foo (...); if (expr)
           ...

     endmethod

The only syntactic diﬀerence is the position of the semicolon. In the ﬁrst case, if (expr) is an
implicit condition on the method. In the second case the method has no implicit condition, and if
(expr) starts a conditional statement inside the method. In the ﬁrst case, if the expression is false,
any rule that invokes this method cannot ﬁre, i.e., no action in the rule or the rest of this method

32                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

is performed. In the second case, the method does not prevent an invoking rule from ﬁring, and if
the rule does ﬁre, the conditional statement is not executed but other actions in the rule and the
method may be performed.

The method body is exactly like a function body, which is discussed in Section 8.8 on function
deﬁnitions.

See also Section 9.12 for the more general concepts of interface expressions and expressions as ﬁrst-
class objects.

Example:

interface GrabAndGive;  // interface is declared

method Action grab(Bit#(8) value); // method grab is declared

method Bit#(8) give();  // method give is declared

endinterface

module mkExample (GrabAndGive);
    Reg#(Bit#(8)) value_reg &lt;- mkReg(?);
    Reg#(Bool) not_yet &lt;- mkReg(True);

// method grab is defined
method Action grab(Bit#(8) value) if (not_yet);

    value_reg &lt;= value;
    not_yet &lt;= False;
endmethod

    //method give is defined
    method Bit#(8) give() if (!not_yet);

         return value_reg;
    endmethod
endmodule

5.5.1 Shorthands for Action and ActionValue method deﬁnitions

If a method has type Action, then the following shorthand syntax may be used. Section 9.6 describes
action blocks in more detail.

methodDef               ::= method Action identiﬁer ( methodFormals ) [ implicitCond ] ;
                                    { actionStmt }

                              endmethod [ : identiﬁer ]

i.e., if the type Action is used after the method keyword, then the method body can directly contain
a sequence of actionStmts without the enclosing action and endaction keywords.

Similarly, if a method has type ActionValue(t) (Section 9.7), the following shorthand syntax may
be used:

methodDef               ::= method ActionValue #( type ) identiﬁer ( methodFormals )
                                          [ implicitCond ; ]

                                    { actionValueStmt }
                              endmethod [ : identiﬁer ]

i.e., if the type ActionValue(t) is used after the method keyword, then the method body can
directly contain a sequence of actionStmts without the enclosing actionvalue and endactionvalue
keywords.

Example: The long form deﬁnition of an Action method:

                        c 2008 Bluespec, Inc. All rights reserved                         33


Reference Guide                                                      Bluespec SystemVerilog

    method grab(Bit#(8) value);
         action
               last_value &lt;= value;
         endaction

    endmethod

can be replaced by the following shorthand deﬁnition:

    method Action grab(Bit#(8) value);
         last_value &lt;= value;

    endmethod

5.5.2 Deﬁnition of subinterfaces

Note: this is an advanced topic and can be skipped on ﬁrst reading.

Declaration of subinterfaces (hierarchical interfaces) was described in Section 5.2.1. A subinterface
member of an interface can be deﬁned using the following syntax.

    moduleStmt       ::= subinterfaceDef

    subinterfaceDef  ::= interface Identiﬁer identiﬁer ;
                              { subinterfaceDefStmt }

                           endinterface [ : identiﬁer ]

    subinterfaceDefStmt ::= methodDef | subinterfaceDef

The subinterface member is deﬁned within interface-endinterface brackets. The ﬁrst Identiﬁer
must be the name of the subinterface member’s type (an interface type), without any parame-
ters. The second identiﬁer (and the optional identiﬁer following the endinterface must be the
subinterface member name. The subinterfaceDefStmts then deﬁne the methods or further nested
subinterfaces of this member. Example (please refer to the ILookup interface deﬁned in Section
5.2.1):

module ...
    ...
    ...
    interface Server mif;

           interface Put request;
                 method put(...);
                       ...
                 endmethod: put

           endinterface: request

           interface Get response;
                 method get();
                       ...
                 endmethod: get

           endinterface: response

    endinterface: mif
    ...
endmodule

34                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

5.5.3 Deﬁnition of methods and subinterfaces by assignment

Note: this is an advanced topic and can be skipped on ﬁrst reading.

A method can also be deﬁned using the following syntax.

methodDef               ::= method [ type ] identiﬁer ( methodFormals ) [ implicitCond ]
                                 = expression ;

The part up to and including the implicitCond is the same as the standard syntax shown in Section
5.5. Then, instead of a semicolon, we have an assignment to an expression that represents the
method body. The expression can of course use the method’s formal arguments, and it must have
the same type as the return type of the method. See Sections 9.6 and 9.7 for how to construct
expressions of Action type and ActionValue type, respectively.

A subinterface member can also be deﬁned using the following syntax.

subinterfaceDef         ::= interface [ type ] identiﬁer = expression ;

The identiﬁer is just the subinterface member name. The expression is an interface expression
(described in Section 9.12) of the appropriate interface type.

For example, in the following module the subinterface Put is deﬁned by assignment.

//in this module, there is an instanciated FIFO, and the Put interface
//of the &quot;mkSameInterface&quot; module is the same interface as the fifo’s:

interface IFC1 ;
    interface Put#(int) in0 ;

endinterface

(*synthesize*)
module mkSameInterface (IFC1);

    FIFO#(int) myFifo &lt;- mkFIFO;
    interface Put in0 = fifoToPut(myFifo);
endmodule

5.6 Rules in module deﬁnitions

The internal behavior of a module is described using zero or more rules.

moduleStmt              ::= rule

rule                    ::= [ attributeInstances ]

                        rule identiﬁer [ ruleCond ] ;

                                  ruleBody

                        endrule [ : identiﬁer ]

ruleCond                ::= ( condPredicate )
condPredicate           ::= exprOrCondPattern { &amp;&amp;&amp; exprOrCondPattern }
exprOrCondPattern       ::= expression
                        | expression matches pattern

ruleBody                ::= { actionStmt }

A rule is optionally preceded by an attributeInstances; these are described in Section 13.3. Every
rule must have a name (the identiﬁer ). If the closing endrule is labelled with an identiﬁer, it must
be the same name. Rule names need not be unique, since they do not have any semantic signiﬁcance
and are only used for debugging; however, it is good style (and helps in debugging) to use unique
names.

                        c 2008 Bluespec, Inc. All rights reserved                         35


Reference Guide                                                         Bluespec SystemVerilog

The ruleCond, if present, may be a boolean expression, or it may be a pattern-match (pattern
matching is described in Section 10). It can use any identiﬁers from the scope surrounding the rule,
i.e., visible in the module body. If it is a pattern-match, any variables bound in the pattern are
available in the rule body.

The ruleBody must be of type Action, using a sequence of zero or more actionStmts. We discuss
actionStmts in Section 9.6, but here we make a key observation. Actions include updates to state
elements (including register writes). There are no restrictions on diﬀerent rules updating the same
state elements. The BSV compiler will generate all the control logic necessary for such shared
update, including multiplexing, arbitration, and resource control. The generated control logic will
ensure rule atomicity, discussed brieﬂy in the next paragraphs.

A more detailed discussion of rule semantics is given in Section 6.2, Dynamic Semantics, but we
outline the key point brieﬂy here. The ruleCond is called the explicit condition of the rule. Within
the ruleCond and ruleBody, there may be calls to various methods of various interfaces. Each such
method call has an associated implicit condition. The rule is enabled when its explicit condition and
all its implicit conditions are true. A rule can ﬁre, i.e., execute the actions in its ruleBody, when the
rule is enabled and when the actions cannot “interfere” with the actions in the bodies of other rules.
Non-interference is described more precisely in Section 6.2 but, roughly speaking, it means that the
rule execution can be viewed as an atomic state transition, i.e., there cannot be any race conditions
between this rule and other rules.

This atomicity and the automatic generation of control logic to guarantee atomicity is a key beneﬁt of
BSV. Note that because of method calls in the rule and, transitively, method calls in those methods,
a rule can touch (read/write) state that is distributed in several modules. Thus, a rule can express
a major state change in the design. The fact that it has atomic semantics guarantees the absence of
a whole class of race conditions that might otherwise bedevil the designer. Further, changes in the
design, whether in this module or in other modules, cannot introduce races, because the compiler
will verify atomicity.

See also Section 9.13 for a discussion of the more general concepts of rule expressions and rules as
ﬁrst-class objects.

5.7 Examples

A register is primitive module with the following predeﬁned interface:

interface Reg#(type a);

    method Action _write (a x1);

    method a       _read ();

endinterface: Reg

It is polymorphic, i.e., it can contain values of any type a. It has two methods. The _write()
method takes an argument x1 of type a and returns an Action, i.e., an enable-wire that, when
asserted, will deposit the value into the register. The _read() method takes no arguments and
returns the value that is in the register.

The principal predeﬁned module deﬁnition for a register has the following header:

// takes an initial value for the register
module mkReg#(a v) (Reg#(a)) provisos (Bits#(a, sa));

The module parameter v of type a is speciﬁed when instantiating the module (creating the register),
and represents the initial value of the register. The module deﬁnes an interface of type Reg #(a).
The proviso speciﬁes that the type a must be convertible into an sa-bit value. Provisos are discussed
in more detail in Sections 4.2 and 14.1.

36                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

Here is a module to compute the GCD (greatest common divisor) of two numbers using Euclid’s
algorithm.

interface ArithIO#(type a);

method Action start (a x, a y);

method a                result;

endinterface: ArithIO

module mkGCD(ArithIO#(Bit#(size_t)));

Reg#(Bit#(size_t)) x(); // x is the interface to the register

mkRegU reg_1(x);                 // reg_1 is the register instance

Reg #(Bit#(size_t)) y(); // y is the interface to the register

mkRegU reg_2(y);                 // reg_2 is the register instance

rule flip (x &gt; y &amp;&amp; y != 0);
      x &lt;= y;
      y &lt;= x;

endrule

rule sub (x &lt;= y &amp;&amp; y != 0);
      y &lt;= y - x;

endrule

method Action start(Bit#(size_t) num1, Bit#(size_t) num2) if (y == 0);
      action
            x &lt;= num1;
            y &lt;= num2;
      endaction

endmethod: start

method Bit#(size_t) result() if (y == 0);
      result = x;

endmethod: result

endmodule: mkGCD

The interface type is called ArithIO because it expresses the interactions of modules that do any kind
of two-input, one-output arithmetic. Computing the GCD is just one example of such arithmetic.
We could deﬁne other modules with the same interface that do other kinds of arithmetic.

The module contains two rules, flip and sub, which implement Euclid’s algorithm. In other words,
assuming the registers x and y have been initialized with the input values, the rules repeatedly
update the registers with transformed values, terminating when the register y contains zero. At that
point, the rules stop ﬁring, and the GCD result is in register x. Rule flip uses standard Verilog
non-blocking assignments to express an exchange of values between the two registers. As in Verilog,
the symbol &lt;= is used both for non-blocking assignment as well as for the less-than-or-equal operator
(e.g., in rule sub’s explicit condition), and as usual these are disambiguated by context.

The start method takes two arguments num1 and num2 representing the numbers whose GCD is
sought, and loads them into the registers x and y, respectively. The result method returns the
result value from the x register. Both methods have an implicit condition (y == 0) that prevents
them from being used while the module is busy computing a GCD result.

A test bench for this module might look like this:

                        c 2008 Bluespec, Inc. All rights reserved       37


Reference Guide                                               Bluespec SystemVerilog

module mkTest ();

    ArithIO#(Bit#(32)) gcd;  // declare ArithIO interface gcd

    mkGCD the_gcd (gcd); // instantiate gcd module the_gcd

    rule getInputs;
          ... read next num1 and num2 from file ...
          the_gcd.start (num1, num2); // start the GCD computation

    endrule

    rule putOutput;                                     // print result
           $display(&quot;Output is %d&quot;, the_gcd.result());

    endrule
endmodule: mkTest

The ﬁrst two lines instantiate a GCD module. The getInputs rule gets the next two inputs from
a ﬁle, and then initiates the GCD computation by calling the start method. The putOutput rule
prints the result. Note that because of the semantics of implicit conditions and enabling of rules,
the getInputs rule will not ﬁre until the GCD module is ready to accept input. Similarly, the
putOutput rule will not ﬁre until the output method is ready to deliver a result.3

The mkGCD module is trivial in that the rule conditions ((x &gt; y) and (x &lt;= y)) are mutually
exclusive, so they can never ﬁre together. Nevertheless, since they both write to register y, the
compiler will insert the appropriate multiplexers and multiplexer control logic.

Similarly, the rule getInputs, which calls the start method, can never ﬁre together with the mkGCD
rules because the implicit condition of getInputs, i.e., (y == 0) is mutually exclusive with the
explicit condition (y != 0) in flip and sub. Nevertheless, since getInputs writes into the_gcd’s
registers via the start method, the compiler will insert the appropriate multiplexers and multiplexer
control logic.

In general, many rules may be enabled simultaneously, and subsets of rules that are simultaneously
enabled may both read and write common state. The BSV compiler will insert appropriate schedul-
ing, datapath multiplexing, and control to ensure that when rules ﬁre in parallel, the net state change
is consistent with the atomic semantics of rules.

5.8 Synthesizing Modules

In order to generate code for a BSV design (for either Verilog or Bluesim), it is necessary to indicate
to the complier which module(s) are to be synthesized. A BSV module that is marked for code
generation is said to be a synthesized module.
In order to be synthesizable, a module must meet the following characteristics:

    • The module must be of type Module and not of any other module type that can be deﬁned
       with ModuleCollect;

    • Its interface must be fully speciﬁed; there can be no polymorphic types in the interface;

    • Its interface is a type whose methods and subinterfaces are all convertible to wires (see Section
       5.8.2).

    • All other inputs to the module must be convertible to Bits (see Section 5.8.2).

    3The astute reader will recognize that in this small example, since the result method is initially ready, the test
bench will ﬁrst output a result of 0 before initiating the ﬁrst computation. Let us overlook this by imagining that
Euclid is clearing his throat before launching into his discourse.

38                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

A module can be marked for synthesis in one of two ways.

   1. A module can be annotated with the synthesize attribute (see section 13.1.1). The appro-
       priate syntax is show below.

            (* synthesize *)
            module mkFoo (FooIfc);
            ...
            endmodule

   2. Alternatively, the -g compiler ﬂag can be used on the bsc command line to indicate which
       module is to be synthesized. In order to have the same eﬀect as the attribute syntax shown
       above, the ﬂag would be used with the format -g mkFoo (the appropriate module name follows
       the -g ﬂag).

Note that multiple modules may be selected for code generation (by using multiple synthesize
attributes, multiple -g compiler ﬂags, or a combination of the two).

Separate synthesis of a module can aﬀect scheduling. This is because input wires to the module, such
as method arguments, now become a ﬁxed resource that must be shared, whereas without separate
synthesis, module inlining allows them to be bypassed (eﬀectively replicated). Consider a module
representing a register ﬁle containing 32 registers, with a method read(j) that reads the value of the
j’th register. Inside the module, this just indexes an array of registers. When separately synthesized,
the argument j becomes a 5-bit wide input port, which can only be driven with one value in any
given clock. Thus, two rules that invoke read(3) and read(11), for example, will conﬂict and then
they cannot ﬁre in the same clock. If, however, the module is not separately synthesized, the module
and the read() method are inlined, and then each rule can directly read its target register, so the
rules can ﬁre together in the same clock. Thus, in general, the addition of a synthesis boundary can
restrict behaviors.

5.8.1 Type Polymorphism

As discussed in section 4.1, BSV supports polymorphic types, including interfaces (which are them-
selves types). Thus, a single BSV module deﬁnition, which provides a polymorphic interface, in eﬀect
deﬁnes a family of diﬀerent modules with diﬀerent characteristics based on the speciﬁc parameter(s)
of the polymorphic interface. Consider the module deﬁnition presented in section 5.7.

    module mkGCD (ArithIO#(Bit#(size_t)));
    ...
    endmodule

Based on the speciﬁc type parameter given to the ArithIO interface, the code required to implement
mkGCD will diﬀer. Since the Bluespec compiler does not create ”parameterized” Verilog, in order for
a module to be synthesizable, the associated interface must be fully speciﬁed (i.e not polymorphic).
If the mkGCD module is annotated for code generation as is

    (* synthesize *)
    module mkGCD (ArithIO#(Bit#(size_t)));
    ...
    endmodule

and we then run the compiler, we get the following error message.

                        c 2008 Bluespec, Inc. All rights reserved  39


Reference Guide                                             Bluespec SystemVerilog

    Error: &quot;GCD.bsv&quot;, line 7, column 8: (T0043)
         &quot;Cannot synthesize ‘mkGCD’: Its interface is polymorphic&quot;

If however we instead re-write the deﬁnition of mkGCD such that all the references to the type
parameter size_t are replaced by a speciﬁc value, in other words if we write something like,

    (* synthesize *)
    module mkGCD32 (ArithIO#(Bit#(32)));

         Reg#(Bit#(32)) x(); // x is the interface to the register
         mkRegU reg_1(x); // reg_1 is the register instance

         ...

    endmodule

then the compiler will complete successfully and provide code for a 32-bit version of the module
(called mkGCD32). Equivalently, we can leave the code for mkGCD unchanged and instantiate it inside
another synthesized module which fully speciﬁes the provided interface.

    (* synthesize *)
    module mkGCD32(ArithIO#(Bit#(32)));

         let ifc();
         mkGCD _temp(ifc);
         return (ifc);
    endmodule

5.8.2 Module Interfaces and Arguments
As mentioned above, a module is synthesizable if its interface is convertible to wires.

    • An interface is convertible to wires if all methods and subinterfaces are convertible to wires.

    • A method is convertible to wires if

          – all arguments are convertible to bits;
          – it is an Action method or it is an ActionValue or value method where the return value

             is convertible to bits.

    • Clock, Reset, and Inout subinterfaces are convertible to wires.

    • A Vector interface can be synthesized as long as the type inside the Vector is of type Clock,
       Reset, Inout or a type which is convertible to bits.

To be convertible to bits, a type must be in the Bits typeclass.

For a module to be synthesizable its arguments must be of type Clock, Reset, Inout, or a type
convertible to bits. Vectors of the preceeding types are also synthesizable. If a module has one or
more arguments which are not one of the above types, the module is not synthesizable. For example,
if an argument is a datatype, such as Integer, which is not in the Bits typeclass, then the module
cannot be separately synthesized.

40               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

6 Static and dynamic semantics

What is a legal BSV source text, and what are its legal behaviors? These questions are addressed by
the static and dynamic semantics of BSV. The BSV compiler checks that the design is legal according
to the static semantics, and produces RTL hardware that exhibits legal behaviors according to the
dynamic semantics.

Conceptually, there are three phases in processing a BSV design, just like in Verilog and SystemVer-
ilog:

• Static checking: this includes syntactic correctness, type checking and proviso checking.

• Static elaboration: actual instantiation of the design and propagation of parameters, producing
   the module instance hierarchy.

• Execution: execution of the design, either in a simulator or as real hardware.

We refer to the ﬁrst two as the static phase (i.e., pre-execution), and to the third as the dynamic
phase. Dynamic semantics are about the temporal behavior of the statically elaborated design,
that is, they describe the dynamic execution of rules and methods and their mapping into clocked
synchronous hardware.

A BSV program can also contain assertions; assertion checking can occur in all three phases, de-
pending on the kind of assertion.

6.1 Static semantics

The static semantics of BSV are about syntactic correctness, type checking, proviso checking, static
elaboration and static assertion checking. Syntactic correctness of a BSV design is checked by the
parser in the BSV compiler, according to the grammar described throughout this document.

6.1.1 Type checking

BSV is statically typed, just like Verilog, SystemVerilog, C, C++, and Java. This means the usual
things: every variable and every expression has a type; variables must be assigned values that have
compatible types; actual and formal parameters/arguments must have compatible types, etc. All
this checking is done on the original source code, before any elaboration or execution.

BSV uses SystemVerilog’s new tagged union mechanism instead of the older ordinary unions, thereby
closing oﬀ a certain kind of type loophole. BSV also allows more type parameterization (polymor-
phism), without compromising full static type checking.

6.1.2 Proviso checking and bit-width constraints

In BSV, overloading constraints and bit-width constraints are expressed using provisos (Sections 4.2
and 14.1.1). Overloading constraints provide an extensible mechanism for overloading.

BSV is stricter about bit-width constraints than Verilog and SystemVerilog in that it avoids implicit
zero-extension, sign-extension and truncation of bit-vectors. These operations must be performed
consciously by the designer, using library functions, thereby avoiding another source of potential
errors.

                        c 2008 Bluespec, Inc. All rights reserved  41


Reference Guide                                                     Bluespec SystemVerilog

6.1.3 Static elaboration

As in Verilog and SystemVerilog, static elaboration is the phase in which the design is instantiated,
starting with a top-level module instance, instantiating its immediate children, instantiating their
children, and so on to produce the complete instance hierarchy.

BSV has powerful generate-like facilities for succinctly expressing regular structures in designs. For
example, the structure of a linear pipeline may be expressed using a loop, and the structure of a
tree-structured reduction circuit may be expressed using a recursive function. All these are also
unfolded and instantiated during static elaboration. In fact, the BSV compiler unfolds all structural
loops and functions during static elaboration.

A fully elaborated BSV design consists of no more than the following components:

    • A module instance hierarchy. There is a single top-level module instance, and each module
       instance contains zero or more module instances as children.

    • An interface instance. Each module instance presents an interface to its clients, and may itself
       be a client of zero or more interfaces of other module instances.

    • Method deﬁnitions. Each interface instance consists of zero or more method deﬁnitions.
       A method’s body may contain zero or more invocations of methods in other interfaces.
       Every method has an implicit condition, which can be regarded as a single output wire that
       is asserted only when the method is ready to be invoked. The implicit condition may directly
       test state internal to its module, and may indirectly test state of other modules by invoking
       their interface methods.

    • Rules. Each module instance contains zero or more rules, each of which contains a condition
       and an action. The condition is a boolean expression. Both the condition and the action may
       contain invocations of interface methods of other modules. Since those interface methods can
       themselves contain invocations of other interface methods, the conditions and actions of a rule
       may span many modules.

6.2 Dynamic semantics

The dynamic semantics of BSV specify the temporal behavior of rules and methods and their map-
ping into clocked synchronous hardware.

Every rule has a syntactically explicit condition and action. Both of these may contain invocations
of interface methods, each of which has an implicit condition. A rule’s composite condition consists
of its syntactically explicit condition ANDed with the implicit conditions of all the methods invoked
in the rule. A rule is said to be enabled if its composite condition is true.

6.2.1 Reference semantics

The simplest way to understand the dynamic semantics is through a reference semantics, which is
completely sequential. However, please do not equate this with slow execution; the execution steps
described below are not the same as clocks; we will see in the next section that many steps can be
mapped into each clock. The execution of any BSV program can be understood using the following
very simple procedure:

    Repeat forever:
          Step: Pick any one enabled rule, and perform its action.
          (We say that the rule is ﬁred or executed.)

42               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Note that after each step, a diﬀerent set of rules may be enabled, since the current rule’s action will
typically update some state elements in the system which, in turn, may change the value of rule
conditions and implicit conditions.

Also note that this sequential, reference semantics does not specify how to choose which rule to
execute at each step. Thus, it speciﬁes a set of legal behaviors, not just a single unique behavior.
The principles that determine which rules in a BSV program will be chosen to ﬁre (and, hence, more
precisely constrain its behavior) are described in section 6.2.3.

Nevertheless, this simple reference semantics makes it very easy for the designer to reason about
invariants (correctness conditions). Since only one rule is executed in each step, we only have to
look at the actions of each rule in isolation to check how it maintains or transforms invariants. In
particular, we do not have to consider interactions with other rules executing simultaneously.

Another way of saying this is: each rule execution can be viewed as an atomic state transition.4 Race
conditions, the bane of the hardware designer, can generally be explained as an atomicity violation;
BSV’s rules are a powerful way to avoid most races.

The reference semantics is based on Term Rewriting Systems (TRSs), a formalism supported by
decades of research in the computer science community [Ter03]. For this reason, we also refer to the
reference semantics as “the TRS semantics of BSV.”

6.2.2 Mapping into eﬃcient parallel clocked synchronous hardware

A BSV design is mapped by the BSV compiler into eﬃcient parallel clocked synchronous hardware.
In particular, the mapping permits multiple rules to be executed in each clock cycle. This is done
in a manner that is consistent with the reference TRS semantics, so that any correctness properties
ascertained using the TRS semantics continue to hold in the hardware.

Standard clocked synchronous hardware imposes the following restrictions:

    • Persistent state is updated only once per clock cycle, at a clock edge. During a clock cycle,
       values read from persistent state elements are the ones that were registered in the last cycle.

    • Clock-speed requirements place a limit on the amount of combinational computation that can
       be performed between state elements, because of propagation delay.

The composite condition of each rule is mapped into a combinational circuit whose inputs, possibly
many, sense the current state and whose 1-bit output speciﬁes whether this rule is enabled or not.

The action of each rule is mapped into a combinational circuit that represents the state transition
function of the action. It can have multiple inputs and multiple outputs, the latter being the
computed next-state values.

Figure 1 illustrates a general scheme to compose rule components when mapping the design to clocked
synchronous hardware. The State box lumps together all the state elements in the BSV design (as
described earlier, state elements are explicitly speciﬁed in BSV). The BSV compiler produces a
rule-control circuit which conceptually takes all the enable (cond) signals and all the data (action)
outputs and controls which of the data outputs are actually captured at the next clock in the state
elements. The enable signals feed a scheduler circuit that decides which of the rules will actually
ﬁre. The scheduler, in turn, controls data multiplexers that select which data outputs reach the
data inputs of state elements, and controls which state elements are enabled to capture the new
data values. Firing a rule simply means that the scheduler selects its data output and clocks it into
the next state.

At each clock, the scheduler selects a subset of rules to ﬁre. Not all subsets are legal. A subset is
legal if and only if the rules in the subset can be ordered with the following properties:

    4 We use the term atomic as it is used in concurrency theory (and in operating systems and databases), i.e., to
mean indivisible.

                        c 2008 Bluespec, Inc. All rights reserved  43


Reference Guide                                             Bluespec SystemVerilog

Figure 1: A general scheme for mapping an N-rule system into clocked synchronous hardware.

    • A hypothetical sequential execution of the ordered subset of rules is legal at this point, ac-
       cording to the TRS semantics. In particular, the ﬁrst rule in the ordered subset is currently
       enabled, and each subsequent rule would indeed be enabled when execution reaches it in the
       hypothetical sequence.

       A special case is where all rules in the subset are already currently enabled, and no rule would
       be disabled by execution of prior rules in the order.

    • The hardware execution produces the same net eﬀect on the state as the hypothetical sequential
       execution, even though the hardware execution performs reads and writes in a diﬀerent order
       from the hypothetical sequential execution.

The BSV compiler performs a very sophisticated analysis of the rules in a design and synthesizes an
eﬃcient hardware scheduler that controls execution in this manner.

Note that the scheme in Figure 1 is for illustrative purposes only. First, it lumps together all the
state, shows a single rule-control box, etc., whereas in the real hardware generated by the BSV
compiler these are distributed, localized and modular. Second, it is not the only way to map the
design into clocked synchronous hardware. For example, any two enabled rules can also be executed
in a single clock by feeding the action outputs of the ﬁrst rule into the action inputs of the second
rule, or by synthesizing hardware for a composite circuit that computes the same function as the
composition of the two actions, and so on. In general, these alternative schemes may be more
complex to analyze, or may increase total propagation delay, but the compiler may use them in
special circumstances.

In summary, the BSV compiler performs a detailed and sophisticated analysis of rules and their
interactions, and maps the design into very eﬃcient, highly parallel, clocked synchronous hardware
including a dynamic scheduler that allows many rules to ﬁre in parallel in each clock, but always
in a manner that is consistent with the reference TRS semantics. The designer can use the simple
reference semantics to reason about correctness properties and be conﬁdent that the synthesized
parallel hardware will preserve those properties. (See Section 13.3 for the “scheduling attributes”
mechanism using which the designer can guide the compiler in implementing the mapping.)

When coding in other HDLs, the designer must maintain atomicity manually. He must recognize
potential race conditions, and design the appropriate data paths, control and synchronization to
avoid them. Reasoning about race conditions can cross module boundaries, and can be introduced
late in the design cycle as the problem speciﬁcation evolves. The BSV compiler automates all of this
and, further, is capable of producing RTL that is competitive with hand-coded RTL.

44               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

6.2.3 How rules are chosen to ﬁre

The previous section described how an eﬃcient circuit can be built whose behavior will be consis-
tent with sequential TRS semantics of BSV. However, as noted previously, the sequential reference
semantics can be consistent with a range of diﬀerent behaviors. There are two rule scheduling prin-
ciples that guide the BSV compiler in choosing which rules to schedule in a clock cycle (and help
a designer build circuits with predictable behavior). Except when overridden by an explicit user
command or annotation, the BSV compiler schedules rules according to the following two principles:

   1. Every rule enabled during a clock cycle will either be ﬁred as part of that clock cycle or a
       warning will be issued during compilation.

   2. A rule will ﬁre at most one time during a particular clock cycle.

The ﬁrst principle comes into play when two (or more) rules conﬂict - either because they are
competing for a limited resource or because the result of their simultaneous execution is not consistent
with any sequential rule execution. In the absence of a user annotation, the compiler will arbitrarily
choose 5 which rule to prioritize, but must also issue a warning. This guarantees the designer is
aware of the ambiguity in the design and can correct it. It might be corrected by changing the rules
themselves (rearranging their predicates so they are never simultaneously applicable, for example)
or by adding an urgency annotation which tells the compiler which rule to prefer (see section 13.3.3).
When there are no scheduling warnings, it is guaranteed that the compiler is making no arbitrary
choices about which rules to execute.

The second principle ensures that continuously enabled rules (like a counter increment rule) will
not executed an unpredictable number of time during a clock cycle. According to the ﬁrst rule
scheduling principle, a rule that is always enabled will be executed at least once during a clock
cycle. However, since the rule remains enabled it theoretically could execute multiple times in a
clock cycle (since that behavior would be consistent with a sequential semantics). Since rules (even
simple things like a counter increment) consume limited resources (like register write ports) it is
pragmatically useful to restrict them to executing only once in a cycle (in the absence of speciﬁc
user instructions to the contrary). Executing a continuously enabled rule only once in a cycle is also
the more straightforward and intuitive behavior.

Together, these two principles allow a designer to completely determine the rules that will be chosen
to ﬁre by the schedule (and, hence, the behavior of the resulting circuit).

6.2.4 Mapping speciﬁc hardware models

Annotations on the methods of a module are used by the BSV compiler to model the hardware
behavior into TRS semantics. For example, all reads from a register must be scheduled before any
writes to the same resgister. That is to say, any rule which reads from a register must be scheduled
earlier than any other rule which writes to it. More generally, there exist scheduling constraints for
speciﬁc hardware modules which describe how methods interact within the schedule. The scheduling
annotations describe the constraints enforced by the BSV compiler.

The meanings of the scheduling annotations are:

C   conﬂicts

CF  conﬂict-free

    5The compiler’s choice, while arbitrary, is deterministic. Given the same source and compiler version, the same
schedule (and, hence, the same hardware) will be produced. However, because it is an arbitrary choice, it can be
sensitive to otherwise irrelevant details of the program and is not guaranteed to remain the same if the source or
compiler version changes.

                        c 2008 Bluespec, Inc. All rights reserved  45


Reference Guide                                                           Bluespec SystemVerilog

    SB           sequence before

    SBR          sequence before restricted (cannot be in the same rule)

    SA           sequence after

    SAR          sequence after restricted (cannot be in the same rule)

Below is an example of the scheduling annotations for a register:

                                  Scheduling Annotations
                                            Register

                                         read write

                                  read   CF SB
                                  write  SA SBR

The table describes the following scheduling constraints:

    • Two read methods would be conﬂict-free (CF), that is, you could have multiple methods that
       read from the same register in the same rule, sequenced in any order.

    • A write is sequenced after (SA) a read.
    • A read is sequenced before (SB) a write.
    • And ﬁnally, if you have two write methods, one must be sequenced before the other, and they

       cannot be in the same rule, as indicated by the annotation SBR.

The scheduling annotations are speciﬁc to the TRS model desired and a single hardware component
can have multiple TRS models. For example, a register may be implemented using a mkReg module
or a mkConfigReg module, which are identical except for their scheduling annotations.

7 User-deﬁned types (type deﬁnitions)

User-deﬁned types may appear at the top level of packages.

    typeDef      ::= typedefSynonym
                 | typedefEnum
                 | typedefStruct
                 | typedefTaggedUnion

As a matter of style, BSV requires that all enumerations, structs and unions be declared only via
typedef, i.e., it is not possible directly to declare a variable, formal parameter or formal argument
as an enum, struct or union without ﬁrst giving that type a name using a typedef.

Each typedef of an enum, struct or union introduces a new type that is diﬀerent from all other types.
For example, even if two typedefs give names to struct types with exactly the same corresponding
member names and types, they deﬁne two distinct types.

Other typedefs, i.e., not involving an enum, struct or union, merely introduce type synonyms for
existing types.

7.1 Type synonyms

Type synonyms are just for convenience and readability, allowing one to deﬁne shorter or more
meaningful names for existing types. The new type and the original type can be used interchangeably
anywhere.

46               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

typedefSynonym          ::= typedef type typeDefType ;

typeDefType             ::= typeIde [ typeFormals ]

typeFormals             ::= # ( typeFormal { , typeFormal })

typeFormal              ::= [ numeric ] type typeIde

Examples. Deﬁning names for bit vectors of certain lengths:

typedef bit [7:0] Byte;
typedef bit [31:0] Word;
typedef bit [63:0] LongWord;

Examples. Deﬁning names for polymorphic data types.

typedef Tuple#3(a, a, a) Triple#(type a);
typdef Int#(n) MyInt#(type n);

The above example could also be written as:

typedef Int#(n) MyInt#(numeric type n);

The numeric is not required because the parameter to Int will always be numeric. numeric is only
required when the compiler can’t determine whether the parameter is a numeric or non-numeric
type. It will then default to assuming it is non-numeric. The user can override this default by
specifying numeric in the typedef statement.

A typedef statement can be used to deﬁne a synonym for an already deﬁned synonym. Example:

typedef Triple#(Longword) TLW;

Since an Interface is a type, we can have nested types:

typedef Reg#(Vector#(8, UInt#(8))) ListReg;

typedef List#(List#(Bit#(4)))   ArrayOf4Bits;

7.2 Enumerations

   typedefEnum          ::= enum { typedefEnumElement { , typedefEnumElement    } } Identiﬁer
[ derives ] ;
                        ::= Identiﬁer [ = intLiteral ]
   typedefEnumElement   | Identiﬁer [intLiteral ] [ = intLiteral ]
                        | Identiﬁer [intLiteral :intLiteral ] [ = intLiteral ]

Enumerations (enums) provide a way to deﬁne a set of unique symbolic constants, also called labels or
member names. Each enum deﬁnition creates a new type diﬀerent from all other types. Enum labels
may be repeated in diﬀerent enum deﬁnitions. Enumeration labels must begin with an uppercase
letter.

The optional derives clause is discussed in more detail in Sections 4.3 and 14.1. One common form is
deriving (Bits), which tells the compiler to generate a bit-representation for this enum. Another
common form of the clause is deriving (Eq), which tells the compiler to pick a default equality
operation for these labels, so they can also be tested for equality and inequality. A third common

                        c 2008 Bluespec, Inc. All rights reserved               47


Reference Guide                                             Bluespec SystemVerilog

form is deriving (Bounded), which tells the compiler to deﬁne constants minBound and maxBound
for this type, equal in value to the ﬁrst and last labels in the enumeration. These speciﬁcations can
be combined, e.g., deriving (Bits, Eq, Bounded). All these default choices for representation,
equality and bounds can be overridden (see Section 14.1). The form deriving (Ord) is not currently
supported for enums.

The declaration may specify the encoding used by deriving(Bits) by assigning numbers to tags.
When an assignment is omitted, the tag receives an encoding of the previous tag incremented by one;
when the encoding for the initial tag is omitted, it defaults to zero. Specifying the same encoding
for more than one tag results in an error.

Multiple tags may be declared by using the index (Tag [ntags ]) or range (Tag [start :end ]) no-
tation. In the former case, ntags tags will be generated, from Tag0 to Tagn-1 ; in the latter case,
|end − start| + 1 tags, from Tagstart to Tagend .

Example. The boolean type can be deﬁned in the language itself:

 typedef enum { False, True } Bool deriving (Bits, Eq);

The compiler will pick a one-bit representation, with 1’b0 and 1’b1 as the representations for False
and True, respectively. It will deﬁne the == and != operators to also work on Bool values.
Example. Excerpts from the speciﬁcation of a processor:

 typedef enum { R0, R1, ..., R31 } RegName deriving (Bits);
 typedef RegName Rdest;
 typedef RegName Rsrc;

The ﬁrst line deﬁnes an enum type with 32 register names. The second and third lines deﬁne type
synonyms for RegName that may be more informative in certain contexts (“destination” and “source”
registers). Because of the deriving clause, the compiler will pick a ﬁve-bit representation, with
values 5’h00 through 5’h1F for R0 through R31.

Example. Tag encoding when deriving(Bits) can be speciﬁed manually:

 typedef enum {
    Add = 5,
    Sub = 0,
    Not,
    Xor = 3,
    ...

 } OpCode deriving (Bits);

The Add tag will be encoded to ﬁve, Sub to zero, Not to one, and Xor to three.

Example. A range of tags may be declared in a single clause:

 typedef enum {
    Foo[2],
    Bar[5:7],
    Quux[3:2]

 } Glurph;

This is equivalent to the declaration

48               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

typedef enum {
   Foo0,
   Foo1,
   Bar5,
   Bar6,
   Bar7,
   Quux3,
   Quux2

} Glurph;

7.3 Structs and tagged unions

A struct deﬁnition introduces a new record type.

SystemVerilog has ordinary unions as well as tagged unions, but in BSV we only use tagged unions,
for several reasons. The principal beneﬁt is safety (veriﬁcation). Ordinary unions open a serious
type-checking loophole, whereas tagged unions are completely type-safe. Other reasons are that,
in conjunction with pattern matching (Section 10), tagged unions yield much more succinct and
readable code, which also improves correctness. In the text below, we may simply say “union” for
brevity, but it always means “tagged union.”

typedefStruct           ::= typedef struct {
                                    { structMember }

                              } typeDefType [ derives ] ;

typedefTaggedUnion ::= typedef union tagged {
                                          { unionMember }

                                    } typeDefType [ derives ] ;

structMember            ::= type identiﬁer ;
                        | subUnion identiﬁer ;

unionMember             ::= type Identiﬁer ;
                        | subStruct Identiﬁer ;
                        | subUnion Identiﬁer ;
                        | void Identiﬁer ;

subStruct               ::= struct {
                                    { structMember }

                              }

subUnion                ::= union tagged {
                                    { unionMember }

                              }

typeDefType             ::= typeIde [ typeFormals ]

typeFormals             ::= # ( typeFormal { , typeFormal })

typeFormal              ::= [ numeric ] type typeIde

All types can of course be mutually nested if mediated by typedefs, but unions can also be mutually
nested directly, as described in the syntax above. Structs and unions contain members. A union
member (but not a struct member) can have the special void type (see the types MaybeInt and
Maybe in the examples below for uses of void). All the member names in a particular struct or
union must be unique, but the same names can be used in other structs and members; the compiler
will try to disambiguate based on type.

A struct value contains the ﬁrst member and the second member and the third member, and so on.
A union value contains just the ﬁrst member or just the second member or just the third member,

                        c 2008 Bluespec, Inc. All rights reserved  49


Reference Guide                                             Bluespec SystemVerilog

and so on. Struct member names must begin with a lowercase letter, whereas union member names
must begin with an uppercase letter.

In a tagged union, the member names are also called tags. Tags play a very important safety role.
Suppose we had the following:

 typedef union tagged { int Tagi; OneHot Tagoh; } U deriving (Bits);
 U x;

The variable x not only contains the bits corresponding to one of its member types int or OneHot,
but also some extra bits (in this case just one bit) that remember the tag, 0 for Tagi and 1 for
Tagoh. When the tag is Tagi, it is impossible to read it as a OneHot member, and when the tag is
Tagoh it is impossible to read it as an int member, i.e., the syntax and type checking ensure this.
Thus, it is impossible accidentally to misread what is in a union value.

The optional derives clause is discussed in more detail in Section 14.1. One common form is deriving
(Bits), which tells the compiler to pick a default bit-representation for the struct or union. For
structs it is simply a concatenation of the representations of the members. For unions, the repre-
sentation consists of t + m bits, where t is the minimum number of bits to code for the tags in this
union and m is the number of bits for the largest member. Every union value has a code in the t-bit
ﬁeld that identiﬁes the tag, concatenated with the bits of the corresponding member, right-justiﬁed
in the m-bit ﬁeld. If the member needs fewer than m bits, the remaining bits (between the tag and
the member bits) are undeﬁned.

Struct and union typedefs can deﬁne new, polymorphic types, signalled by the presence of type
parameters in #(...). Polymorphic types are discussed in section 4.1.

Section 9.11 on struct and union expressions describes how to construct struct and union values and
to access and update members. Section 10 on pattern-matching describes a more high-level way to
access members from structs and unions and to test union tags.

Example. Ordinary, traditional record structures:

 typedef struct { int x; int y; } Coord;
 typedef struct { Addr pc; RegFile rf; Memory mem; } Proc;

Example. Encoding instruction operands in a processor:

 typedef union tagged {
       bit [4:0] Register;
       bit [21:0] Literal;
       struct {
              bit [4:0] regAddr;
              bit [4:0] regIndex;
       } Indexed;

 } InstrOperand;

An instruction operand is either a 5-bit register speciﬁer, a 22-bit literal value, or an indexed memory
speciﬁer, consisting of two 5-bit register speciﬁers.

Example. Encoding instructions in a processor:

 typedef union tagged {
      struct {
            Op op; Reg rs; CPUReg rt; UInt16 imm;
      } Immediate;

50               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

      struct {
            Op op; UInt26 target;

      } Jump;
 } Instruction

    deriving (Bits);

An Instruction is either an Immediate or a Jump. In the former case, it contains a ﬁeld, op,
containing a value of type Op; a ﬁeld, rs, containing a value of type Reg; a ﬁeld, rt, containing a
value of type CPUReg; and a ﬁeld, imm, containing a value of type UInt16. In the latter case, it
contains a ﬁeld, op, containing a value of type Op, and a ﬁeld, target, containing a value of type
UInt26.

Example. Optional integers (an integer together with a valid bit):

 typedef union tagged {
       void Invalid;
       int Valid;

 } MaybeInt
    deriving (Bits);

A MaybeInt is either invalid, or it contains an integer (Valid tag). The representation of this type
will be 33 bits— one bit to represent Invalid or Valid tag, plus 32 bits for an int. When it carries
an invalid value, the remaining 32 bits are undeﬁned. It will be impossible to read/interpret those
32 bits when the tag bit says it is Invalid.

This MaybeInt type is very useful, and not just for integers. We generalize it to a polymorphic type:

 typedef union tagged {
       void Invalid;
       a Valid;

 } Maybe#(type a)
    deriving (Bits);

This Maybe type can be used with any type a. Consider a function that, given a key, looks up a
table and returns some value associated with that key. Such a function can return either an invalid
result (Invalid), if the table does not contain an entry for the given key, or a valid result Valid v
if v is associated with the key in the table. The type is polymorphic (type parameter a) because it
may be used with lookup functions for integer tables, string tables, IP address tables, etc. In other
words, we do not over-specify the type of the value v at which it may be used.

See Section 12.4 for an important, predeﬁned set of struct types called Tuples for adhoc structs of
between two and seven members.

8 Variable declarations and statements

Statements can occur in various contexts: in packages, modules, function bodies, rule bodies, action
blocks and actionvalue blocks. Some kinds of statements have been described earlier because they
were speciﬁc to certain contexts: module deﬁnitions (moduleDef ) and instantiation (moduleInst),
interface declarations (interfaceDecl ), type deﬁnitions (typeDef ), method deﬁnitions (methodDef )
inside modules, rules (rule) inside modules, and action blocks (actionBlock ) inside modules.

Here we describe variable declarations, register assignments, variable assignments, loops, and func-
tion deﬁnitions. These can be used in all statement contexts.

                        c 2008 Bluespec, Inc. All rights reserved  51


Reference Guide                                                     Bluespec SystemVerilog

8.1 Variable and array declaration and initialization

Variables in BSV are used to name intermediate values. Unlike Verilog and SystemVerilog, variables
never represent state, i.e., they do not hold values over time. Every variable’s type must be declared,
after which it can be bound to a value one or more times.

One or more variables can be declared by giving the type followed by a comma-separated list of
identiﬁers with optional initializations:

    varDecl        ::= type varInit { , varInit } ;

    varInit        ::= identiﬁer [ arrayDims ] [ = expression ]

    arrayDims      ::= [ expression ] { [ expression ] }

The declared identiﬁer can be an array (when arrayDims is present). The expressions in arrayDims
represent the array dimensions, and must be constant expressions (i.e., computable during static
elaboration). The array can be multidimensional.

Note that array variables are distinct from the RegFile (section C.1.1) and Vector (section C.2)
data types. Array variables are just a structuring mechanism for values, whereas the RegFile type
represents a particular hardware module, like a register ﬁle, with a limited number of read and write
ports. In many programs, array variables are used purely for static elaboration, e.g., an array of
registers is just a convenient way to refer to a collection of registers with a numeric index.

Each declared variable can optionally have an initialization.

Example. Declare two integer variables and initialize them:

Integer x = 16, y = 32;

Example. Declare two array identiﬁers a and b containing int values at each index:

int a[20], b[40];

Example. Declare an array of 3 Int#(5) values and initialize them:

Int#(5) xs[3] = {14, 12, 9};

Example. Declare an array of 3 arrays of 4 Int#(5) values and initialize them:

Int#(5) xs[3][4] = {{1,2,3,4},
                               {5,6,7,8},
                               {9,10,11,12}};

Example. The array values can be polymorphic, but they must deﬁned during elaboration:

Get #(a) gs[3] = {g0,g2, g2};

8.2 Variable assignment

A variable can be bound to a value using assignment:

    varAssign      ::= lValue = expression ;

    lValue         ::= identiﬁer
                   | lValue . identiﬁer
                   | lValue [ expression ]
                   | lValue [ expression : expression ]

The left-hand side (lValue) in its simplest form is a simple variable (identiﬁer ).

Example. Declare a variable wordSize to have type Integer and assign it the value 16:

52                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

 Integer wordSize;
 wordSize = 16;

Multiple assignments to the same variable are just a shorthand for a cascaded computation. Example:

 int x;
 x = 23;
 // Here, x represents the value 23
 x = ifc.meth (34);
 // Here, x represents the value returned by the method call
 x = x + 1;
 // Here, x represents the value returned by the method call, plus 1

Note that these assignments are ordinary, zero-time assignments, i.e., they never represent a dynamic
assignment of a value to a register. These assignments only represent the convenient naming of an
intermediate value in some zero-time computation. Dynamic assignments are always written using
the non-blocking assignment operator &lt;=, and are described in Section 8.4.

In general, the left-hand side (lValue) in an assignment statement can be a series of index- and ﬁeld-
selections from an identiﬁer representing a nesting of arrays, structs and unions. The array-indexing
expressions must be computable during static elaboration.

For bit vectors, the left-hand side (lValue) may also be a range between two indices. The indices must
be computable during static elaboration, and, if the indices are not literal constants, the right-hand
side of the assignment should have a deﬁned bit width. The size of the updated range (determined
by the two literal indices or by the size of the right-hand side) must be less than or equal to the size
of the target bit vector.

Example. Update an array variable b:

b[15] = foo.bar(x);

Example. Update bits 15 to 8 (inclusive) of a bit vector b:

 b[15:8] = foo.bar(x);
Example. Update a struct variable (using the processor example from Section 7.3):

cpu.pc = cpu.pc + 4;

Semantically, this can be seen as an abbreviation for:

cpu = Proc { pc: cpu.pc + 4, rf: cpu.rf, mem: cpu.mem };

i.e., it reassigns the struct variable to contain a new struct value in which all members other than
the updated member have their old values. The right-hand side is a struct expression; these are
described in Section 9.11.

Update of tagged union variables is done using normal assignment notation, i.e., one replaces the
current value in a tagged union variable by an entirely new tagged union value. In a struct it makes
sense to update a single member and leave the others unchanged, but in a union, one member
replaces another. Example (extending the previous processor example):

                        c 2008 Bluespec, Inc. All rights reserved                  53


Reference Guide                                                     Bluespec SystemVerilog

 typedef union tagged {
       bit [4:0] Register;
       bit [21:0] Literal;
       struct {
              bit [4:0] regAddr;
              bit [4:0] regIndex;
       } Indexed;

 } InstrOperand;
 ...
 InstrOperand orand;
 ...
 orand = tagged Indexed { regAddr:3, regIndex:4 };
 ...
 orand = tagged Register 23;

The right-hand sides of the assignments are tagged union expressions; these are described in Section
9.11.

8.3 Implicit declaration and initialization

The let statement is a shorthand way to declare and initialize a variable in a single statement. A
variable which has not been declared can be assigned an initial value and the compiler will infer the
type of the variable from the expression on the right hand side of the statement:

    varDecl          ::= let identiﬁer = expression ;

Example:

    let n = valueof(BuffSize);

The pseudo-function valueof returns an Integer value, which will be assigned to n at compile time.
Thus the variable n is assumed to have the type of Integer.

If the expression is the value returned by an actionvalue method, the notation will be:

    varAssign        ::= let identiﬁer &lt;- expression ;

Note the diﬀerence between this statement:

    let m1 = m1displayfifo.first;

and this statement:

    let z1 &lt;- rndm.get;

In the ﬁrst example, m1displayfifo.first is a value method; m1 is assigned the value and type
returned by the value method. In the latter, rndm.get is an actionvalue method; z1 is assigned the
value and type returned by the actionvalue method.

8.4 Register reads and writes

Register writes occur primarily inside rules and methods.

    regWrite         ::= lValue &lt;= expression
                     | ( expression ) &lt;= expression

54                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

The left-hand side must contain a writeable interface type, such as Reg#(t) (for some type t that
has a representation in bits). It is either an lValue or a parenthesized expression (e.g., the register
interface could be selected from an array of register interfaces or returned from a function). The
right-hand side must have the same type as the left-hand side would have if it were typechecked
as an expression (including read desugaring, as described below). BSV allows only the so-called
non-blocking assignments of Verilog, i.e., the statement speciﬁes that the register gets the new value
at the end of the current cycle, and is only available in the next cycle.

Following BSV’s principle that all state elements (including registers) are module instances, and all
interaction with a module happens through its interface, a simple register assignment r&lt;=e is just a
convenient alternative notation for a method call:

r. write (e)

Similarly, if r is an expression of type Reg#(t), then mentioning r in an expression is just a convenient
alternative notation for diﬀerent method call:

r. read ()

The implicit addition of the . read method call to variables of type Reg#(t) is the simplest example
of read desugaring.

Example. Instantiating a register interface and a register, and using it:

Reg#(int) r();          // create a register interface
mkReg#(0) the_r (r);    // create a register the_r with interface r
...
...                      // Convenient notation for: r._write (r._read() + 1)
rule ...

      r &lt;= r + 1;
endrule

8.4.1 Registers and square-bracket notation

Register writes can be combined with the square-bracket notation.

regWrite                ::= lValue arrayIndexes &lt;= expression

arrayIndexes            ::= [ expression ] { [ expression ] }

There are two diﬀerent ways to interpret this combination. First, it can mean to select a register
out of a collection of registers and write it.

Example. Updating a register in an array of registers:

List#(Reg#(int)) regs;   // increment the register at position 3
...
regs[3] &lt;= regs[3] + 1;

Note that when the square-bracket notation is used on the right-hand side, read desugaring is also
applied6. This allows the expression regs[3] to be interpreted as a register read without unnecessary
clutter.

The indexed register assignment notation can also be used for partial register updates, when the
register contains an array of elements of some type t (in a particular case, this could be an array
of bits). This interpretation is just a shorthand for a whole register update where only the selected
element is updated. In other words,

    6To suppress read desugaring use asReg or asIfc

                         c 2008 Bluespec, Inc. All rights reserved             55


Reference Guide                                                     Bluespec SystemVerilog

x[j] &lt;= v;

can be a shorthand for:

x &lt;= replace (x, j, v);

where replace is a pure function that takes the whole value from register x and produces a whole
new value with the j’th element replaced by v. The statement then assigns this new value to the
register x.

It is important to understand the tool infers the appropriate meaning for an indexed register write
based on the types available and the context:

Reg#(Bit#(32)) x;
x[3] &lt;= e;
List#(Reg#(a)) x;
y[3] &lt;= e;

In the former case, x is a register containing an array of items (in this example a bit vector), so the
statement updates the third item in this array (a single bit) and stores the updated bit vector in
the register. In the latter case, y is an array of registers, so register at position 3 in the array is
updated. In the former case, multiple writes to diﬀerent indices in a single rule with non-exclusive
conditions are forbidden (because they would be multiple conﬂicting writes to the same register)7,
writing the ﬁnal result back to the register. In the latter case, multiple writes to diﬀerent indices
will be allowed, because they are writes to diﬀerent registers (though multiple writes to the same
index, under non-exclusive conditions would not be allowed, of course).

It also is possible to mix these notations, i.e., writing a single statement to perform a partial update
of a register in an array of registers.

Example: Mixing types of square-bracket notation in a register write

List#(Reg#(bit[3:0])) ys;

...

y[4][3] &lt;= e;            // Update bit 3 of the register at position 4

8.4.2 Registers and range notation

Just as there is a range notation for bit extraction and variable assignments, there is also a range
notation for register writes.

    regWrite             ::= lValue [ expression : expression ] &lt;= expression

The index expressions in the range notation follow the same rules as the corresponding expressions
in variable assignment range updates (they must be static expressions and if they are not literal
constants the right-hand side should have a deﬁned bit width). Just as the indexed, partial register
writes described in the previous subsection, multiple range-notation register writes cannot be mixed
in the same rule8.

Example: A range-notation register write

Reg#(Bit#(32)) r;

r[23:12] &lt;= e; // Update a 12-bit range in the middle of r

    7If multiple partial register writes are desired the best thing to do is to assign the register’s value to a variable and
then do cascaded variable assignments (as described in section 8.2)

    8As described in the preceding footnote, using variable assignment is the best way to achive this eﬀect, if desired.

56                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

8.4.3 Registers and struct member selection

regWrite                ::= lValue . identiﬁer &lt;= expression

As with the square-bracket notation, a register update involving a ﬁeld selection can mean one of
two things. First, for a register containing a structure, it means update the particular ﬁeld of the
register value and write the result back to the register.

Example: Updating a register containing a structure

typedef struct { Bit#(32) a; Bit#(16) b; } Foo deriving(Bits);
...
Reg#(Foo) r;
...
r.a &lt;= 17;

Second, it can mean to select the named ﬁeld out of a compile-time structure that contains a register
and write that register.

Example: Writing a register contained in a structure

typedef struct { Reg#(Bit#(32)) c; Reg#(Bit#(16)) d; } Baz;
...
Baz b;
...
b.a &lt;= 23;

In both cases, the same notation is used and the compiler infers which interpretation is appropriate.
As with square-bracket selection, struct member selection implies read desugaring, unless inhibited
by asReg or asIfc.

8.5 Begin-end statements

A begin-end statement is a block that allows one to collect multiple statements into a single state-
ment, which can then be used in any context where a statement is required.

   &lt;ctxt&gt;BeginEndStmt ::= begin [ : identiﬁer ]
                                             { &lt;ctxt&gt;Stmt }

                                       end [ : identiﬁer ]

The optional identiﬁer labels are currently used for documentation purposes only; in the future they
may be used for hierarchical references. The statements contained in the block can contain local
variable declarations and all the other kinds of statements. Example:

module mkBeginEnd#(Bit#(2) sel) ();
    Reg#(Bit#(4)) a &lt;- mkReg(0);
    Reg#(Bool) done &lt;- mkReg(False);

rule decode (!done);    //in the 2’b11 case we don’t want more than
   case (sel)
       2’b00: a &lt;= 0;
       2’b01: a &lt;= 1;
       2’b10: a &lt;= 2;
       2’b11: begin
            a &lt;= 3;

                        c 2008 Bluespec, Inc. All rights reserved    57


Reference Guide                                                            Bluespec SystemVerilog

                 done &lt;= True;  //one action done, therefore we add begin/end
            end
       endcase
    endrule
endmodule

8.6 Conditional statements

Conditional statements include if statements and case statements. An if statement contains a
predicate, a statement representing the true arm and, optionally, the keyword else followed by a
statement representing the false arm.

    &lt;ctxt&gt;If           ::= if ( condPredicate )
                                   &lt;ctxt&gt;Stmt

                             [ else
                                   &lt;ctxt&gt;Stmt ]

    condPredicate      ::= exprOrCondPattern { &amp;&amp;&amp; exprOrCondPattern }

    exprOrCondPattern ::= expression

                       | expression matches pattern

If-statements have the usual semantics— the predicate is evaluated, and if true, the true arm is exe-
cuted, otherwise the false arm (if present) is executed. The predicate can be any boolean expression.
More generally, the predicate can include pattern matching, and this is described in Section 10, on
pattern matching.

There are two kinds of case statements: ordinary case statements and pattern-matching case state-
ments. Ordinary case statements have the following grammar:

    &lt;ctxt&gt;Case         ::= case ( expression )
                                   { &lt;ctxt&gt;CaseItem }
                                   [ &lt;ctxt&gt;DefaultItem ]

                             endcase

    &lt;ctxt&gt;CaseItem     ::= expression { , expression } : &lt;ctxt&gt;Stmt

    &lt;ctxt&gt;DefaultItem ::= default [ : ] &lt;ctxt&gt;Stmt

Each case item contains a left-hand side and a right-hand side, separated by a colon. The left-
hand side contains a series of expressions, separated by commas. The case items may optionally be
followed, ﬁnally, by a default item (the colon after the default keyword is optional).

Case statements are equivalent to an expansion into a series of nested if-then-else statements. For
example:

case (e1)

    e2, e3 : s2;

    e4          : s4;

    e5, e6, e7: s5;

    default : s6;

endcase

is equivalent to:

x1 = e1;         // where x1 is a new variable:
if            (x1 == e2) s2;
else if       (x1 == e3) s2;
else if       (x1 == e4) s4;

58                              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

else if  (x1 == e5) s5;
else if  (x1 == e6) s5;
else if  (x1 == e7) s5;
else
                            s6;

The case expression (e1) is evaluated once, and tested for equality in sequence against the value
of each of the left-hand side expressions. If any test succeeds, then the corresponding right-hand
side statement is executed. If no test succeeds, and there is a default item, then the default item’s
right-hand side is executed. If no test succeeds, and there is no default item, then no right-hand side
is executed.

Example:

module mkConditional#(Bit#(2) sel) ();
    Reg#(Bit#(4)) a &lt;- mkReg(0);
    Reg#(Bool) done &lt;- mkReg(False);

    rule decode ;
       case (sel)
            2’b00: a &lt;= 0;
            2’b01: a &lt;= 1;
            2’b10: a &lt;= 2;
            2’b11: a &lt;= 3;
       endcase

    endrule

    rule finish ;
       if (a == 3)
            done &lt;= True;
       else
            done &lt;= False;

    endrule
endmodule

Pattern-matching case statements are described in Section 10.

8.7 Loop statements

BSV has for loops and while loops.

It is important to note that this use of loops does not express time-based behavior. Instead, they are
used purely as a means to express zero-time iterative computations, i.e., they are statically unrolled
and express the concatenation of multiple instances of the loop body statements. In particular, the
loop condition must be evaluable during static elaboration. For example, the loop condition can
never depend on a value in a register, or a value returned in a method call, which are only known
during execution and not during static elaboration.

See Section 11 on FSMs for an alternative use of loops to express time-based (temporal) behavior.

8.7.1 While loops

&lt;ctxt&gt;While             ::= while ( expression )
                                    &lt;ctxt&gt;Stmt

                        c 2008 Bluespec, Inc. All rights reserved  59


Reference Guide                                                 Bluespec SystemVerilog

While loops have the usual semantics. The predicate expression is evaluated and, if true, the loop
body statement is executed, and then the while loop is repeated. Note that if the predicate initially
evaluates false, the loop body is not executed at all.

Example. Sum the values in an array:

 int a[32];
 int x = 0;
 int j = 0;
 ...
 while (j &lt; 32)

       x = x + a[j];

8.7.2 For loops

    &lt;ctxt&gt;For        ::= for ( forInit ; forTest ; forIncr )
                                 &lt;ctxt&gt;Stmt

    forInit          ::= forOldInit | forNewInit

    forOldInit       ::= simpleVarAssign { , simpleVarAssign }

    simpleVarAssign  ::= identiﬁer = expression

    forNewInit       ::= type identiﬁer = expression { , simpleVarDeclAssign }

    simpleVarDeclAssign ::= [ type ] identiﬁer = expression

    forTest          ::= expression

    forIncr          ::= varIncr { , varIncr }
    varIncr          ::= identiﬁer = expression

The forInit phrase can either initialize previously declared variables (forOldInit), or it can declare
and initialize new variables whose scope is just this loop (forNewInit). They diﬀer in whether or
not the ﬁrst thing after the open parenthesis is a type.

In forOldInit, the initializer is just a comma-separated list of variable assignments.

In forNewInit, the initializer is a comma-separated list of variable declarations and initializations.
After the ﬁrst one, not every initializer in the list needs a type; if missing, the type is the nearest
type earlier in the list. The scope of each variable declared extends to subsequent initializers, the
rest of the for-loop header, and the loop body statement.

Example. Copy values from one array to another:

int a[32], b[32];
...
...
for (int i = 0, j = i+offset; i &lt; 32-offset; i = i+1, j = j+1)

      a[i] = b[j];

8.8 Function deﬁnitions

A function deﬁnition is introduced by the function keyword. This is followed by the type of the
function return-value, the name of the function being deﬁned, the formal arguments, and optional
provisos (provisos are discussed in more detail in Section 14.1). After this is the function body and,
ﬁnally, the endfunction keyword that is optionally labelled again with the function name. Each
formal argument declares an identiﬁer and its type.

60                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

functionDef             ::= functionProto
                                    functionBody

                              endfunction [ : identiﬁer ]

functionProto           ::= function type identiﬁer ( [ functionFormals ] ) [ provisos ] ;

functionFormals         ::= functionFormal { , functionFormal }

functionFormal          ::= type identiﬁer

The function body can contain the usual repertoire of statements:

functionBody            ::= actionBlock
                        | actionValueBlock
                        | { functionBodyStmt }

functionBodyStmt        ::= &lt;functionBody&gt;If | &lt;functionBody&gt;Case
                        | &lt;functionBody&gt;BeginEndStmt
                        | &lt;functionBody&gt;For
                        | &lt;functionBody&gt;While
                        | varDecl | varAssign
                        | varDo | varDeclDo
                        | functionDef
                        | functionStmt
                        | systemTaskStmt
                        | ( expression )
                        | returnStmt

returnStmt              ::= return expression ;

A value can be returned from a function in two ways, as in SystemVerilog. The ﬁrst method is to
assign a value to the function name used as an ordinary variable. This “variable” can be assigned
multiple times in the function body, including in diﬀerent arms of conditionals, in loop bodies, and
so on. The function body is viewed as a traditional sequential program, and value in the special
variable at the end of the body is the value returned. However, the “variable” cannot be used in
an expression (e.g., on the right-hand side of an assignment) because of ambiguity with recursive
function calls.

Alternatively, one can use a return statement anywhere in the function body to return a value
immediately without any further computation. If the value is not explicitly returned nor bound, the
returned value is undeﬁned.

Example. The boolean negation function:

 function Bool notFn (Bool x);
       if (x) notFn = False;
       else notFn = True;

 endfunction: notFn

Example. The boolean negation function, but using return instead:

 function Bool notFn (Bool x);
       if (x) return False;
       else return True;

 endfunction: notFn

Example. The factorial function, using a loop:

                        c 2008 Bluespec, Inc. All rights reserved                           61


Reference Guide                                                    Bluespec SystemVerilog

 function int factorial (int n);
      int f = 1, j = 0;
      while (j &lt; n)
         begin
            f = f * j;
            j = j + 1;
         end
      factorial = f;

 endfunction: factorial

Example. The factorial function, using recursion:

 function int factorial (int n);
      if (n &lt;= 1) return (1);
      else return (n * factorial (n - 1));

 endfunction: factorial

8.8.1 Deﬁnition of functions by assignment

A function can also be deﬁned using the following syntax.

    functionProto       ::= function type identiﬁer ( [ functionFormals ] ) [ provisos ]
                             = expression ;

The part up to and including the provisos is the same as the standard syntax shown in Section 8.8.
Then, instead of a semicolon, we have an assignment to an expression that represents the function
body. The expression can of course use the function’s formal arguments, and it must have the same
type as the return type of the function.

Example 1. The factorial function, using recursion (from above:)

function int factorial (int n) = (n&lt;=1 ? 1 : n * factorial(n-1));

Example 2. Turning a method into a function. The following function deﬁnition:

    function int f1 (FIFO#(int) i);
        return i.first();

    endfunction

could be rewritten as:

function int f2(FIFO#(int) i) = i.first();

8.8.2 Function types

The function type is required for functions deﬁned at the top level of a package and for recursive
functions (such as the factorial examples above). You may choose to leave out the types within a
function deﬁnition at lower levels for non-recursive functions,
If not at the top level of a package, Example 2 from the previous section could be rewritten as:

    function f1(i);
         return i.first();

    endfunction

62                      c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

or, if deﬁning the function by assignment:

 function f1 (i) = i.first();

Note that currently incomplete type information will be ignored. If, in the above example, partial
type information were provided, it would be the same as no type information being provided. This
may cause a type-checking error to be reported by the compiler.

 function int f1(i) = i.first(); // The function type int is specified
                                                     // The argument type is not specified

9 Expressions

Expressions occur on the right-hand sides of variable assignments, on the left-hand and right-hand
side of register assignments, as actual parameters and arguments in module instantiation, function
calls, method calls, array indexing, and so on.

There are many kinds of primary expressions. Complex expressions are built using the conditional
expressions and unary and binary operators.

expression              ::= condExpr
                        | operatorExpr
                        | exprPrimary

exprPrimary             ::= identiﬁer
                        | intLiteral
                        | stringLiteral
                        | systemFunctionCall
                        | ( expression )
                        | · · · see other productions · · ·

9.1 Don’t-care expressions

When the value of an expression does not matter, a don’t-care expression can be used. It is written
with just a question mark and can be used at any type. The compiler will pick a suitable value.

exprPrimary             ::= ?

A don’t-care expression is similar, but not identical to, the x value in Verilog, which represents an
unknown value. A don’t-care expression is unknown to the programmer, but represents a particular
ﬁxed value chosen statically by the compiler.

The programmer is encouraged to use don’t-care values where possible, both because it is useful
documentation and because the compiler can often choose values that lead to better circuits.

Example:

module mkDontCare ();

// instantiating registers where the initial value is &quot;Dontcare&quot;
    Reg#(Bit#(4)) a &lt;- mkReg(?);
    Reg#(Bit#(4)) b &lt;- mkReg(?);

    Bool done = (a==b);
// defining a Variable with an initial value of &quot;Dontcare&quot;

    Bool mybool = ?;
endmodule

                        c 2008 Bluespec, Inc. All rights reserved  63


Reference Guide                                                     Bluespec SystemVerilog

9.2 Conditional expressions

Conditional expressions include the conditional operator and case expressions. The conditional
operator has the usual syntax:

    condExpr       ::= condPredicate ? expression : expression

    condPredicate  ::= exprOrCondPattern { &amp;&amp;&amp; exprOrCondPattern }

    exprOrCondPattern ::= expression
                                  | expression matches pattern

Conditional expressions have the usual semantics. In an expression e1:e2:e3, e1 can be a boolean
expression. If it evaluates to True, then the value of e2 is returned; otherwise the value of e3 is
returned. More generally, e1 can include pattern matching, and this is described in Section 10, on
pattern matching

Example.

module mkCondExp ();

// instantiating registers
    Reg#(Bit#(4)) a &lt;- mkReg(0);
    Reg#(Bit#(4)) b &lt;- mkReg(0);

    rule dostuff;
         a &lt;= (b&gt;4) ? 2 : 10;

    endrule
endmodule

Case expressions are described in Section 10, on pattern matching.

9.3 Unary and binary operators

    operatorExpr   ::= unop expression
                   | expression binop expression

Binary operator expressions are built using the unop and binop operators listed in the following
table, which are a subset of the operators in SystemVerilog. The operators are listed here in order
of decreasing precedence.

64                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                        Reference Guide

             Operator   Associativity  Comments
           +-!~               n/a      Unary: plus, minus, logical not, bitwise invert
                              n/a      Unary: and reduction
                 &amp;            n/a      Unary: nand reduction
                 ~&amp;           n/a      Unary: or reduction
                 |            n/a      Unary: nor reduction
                 ~|           n/a      Unary: xor reduction
                 ^            n/a      Unary: xnor reduction
              ^~ ~^          Left      multiplication, division, modulus
             */%             Left      addition, subtraction
               +-            Left      left and right logical shift
              &lt;&lt; &gt;&gt;          Left      comparison ops
          &lt;= &gt;= &lt; &gt;          Left      equality, inequality
              == !=          Left      bitwise and
                 &amp;           Left      bitwise xor
                 ^           Left      bitwise equivalence
              ^~ ~^          Left      bitwise or
                 |           Left      logical and
                 &amp;&amp;          Left      logical or
                 ||

Constructs that do not have any closing token, such as conditional statements and expressions, have
lowest precedence so that, for example,

e1 ? e2 : e3 + e4

is parsed as follows:

e1 ? e2 : (e3 + e4)

and not as follows:

(e1 ? e2 : e3) + e4

9.4 Bit concatenation and selection

Bit concatenation and selection are expressed in the usual Verilog notation:

exprPrimary             ::= bitConcat | bitSelect

bitConcat               ::= { expression { , expression } }

bitSelect               ::= exprPrimary [ expression [ : expression ] ]

In a bit concatenation, each component must have the type bit[m:0] (m≥0, width m + 1). The
result has type bit[n:0] where n + 1 is the sum of the individual bit-widths (n≥0).

In a bit or part selection, the exprPrimary must have type bit[m:0] (m≥0), and the index expres-
sions must have type bit[31:0]. With a single index ([e]), a single bit is selected, and the output
is of type bit[1:0]. With two indexes ([e1:e2]), e1 must be ≥ e2, and the indexes are inclusive,
i.e., the bits selected go from the low index to the high index, inclusively. The selection has type
bit[k:0] where k + 1 is the width of the selection. Since the index expressions can in general be
dynamic values (e.g., read out of a register), the type-checker may not be able to ﬁgure out this
type, in which case it may be necessary to use a type assertion to tell the compiler the desired result
type (see Section 9.10). The type speciﬁed by the type assertion need not agree with width speciﬁed
by the indexes— the system will truncate from the left (most-signiﬁcant bits) or pad with zeros to
the left as necessary.

Example:

                        c 2008 Bluespec, Inc. All rights reserved                       65


Reference Guide                                                        Bluespec SystemVerilog

    module mkBitConcatSelect ();

          Bit#(3) a = 3’b010;     //a = 010
          Bit#(7) b = 7’h5e;      //b = 1011110

        Bit#(10) abconcat = {a,b}; // = 0101011110
        Bit#(4) bselect = b[6:3]; // = 1011
    endmodule

In BSV programs one will sometimes encounter the Bit#(0) type. One common idiomatic example
is the type Maybe#(Bit#(0)) (see the Maybe#() type in Section 7.3). Here, the type Bit#(0) is just
used as a place holder, when all the information is being carried by the Maybe structure.

9.5 Begin-end expressions

A begin-end expression is like an “inline” function, i.e., it allows one to express a computation using
local variables and multiple variable assignments and then ﬁnally to return a value. A begin-end
expression is analogous to a “let block” commonly found in functional programming languages. It
can be used in any context where an expression is required.

    exprPrimary       ::= beginEndExpr

    beginEndExpr      ::= begin [ : identiﬁer ]
                                  { beginEndExprStmt }
                                  expression

                            end [ : identiﬁer ]

Optional identiﬁer labels are currently used for documentation purposes only. The statements con-
tained in the block can contain local variable declarations and all the other kinds of statements.

    beginEndExprStmt  ::= varDecl | varAssign
                      | functionDef
                      | functionStmt
                      | systemTaskStmt
                      | ( expression )

Example:

int z;                      // x2 is local, x from surrounding scope
z = (begin                  // y2 is local, y from surrounding scope
                            // returned value (sum of squares)
           int x2 = x * x;
           int y2 = y * y;
           (x2 + y2);
       end);

9.6 Actions and action blocks

Any expression that is intended to act on the state of the circuit (at circuit execution time) is called
an action and has type Action. The type Action is special, and cannot be redeﬁned.

Primitive actions are provided as methods in interfaces to predeﬁned objects (such as registers or
arrays). For example, the predeﬁned interface for registers includes a ._write() method of type
Action:

66                          c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

interface Reg#(type a);

method Action _write (a x);

method a               _read ();

endinterface: Reg

Section 8.4 describes special syntax for register reads and writes using non-blocking assignment so
that most of the time one never needs to mention these methods explicitly.

The programmer can create new actions only by building on these primitives, or by using Verilog
modules. Actions are combined by using action blocks:

exprPrimary             ::= actionBlock

actionBlock             ::= action [ : identiﬁer ]
                                    { actionStmt }

                              endaction [ : identiﬁer ]

actionStmt              ::= &lt;action&gt;If | &lt;action&gt;Case
                        | &lt;action&gt;BeginEndStmt
                        | &lt;action&gt;For
                        | &lt;action&gt;While
                        | regWrite
                        | varDecl | varAssign
                        | varDo | varDeclDo
                        | functionStmt
                        | systemTaskStmt
                        | ( expression )
                        | actionBlock

The action block can be labelled with an identiﬁer, and the endaction keyword can optionally be
labelled again with this identiﬁer. Currently this is just for documentation purposes.

Example:

Action a;
a = (action

            x &lt;= x+1;
            y &lt;= z;
       endaction);

The Standard Prelude package deﬁnes the trivial action that does nothing:

Action noAction;

which is equivalent to the expression:

action
endaction

The Action type is actually a special case of the more general type ActionValue, described in the
next section:

typedef ActionValue#(void) Action;

                         c 2008 Bluespec, Inc. All rights reserved         67


Reference Guide                                                  Bluespec SystemVerilog

9.7 Actionvalue blocks

Note: this is an advanced topic and can be skipped on ﬁrst reading.

Actionvalue blocks express the concept of performing an action and simultaneously returning a value.
For example, the pop() method of a stack interface may both pop a value from a stack (the action)
and return what was at the top of the stack (the value). ActionValue is a predeﬁned abstract type:

ActionValue#(a)

The type parameter a represents the type of the returned value. The type ActionValue is special,
and cannot be redeﬁned.

Actionvalues are created using actionvalue blocks. The statements in the block contain the actions
to be performed, and a return statement speciﬁes the value to be returned.

    exprPrimary       ::= actionValueBlock

    actionValueBlock  ::= actionvalue [ : identiﬁer ]
                                  { actionValueStmt }

                            endactionvalue [ : identiﬁer ]

    actionValueStmt   ::= &lt;actionValue&gt;If | &lt;actionValue&gt;Case
                      | &lt;actionValue&gt;BeginEndStmt
                      | &lt;actionValue&gt;For
                      | &lt;actionValue&gt;While
                      | regWrite
                      | varDecl | varAssign
                      | varDo | varDeclDo
                      | functionStmt
                      | systemTaskStmt
                      | ( expression )
                      | returnStmt

Given an actionvalue av, we use a special notation to perform the action and yield the value:

    varDeclDo         ::= type identiﬁer &lt;- expression ;

    varDo             ::= identiﬁer &lt;- expression ;

The ﬁrst rule above declares the identiﬁer, performs the actionvalue represented by the expression,
and assigns the returned value to the identiﬁer. The second rule is similar and just assumes the
identiﬁer has previously been declared.

Example. A stack:

interface IntStack;             push (int x);
      method Action             pop();
      method ActionValue#(int)

endinterface: IntStack

...                             -- A
      IntStack s1;              -- B

...
      IntStack s2;

...
      action
            int x &lt;- s1.pop;
            s2.push (x+1);
      endaction

68                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

In line A, we perform a pop action on stack s1, and the returned value is bound to x. If we wanted
to discard the returned value, we could have omitted the “x &lt;-” part. In line B, we perform a push
action on s2.
Note the diﬀerence between this statement:

       x &lt;- s1.pop;

and this statement:

       z = s1.pop;

In the former, x must be of type int; the statement performs the pop action and x is bound to
the returned value. In the latter, z must be of type Method#(ActionValue#(int)) and z is simply
bound to the method s1.pop. Later, we could say:

       x &lt;- z;

to perform the action and assign the returned value to x. Thus, the = notation simply assigns the
left-hand side to the right-hand side. The &lt;- notation, which is only used with actionvalue right-hand
sides, performs the action and assigns the returned value to the left-hand side.
Example: Using an actionvalue block to deﬁne a pop in a FIFO.

import FIFO :: *;

// Interface FifoWithPop combines first with deq
interface FifoWithPop#(type t);

    method Action enq(t data);
    method Action clear;
    method ActionValue#(t) pop;
endinterface

// Data is an alias of Bit#(8)
typedef Bit#(8) Data;

// The next function makes a deq and first from a fifo and returns an actionvalue block
function ActionValue#(t) fifoPop(FIFO#(t) f) provisos(Bits#(t, st));

    return(
         actionvalue
              f.deq;
              return f.first;
         endactionvalue

    );
endfunction

// Module mkFifoWithPop
(* synthesize, always_ready = &quot;clear&quot; *)
module mkFifoWithPop(FifoWithPop#(Data));

    // A fifo of depth 2
    FIFO#(Data) fifo &lt;- mkFIFO;

    // methods
    method enq = fifo.enq;
    method clear = fifo.clear;
    method pop = fifoPop(fifo);
endmodule

                        c 2008 Bluespec, Inc. All rights reserved  69


Reference Guide                                                 Bluespec SystemVerilog

9.8 Function calls

Function calls are expressed in the usual notation, i.e., a function applied to its arguments, listed in
parentheses. If a function does not have any arguments, the parentheses are optional.

    exprPrimary      ::= functionCall

    functionCall     ::= exprPrimary [ ( [ expression { , expression } ] ) ]

A function which has a result type of Action can be used as a statement when in the appropriate
context.

    functionStmt     ::= functionCall ;

Note that the function position is speciﬁed as exprPrimary, of which identiﬁer is just one special
case. This is because in BSV functions are ﬁrst-class objects, and so the function position can be
an expression that evaluates to a function value. Function values and higher-order functions are
described in Section 14.2.

Example:

module mkFunctionCalls ();

    function Bit#(4) everyOtherBit(Bit#(8) a);
        let result = {a[7], a[5], a[3], a[1]};
        return result;

    endfunction

    function Bool isEven(Bit#(8) b);
        return (b[0] == 0);

    endfunction

    Reg#(Bit#(8)) a  &lt;- mkReg(0);
    Reg#(Bit#(4)) b  &lt;- mkReg(0);

    rule doSomething (isEven(a)); // calling &quot;isEven&quot; in predicate: fire if a is an even number
         b &lt;= everyOtherBit(a); // calling a function in the rule body

    endrule
endmodule

9.9 Method calls

Method calls are expressed by selecting a method from an interface using dot notation, and then
applying it to arguments, if any, listed in parentheses. If the method does not have any arguments
the parentheses are optional.

    exprPrimary      ::= methodCall

    methodCall       ::= exprPrimary . identiﬁer [ ( [ expression { , expression } ] ) ]

The exprPrimary is any expression that represents an interface, of which identiﬁer is just one special
case. This is because in BSV interfaces are ﬁrst-class objects. The identiﬁer must be a method in
the supplied interface. Example:

// consider the following stack interface

interface StackIFC #(type data_t);
    method Action push(data_t data); // an Action method with an argument

70                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

method ActionValue#(data_t) pop(); // an actionvalue method

method data_t first;                       // a value method

endinterface

// when instantiated in a top module

module mkTop ();

StackIFC#(int) stack &lt;- mkStack; // instantiating a stack module

Reg#(int)         counter &lt;- mkReg(0);// a counter register

Reg#(int)         result &lt;- mkReg(0);// a result register

rule pushdata;
    stack.push(counter); // calling an Action method

endrule

rule popdata;            // calling an ActionValue method
    let x &lt;- stack.pop;
    result &lt;= x;

endrule

rule readValue;
    let temp_val = stack.first; // calling a value method

endrule

rule inc_counter;
    counter &lt;= counter +1;

endrule

endmodule

9.10 Static type assertions

We can assert that an expression must have a given type by using Verilog’s “type cast” notation:

exprPrimary             ::= typeAssertion

typeAssertion           ::= type ’ bitConcat
                        | type ’ ( expression )

bitConcat               ::= { expression { , expression } }

In most cases type assertions are used optionally just for documentation purposes. Type assertions
are necessary in a few places where the compiler cannot work out the type of the expression (an
example is a bit-selection with run-time indexes).

In BSV although type assertions use Verilog’s type cast notation, they are never used to change an
expression’s type. They are used either to supply a type that the compiler is unable to determine by
itself, or for documentation (to make the type of an expression apparent to the reader of the source
code).

9.11 Struct and union expressions

Section 7.3 describes how to deﬁne struct and union types. Section 8.1 describes how to declare
variables of such types. Section 8.2 describes how to update variables of such types.

                        c 2008 Bluespec, Inc. All rights reserved                                 71


Reference Guide                                                 Bluespec SystemVerilog

9.11.1 Struct expressions

To create a struct value, e.g., to assign it to a struct variable or to pass it an actual argument for a
struct formal argument, we use the following notation:

    exprPrimary      ::= structExpr

    structExpr       ::= Identiﬁer { memberBind { , memberBind } }

    memberBind       ::= identiﬁer : expression

The leading Identiﬁer is the type name to which the struct type was typedefed. Each memberBind
speciﬁes a member name (identiﬁer ) and the value (expression) it should be bound to. The members
need not be listed in the same order as in the original typedef. If any member name is missing, that
member’s value is undeﬁned.

Semantically, a structExpr creates a struct value, which can then be bound to a variable, passed as
an argument, stored in a register, etc.

Example (using the processor example from Section 7.3):

typedef struct { Addr pc; RegFile rf; Memory mem; } Proc;
...
Proc cpu;

cpu = Proc { pc : 0, rf : ... };

In this example, the mem ﬁeld is undeﬁned since it is omitted from the struct expression.

9.11.2 Struct member selection

A member of a struct value can be selected with dot notation.

    exprPrimary      ::= exprPrimary . identiﬁer

Example (using the processor example from Section 7.3):

cpu.pc

Since the same member name can occur in multiple types, the compiler uses type information to
resolve which member name you mean when you do a member selection. Occasionally, you may
need to add a type assertion to help the compiler resolve this.

Update of struct variables is described in Section 8.2.

9.11.3 Tagged union expressions

To create a tagged union value, e.g., to assign it to a tagged union variable or to pass it an actual
argument for a tagged union formal argument, we use the following notation:

    exprPrimary      ::= taggedUnionExpr

    taggedUnionExpr  ::= tagged Identiﬁer { memberBind { , memberBind } }
                     | tagged Identiﬁer exprPrimary

    memberBind       ::= identiﬁer : expression

The leading Identiﬁer is a member name of a union type, i.e., it speciﬁes which variant of the union
is being constructed.

72                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

The ﬁrst form of taggedUnionExpr can be used when the corresponding member type is a struct.
In this case, one directly lists the struct member bindings, enclosed in braces. Each memberBind
speciﬁes a member name (identiﬁer ) and the value (expression) it should be bound to. The members
do not need to be listed in the same order as in the original struct deﬁnition. If any member name
is missing, that member’s value is undeﬁned.

Otherwise, one can use the second form of taggedUnionExpr , which is the more general notation,
where exprPrimary is directly an expression of the required member type.

Semantically, a taggedUnionExpr creates a tagged union value, which can then be bound to a variable,
passed as an argument, stored in a register, etc.

Example (extending the previous one-hot example):

typedef union tagged { int Tagi; OneHot Tagoh; } U deriving (Bits);
...

   U x; // these lines are (e.g.) in a module body.
   x = tagged Tagi 23;
   ...
   x = tagged Tagoh (encodeOneHot (23));

Example (extending the previous processor example):

typedef union tagged {
      bit [4:0] Register;
      bit [21:0] Literal;
      struct {
            bit [4:0] regAddr;
            bit [4:0] regIndex;
      } Indexed;

} InstrOperand;
...
InstrOperand orand;
...
orand = tagged Indexed { regAddr:3, regIndex:4 };

9.11.4 Tagged union member selection

A tagged union member can be selected with the usual dot notation. If the tagged union value does
not have the tag corresponding to the member selection, the value is undeﬁned. Example:

InstrOperand orand;
...
... orand.Indexed.regAddr ...

In this expression, if orand does not have the Indexed tag, the value is undeﬁned. Otherwise, the
regAddr ﬁeld of the contained struct is returned.

Selection of tagged union members is more often done with pattern matching, which is discussed in
Section 10.

Update of tagged union variables is described in Section 8.2.

                        c 2008 Bluespec, Inc. All rights reserved    73


Reference Guide                                                        Bluespec SystemVerilog

9.12 Interface expressions

Note: this is an advanced topic that may be skipped on ﬁrst reading.

Section 5.2 described top-level interface declarations. Section 5.5 described deﬁnition of the interface
oﬀered by a module, by deﬁning each of the methods in the interface, using methodDef s. That is
the most common way of deﬁning interfaces, but it is actually just a convenient alternative notation
for the more general mechanism described in this section. In particular, method deﬁnitions in a
module are a convenient alternative notation for a return statement that returns an interface value
speciﬁed by an interface expression.

    moduleStmt     ::= returnStmt

    returnStmt     ::= return expression ;

    expression     ::= · · · see other productions · · ·
                   | exprPrimary

    exprPrimary    ::= interfaceExpr

    interfaceExpr  ::= interface Identiﬁer ;
                               { interfaceStmt }

                         endinterface [ : Identiﬁer ]

    interfaceStmt  ::= varDecl | varAssign
                   | methodDef

An interface expression deﬁnes a value of an interface type. The Identiﬁer must be an interface type
in an existing interface type deﬁnition.

Example. Deﬁning the interface for a stack of depth one (using a register for storage):

module mkStack#(type a) (Stack#(a));
   Reg#(Maybe#(a)) r;
   ...
   Stack#(a) stkIfc;
   stkIfc = interface Stack;
                       method push (x) if (r matches tagged Invalid);
                              r &lt;= tagged Valid x;
                       endmethod: push

                       method pop if (r matches tagged Valid .*);
                              r &lt;= tagged Invalid

                       endmethod: pop

                       method top if (r matches tagged Valid .v);
                              return v

                       endmethod: top
                 endinterface: Stack
    return stkIfc;
 endmodule: mkStack

The Maybe type is described in Section 7.3. Note that an interface expression looks similar to an
interface declaration (Section 5.2) except that it does not list type parameters and it contains method
deﬁnitions instead of method prototypes.

Interface values are ﬁrst-class objects. For example, this makes it possible to write interface trans-
formers that convert one form of interface into another. Example:

74                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

interface FIFO#(type a);               // define interface type FIFO

method Action enq (a x);

method Action deq;

method a     first;

endinterface: FIFO

interface Get#(type a);                // define interface type Get
      method ActionValue#(a) get;

endinterface: Get

// Function to transform a FIFO interface into a Get interface

function Get#(a) fifoToGet (FIFO#(a) f);
    return (interface Get
                      method get();
                            actionvalue
                                  f.deq();
                                  return f.first();
                            endactionvalue
                      endmethod: get
                 endinterface);

endfunction: fifoToGet

9.12.1 Diﬀerences between interfaces and structs

Interfaces are similar to structs in the sense that both contain a set of named items—members in
structs, methods in interfaces. Both are ﬁrst-class values—structs are created with struct expressions,
and interfaces are created with interface expressions. A named item is selected from both using the
same notation—struct.member or interface.method.
However, they are diﬀerent in the following ways:

    • Structs cannot contain methods; interfaces can contain nothing but methods (and subinter-
       faces).

    • Struct members can be updated; interface methods cannot.

    • Struct members can be selected; interface methods cannot be selected, they can only be invoked
       (inside rules or other interface methods).

    • Structs can be used in pattern matching; interfaces cannot.

9.13 Rule expressions

Note: This is an advanced topic that may be skipped on ﬁrst reading.

Section 5.6 described deﬁnition of rules in a module. That is the most common way to deﬁne rules,
but it is actually just a convenient alternative notation for the more general mechanism described
in this section. In particular, rule deﬁnitions in a module are a convenient alternative notation for
a call to the built-in addRules() function passing it an argument value of type Rules. Such a value
is in general created using a rule expression. A rule expression has type Rules and consists of a
collection of individual rule constructs.

exprPrimary             ::= rulesExpr

                        c 2008 Bluespec, Inc. All rights reserved     75


Reference Guide                                                      Bluespec SystemVerilog

    rulesExpr        ::= [ attributeInstances ]
                           rules [ : identiﬁer ]
                                 rulesStmt
                           endrules [ : identiﬁer ]

    rulesStmt        ::= varDecl | varAssign
                     | rule

A rule expression is optionally preceded by an attributeInstances; these are described in Section 13.3.
A rule expression is a block, bracketed by rules and endrules keywords, and optionally labelled
with an identiﬁer. Currently the identiﬁer is used only for documentation. The individual rule
construct is described in Section 5.6.

Example. Executing a processor instruction:

rules
   Word instr = mem[pc];

    rule instrExec;

    case (instr) matches

               tagged Add { .r1, .r2, .r3 }: begin

                                              pc &lt;= pc+1;

                                              rf[r1] &lt;= rf[r2] + rf[r3];

                                              end;

               tagged Jz {.r1, .r2}          : if (r1 == 0)

                                              begin

                                                    pc &lt;= r2;

                                              end;

    endcase

    endrule

endrules

Example. Deﬁning a counter:

// IfcCounter with read method

interface IfcCounter#(type t);

    method t     readCounter;

endinterface

// Definition of CounterType
typedef Bit#(16) CounterType;

// The next function returns the rule addOne
function Rules incReg(Reg#(CounterType) a);

   return( rules
      rule addOne;
           a &lt;= a + 1;
      endrule

   endrules);
endfunction

// Module counter using IfcCounter interface
(* synthesize,

76                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

    reset_prefix = &quot;reset_b&quot;,
    clock_prefix = &quot;counter_clk&quot;,
    always_ready, always_enabled *)
module counter (IfcCounter#(CounterType));

    // Reg counter gets reset to 1 asynchronously with the RST signal
    Reg#(CounterType) counter &lt;- mkRegA(1);

    // Add incReg rule to increment the counter
    addRules(incReg(asReg(counter)));

    // Next rule resets the counter to 1 when it reaches its limit
    rule resetCounter (counter == ’1);
    action

       counter &lt;= 0;
    endaction
    endrule

    // Output the counters value
    method CounterType readCounter;

       return counter;
    endmethod

endmodule

10 Pattern matching

Pattern matching provides a visual and succinct notation to compare a value against structs, tagged
unions and constants, and to access members of structs and tagged unions. Pattern matching can be
used in case statements, case expressions, if statements, conditional expressions, rule conditions,
and method conditions.

pattern                 ::= . identiﬁer                                Pattern variable
                        | .*                                                    Wildcard
                        | constantPattern                                       Constant
                        | taggedUnionPattern
                        | structPattern                                   Tagged union
                        | tuplePattern                                              Struct
                                                                                    Tuple

constantPattern         ::= intLiteral
                        | Identiﬁer
                                                                       Enum label

taggedUnionPattern ::= tagged Identiﬁer [ pattern ]

structPattern           ::= tagged Identiﬁer { identiﬁer : pattern { , identiﬁer : pattern } }

tuplePattern            ::= { pattern { , pattern } }

A pattern is a nesting of tagged union and struct patterns with the leaves consisting of pattern
variables, constant expressions, and the wildcard pattern .*.

In a pattern .x, the variable x is declared at that point as a pattern variable, and is bound to the
corresponding component of the value being matched.

A constant pattern is an integer literal, or an enumeration label (such as True or False). Integer
literals can include the wildcard character ? (example: 4’b00??).

                        c 2008 Bluespec, Inc. All rights reserved      77


Reference Guide                                                     Bluespec SystemVerilog

A tagged union pattern consists of the tagged keyword followed by an identiﬁer which is a union
member name. If that union member is not a void member, it must be followed by a pattern for
that member.

In a struct pattern, the Identiﬁer following the tagged keyword is the type name of the struct as
given in its typedef declaration. Within the braces are listed, recursively, the member name and a
pattern for each member of the struct. The members can be listed in any order, and members can
be omitted.

A tuple pattern is enclosed in braces and lists, recursively, a pattern for each member of the tuple
(tuples are described in Section 12.4).

A pattern always occurs in a context of known type because it is matched against an expression of
known type. Recursively, its nested patterns also have known type. Thus a pattern can always be
statically type-checked.

Each pattern introduces a new scope; the extent of this scope is described separately for each of
the contexts in which pattern matching may be used. Each pattern variable is implicitly declared
as a new variable within the pattern’s scope. Its type is uniquely determined by its position in the
pattern. Pattern variables must be unique in the pattern, i.e., the same pattern variable cannot be
used in more than one position in a single pattern.

In pattern matching, the value V of an expression is matched against a pattern. Note that static
type checking ensures that V and the pattern have the same type. The result of a pattern match is:

    • A boolean value, True, if the pattern match succeeds, or False, if the pattern match fails.

    • If the match succeeds, the pattern variables are bound to the corresponding members from V ,
       using ordinary assignment.

Each pattern is matched using the following simple recursive rule:

    • A pattern variable always succeeds (matches any value), and the variable is bound to that
       value (using ordinary procedural assignment).

    • The wildcard pattern .* always succeeds.

    • A constant pattern succeeds if V is equal to the value of the constant. Integer literals can
       include the wildcard character ?. An integer literal containing a wildcard will match any
       constant obtained by replacing each wildcard character by a valid digit. For example, ’h12?4
       will match any constant between ’h1204 and ’h12f4 inclusive.

    • A tagged union pattern succeeds if the value has the same tag and, recursively, if the nested
       pattern matches the member value of the tagged union.

    • A struct or tuple pattern succeeds if, recursively, each of the nested member patterns matches
       the corresponding member values in V . In struct patterns with named members, the textual
       order of members does not matter, and members may be omitted. Omitted members are
       ignored.

Conceptually, if the value V is seen as a ﬂattened vector of bits, the pattern speciﬁes the following:
which bits to match, what values they should be matched with and, if the match is successful, which
bits to extract and bind to the pattern identiﬁers.

78               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

10.1 Case statements with pattern matching

Case statements can occur in various contexts, such as in modules, function bodies, action and
actionValue blocks, and so on. Ordinary case statements are described in Section 8.6. Here we
describe pattern-matching case statements.

&lt;ctxt&gt;Case              ::= case ( expression ) matches
                                    { &lt;ctxt&gt;CasePatItem }
                                    [ &lt;ctxt&gt;DefaultItem ]

                              endcase

&lt;ctxt&gt;CasePatItem ::= pattern { &amp;&amp;&amp; expression } : &lt;ctxt&gt;Stmt

&lt;ctxt&gt;DefaultItem ::= default [ : ] &lt;ctxt&gt;Stmt

The keyword matches after the main expression (following the case keyword) signals that this is a
pattern-matching case statement instead of an ordinary case statement.

Each case item contains a left-hand side and a right-hand side, separated by a colon. The left-hand
side contains a pattern and an optional ﬁlter (&amp;&amp;&amp; followed by a boolean expression). The right-hand
side is a statement. The pattern variables in a pattern may be used in the corresponding ﬁlter and
right-hand side. The case items may optionally be followed, ﬁnally, by a default item (the colon
after the default keyword is optional).

The value of the main expression (following the case keyword) is matched against each case item, in
the order given, until an item is selected. A case item is selected if and only if the value matches the
pattern and the ﬁlter (if present) evaluates to True. Note that there is a left-to-right sequentiality
in each item— the ﬁlter is evaluated only if the pattern match succeeds. This is because the ﬁlter
expression may use pattern variables that are meaningful only if the pattern match succeeds. If none
of the case items matches, and a default item is present, then the default item is selected.

If a case item (or the default item) is selected, the right-hand side statement is executed. Note that
the right-hand side statement may use pattern variables bound on the left hand side. If none of the
case items succeed, and there is no default item, no statement is executed.

Example (uses the Maybe type deﬁnition of Section 7.3):

case (f(a)) matches
      tagged Valid .x : return x;
      tagged Invalid : return 0;

endcase

First, the expression f(a) is evaluated. In the ﬁrst arm, the value is checked to see if it has the form
tagged Valid .x, in which case the pattern variable x is assigned the component value. If so, then
the case arm succeeds and we execute return x. Otherwise, we fall through to the second case arm,
which must match since it is the only other possibility, and we return 0.

Example:

typedef union tagged {
      bit [4:0] Register;
      bit [21:0] Literal;
      struct {
            bit [4:0] regAddr;
            bit [4:0] regIndex;
      } Indexed;

} InstrOperand;
...

                        c 2008 Bluespec, Inc. All rights reserved  79


Reference Guide                                                   Bluespec SystemVerilog

InstrOperand orand;

...

     case (orand) matches

          tagged Register .r                          : x = rf [r];

          tagged Literal .n                           : x = n;

          tagged Indexed {regAddr: .ra, regIndex: .ri} : x = mem[ra+ri];

     endcase

Example:

Reg#(Bit#(16)) rg &lt;- mkRegU;
   rule r;
      case (rg) matches
         ’b_0000_000?_0000_0000: $display(&quot;1&quot;);
         ’o_0?_00: $display(&quot;2&quot;);
         ’h_?_0: $display(&quot;3&quot;);
         default: $display(&quot;D&quot;);
      endcase
   endrule

10.2 Case expressions with pattern matching

    caseExpr         ::= case ( expression ) matches
                                 { caseExprItem }

                           endcase

    caseExprItem     ::= pattern [ &amp;&amp;&amp; expression ] : expression
                     | default [ : ] expression

Case expressions with pattern matching are similar to case statements with pattern matching. In
fact, the process of selecting a case item is identical, i.e., the main expression is evaluated and
matched against each case item in sequence until one is selected. Case expressions can occur in
any expression context, and the right-hand side of each case item is an expression. The whole case
expression returns a value, which is the value of the right-hand side expression of the selected item.
It is an error if no case item is selected and there is no default item.

In contrast, case statements can only occur in statement contexts, and the right-hand side of each
case arm is a statement that is executed for side eﬀect. The diﬀerence between case statements and
case expressions is analogous to the diﬀerence between if statements and conditional expressions.

Example. Rules and rule composition for Pipeline FIFO using case statements with pattern match-
ing.

package PipelineFIFO;

import FIFO::*;

module mkPipelineFIFO (FIFO#(a))
    provisos (Bits#(a, sa));

    // STATE ----------------

    Reg#(Maybe#(a))  taggedReg &lt;- mkReg (tagged Invalid); // the FIFO
    RWire#(a)
    RWire#(Bit#(0))  rw_enq &lt;- mkRWire;               // enq method signal

                     rw_deq &lt;- mkRWire;               // deq method signal

80                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

// RULES and RULE COMPOSITION ----------------

Maybe#(a) taggedReg_post_deq = case (rw_deq.wget) matches
                                                    tagged Invalid : return taggedReg;
                                                    tagged Valid .x : return tagged Invalid;

                                                 endcase;

Maybe#(a) taggedReg_post_enq = case (rw_enq.wget) matches
                                                    tagged Invalid : return taggedReg_post_deq;
                                                    tagged Valid .v : return tagged Valid v;

                                                 endcase;

rule update_final (isValid(rw_enq.wget) || isValid(rw_deq.wget));
      taggedReg &lt;= taggedReg_post_enq;

endrule

10.3 Pattern matching in if statements and other contexts

If statements are described in Section 8.6. As the grammar shows, the predicate (condPredicate)
can be a series of pattern matches and expressions, separated by &amp;&amp;&amp;. Example:

       if ( e1 matches p1 &amp;&amp;&amp; e2 &amp;&amp;&amp; e3 matches p3 )
          stmt1

       else
          stmt2

Here, the value of e1 is matched against the pattern p1; if it succeeds, the expression e2 is evaluated;
if it is true, the value of e3 is matched against the pattern p3; if it succeeds, stmt1 is executed,
otherwise stmt2 is executed. The sequential order is important, because e2 and e3 may use pattern
variables bound in p1, and stmt1 may use pattern variables bound in p1 and p3, and pattern variables
are only meaningful if the pattern matches. Of course, stmt2 cannot use any of the pattern variables,
because none of them may be meaningful when it is executed.

In general the condPredicate can be a series of terms, where each term is either a pattern match
or a ﬁlter expression (they do not have to alternate). These are executed sequentially from left to
right, and the condPredicate succeeds only if all of them do. In each pattern match e matches p, the
value of the expression e is matched against the pattern p and, if successful, the pattern variables are
bound appropriately and are available for the remaining terms. Filter expressions must be boolean
expressions, and succeed if they evaluate to True. If the whole condPredicate succeeds, the bound
pattern variables are available in the corresponding “consequent” arm of the construct.

The following contexts also permit a condPredicate cp with pattern matching:

    • Conditional expressions (Section 9.2):
             cp ? e2 : e3

       The pattern variables from cp are available in e2 but not in e3.

    • Conditions of rules (Sections 5.6 and 9.13):
             rule r (cp);
                ... rule body ...
             endrule

       The pattern variables from cp are available in the rule body.

                        c 2008 Bluespec, Inc. All rights reserved                                81


Reference Guide                                             Bluespec SystemVerilog

    • Conditions of methods (Sections 5.5 and 9.12):
             method t f (...) if (cp);
                ... method body ...
             endmethod

       The pattern variables from cp are available in the method body.

Example. Continuing the Pipeline FIFO example from the previous section (10.2).

 // INTERFACE ----------------

    method Action enq(v) if (taggedReg_post_deq matches tagged Invalid);
         rw_enq.wset(v);

    endmethod

    method Action deq() if (taggedReg matches tagged Valid .v);
         rw_deq.wset(?);

    endmethod

    method first() if (taggedReg matches tagged Valid .v);
         return v;

    endmethod

    method Action clear();
         taggedReg &lt;= tagged Invalid;

    endmethod

endmodule: mkPipelineFIFO

endpackage: PipelineFIFO

10.4 Pattern matching assignment statements

Pattern matching can be used in variable assignments for convenient access to the components of a
tuple or struct value.

    varAssign    ::= match pattern = expression ;

The pattern variables in the left-hand side pattern are declared at this point and their scope extends
to subsequent statements in the same statement sequence. The types of the pattern variables are
determined by their position in the pattern.

The left-hand side pattern is matched against the value of the right-hand side expression. On a
successful match, the pattern variables are assigned the corresponding components in the value.

Example:

    Reg#(Bit#(32)) a &lt;- mkReg(0);
    Tuple2#(Bit#(32), Bool) data;

    rule r1;
        match {.in, .start} = data;
        //using &quot;in&quot; as a local variable
        a &lt;= in;

    endrule

82               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                               Reference Guide

11 Finite state machines

BSV contains a powerful and convenient notation for expressing ﬁnite state machines (FSMs). FSMs
are essentially well-structured processes involving sequencing, parallelism, conditions and loops, with
a precise compositional model of time. In principle, FSMs can be coded with rules, which are strictly
more powerful, but the FSM sublanguage herein provides a succinct notation for FSM structures
and automates all the generation and management of the actual FSM state. In fact, the BSV
compiler translates all the constructs described here internally into rules. In particular, the primitive
statements in these FSMs are standard actions (Section 9.6), obeying all the scheduling semantics
of actions (Section 6.2).

First, one uses the Stmt sublanguage, described in Section C.5.1 to compose the actions of an
FSM using sequential, parallel, conditional and looping structures. This sublanguage is within the
expression syntactic category, i.e., a term in the sublanguage is an expression whose value is of type
Stmt. This value can be bound to identiﬁers, passed as arguments and results of functions, held in
static data structures, etc., like any other value. Finally, the FSM can be instantiated into hardware,
multiple times if desired, by passing the Stmt value to the module constructor mkFSM. The resulting
module interface has type FSM, which has methods to start the FSM and to wait until it completes.

In order to use this sublanguage, it is necessary to import the StmtFSM package, which is described
in more detail in Section C.5.1.

12 Important primitives

These primitives are available via the Standard Prelude package and other standard libraries. See
also Appendix C more useful libraries.

12.1 The types bit and Bit

The type bit[m:0] and its synonym Bit#(Mplus1) represents bit-vectors of width m + 1, provided
the type Mplus1 has been suitably deﬁned. The lower (lsb) index must be zero. Example:

bit [15:0] zero;
zero = 0

typedef bit [50:0] BurroughsWord;

Syntax for bit concatenation and selection is described in Section 9.4.
There is also a useful function, split, to split a bit-vector into two sub-vectors:

function Tuple2#(Bit#(m), Bit#(n)) split (Bit#(mn) xy)
    provisos (Add#(m,n,mn));

It takes a bit-vector of size mn and returns a 2-tuple (a pair, see Section 12.4) of bit-vectors of size
m and n, respectively. The proviso expresses the size constraints using the built-in Add type class.

The function split is polymorphic, i.e, m and n may be diﬀerent in diﬀerent applications of the func-
tion, but each use is fully type-checked statically, i.e., the compiler veriﬁes the proviso, performing
any calculations necessary to do so.

                        c 2008 Bluespec, Inc. All rights reserved                    83


Reference Guide                                                  Bluespec SystemVerilog

12.1.1 Bit-width compatibility

BSV is currently very strict about bit-width compatibility compared to Verilog and SystemVerilog,
in order to reduce the possibility of unintentional errors. In BSV, the types bit[m:0] and bit[n:0]
are compatible only if m = n. For example, an attempt to assign from one type to the other, when
m=n, will be reported by the compiler as a type-checking error—there is no automatic padding or
truncation. The Standard Prelude package (see Section B) contains functions such as extend() and
truncate(), which may be used explicitly to extend or truncate to a required bit-width. These
functions, being overloaded over all bit widths, are convenient to use, i.e., you do not have to
constantly calculate the amount by which to extend or truncate; the type checker will do it for you.

12.2 UInt, Int, int and Integer

The types UInt#(n) and Int#(n), respectively, represent unsigned and signed integer data types of
width n bits. These types have all the operations from the type classes (overloading groups) Bits,
Literal, Eq, Arith, Ord, Bounded, Bitwise, BitReduction, and BitExtend. (See Appendix B for
the speciﬁcations of these type classes and their associated operations.)

Note that the types UInt and Int are not really primitive; they are deﬁned completely in BSV.

The type int is just a synonym for Int#(32).

The type Integer represents unbounded integers. Because they are unbounded, they are only used
to represent static values used during static elaboration. The overloaded function fromInteger
allows conversion from an Integer to various other types.

12.3 String

The type String is deﬁned in the Standard Prelude package (B.2.7). Strings are mostly used in
system tasks (such as $display). Strings can be concatenated using the strConcat function, and
they can be tested for equality and inequality using the == and != operators. String literals, written
in double-quotes, are described in Section 2.5.

12.4 Tuples

It is frequently necessary to group a small number of values together, e.g., when returning multiple
results from a function. Of course, one could deﬁne a special struct type for this purpose, but BSV
predeﬁnes a number of structs called tuples that are convenient:

typedef struct {a _1; b _2;} Tuple2#(type a, type b) deriving (Bits,Eq,Bounded);

typedef          ...          Tuple3#(type a, type b, type c) ...;

typedef          ...          ...  ...;

typedef          ...          Tuple7#(type a, ..., type g) ...;

Values of these types can be created by applying a predeﬁned family of constructor functions:

tuple2 (e1, e2)
tuple3 (e1, e2, e3)
...
tuple7 (e1, e2, e3, ..., e7)

where the expressions eJ evaluate to the component values of the tuples.
Components of tuples can be extracted using a predeﬁned family of selector functions:

84                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

 tpl_1 (e)
 tpl_2 (e)
 ...
 tpl_7 (e)

where the expression e evaluates to tuple value. Of course, only the ﬁrst two are applicable to
Tuple2 types, only the ﬁrst three are applicable to Tuple3 types, and so on.
In using a tuple component selector, it is sometimes necessary to use a static type assertion to help
the compiler work out the type of the result. Example:

 UInt#(6)’(tpl_2 (e))

Tuple components are more conveniently selected using pattern matching. Example:

 Tuple2#(int, Bool) xy;
 ...

      case (xy) matches
            { .x, .y } : ... use x and y ...

      endcase

12.5 Registers

The most elementary module available in BSV is the register (B.4), which has a Reg interface.
Registers are instantiated using the mkReg module, whose single parameter is the initial value of the
register. Registers can also be instantiated using the mkRegU module, which takes no parameters
(don’t-care initial value). The Reg interface type and the module types are shown below.

interface Reg#(type a);

method Action _write (a x);

method a                _read;

endinterface: Reg

module mkReg#(a initVal) (Reg#(a))
    provisos (Bits#(a, sa));

module mkRegU (Reg#(a))
    provisos (Bits#(a, sa));

Registers are polymorphic, i.e., in principle they can hold a value of any type but, of course, ulti-
mately registers store bits. Thus, the provisos on the modules indicate that the type must be in the
Bits type class (overloading group), i.e., the operations pack() and unpack() must be deﬁned on
this type to convert into to bits and back.

Section 8.4 describes special notation whereby one rarely uses the _write() and _read methods
explicitly. Instead, one more commonly uses the traditional non-blocking assignment notation for
writes and, for reads, one just mentions the register interface in an expression.

Since mentioning the register interface in an expression is shorthand for applying the _read method,
BSV also provides a notation for overriding this implicit read, producing an expression representing
the register interface itself:

asReg (r)

                         c 2008 Bluespec, Inc. All rights reserved  85


Reference Guide                                                    Bluespec SystemVerilog

Since it is also occasionally desired to have automatically read interfaces that are not registers, BSV
also provides a notation for more general suppression of read desugaring, producing an expression
that always represents an interface itself:

       asIfc(ifc)

12.6 FIFOs

Package FIFO (C.1.2) deﬁnes several useful interfaces and modules for FIFOs:

interface FIFO#(type a);

    method Action enq (a x);

    method Action deq;

    method a        first;

    method Action clear;

endinterface: FIFO

module mkFIFO (FIFO#(a))
      provisos (Bits#(a, as));

module mkSizedFIFO#(Integer depth) (FIFO#(a))
      provisos (Bits#(a, as));

The FIFO interface type is polymorphic, i.e., the FIFO contents can be of any type a. However,
since FIFOs ultimately store bits, the content type a must be in the Bits type class (overloading
group); this is speciﬁed in the provisos for the modules.

The module mkFIFO leaves the capacity of the FIFO unspeciﬁed (the number of entries in the FIFO
before it becomes full).

The module mkSizedFIFO takes the desired capacity of the FIFO explicitly as a parameter.

Of course, when compiled, mkFIFO will pick a particular capacity, but for formal veriﬁcation purposes
it is useful to leave this undetermined. It is often useful to be able to prove the correctness of a design
without relying on the capacity of the FIFO. Then the choice of FIFO depth can only aﬀect circuit
performance (speed, area) and cannot aﬀect functional correctness, so it enables one to separate the
questions of correctness and “performance tuning.” Thus, it is good design practice initially to use
mkFIFO and address all functional correctness questions. Then, if performance tuning is necessary,
it can be replaced with mkSizedFIFO.

12.7 FIFOFs

Package FIFOF (C.1.2) deﬁnes several useful interfaces and modules for FIFOs. The FIFOF interface
is like FIFO, but it also has methods to test whether the FIFO is full or empty:

interface FIFOF#(type a);

    method Action enq (a x);

    method Action deq;

    method a        first;

    method Action clear;

    method Bool notFull;

    method Bool notEmpty;

endinterface: FIFOF

86                      c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

 module mkFIFOF (FIFOF#(a))
      provisos (Bits#(a, as));

 module mkSizedFIFOF#(Integer depth) (FIFOF#(a))
      provisos (Bits#(a, as));

The module mkFIFOF leaves the capacity of the FIFO unspeciﬁed (the number of entries in the FIFO
before it becomes full). The module mkSizedFIFOF takes the desired capacity of the FIFO as an
argument.

12.8 System tasks and functions

BSV supports a number of Verilog’s system tasks and functions. There are two types of system tasks;
statements which are conceptually equivalent to Action functions, and calls which are conceptually
equivalent to ActionValue and Value functions. Calls can be used within statements.

systemTaskStmt          ::= systemTaskCall ;

12.8.1 Displaying information

systemTaskStmt          ::= displayTaskName ( [ expression [ , expression ] ] );

displayTaskName         ::= $display | $displayb | $displayo | $displayh
                        | $write | $writeb | $writeo | $writeh

These system task statements are conceptually function calls of type Action, and can be used in
any context where an action is expected.

The only diﬀerence between the $display family and the $write family is that members of the
former always output a newline after displaying the arguments, whereas members of the latter do
not.

The only diﬀerence between the ordinary, b, o and h variants of each family is the format in which
numeric expressions are displayed if there is no explicit format speciﬁer. The ordinary $display
and $write will output, by default, in decimal format, whereas the b, o and h variants will output
in binary, octal and hexadecimal formats, respectively.

There can be any number of argument expressions between the parentheses. The arguments are
displayed in the order given. If there are no arguments, $display just outputs a newline, whereas
$write outputs nothing.

The argument expressions can be of type String, Bit#(n) (i.e., of type bit[n-1:0]), Integer,
or any type that is a member of the overloading group Bits. Members of Bits will display their
packed representation. The output will be interpreted as a signed number for the types Integer
and Int#(n). Arguments can also be literals. Integers and literals are limited to 32 bits.

Arguments of type String are interpreted as they are displayed. The characters in the string are
output literally, except for certain special character sequences beginning with a % character, which
are interpreted as format-speciﬁers for subsequent arguments. The following format speciﬁers are
supported9:

%d  Output a number in decimal format

%b  Output a number in binary format

%o  Output a number in octal format

    9Displayed strings are passed through the compiler unchanged, so other format speciﬁers may be supported by
your Verilog simulator. Only the format speciﬁers above are supported by Bluespec’s C-based simulator.

                        c 2008 Bluespec, Inc. All rights reserved                 87


Reference Guide                                                       Bluespec SystemVerilog

    %h           Output a number in hexadecimal format

    %c           Output a character with given ASCII code

    %s           Output a string (argument must be a string)

    %t           Output a number in time format

    %m           Output hierarchical name

The values output are sized automatically to the largest possible value, with leading zeros, or in the
case of decimal values, leading spaces. The automatic sizing of displayed data can be overridden
by inserting a value n indicating the size of the displayed data. If n=0 the output will be sized to
minimum needed to display the data without leading zeros or spaces.

ActionValues (see Section 9.7) whose returned type is displayable can also be directly displayed.
This is done by performing the associated action (as part of the action invoking $display) and
displaying the returned value.

Example:

$display (&quot;%t&quot;, $time);

For display statements in diﬀerent rules, the outputs will appear in the usual logical scheduling order
of the rules. For multiple display statements within a single rule, technically there is no deﬁned
ordering in which the outputs should appear, since all the display statements are Actions within
the rule and technically all Actions happen simultaneously in the atomic transaction. However, as
a convenience to the programmer, the compiler will arrange for the display outputs to appear in
the normal textual order of the source text, taking into accout the usual ﬂow around if-then-elses,
statically elaborated loops, and so on. However, for a rule that comprises separately compiled parts
(for example, a rule that invokes a method in a separately compiled module), the system cannot
guarantee the ordering of display statements across compilation boundaries. Within each separately
compiled part, the display outputs will appear in source text order, but these groups may appear in
any order. In particular, veriﬁcation engineers should be careful about these benign (semantically
equivalent) reorderings when checking the outputs for correctness.

12.8.2 $format

    systemTaskCall  ::= $format ( [ expression [ , expression ] ] )

Bluespec also supports $format, a display related system task that does not exist in Verilog. $format
takes the same arguments as the $display family of system tasks. However, unlike $display (which
is a function call of type Action), $format is a value function which returns an object of type Fmt
(section B.2.8). Fmt representations of data objects can thus be written hierarchically and applied
to polymorphic types. The FShow package, described in Section C.7.8, deﬁnes a typeclass based on
this capability.

Example:

typedef struct {OpCommand command;

          Bit#(8) addr;

          Bit#(8) data;

          Bit#(8) length;

          Bool      lock;

          } Header deriving (Eq, Bits, Bounded);

88                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

function Fmt fshow (Header value);
      return ($format(&quot;&lt;HEAD &quot;)
            +
            fshow(value.command)
            +
            $format(&quot; (%0d)&quot;, value.length)
            +
            $format(&quot; A:%h&quot;, value.addr)
            +
            $format(&quot; D:%h&gt;&quot;, value.data));

endfunction

12.8.3 File data type

File is a deﬁned type in BSV which is deﬁned as:
      typedef union tagged {
            void InvalidFile ;
            Bit#(31) MCD;
            Bit#(31) FD;
      } File;

                          Type Classes for File

Bits Eq Literal Arith Ord Bounded Bitwise                            Bit  Bit

           √√                                                 √      Reduction Extend
File

Note: Bitwise operations are valid only for sub-type MCD.

12.8.4 Opening and closing ﬁle operations

systemTaskCall          ::= $fopen ( ﬁleName [ , ﬁleType ] )

systemTaskStmt          ::= $fclose ( ﬁleIdentiﬁer ) ;

The $fopen system call is of type ActionValue and can be used anywhere an ActionValue is
expected. The argument ﬁleName is of type String. $fopen returns a ﬁleIdentiﬁer of type File. If
there is a ﬁleType argument, the ﬁleIdentiﬁer returned is a ﬁle descriptor of type FD. If there is not
a ﬁleType argument, the ﬁleIdentiﬁer returned is a multi channel descriptor of type MCD.

One ﬁle of type MCD is pre-opened for append, stdout_mcd (value 1).

Three ﬁles of type FD are pre-opened; they are stdin (value 0), stdout (value 1), and stderr (value
2). stdin is pre-opened for reading and stdout and stderr are pre-opened for append.

The fileType determines, according to the following table, how other ﬁles of type FD are opened:

Argument                  File Types for File Descriptors
&quot;r&quot; or &quot;rb&quot;
&quot;w&quot; or &quot;wb&quot;               Description
&quot;a&quot; or &quot;ab&quot;               open for reading
&quot;r+&quot;, or &quot;r+b&quot;, or &quot;rb+&quot;  truncate to zero length or create for writing
&quot;w+&quot;, or &quot;w+b&quot;, or &quot;wb+&quot;  append; open for writing at end of ﬁle, or create for writing
&quot;a+&quot;, or &quot;a+b&quot;, or &quot;ab+&quot;  open for update (reading and writing)
                          truncate or create for update
                          append; open or create for update at end of ﬁle

                          c 2008 Bluespec, Inc. All rights reserved                    89


Reference Guide                                                      Bluespec SystemVerilog

The $fclose system call is of type Action and can be used in any context where an action is
expected.

12.8.5 Writing to a ﬁle

    systemTaskStmt  ::= ﬁleTaskName ( ﬁleIdentiﬁer , [ expression [ , expression ] ] ) ;

    ﬁleTaskName     ::= $fdisplay | $fdisplayb | $fdisplayo | $fdisplayh
                    | $fwrite | $fwriteb | $fwriteo | $fwriteh

These system task calls are conceptually function calls of type Action, and can be used in any
context where an action is expected. They correspond to the display tasks ($display, $write)
but they write to speciﬁc ﬁles instead of to the standard output. They accept the same arguments
(Section 12.8.1) as the tasks they are based on, with the addition of a ﬁrst parameter ﬁleIdentiﬁer
which indicates where to direct the ﬁle output.

Example:

    Reg#(int) cnt &lt;- mkReg(0);
    let fh &lt;- mkReg(InvalidFile) ;
    let fmcd &lt;- mkReg(InvalidFile) ;

    rule open (cnt == 0 ) ;

    // Open the file and check for proper opening

    String dumpFile = &quot;dump_file1.dat&quot; ;

    File lfh &lt;- $fopen( dumpFile, &quot;w&quot; ) ;

    if ( lfh == InvalidFile )

          begin

             $display(&quot;cannot open %s&quot;, dumpFile);

             $finish(0);

          end

    cnt &lt;= 1 ;

    fh &lt;= lfh ;                // Save the file in a Register

    endrule

    rule open2 (cnt == 1 ) ;

    // Open the file and check for proper opening

    // Using a multi-channel descriptor.

    String dumpFile = &quot;dump_file2.dat&quot; ;

    File lmcd &lt;- $fopen( dumpFile ) ;

    if ( lmcd == InvalidFile )

          begin

             $display(&quot;cannot open %s&quot;, dumpFile );

             $finish(0);

          end

    lmcd = lmcd | stdout_mcd ; // Bitwise operations with File MCD

    cnt &lt;= 2 ;

    fmcd &lt;= lmcd ;              // Save the file in a Register

    endrule

    rule dump (cnt &gt; 1 );                     // Writes to dump_file1.dat
        $fwrite( fh , &quot;cnt = %0d\n&quot;, cnt);    // Writes to dump_file2.dat
        $fwrite( fmcd , &quot;cnt = %0d\n&quot;, cnt);  // and stdout
        dump_file2.dat
        cnt &lt;= cnt + 1;

    endrule

90                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                            Reference Guide

12.8.6 Formatting output to a string

systemTaskStmt          ::= stringTaskName ( ifcIdentiﬁer , [ expression [ , expression ] ] ) ;

stringTaskName          ::= $swrite | $swriteb | $swriteo | $swriteh | $sformat

These system task calls are analogous to the $fwrite family of system tasks. They are conceptually
function calls of type Action, and accept the same type of arguments as the corresponding $fwrite
tasks, except that the ﬁrst parameter must now be an interface with an _write method that takes
an argument of type Bit#(n).

The task $sformat is similar to $swrite, except that the second argument, and only the second
argument, is interpreted as a format string. This format argument can be a static string, or it
can be a dynamic value whose content is interpreted as the format string. No other arguments in
$sformat are interpreted as format strings. $sformat supports all the format speciﬁes supported
by $display, as documented in 12.8.1.

The Bluespec compiler de-sugars each of these task calls into a call of an ActionValue version of
the same task. For example:

          $swrite(foo, &quot;The value is %d&quot;, count);

de-sugars to

            let x &lt;- $swriteAV(&quot;The value is %d&quot;, count);
            foo &lt;= x;

An ActionValue value version is available for each of these tasks. The associated syntax is given
below.

systemTaskCall          ::= stringAVTaskName ( [ expression [ , expression ] ] )

stringAVTaskName ::= $swriteAV | $swritebAV | $swriteoAV | $swritehAV | $sformatAV

The ActionValue versions of these tasks can also be called directly by the user.

Use of the system tasks described in this section allows a designer to populate state elements with
dynamically generated debugging strings. These values can then be viewed using other display tasks
(using the %s format speciﬁer) or output to a VCD ﬁle for examination in a waveform viewer.

12.8.7 Reading from a ﬁle

systemTaskCall          ::= $fgetc ( ﬁleIdentiﬁer )

systemTaskStmt          ::= $ungetc ( expression, ﬁleIdentiﬁer ) ;

The $fgetc system call is a function of type ActionValue#(int) which returns an int from the ﬁle
speciﬁed by ﬁleIdentiﬁer.

The $ungetc system statement is a function of type Action which inserts the character speciﬁed by
expression into the buﬀer speciﬁed by ﬁleIdentiﬁer.

Example:

rule open ( True ) ;
    String readFile = &quot;gettests.dat&quot;;
    File lfh &lt;- $fopen(readFile, &quot;r&quot; ) ;

int i &lt;- $fgetc( lfh );
if ( i != -1 )

    begin

                        c 2008 Bluespec, Inc. All rights reserved                 91


Reference Guide                                                    Bluespec SystemVerilog

                  Bit#(8) c = truncate( pack(i) ) ;
             end
        else // an error occurred.
             begin

                  $display( &quot;Could not get byte from %s&quot;,
                       readFile ) ;

             end

        $fclose ( lfh ) ;
        $finish(0);
    endrule

12.8.8 Flushing output

    systemTaskStmt  ::= $fflush ( [ ﬁleIdentiﬁer ] ) ;

The system call $fflush is a function of type Action and can be used in any context where an
actions is expected. The $fflush function writes any buﬀered output to the ﬁle(s) speciﬁed by the
ﬁleIdentiﬁer. If no argument is provided, $fflush writes any buﬀered output to all open ﬁles.

12.8.9 Stopping simulation

   systemTaskStmt   ::= $finish [ ( expression ) ] ; systemTaskStmt  ::= $stop [
( expression ) ] ;

These system task calls are conceptually function calls of type Action, and can be used in any
context where an action is expected.

The $finish task causes simulation to stop immediately and exit back to the operating system. The
$stop task causes simulation to suspend immediately and enter an interactive mode. The optional
argument expressions can be 0, 1 or 2, and control the verbosity of the diagnostic messages printed
by the simulator. the default (if there is no argument expression) is 1.

12.8.10 VCD dumping

    systemTaskStmt  ::= $dumpvars | $dumpon | $dumpoff ;

These system task calls are conceptually function calls of type Action, and can be used in any
context where an action is expected.

A call to $dumpvars starts dumping the changes of all the state elements in the design to the
VCD ﬁle. BSV’s $dumpvars does not currently support arguments that control the speciﬁc module
instances or levels of hierarchy that are dumped.

Subsequently, a call to $dumpoff stops dumping, and a call to $dumpon resumes dumping.

12.8.11 Time functions

   systemFunctionCall ::= $time | $stime
These system function calls are conceptually of ActionValue type (see Section 9.7), and can be used
anywhere an ActionValue is expected. The time returned is the time when the associated action
was performed.

The $time function returns a 64-bit integer (speciﬁcally, of type Bit#(64)) representing time, scaled
to the timescale unit of the module that invoked it.

92                      c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

The $stime function returns a 32-bit integer (speciﬁcally, of type Bit#(32)) representing time,
scaled to the timescale unit of the module that invoked it. If the actual simulation time does not ﬁt
in 32 bits, the lower-order 32 bits are returned.

12.8.12 Real functions

There are two system tasks deﬁned for the Real data type (section B.2.6), used to convert between
Real and IEEE standard 64-bit vector representation, $realtobits and $bitstoreal. They are
identical to the Verilog functions.

systemTaskCall          ::= $realtobits ( expression )

systemTaskCall          ::= $bitstoreal ( expression )

12.8.13 Testing command line input

Information for use in simulation can be provided on the command line. This information is spec-
iﬁed via optional arguments in the command used to invoke the simulator. These arguments are
distinguished from other simulator arguments by starting with a plus (+) character and are therefore
known as plusargs. Following the plus is a string which can be examined during simulation via
system functions.

systemTaskCall          ::= $test$plusargs ( expression )

The $test$plusargs system function call is conceptually of ActionValue type (see Section 9.7),
and can be used anywhere an ActionValue is expected. An argument of type String is expected
and a boolean value is returned indicating whether the provided string matches the beginning of any
plusarg from the command line.

13 Guiding the compiler with attributes

This section describes how to guide the compiler in some of its decisions using BSV’s attribute
syntax.

attributeInstances      ::= attributeInstance
                              { attributeInstance }

attributeInstance       ::= (* attrSpec { , attrSpec } *)

attrSpec                ::= attrName [ = expression ]

attrName                ::= identiﬁer |Identiﬁer

Multiple attributes can be written together on a single line

(* synthesize, always_ready = &quot;read, subifc.enq&quot; *)

Or attributes can be written on multiple lines

(* synthesize *)
(* always_ready = &quot;read, subifc.enq&quot; *)

Attributes can be associated with a number of diﬀerent language constructs such as module, interface,
and function deﬁnitions. A given attribute declaration is applied to the ﬁrst attribute construct that
follows the declaration.

                        c 2008 Bluespec, Inc. All rights reserved  93


Reference Guide                                                 Bluespec SystemVerilog

13.1 Verilog module generation attributes

In addition to compiler ﬂags on the command line, it is possible to guide the compiler with attributes
that are included in the BSV source code.

The attributes synthesize and noinline control code generation for top-level modules and func-
tions, respectively.

                 Attribute name      Section  Top-level module  Top-level function
                                                  deﬁnitions         deﬁnitions
                        synthesize    13.1.1            √
                           noinline   13.1.2                              √

13.1.1 synthesize

When the compiler is directed to generate Verilog or Bluesim code for a BSV module, by default it
tries to integrate all deﬁnitions into one big module. The synthesize attribute marks a module for
code generation and ensures that, when generated, instantiations of the module are not ﬂattened but
instead remain as references to a separate module deﬁnition. Modules that are annotated with the
synthesize attribute are said to be synthesized modules. The BSV hierarchy boundaries associated
with synthesized modules are maintained during code generation. Not all BSV modules can be
synthesized modules (i.e.,can maintain a module boundary during code generation). Section 5.8
describes in more detail which modules are synthesizable.

13.1.2 noinline

The noinline attribute is applied to functions, instructing the compiler to generate a separate
module for the function. This module is instantiated as many times as required by its callers. When
used in complicated calling situations, the use of the noinline attribute can simplify and speed up
compilation. The noinline attribute can only be applied to functions that are deﬁned at the top
level and the inputs and outputs of the function must be in the typeclass Bits.

Example:

 (* noinline *)
 function Bit#(LogK) popCK(Bit#(K) x);

    return (popCountTable(x));
 endfunction: popCK

13.2 Interface attributes

Interface attributes express protocol and naming requirements for generated Verilog interfaces. They
are considered during generation of the Verilog module which uses the interface. These attributes
can be applied to synthesized modules, methods, interfaces, and subinterfaces at the top level only.
If the module is not synthesized, the attribute is ignored. The following table shows which attributes
can be applied to which elements. These attributes cannot be applied to Clock, Reset, or Inout
subinterface declarations.

94               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

Attribute name     Section  Synthesized    Interface    Methods of     Subinterfaces of
                              module          type     interface type   interface type
          ready=    13.2.1                              declarations     declarations
         enable=    13.2.1  deﬁnitions   declarations
          result=   13.2.1                                    √                 √
          preﬁx=    13.2.1        √            √              √
                    13.2.1        √            √              √                 √
            port=   13.2.2                                    √                 √
   always ready     13.2.2                                    √
always enabled                                                √
                                                              √

There is a direct correlation between interfaces in Bluespec and ports in the generated Verilog. These
attributes can be applied to interfaces to control the naming and the protocols of the generated
Verilog ports.

Bluespec uses a simple Ready-Enable micro-protocol for each method within the module’s interface.
Each method contains both a output Ready (RDY) signal and an input Enable (EN) signal in
addition to any needed directional data lines. When a method can be safely called it asserts its
RDY signal. When an external caller sees the RDY signal it may then call (in the same cycle) the
method by asserting the method’s EN signal and providing any required data.

Generated Verilog ports names are based the method name and argument names, with some standard
preﬁxes. In the ActionValue method method1 shown below

method ActionValue#( type_out ) method1 ( type_in data_in ) ;

the following ports are generated:

RDY_method1                         Output ready signal of the protocol
EN_method1                          Input signal for Action and Action Value methods
method1                             Output signal of ActionValue and Value methods
method1_data_in                     Input signal for method arguments

Interface attributes allow control over the naming and protocols of individual methods or entire
interfaces.

13.2.1 Renaming attributes

ready= and enable= Ready and enable ports use RDY_ and EN_ as the default preﬁx to the
method names. The attributes ready= ”string” and enable= ”string” replace the preﬁx annotation
and method name with the speciﬁed string as the name instead. These attributes may be associated
with method declarations (methodProto) only (Section 5.2).

In the above example, the following attribute would replace the RDY_method1 with avMethodIsReady
and EN_method1 with GO.

(* ready = &quot;avMethodIsReady&quot;, enable = &quot;GO&quot; *)

Note that the ready= attribute is ignored if the method or module is annotated as always_ready
or always_enabled, while the enable= attribute is ignored for value methods as those are annotated
as always_enabled.

                        c 2008 Bluespec, Inc. All rights reserved                        95


Reference Guide                                             Bluespec SystemVerilog

result= By default the output port for value methods and ActionValue methods use the method
name. The attribute result = ”string” causes the output to be renamed to the speciﬁed string. This
is useful when the desired port names must begin with an upper case letter, which is not valid for
a method name. These attributes may be associated with method declarations (methodProto) only
(Section 5.2).

In the above example, the following attribute would replace the method1 port with OUT.

(* result = &quot;OUT&quot; *)

Note that the result= attribute is ignored if the method is an Action method which does not
return a result.

preﬁx= and port= By default, the input ports for methods are named by using the name of the
method as the preﬁx and the name of the method argument as the suﬃx, into method_argument.
The preﬁx and/or suﬃx name can be replaced by the attributes prefix= ”string” and port= ”string”.
By combining these attributes any desired string can be generated. The prefix= attribute replaces
the method name and the port= attribute replaces the argument name in the generated Verilog port
name. The preﬁx string may be empty, in which case the joining underscore is not added.

The prefix= attribute may be associated with method declarations (methodProto) or sub-interface
declarations (subinterfaceDecl). The port= attribute may be associated with each method prototype
argument in the interface declaration (methodProtoFormal ) (Section 5.2).

In the above example, the following attribute would replace the method1_data_in port with IN_DATA.

(* prefix = &quot;&quot; *)
    method ActionValue#( type_out )
            method1( (* port=&quot;IN_DATA&quot; *) type_in data_in ) ;

Note that the prefix= attribute is ignored if the method does not have any arguments.

The prefix= attribute may also be used on sub-interface declarations to aid the renaming of interface
hierarchies. By default, interface hierarchies are named by preﬁxing the sub-interface name to names
of the methods within that interface (Section 5.2.1.) Using the prefix attribute on the subinterface
is a way of replacing the sub-interface name. This is demonstrated in the example in Section 13.2.3.

13.2.2 Port protocol attributes

The port protocol attributes always_enabled and always_ready remove unnecessary ports. In all
cases the compiler veriﬁes that the attributes are correctly applied.

The attribute always_enabled speciﬁes that no enable signal will be generated for the associated
interface methods. The methods will be executed on every clock cycle and the compiler veriﬁes that
the caller does this.

The attribute always_ready speciﬁes that no ready signals will be generated. The compiler veriﬁes
that the associated interface methods are permanently ready. always_enabled implies always_ready.

The always_ready and always_enabled attributes can be associated with the method declara-
tions (methodProto), the sub-interface declarations (subinterfaceDecl), or the interface declaration
(interfaceDecl) itself. In these cases, the attribute does not take any arguments. Example:

interface Test;
    (* always_enabled *)
    method ActionValue#(Bool) check;

endinterface: Test

96               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

The attributes can also be associated with a module, in which case the attribute can have as an
argument the list of methods to which the attribute is applied. When associated with a module, the
attributes are applied when the interface is implemented by a module, not at the declaration of the
interface. Example:

interface ILookup;                   //the definition of the interface
      interface Fifo#(int) subifc;
      method Action read ();

endinterface: ILookup

(* always_ready = &quot;read, subifc.enq&quot; * )//the attribute is applied when the

module mkServer (ILookup);           //interface is implemented within

...                                  //a module.

endmodule: mkServer

In this example, note that only the enq method of the subifc interface is always_ready. Other
methods of the interface, such as deq, are not always_ready.

If every method of the interface is always_ready or always_enabled, individual methods don’t have
to be speciﬁed when applying the attribute to a module. Example:

(* always_enabled *)
module mkServer (ILookup);

13.2.3 Interface attributes example

(* always_ready *)                   // all methods in this and all sub-interface
                                     // have this property
interface ILookup;                   // always_enabled is also allowed here
      (* prefix = &quot;&quot; *)
      interface Fifo#(int) subifc;   // subifc_ will not be used in naming
                                     // always_enabled and always_ready are allowed.

(* enable = &quot;GOread&quot; *)              // EN_read becomes GOread
method Action read ();
(* always_enabled *)                 // always_enabled and always_ready
                                     // are allowed on any individual method
(* result = &quot;CHECKOK&quot; *)             // output checkData becomes CHECKOK
(* prefix = &quot;&quot; *)                    // checkData_datain1 becomes DIN1
                                     // checkData_datain2 becomes DIN2
method ActionValue#(Bool)   checkData ( (* port= &quot;DIN1&quot; *) int datain1

                                               (* port= &quot;DIN2&quot; *) int datain2 ) ;

endinterface: ILookup

                        c 2008 Bluespec, Inc. All rights reserved                  97


Reference Guide                                                           Bluespec SystemVerilog

13.3 Scheduling attributes

                      Attribute name     Section   Module        rule        rules
                                                  deﬁnitions  deﬁnitions  expressions
                   ﬁre when enabled       13.3.1
              no implicit conditions      13.3.2       √           √            √
                                          13.3.3       √           √            √
                 descending urgency       13.3.4       √           √            √
                      execution order     13.3.5       √           √            √
                                          13.3.6       √           √            √
                  mutually exclusive      13.3.7                   √
                           conﬂict free                            √
                               preempts

Scheduling attributes are used to express certain performance requirements. When the compiler
maps rules into clocks, as described in Section 6.2.2, scheduling attributes guide or constrain its
choices, in order to produce a schedule that will meet performance goals.

Scheduling attributes are most often attached to rules or to rule expressions, but some can also be
added to module deﬁnitions.

The scheduling attributes are are only applied when the module is synthesized.

13.3.1 fire_when_enabled

The fire_when_enabled scheduling attribute immediately precedes a rule (just before the rule
keyword) and governs the rule.

It asserts that this rule must ﬁre whenever its predicate and its implicit conditions are true, i.e.,
when the rule conditions are true, the attribute checks that there are no scheduling conﬂicts with
other rules that will prevent it from ﬁring. This is statically veriﬁed by the compiler. If the rule
won’t ﬁre, the compiler will report an error.

Example. Using fire_when_enabled to ensure the counter is reset:

// IfcCounter with read method

interface IfcCounter#(type t);

    method t  readCounter;

endinterface

// Definition of CounterType
typedef Bit#(16) CounterType;

// Module counter using IfcCounter interface. It never contains 0.

(* synthesize,
    reset_prefix = &quot;reset_b&quot;,
    clock_prefix = &quot;counter_clk&quot;,
    always_ready = &quot;readCounter&quot;,
    always_enabled= &quot;readCounter&quot; *)

module counter (IfcCounter#(CounterType));
    // Reg counter gets reset to 1 asynchronously with the RST signal
    Reg#(CounterType) counter &lt;- mkRegA(1);

    // Next rule resets the counter to 1 when it reaches its limit.

98            c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

    // The attribute fire_when_enabled will check that this rule will fire
    // if counter == ’1
    (* fire_when_enabled *)
    rule resetCounter (counter == ’1);

       counter &lt;= 1;
    endrule

    // Next rule updates the counter.
    rule updateCounter;

       counter &lt;= counter + 1;
    endrule

    // Method to output the counter’s value
    method CounterType readCounter;

       return counter;
    endmethod
endmodule

Rule resetCounter conﬂicts with rule updateCounter because both try to modify the counter
register when it contains all its bits set to one. If the rule updateCounter is more urgent, only the
rule updateCounter will ﬁre. In this case, the assertion fire_when_enabled will be violated and
the compiler will produce an error message. Note that without the assertion fire_when_enabled
the compilation process will be correct.

13.3.2 no_implicit_conditions

The no_implicit_conditions scheduling attribute immediately precedes a rule (just before the
rule keyword) and governs the rule.

It asserts that the implicit conditions of all interface methods called within the rule must always
be true; only the explicit rule predicate controls whether the rule can ﬁre or not. This is statically
veriﬁed by the compiler, and it will report an error if necessary.

Example:

// Import the FIFO package
import FIFO :: *;

// IfcCounter with read method

interface IfcCounter#(type t);

method t      readCounter;

method Action setReset(t a);

endinterface

// Definition of CounterType
typedef Bit#(16) CounterType;

// Module counter using IfcCounter interface
(* synthesize,

    reset_prefix = &quot;reset_b&quot;,
    clock_prefix = &quot;counter_clk&quot;,
    always_ready = &quot;readCounter&quot;,
    always_enabled = &quot;readCounter&quot; *)
module counter (IfcCounter#(CounterType));

                        c 2008 Bluespec, Inc. All rights reserved  99


Reference Guide                                                      Bluespec SystemVerilog

     // Reg counter gets reset to 1 asynchronously with the RST signal
     Reg#(CounterType) counter &lt;- mkRegA(1);

     // The 4 depth valueFifo contains a list of reset values
     FIFO#(CounterType) valueFifo &lt;- mkSizedFIFO(4);

     /* Next rule increases the counter with each counter_clk rising edge

     if the maximum has not been reached                                   */

     (* no_implicit_conditions *)

     rule updateCounter;

     if (counter != ’1)

     counter &lt;= counter + 1;

     endrule

     // Next rule resets the counter to a value stored in the valueFifo
     (* no_implicit_conditions *)
     rule resetCounter (counter == ’1);

        counter &lt;= valueFifo.first();
        valueFifo.deq();
     endrule

     // Output the counters value
     method CounterType readCounter;

        return counter;
     endmethod

    // Update the valueFifo
    method Action setReset(CounterType a);

       valueFifo.enq(a);
    endmethod
endmodule

The assertion no_implicit_conditions is incorrect for the rule resetCounter, resulting in a com-
pilation error. This rule has the implicit condition in the FIFO module due to the fact that the deq
method cannot be invoked if the ﬁfo valueFifo is empty. Note that without the assertion no error
will be produced and that the condition if (counter != ’1) is not considered an implicit one.

13.3.3 descending_urgency

The compiler maps rules into clocks, as described in Section 6.2.2. In each clock, amongst all the
rules that can ﬁre in that clock, the system picks a subset of rules that do not conﬂict with each
other, so that their parallel execution is consistent with the reference TRS semantics. The order in
which rules are considered for selection can aﬀect the subset chosen. For example, suppose rules r1
and r2 conﬂict, and both their conditions are true so both can execute. If r1 is considered ﬁrst and
selected, it may disqualify r2 from consideration, and vice versa. Note that the urgency ordering is
independent of the TRS ordering of the rules, i.e., the TRS ordering may be r1 before r2, but either
one could be considered ﬁrst by the compiler.

The designer can specify that one rule is more urgent than another, so that it is always considered
for scheduling before the other. The relationship is transitive, i.e., if rule r1 is more urgent than
rule r2, and rule r2 is more urgent than rule r3, then r1 is considered more urgent than r3.

Urgency is speciﬁed with the descending_urgency attribute. Its argument is a string containing a
comma-separated list of rule names (see Section 5.6 for rule syntax, including rule names). Example:

100                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

       (* descending_urgency = &quot;r1, r2, r3&quot; *)

This example speciﬁes that r1 is more urgent than r2 which, in turn, is more urgent than r3.
If urgency attributes are contradictory, i.e., they specify both that one rule is more urgent than
another and its converse, the compiler will report an error. Note that such a contradiction may
be a consequence of a collection of urgency attributes, because of transitivity. One attribute may
specify r1 more urgent than r2, another attribute may specify r2 more urgent than r3, and another
attribute may specify r3 more urgent than r1, leading to a cycle, which is a contradiction.
The descending_urgency attribute can be placed in one of three syntactic positions:

    • It can be placed just before the module keyword in a module deﬁnitions (Section 5.3), in which
       case it can refer directly to any of the rules inside the module.

    • It can be placed just before the rule keyword in a rule deﬁnition, (Section 5.6) in which case
       it can refer directly to the rule or any other rules at the same level.

    • It can be placed just before the rules keyword in a rules expression (Section 9.13), in which
       case it can refer directly to any of the rules in the expression.

In addition, an urgency attribute can refer to any rule in the module hierarchy at or below the
current module, using a hierarchical name. For example, suppose we have:

module mkFoo ...;

      mkBar the_bar (barInterface);

      (* descending_urgency = &quot;r1, the_bar.r2&quot; *)
      rule r1 ...

            ...
      endrule

endmodule: mkFoo

The hierarchical name the_bar.r2 refers to a rule named r2 inside the module instance the_bar.
This can be several levels deep, i.e., the scheduling attribute can refer to a rule deep in the module
hierarchy, not just the sub-module immediately below. In general a hierarchical rule name is a
sequence of module instance names and ﬁnally a rule name, separated by periods.

A reference to a rule in a sub-module cannot cross synthesis boundaries. This is because synthesis
boundaries are also scheduler boundaries. Each separately synthesized part of the module hierarchy
contains its own scheduler, and cannot directly aﬀect other schedulers. Urgency can only apply to
rules considered within the same scheduler.

If rule urgency is not speciﬁed, and it impacts the choice of schedule, the compiler will print a
warning to this eﬀect during compilation.

Example. Using descending_urgency to control the scheduling of conﬂicting rules:

// IfcCounter with read method

interface IfcCounter#(type t);

method t      readCounter;

endinterface

// Definition of CounterType

                        c 2008 Bluespec, Inc. All rights reserved  101


Reference Guide                                                Bluespec SystemVerilog

typedef Bit#(16) CounterType;

// Module counter using IfcCounter interface. It never contains 0.
(* synthesize,

    reset_prefix = &quot;reset_b&quot;,
    clock_prefix = &quot;counter_clk&quot;,
    always_ready = &quot;readCounter&quot;,
    always_enabled= &quot;readCounter&quot; *)
module counter (IfcCounter#(CounterType));

     // Reg counter gets reset to 1 asynchronously with the RST signal
     Reg#(CounterType) counter &lt;- mkRegA(1);

     /* The descending_urgency attribute will indicate the scheduling

     order for the indicated rules.                                     */

     (* descending_urgency = &quot;resetCounter, updateCounter&quot; *)

     // Next rule resets the counter to 1 when it reaches its limit.
     rule resetCounter (counter == ’1);
     action

        counter &lt;= 1;
     endaction
     endrule

     // Next rule updates the counter.
     rule updateCounter;
     action

        counter &lt;= counter + 1;
     endaction
     endrule

     // Method to output the counter’s value
     method CounterType readCounter;

        return counter;
     endmethod

endmodule

Rule resetCounter conﬂicts with rule updateCounter because both try to modify the counter
register when it contains all its bits set to one. Without any descending_urgency attribute, the
updateCounter rule may obtain more urgency, meaning that if the predicate of resetCounter is
met, only the rule updateCounter will ﬁre. By setting the descending_urgency attribute the
designer can control the scheduling in the case of conﬂicting rules.

13.3.4 execution_order

With the execution_order attribute, the designer can specify that, when two rules ﬁre in the same
cycle, one rule should sequence before the other. This attribute is similar to the descending_urgency
attribute (section 13.3.3) except that it speciﬁes the execution order instead of the urgency order.
The execution_order attribute may occur in the same syntactic positions as the descending_urgency
attribute (Section 13.3.3) and takes a similar argument, a string containing a comma-separated list
of rule names. Example:

       (* execution_order = &quot;r1, r2, r3&quot; *)

102              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

This example speciﬁes that r1 should execute before r2 which, in turn, should execute before r3.

If two rules cannot execute in the order speciﬁed, because of method calls which must sequence in
the opposite order, for example, then the two rules are forced to conﬂict.

13.3.5 mutually_exclusive

The scheduler always attempts to deduce when two rules are mutually exclusive (based on their
predicates). However, this deduction can fail even when two rules are actually exclusive, either
because the scheduler eﬀort limit is exceeded or because the mutual exclusion depends on a higher-
level invariant that the scheduler does not know about. The mutually_exclusive attribute allows
the designer to overrule the scheduler’s deduction and forces the generated schedule to treat the
annotated rules as exclusive. The mutually_exclusive attribute may occur in the same syntactic
positions as the descending_urgency attribute (Section 13.3.3) and takes a similar argument, a
string containing a comma-separated list of rule names. Example:

(* mutually_exclusive = &quot;r1, r2, r3&quot; *)

This example speciﬁes that every pair of rules that are in the annotation (i.e (r1, r2), (r1, r3), and
(r2, r3)) is a mutually-exclusive rule pair.

Since an asserted mutual exclusion does not come with a proof of this exclusion, the compiler will
insert code that will check and generate a runtime error if two rules ever execute during the same clock
cycle during simulation. This allows a designer to ﬁnd out when their use of the mutually_exclusive
attribute is incorrect.

13.3.6 conflict_free

Like the mutually_exclusive rule attribute (section 13.3.5), the conflict_free rule attribute is a
way to overrule the scheduler’s deduction about the relationship between two rules. However, unlike
rules that are annotated mutually_exclusive, rules that are conflict_free may ﬁre in the same
clock cycle. Instead, the conflict_free attribute asserts that the annotated rules will not make
method calls that are inconsistent with the generated schedule when they execute.

The conflict_free attribute may occur in the same syntactic positions as the descending_urgency
attribute (Section 13.3.3) and takes a similar argument, a string containing a comma-separated list
of rule names. Example:

(* conflict_free = &quot;r1, r2, r3&quot; *)

This example speciﬁes that every pair of rules that are in the annotation (i.e (r1, r2), (r1, r3), and
(r2, r3)) is a conﬂict-free rule pair.

For example, two rules may both conditionally enqueue data into a FIFO with a single enqueue
port. Ordinarily, the scheduler would conclude that the two rules conﬂict since they are competing
for a single method. However, if they are annotated as conflict_free the designer is asserting that
when one rule is enqueuing into the FIFO, the other will not be, so the conﬂict is apparent, not real.
With the annotation, the schedule will be generated as if any conﬂicts do not exist and code will be
inserted into the resulting model to check if conﬂicting methods are actually called by the conﬂict
free rules during simulation.

It is important to know the conflict_free attribute’s capabilities and limitations. The attribute
works with more than method calls that totally conﬂict (like the single enqueue port). During simu-
lation, it will check and report any method calls amongst conflict_free rules that are inconsistent
with the generated schedule (including registers being read after they have been written and wires
being written after they are read). On the other hand, the conflict_free attribute does not over-
rule the scheduler’s deductions with respect to resource usage (like uses of a multi-ported register
ﬁle).

                        c 2008 Bluespec, Inc. All rights reserved  103


Reference Guide                                             Bluespec SystemVerilog

13.3.7 preempts

The designer can also prevent a rule from ﬁring whenever another rule (or set of rules) ﬁres. The
preempts attribute accepts two elements as arguments. Each element may be either a rule name or
a list of rule names. A list of rule names must be separated by commas and enclosed in parentheses.
In each cycle, if any of the rule names speciﬁed in the ﬁrst list can be executed and are scheduled
to ﬁre, then none of the rules speciﬁed in the second list will be allowed to ﬁre.
The preempts attribute is similar to the descending_urgency attribute (section 13.3.3), and may
occur in the same syntactic positions. The preempts attribute is equivalent to forcing a conﬂict
and adding descending_urgency. With descending_urgency, if two rules do not conﬂict, then
both would be allowed to ﬁre even if an urgency order had been speciﬁed; with preempts, if one
rule preempts the other, they can never ﬁre together. If r1 preempts r2, then the compiler forces a
conﬂict and gives r1 priority. If r1 is able to ﬁre, but is not scheduled to, then r2 can still ﬁre.
Examples:

   (* preempts = &quot;r1, r2&quot; *)

If r1 will ﬁre, r2 will not.

   (* preempts = &quot;(r1, r2), r3&quot; *)

If either r1 or r2 (or both) will ﬁre, r3 will not.

   (* preempts = &quot;(the_bar.r1, (r2, r3)&quot; *)

If the rule r1 in the submodule the_bar will ﬁre, then neither r2 nor r3 will ﬁre.

13.4 Evaluation behavior attributes

13.4.1 split and nosplit

                 Attribute name Section Action ActionValue

                                       statements statements
                                       √  √
                 split/nosplit 13.4.1

The split/nosplit attributes are applied to Action and ActionValue statements, but cannot
preceed certain expressions inside an action/endaction including return, variable declarations,
instantiations, and function statements.

When a rule contains an if (or case) statement, the compiler has the option either of splitting the
rule into two mutually exclusive rules, or leaving it as one rule for scheduling but using MUXes in the
production of the action. Rule splitting can sometimes be desirable because the two split rules are
scheduled independently, so non-conﬂicting branches of otherwise conﬂicting rules can be scheduled
concurrently. Splitting also allows the split fragments to appear in diﬀerent positions in the logical
execution order, providing the eﬀect of condition dependent scheduling.

Splitting is turned oﬀ by default for two reasons:

     • When a rule contains many if statements, it can lead to an exponential explosion in the
        number of rules. A rule with 15 if statements might split into 215 rules, depending on how
        independent the statements and their branch conditions are. An explosion in the number of
        rules can dramatically slow down the compiler and cause other problems for later compiler
        phases, particularly scheduling.

104              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

• Splitting propagates the branch condition of each if to the predicates of the split rules. Re-
   sources required to compute rule predicates are reserved on every cycle. If a branch condition
   requires a scarce resource, this can starve other parts of the design that want to use that
   resource.

The split and nosplit attributes override any compiler ﬂags, either the default or a ﬂag entered
on the command line (-split-if).

The split attribute splits all branches in the statement immediately following the attribute state-
ment, which must be an Action statement. A split immediately preceeding a binding (e.g. let)
statement is not valid. If there are nested if or case statements within the split statement, it will
continue splitting recursively through the branches of the statement. The nosplit attribute can be
used to disable rule splitting within nested if statements.

Example:

module mkConditional#(Bit#(2) sel) ();
    Reg#(Bit#(4)) a &lt;- mkReg(0);
    Reg#(Bool) done &lt;- mkReg(False);

    rule finish ;
       (*split*)
       if (a == 3)
            begin
                 done &lt;= True;
            end
       else
            (*nosplit*)
            if (a == 0)
                 begin
                      done &lt;= False;
                      a &lt;= 1;
                 end
            else
                 begin
                      done &lt;= False;
                 end

    endrule
endmodule

To enable rule splitting for an entire design, use the compiler ﬂag -split-if at compile time. See the
user guide for more information on compiler ﬂags. You can enable rule splitting for an entire design
with the -split-if ﬂag and then disable the eﬀect for speciﬁc rules, by specifying the nosplit
attribute before the rules you do not want to split.

13.5 Input clock and reset attributes

The following attributes control the deﬁnition and naming of clock oscillator, clock gate, and reset
ports. The attributes can only be applied to top-level module deﬁnitions.

                        c 2008 Bluespec, Inc. All rights reserved  105


Reference Guide                                Section                  Bluespec SystemVerilog

                          Attribute name       13.5.1   Top-level module
                          clock preﬁx=         13.5.1             √
                          gate preﬁx=          13.5.1             √
                          reset preﬁx=         13.5.2             √
                          gate input clocks=   13.5.2             √
                          gate all clocks      13.5.3             √
                          default clock osc=   13.5.3             √
                          default clock gate=  13.5.3             √
                          default gate inhigh  13.5.3             √
                          default gate unused  13.5.3             √
                          default reset=       13.5.4             √
                          clock family=        13.5.4             √
                          clock ancestors=                        √

13.5.1 Clock and reset preﬁx naming attributes

The generated port renaming attributes clock_prefix=, gate_prefix=, and reset_prefix= re-
name the ports for the clock oscillators, clock gates, and resets in a module by specifying a preﬁx
string to be added to each port name. The preﬁx is used only when a name is not provided for the
port, (as described in Sections 13.5.3 and 13.6.1), requiring that the port name be created from the
preﬁx and argument name. The attributes are associated with a module and are only applied when
the module is synthesized.

Attribute                   Clock Preﬁx Naming Attributes
clock_prefix=  Default name Description
gate_prefix=
reset_prefix=  CLK                             Provides the preﬁx string to be added to port names for
               CLK GATE                        all the clock oscillators in a module.
               RST N                           Provides the preﬁx string to be added to port names for
                                               all the clock gates in a module.
                                               Provides the preﬁx string to be added to port names for
                                               all the resets in a module.

If a preﬁx is speciﬁed as the empty string, then no preﬁx will be used when creating the port names;
that is the argument name alone will be used as the name.

Example:

(* synthesize, clock_prefix = &quot;CK&quot; *)
module mkMod(Clock clk2, ModIfc ifc);

generates the following in the Verilog:

module mkMod (CK, RST_N, CK_clk2, ...

Where CK is the default clock (using the user-supplied preﬁx), RST_N is the default reset (using the
default preﬁx), and CK_clk2 is the oscillator for the input clk2 (using the user-supplied preﬁx).

106            c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

13.5.2 Gate synthesis attributes

When a module is synthesized, one port, for the oscillator, is created for each clock input (including
the default clock). The gate for the clock is defaulted to a logical 1. The attributes gate_all_clocks
and gate_input_clocks= specify that a second port be generated for the gate.
The attribute gate_all_clocks will add a gate port to the default clock and to all input clocks.
The attribute gate_input_clocks= is used to individually specify each input clock which should
have a gate supplied by the parent module.
If an input clock is part of a vector of clocks, the gate port will be added to all clocks in the vector.
Example:

(* gate_input_clock = &quot;clks, c2&quot; *)
module mkM(Vector#(2, Clock) clks, Clock c2);

In this example, a gate port will be added to both the clocks in the vector clks and the clock c2.
A gate port cannot be added to just one of the clocks in the vector clks.
The gate_input_clocks= attribute can be used to add a gate port to the default clock. Example:

( * gate_input_clocks = &quot;default_clock&quot; * )

Note that by having a gate port, the compiler can no longer assume the gate is always logical 1. This
can cause an error if the clock is connected to a submodule which requires the gate to be logical 1.
The gate synthesis attributes are associated with a module and are only applied when the module
is synthesized.

13.5.3 Default clock and reset naming attributes

The default clock and reset naming attributes are associated with a module and are only applied
when the module is synthesized.

The attributes default_clock_osc=, default_clock_gate=, and default_reset= provide the
names for the default clock oscillator, default gate, and default reset ports for a module. When
a name for the default clock or reset is provided, any preﬁx attribute for that port is ignored.

The attributes default_gate_inhigh and default_gate_unused indicate that a gate port should
not be generated for the default clock and whether the gate is always logical 1 or unused. The default
is default_gate_inhigh. This is only necessary when the attribute gate_all_clocks (section
13.5.2) has been used.

The attributes no_default_clock and no_default_reset are used to remove the ports for the
default clock and the default reset.

Attribute               Default Clock and Reset Naming Attributes
                                     Description

default_clock_osc=      Provides the name for the default oscillator port.
no_default_clock        Removes the port for the default clock.
default_clock_gate=     Provides the name for the default gate port.
default_gate_inhigh     Removes the gate ports for the module and the gate is always
                        high.
default_gate_unused     Removes the gate ports for the module and the gate is un-
                        used.
default_reset=          Provides the name for the default reset port.
no_default_reset        Removes the port for the default reset.

                        c 2008 Bluespec, Inc. All rights reserved  107


Reference Guide                                                     Bluespec SystemVerilog

13.5.4 Clock family attributes

The clock_family and clock_ancestors attributes indicate to the compiler that clocks are in the
same domain in situations where the compiler may not recognize the relationship. For example, when
clocks split in synthesized modules and are then recombined in a subsequent module, the compiler
may not recognize that they have a common ancestor. The clock_ancestors and clock_family
attributes allow the designer to explicitly specify the family relationship between the clocks. These
attributes are applied to modules only.
The clock_ancestors attribute speciﬁes an ancestry relationship between clocks. A clock is a gated
version of its ancestors. In other words, if clk1 is an ancestor of clk2 then clk2 is a gated version
of clk1, as speciﬁed in the following statement:

      (* clock_ancestors = &quot;clk1 AOF clk2&quot; *)

Multiple ancestors as well as multiple independent groups can be listed in a single attribute state-
ment. For example:

      (* clock_ancestors = &quot;clk1 AOF clk2 AOF clk3, clk1 AOF clk4, clka AOF clkb&quot; *)

The above statement speciﬁes that clk1 is an ancestor of clk2, which is itself an ancestor of clk3;
that clk1 is also an ancestor of clk4; and that clka is an ancestor of clkb. You can also repeat
the attribute statement instead of including all clock ancestors in a single statement. Example:

      (* clock_ancestors = &quot;clk1 AOF clk2 AOF clk3&quot; *)
      (* clock_ancestors = &quot;clk1 AOF clk4&quot; *)
      (* clock_ancestors = &quot;clka AOF clkb&quot; *)

For clocks which do not have an ancestor relationship, but do share a common ancestor, you can
use the clock_family attribute. Clocks which are in the same family have the same oscillator with
a diﬀerent gate. To be in the same family, one does not have to be a gated version of the other,
instead they may be gated versions of a common ancestor.

      (* clock_family = &quot;clk1, clk2, clk3&quot; *)

Note that clock_ancestors implies same_family.

13.6 Module argument attributes

The attributes in this section are applied to module arguments. The following table shows which
type of module argument each attribute can be applied to. Each attribute can be applied to vectors
of arguments as well.

     Attribute name      Section       Clock/          Reset/         Value        Inout/
                                  vector of clock  vector of reset  argument  vector of inouts
                   osc=   13.6.1
                 gate=    13.6.1          √                √             √             √
          gate inhigh     13.6.1          √                √             √             √
         gate unused      13.6.1          √                              √             √
                reset=    13.6.1          √
         clocked by=      13.6.2
            reset by=     13.6.3
                 port=    13.6.4

108                      c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

13.6.1 Argument-level clock and reset naming attributes

The non-default clock and reset inputs to a module will have a port name created using the argument
name and any associated preﬁx for that port type. This name can be overridden on a per-argument
basis by supplying argument-level attributes that specify the names for the ports.

These attributes are applied to the clock module arguments, except for reset= which is applied to
the reset module arguments.

             Argument-level Clock and Reset Naming Attributes

Attribute    Applies to                 Description

osc=         Clock or vector of clocks  Provides the full name of the oscillator port.
gate=        module arguments
gate_inhigh  Clock or vector of clocks  Provides the full name of the gate port.
gate_unused  module arguments
reset=       Clock or vector of clocks  Indicates that the gate port should be omitted and
             module arguments           the gate is assumed to be high.
             Clock or vector of clocks  Indicates that the gate port should be omitted and is
             module arguments           never used within the module.
             Reset or vector of resets  Provides the full name of the reset port.
             module arguments

Example:

(* synthesize *)
module mkMod((* osc=&quot;ACLK&quot;, gate=&quot;AGATE&quot; *) Clock clk,

                    (* reset=&quot;RESET&quot; *) Reset rst,
                    ModIfc ifc);

generates the following in the Verilog:

module mkMod(CLK, RST_N, ACLK, AGATE, RESET, ...

The attributes can be applied to the base name generated for a vector of clocks, gates or resets.
Example:

(* synthesize *)
module mkMod((* osc=&quot;ACLK&quot;, gate=&quot;AGATE&quot; *) Vector#(2, Clock) clks,

                    (* reset=&quot;ARST&quot; *) Vector#(2, Reset) rsts,
                    ModIfc ifc);

generates the following in the Verilog:

module mkMod(CLK, RST_N, ACLK_0, AGATE_0, ACLK_1, AGATE_1, ARST_0, ARST_1,...

13.6.2 clocked_by=

The attribute clocked_by= allows the user to assert which clock a reset, inout, or value module
argument is associated with, to specify that the argument has no_clock, or to associate the argument
with the default_clock. If the clocked_by= attribute is not provided, the default clock will be
used for inout and value arguments; the clock associated with a reset argument is dervied from where
the reset is connected.

Examples:

                         c 2008 Bluespec, Inc. All rights reserved             109


Reference Guide                                                    Bluespec SystemVerilog

     module mkMod (Clock c2, (* clocked_by=&quot;c2&quot; *) Bool b,
                           ModIfc ifc);

     module mkMod (Clock c2, (* clocked_by=&quot;default_clock&quot; *) Bool b,
                           ModIfc ifc);

     module mkMod (Clock c2, (* clocked_by=&quot;c2&quot; *) Reset rstIn,
                                           (* clocked_by=&quot;default_clock&quot; *) Inout q_inout,
                                           (* clocked_by=&quot;c2&quot; *) Bool b,

                           ModIfc ifc);

To specify that an argument is not associated with any clock domain, the clock no_clock is used.
Example:

       module mkMod (Clock c2, (* clocked_by=&quot;no_clock&quot; *) Bool b,
                              ModIfc ifc);

13.6.3 reset_by=

The attribute reset_by= allows the user to assert which reset an inout or value module argument is
associated with, to specify that the argument has no_reset, or to associate the argument with the
default_reset. If the reset_by= attribute is not provided, the default reset will be used.
Examples:

       module mkMod (Reset r2, (* reset_by=&quot;r2&quot; *) Bool b,
                              ModIfc ifc);

       module mkMod (Reset r2, (* reset_by=&quot;default_reset&quot; *) Inout q_inout,
                              ModIfc ifc);

To specify that the port is not associated with any reset, no_reset is used. Example:

       module mkMod (Reset r2, (* reset_by=&quot;no_reset&quot; *) Bool b,
                              ModIfc ifc);

13.6.4 port=

The attribute port= allows renaming of value module arguments. These are port-like arguments
that are not clocks, resets or parameters. It provides the full name of the port generated for the
argument. This is the same attribute as the port= attribute in Section 13.2.1, as applied to module
arguments instead of interface methods.

13.7 Documentation attributes

A BSV design can specify comments to be included in the generated Verilog by use of the doc
attribute.

     Attribute name     Section   Top-level    Submodule         rule        rules
                  doc=      13.7   module     instantiations  deﬁnitions  expressions
                                  deﬁnitions
                                                     √             √            √
                                       √

110                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Example:

   (* doc = &quot;This is a user-provided comment&quot; *)
To provide a multi-line comment, either include a \n character:

   (* doc = &quot;This is one line\nAnd this is another&quot; *)
Or provide several instances of the doc attribute:

   (* doc = &quot;This is one line&quot; *)
   (* doc = &quot;And this is another&quot; *)
Or:

   (* doc = &quot;This is one line&quot;,
       doc = &quot;And this is another&quot; *)

Multiple doc attributes will appear together in the order that they are given. doc attributes can be
added to modules, module instantiations, and rules, as described in the following sections.

13.7.1 Modules

The Verilog ﬁle that is generated for a synthesized BSV module contains a header comment prior
to the Verilog module deﬁnition. A designer can include additional comments between this header
and the module by attaching a doc attribute to the module being synthesized. If the module is not
synthesized, the doc attributes are ignored.

Example:

   (* synthesize *)
   (* doc = &quot;This is important information about the following module&quot; *)
   module mkMod (IFC);

      ...
   endmodule

13.7.2 Module instantiation

In generated Verilog, a designer might want to include a comment on submodule instantiations,
to document something about that submodule. This can be achieved with a doc attribute on the
corresponding BSV module. There are three ways to express instantiation in BSV syntax, and the
doc attribute can be attached to all three.

   (* doc = &quot;This submodule does something&quot; *)
   FIFO#(Bool) f();
   mkFIFO the_f(f);

   (* doc = &quot;This submodule does something else&quot; *)
   Server srv &lt;- mkServer;

   Client c;
   ...
   (* doc = &quot;This submodule does a third thing&quot; *)
   c &lt;- mkClient;

                        c 2008 Bluespec, Inc. All rights reserved  111


Reference Guide                                             Bluespec SystemVerilog

The syntax also works if the type of the module interface is given with let, a variable, or the current
module type. Example:

   (* doc = &quot;This submodule does something else&quot; *)
   let srv &lt;- mkServer;

If the submodule being instantiated is a separately synthesized module or primitive, then its corre-
sponding Verilog instantiation will be preceded by the comments. Example:

   // submodule the_f
   // This submodule does something
   wire the_f$CLR, the_f$DEQ, the_f$ENQ;
   FIFO2 #(.width(1)) the_f(...);

If the submodule is not separately synthesized, then there is no place in the Verilog module to attach
the comment. Instead, the comment is included in the header at the beginning of the module.
For example, assume that the module the_sub was instantiated inside mkTop with a user-provided
comment but was not separately synthesized. The generated Verilog would include these lines:

   // ...
   // Comments on the inlined module ‘the_sub’:
   // This is the submodule
   //
   module mkTop(...);

The doc attribute can be attached to submodule instantiations inside functions and for-loops.
If several submodules are inlined and their comments carry to the top-module’s header comment, all
of their comments are printed. To save space, if the comments on several modules are the same, the
comment is only displayed once. This can occur, for instance, with doc attributes on instantiations
inside for-loops. For example:

   // Comments on the inlined modules ‘the_sub_1‘, ‘the_sub_2‘,
   // ‘the_sub_3‘:
   // ...

If the doc attribute is attached to a register instantiation and the register is inlined (as is the default),
the Verilog comment is included with the declaration of the register signals. Example:

   // register the_r
   // This is a register
   reg the_r;
   wire the_r$D_IN, the_r$EN;

If the doc attribute is attached to an RWire instantiation, and the wire instantiation is inlined (as
is the default), then the comment is carried to the top-module’s header comment.

If the doc attribute is attached to a probe instantiation, the comment appears in the Verilog above
the declaration of the probe signals. Since the probe signals are declared as a group, the comments
are listed at the start of the group. Example:

   // probes
   //
   // Comments for probe ‘the_r’:
   // This is a probe
   //
   wire the_s$PROBE;
   wire the_r$PROBE;
   ...

112              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

13.7.3 Rules

In generated Verilog, a designer might want to include a comment on rule scheduling signals (such as
CAN_FIRE_ and WILL_FIRE_ signals), to say something about the actions that are performed when
that rule is executed. This can be achieved with a doc attribute attached to a BSV rule declaration
or rules expression.

The doc attribute can be attached to any rule..endrule or rules...endrules statement. Exam-
ple:

    (* doc = &quot;This rule is important&quot; *)
    rule do_something (b);

         x &lt;= !x;
    endrule

If any scheduling signals for the rule are explicit in the Verilog output, their deﬁnition will be
preceeded by the comment. Example:

   // rule RL_do_something
   // This rule is important
   assign CAN_FIRE_RL_do_something = b ;
   assign WILL_FIRE_RL_do_something = CAN_FIRE_RL_do_something ;

If the signals have been inlined or otherwise optimized away and thus do not appear in the Verilog,
then there is no place to attach the comments. In that case, the comments are carried to the top
module’s header. Example:

   // ...
   // Comments on the inlined rule ‘RL_do_something’:
   // This rule is important
   //
   module mkTop(...);

The designer can ensure that the signals will exist in the Verilog by using an appropriate compiler
ﬂag, the -keep-fires ﬂag which is documented in the Bluespec SystemVerilog User Guide.

The doc attribute can be attached to any rule..endrule expression, such as inside a function or
inside a for-loop.

As with comments on submodules, if the comments on several rules are the same, and those comments
are carried to the top-level module header, the comment is only displayed once.

   // ...
   // Comments on the inlined rules ‘RL_do_something_2’, ‘RL_do_something_1’,
   // ‘RL_do_something’:
   // This rule is important
   //
   module mkTop(...);

14 Advanced topics

This section can be skipped on ﬁrst reading.

                        c 2008 Bluespec, Inc. All rights reserved  113


Reference Guide                                             Bluespec SystemVerilog

14.1 Type classes (overloading groups) and provisos

Note that for most BSV programming, one just needs to know about a few predeﬁned type classes
such as Bits and Eq, about provisos, and about the automatic mechanism for deﬁning the overloaded
functions in those type classes using a deriving clause. The brief introduction in Sections 4.2 and
4.3 should suﬃce.

This section is intended for the advanced programmer who may wish to deﬁne new type classes
(using a typeclass declaration), or explicitly to deﬁne overloaded functions using an instance
declaration.

In programming languages, the term overloading refers to the use of a common function name or
operator symbol to represent some number (usually ﬁnite) of functions with distinct types. For
example, it is common to overload the operator symbol + to represent integer addition, ﬂoating
point addition, complex number addition, matrix addition, and so on.

Note that overloading is distinct from polymorphism, which is used to describe a single function
or operator that can operate at an inﬁnity of types. For example, in many languages, a single
polymorphic function arraySize() may be used to determine the number of elements in any array,
no matter what the type of the contents of the array.

A type class (or overloading group) further recognizes that overloading is often performed with
related groups of function names or operators, giving the group of related functions and operators a
name. For example, the type class Ord contains the overloaded operators for order-comparison: &lt;,
&lt;=, &gt; and &gt;=.

If we specify the functions represented by these operator symbols for the types int, Bool, bit[m:0]
and so on, we say that those types are instances of the Ord type class.

A proviso is a (static) condition attached to some constructs. A proviso requires that certain types
involved in the construct must be instances of certain type classes. For example, a generic sort
function for sorting lists of type List#(t) will have a proviso (condition) that t must be an instance
of the Ord type class, because the generic function uses an overloaded comparison operator from
that type class, such as the operator &lt; or &gt;.

Type classes are created explicitly using a typeclass declaration (Section 14.1.2). Further, a type
class is explicitly populated with a new instance type t, using an instance declaration (Section
14.1.3), in which the programmer provides the speciﬁcations for the overloaded functions for the
type t.

14.1.1 Provisos

Consider the following function prototype:

 function List#(t) sort (List#(t) xs)
       provisos (Ord#(t));

This prototype expresses the idea that the sorting function takes an input list xs of items of type
t (presumably unsorted), and produces an output list of type t (presumably sorted). In order to
perform its function it needs to compare elements of the list against each other using an overloaded
comparison operator such as &lt;. This, in turn, requires that the overloaded operator be deﬁned on
objects of type t. This is exactly what is expressed in the proviso, i.e., that t must be an instance
of the type class (overloading group) Ord, which contains the overloaded operator &lt;.

Thus, it is permissible to apply sort to lists of Integers or lists of Bools, because those types are
instances of Ord, but it is not permissible to apply sort to a list of, say, some interface type Ifc
(assuming Ifc is not an instance of the Ord type class).

114              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                       Reference Guide

The syntax of provisos is the following:

provisos                ::= provisos ( proviso { , proviso } )

proviso                 ::= Identiﬁer #(type { , type } )

In each proviso, the Identiﬁer is the name of type class (overloading group). In most provisos, the
type class name T is followed by a single type t, and can be read as a simple assertion that t is an
instance of T , i.e., that the overloaded functions of type class T are deﬁned for the type t. In some
provisos the type class name T may be followed by more than one type t1, ..., tn and these express
more general relationships. For example, a proviso like this:

provisos (Bits#(macAddress, 48))

can be read literally as saying that the types macAddress and 48 are in the Bits type class, or
can be read more generally as saying that values of type macAddress can be converted to and from
values of the type bit[47:0] using the pack and unpack overloaded functions of type class Bits.

We sometimes also refer to provisos as contexts, meaning that they constrain the types that may be
used within the construct to which the provisos are attached.

Occasionally, if the context is too weak, the compiler may be unable to ﬁgure out how to resolve an
overloading. Usually the compiler’s error message will be a strong hint about what information is
missing. In these situations it may be necessary for the programmer to guide the compiler by adding
more type information to the program, in either or both of the following ways:

• Add a static type assertion (Section 9.10) to some expression that narrows down its type.
• Add a proviso to the surrounding construct.

14.1.2 Type class declarations

A new class is declared using the following syntax:

typeclassDef            ::= typeclass typeclassIde typeFormals [ provisos ]
                              [ typedepends ] ;
                                    { overloadedDef }
                              endtypeclass [ : typeclassIde ]

typeclassIde            ::= Identiﬁer

typeFormals             ::= # ( typeFormal { , typeFormal })

typeFormal              ::= [ numeric ] type typeIde

typedepends             ::= dependencies ( typedepend { , typedepend } )

typedepend              ::= typelist determines typelist

typelist                ::= typeIde
                        | ( typeIde { , typeIde } )

overloadedDef           ::= functionProto
                        | varDecl

The typeclassIde is the newly declared class name. The typeFormals represent the types that will be
instances of this class. These typeFormals may themselves be constrained by provisos, in which case
the classes named in provisos are called the “super type classes” of this type class. Type dependencies
(typedepends) are relevant only if there are two or more type parameters; the typedepends comes after
the typeclass’s provisos (if any) and before the semicolon. The overloadedDef s declare the overloaded
variables or function names, and their types.

Example (from the Standard Prelude package):

                        c 2008 Bluespec, Inc. All rights reserved                            115


Reference Guide                                             Bluespec SystemVerilog

 typeclass Literal#(type a);
       function a fromInteger (Integer x);
       function Bool inLiteralRange(a target, Integer i);

 endtypeclass: Literal

This deﬁnes the type class Literal. Any type a that is an instance of Literal must have an
overloaded function called fromInteger that converts an Integer value into the type a. In fact,
this is the mechanism that BSV uses to interpret integer literal constants, e.g., to resolve whether a
literal like 6847 is to be interpreted as a signed integer, an unsigned integer, a ﬂoating point number,
a bit value of 10 bits, a bit value of 8 bits, etc. (See Section 2.3.1 for a more detailed description.).

The typeclass also provides a function inLiteralRange that takes an argument of type a and an
Integer and returns a Bool. In the standard Literal typeclass this boolean indicates whether or
not the supplied Integer is in the range of legal values for the type a.

Example (from a predeﬁned type class in BSV):

 typeclass Bounded#(type a);
       a minBound;
       a maxBound;

 endtypeclass

This deﬁnes the type class Bounded. Any type a that is an instance of Bounded will have two values
called minBound and maxBound that, respectively, represent the minimum and maximum of all values
of this type.

Example (from a predeﬁned type class in BSV):10

    typeclass Arith #(type data_t)
       provisos (Literal#(data_t));
           function data_t \+ (data_t x, data_t y);
           function data_t \- (data_t x, data_t y);
           function data_t negate (data_t x);
           function data_t \* (data_t x, data_t y);
           function data_t \/ (data_t x, data_t y);
           function data_t \% (data_t x, data_t y);

    endtypeclass

This deﬁnes the type class Arith with super type class Literal, i.e., the proviso states that in order
for a type data_t to be an instance of Arith it must also be an instance of the type class Literal.
Further, it has six overloaded functions with the given names and types. Said another way, a type
that is an instance of the Arith type class must have a way to convert integer literals into that type,
and it must have addition, subtraction, negation, multiplication, and division deﬁned on it.

The semantics of a dependency say that once the types on the left of the determines keyword are
ﬁxed, the types on the right are uniquely determined. The types on either side of the list can be a
single type or a list of types, in which case they are enclosed in parentheses.

Example of a typeclass deﬁnition specifying type dependencies:

typeclass Connectable #(type a, type b)
      dependencies (a determines b, b determines a);
           module mkConnections#(a x1, b x2) (Empty);

endtypeclass

  10 We are using Verilog’s notation for escaped identiﬁers to treat operator symbols as ordinary identiﬁers. The
notation allows an identiﬁer to be constructed from arbitrary characters beginning with a backslash and ending with
a whitespace (the backslash and whitespace are not part of the identiﬁer.)

116              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

For any type t we know that Get#(t) and Put#(t) are connectable because of the following decla-
ration in the GetPut package:

instance Connectable#(Get#(element_type), Put#(element_type));

In the Connectable dependency above, it states that a determines b. Therefore, you know that if a
is Get#(t), the only possibility for b is Put#(t).
Example of a typeclass deﬁnition with lists of types in the dependencies:

typeclass Extend #(type a, type b, type c)
      dependencies ((a,c) determines b, (b,c) determines a);

endtypeclass

An example of a case where the dependencies are not commutative:

typeclass Bits#(type a, type sa)
    dependencies (a determines sa);
         function Bit#(sa) pack(a x);
         function a unpack (Bit#(sa) x);

endtypeclass

In the above example, if a were UInt#(16) the dependency would require that b had to be 16; but
the fact that something occupies 16 bits by no means implies that it has to be a UInt.

14.1.3 Instance declarations

A type can be declared to be an instance of a class in two ways, with a general mechanism or with
a convenient shorthand. The general mechanism of instance declarations is the following:

   typeclassInstanceDef ::= instance typeclassIde # ( type { , type } ) [ provisos ] ;
                                             { varAssign ; | functionDef | moduleDef }

                                       endinstance [ : typeclassIde ]

This says that the types are an instance of type class typeclassIde with the given provisos. The
varAssigns, functionDef s and moduleDef s specify the implementation of the overloaded identiﬁers
of the type class.

Example, declaring a type as an instance of the Eq typeclass:

typedef enum { Red, Blue, Green } Color;

instance Eq#(Color);

function Bool \== (Color x, Color y); //must use \== with a trailing

return True;                  //space to define custom instances

endfunction                   //of the Eq typeclass

endinstance

The shorthand mechanism is to attach a deriving clause to a typedef of an enum, struct or tagged
union and let the compiler do the work. In this case the compiler chooses the “obvious” implementa-
tion of the overloaded functions (details in the following sections). The only type classes for which
deriving can be used for general types are Bits, Eq and Bounded. Furthermore, deriving can be
used for any class if the type is a data type that is isomorphic to a type that has an instance for the
derived class.

derives                 ::= deriving ( typeclassIde { , typeclassIde } )

Example:

typedef enum { Red, Blue, Green } Color deriving (Eq);

                        c 2008 Bluespec, Inc. All rights reserved         117


Reference Guide                                                      Bluespec SystemVerilog

14.1.4 The Bits type class (overloading group)

The type class Bits contains the types that are convertible to bit strings of a certain size. Many
constructs have membership in the Bits class as a proviso, such as putting a value into a register,
array, or FIFO.

Example: The Bits type class deﬁnition (which is actually predeﬁned in BSV) looks something like
this:

typeclass Bits#(type a, type n);

     function Bit#(n) pack (a x);

     function a         unpack (Bit#(n) y);

endtypeclass

Here, a represents the type that can be converted to/from bits, and n is always instantiated by a
size type (Section 4) representing the number of bits needed to represent it. Implementations of
modules such as registers and FIFOs use these functions to convert between values of other types
and the bit representations that are really stored in those elements.

Example: The most trivial instance declaration states that a bit-vector can be converted to a bit
vector, by deﬁning both the pack and unpack functions to be identity functions:

instance Bits#(Bit#(k), k);
      function Bit#(k) pack (Bit#(k) x);
            return x;
      endfunction: pack

      function Bit#(k) unpack (Bit#(k) x);
            return x;

      endfunction: unpack
endinstance

Example:

typedef enum { Red, Green, Blue } Color deriving (Eq);

instance Bits#(Color, 2);

     function Bits#(2) pack (Color c);

          if     (c == Red) return 3;

          else if (c == Green) return 2;

          else             return 1;        // (c == Blue)

     endfunction: pack

     function Color unpack (Bits#(2) x);

          if     (x == 3) return Red;

          else if (x == 2) return Green;

          else if (x == 1) return Blue;

          else $error(&quot;Illegal code 0 for unpacking a Color’’);

     endfunction: unpack

endinstance

Note that the deriving (Eq) phrase permits us to use the equality operator == on Color types
in the pack function. Red, Green and Blue are coded as 3, 2 and 1, respectively. If we had used
the deriving(Bits) shorthand in the Color typedef, they would have been coded as 0, 1 and 2,
respectively (Section 14.1.6).

118                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

14.1.5 The SizeOf pseudo-function

The pseudo-function SizeOf#(t) can be applied to a type t to get the numeric type representing its
bit size. The type t must be in the Bits class, i.e., it must already be an instance of Bits#(t,n),
either through a deriving clause or through an explicit instance declaration. The SizeOf function
then returns the corresponding bit size n. Note that SizeOf returns a numeric type, not a numeric
value, i.e., the output of SizeOf can be used in a type expression, and not in a value expression.
SizeOf, which converts a type to a (numeric) type, should not be confused with the pseudo-function
valueof, described in Section 4.2.1, which converts a numeric type to a numeric value.
Example:

 typedef Bit#(8) MyType;
 // MyType is an alias of Bit#(8)

 typedef SizeOf#(MyType) NumberOfBits;
 // NumberOfBits is a numeric type, its value is 8

 Integer ordinaryNumber = valueOf(NumberOfBits);
 // valueOf converts a numeric type into Integer

14.1.6 Deriving Bits

When attaching a deriving(Bits) clause to a user-deﬁned type, the instance derived for the Bits
type class can be described as follows:

    • For an enum type it is simply an integer code, starting with zero for the ﬁrst enum constant
       and incrementing by one for each subsequent enum constant. The number of bits used is the
       minimum number of bits needed to represent distinct codes for all the enum constants.

    • For a struct type it is simply the concatenation of the bits for all the members. The ﬁrst
       member is in the leftmost bits (most signiﬁcant) and the last member is in the rightmost bits
       (least signiﬁcant).

    • For a tagged union type, all values of the type occupy the same number of bits, regardless of
       which member it belongs to. The bit representation consists of two parts—a tag on the left
       (most signiﬁcant) and a member value on the right (least signiﬁcant).
       The tag part uses the minimum number of bits needed to code for all the member names. The
       ﬁrst member name is given code zero, the next member name is given code one, and so on.
       The size of the member value part is always the size of the largest member. The member value
       is stored in this ﬁeld, right-justiﬁed (i.e., ﬂush with the least-signiﬁcant end). If the member
       value requires fewer bits than the size of the ﬁeld, the intermediate bits are don’t-care bits.

Example. Symbolic names for colors:

 typedef enum { Red, Green, Blue } Color deriving (Eq, Bits);

This is the same type as in Section 14.1.4 except that Red, Green and Blue are now coded as 0, 1
and 2, instead of 3, 2, and 1, respectively, because the canonical choice made by the compiler is to
code consecutive labels incrementing from 0.
Example. The boolean type can be deﬁned in the language itself:

 typedef enum { False, True} Bool deriving (Bits);

                        c 2008 Bluespec, Inc. All rights reserved  119


Reference Guide                                             Bluespec SystemVerilog

The type Bool is represented with one bit. False is represented by 0 and True by 1.
Example. A struct type:

 typedef struct { Bit#(8) foo; Bit#(16) bar } Glurph deriving (Bits);

The type Glurph is represented in 24 bits, with foo in the upper 8 bits and bar in the lower 16 bits.
Example. Another struct type:

 typedef struct{ int x; int y } Coord deriving (Bits);

The type Coord is represented in 64 bits, with x in the upper 32 bits and y in the lower 32 bits.
Example. The Maybe type from Section 7.3:

 typedef union tagged {
       void Invalid;
       a Valid;

 } Maybe#(type a)
    deriving (Bits);

is represented in 1 + n bits, where n bits are needed to represent values of type a. If the leftmost
bit is 0 (for Invalid) the remaining n bits are unspeciﬁed (don’t-care). If the leftmost bit is 1 (for
Valid) then the remaining n bits will contain a value of type a.

14.1.7 Deriving Eq

The Eq type class contains the overloaded operators == (logical equality) and != (logical inequality):

 typeclass Eq#(type a);
       function Bool \== (a x1, a x2);
       function Bool \!= (a x1, a x2);

 endtypeclass: Eq

When deriving(Eq) is present on a a user-deﬁned type deﬁnition t, the compiler deﬁnes these
equality/inequality operators for values of type t. It is the natural recursive deﬁnition of these
operators, i.e.,

    • If t is an enum type, two values of type t are equal if they represent the same enum constant.

    • If t is a struct type, two values of type t are equal if the corresponding members are pairwise
       equal.

    • If t is a tagged union type, two values of type t are equal if they have the same tag (member
       name) and the two corresponding member values are equal.

14.1.8 Deriving Bounded

The predeﬁned type class Bounded contains two overloaded identiﬁers minBound and maxBound rep-
resenting the minimum and maximum values of a type a:

 typeclass Bounded#(type a);
       a minBound;
       a maxBound;

 endtypeclass

120              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

The clause deriving(Bounded) can be attached to any user-deﬁned enum deﬁnition t, and the
compiler will deﬁne the values minBound and maxBound for values of type t as the ﬁrst and last enum
constants, respectively.

The clause deriving(Bounded) can be attached to any user-deﬁned struct deﬁnition t with the
proviso that the type of each member is also an instance of Bounded. The compiler-deﬁned minBound
(or maxBound) will be the struct with each member having its respective minBound (respectively,
maxBound).

14.1.9 Deriving type class instances for isomorphic types

Generally speaking, the deriving(...) clause can only be used for the predeﬁned type classes Bits,
Eq and Bounded. However there is a special case where it can be used for any type class. When a
user-deﬁned type t is isomorphic to an existing type t , then all the functions on t automatically
work on t, and so the compiler can trivially derive a function for t by just using the corresponding
function for t .

There are two situations where a newly deﬁned type is isomorphic to an old type: a struct or tagged
union with precisely one member. For example:

   typedef struct { t x; } t deriving (anyClass);
   typedef union tagged { t X; } t deriving (anyClass);

One sometimes deﬁnes such a type precisely for type-safety reasons because the new type is distinct
from the old type although isomorphic to it, so that it is impossible to accidentally use a t value in
a t context and vice versa. Example:

typedef struct { UInt#(32) x; } Apples deriving (Literal, Arith);
...
Apples five;
...
five = 5; // ok, since RHS applies ’fromInteger()’ from Literal

                    // class to Integer 5 to create an Apples value

function Apples eatApple (Apples n);

return n - 1;           // ’1’ is converted to Apples by fromInteger()

                        // ’-’ is available on Apples from Arith class

endfunction: eatApple

The typedef could also have been written with a singleton tagged union instead of a singleton struct:

typedef union tagged { UInt#(32) X; } Apples deriving (Literal, Arith);

14.2 Higher-order functions

In BSV it is possible to write an expression whose value is a function value. These function values
can be passed as arguments to other functions, returned as results from functions, and even carried
in data structures.
Example - the function map, as deﬁned in the package Vector (C.2.8):

                        c 2008 Bluespec, Inc. All rights reserved        121


Reference Guide                                             Bluespec SystemVerilog

 function Vector#(vsize, b_type) map (function b_type func (a_type x),
                                                            Vector#(vsize, a_type) xvect);

       Vector#(vsize, b_type) yvect = newVector;

       for (Integer j = 0; j &lt; valueof(vsize); j=j+1)
              yvect[j] = func (xvect[j]);

       return yvect;
 endfunction: map

 function int sqr (int x);
      return x * x;

 endfunction: sqr

 Vector#(100,int) avect = ...; // initialize vector avect

 Vector#(100,int) bvect = map (sqr, avect);

The function map is polymorphic, i.e., is deﬁned for any size type vsize and value types a_type and
b_type. It takes two arguments:

    • A function func with input of type a_type and output of type b_type.

    • A vector xvect of size vsize containing values of type a_type.

Its result is a new vector yvect that is also of size vsize and containing values of type b_type,
such that yvect[j]=func(xvect[j]). In the last line of the example, we call map passing it the sqr
function and the vector avect to produce a vector bvect that contains the squared versions of all
the elements of vector avect.
Observe that in the last line, the expression sqr is a function-valued expression, representing the
squaring function. It is not an invocation of the sqr function. Similarly, inside map, the identiﬁer
func is a function-valued identiﬁer, and the expression func (xsize [j]) invokes the function.
The function map could be called with a variety of arguments:

   // Apply the extend function to each element of avect
   Vector#(13, Bit#(5)) avect;
   Vector#(13, Bit#(10)) bvect;
   ...
   bvect = map(extend, avect);

or

 // test all elements of avect for even-ness
 Vector#(100,Bool) bvect = map (isEven, avect);

In other words, map captures, in one deﬁnition, the generic idea of applying some function to all
elements of a vector and returning all the results in another vector. This is a very powerful idea
enabled by treating functions as ﬁrst-class values. Here is another example, which may be useful in
many hardware designs:

 interface SearchableFIFO#(type element_type);
       ... usual enq() and deq() methods ...

122              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

      method Bool search (element_type key);

endinterface: SearchableFIFO

module mkSearchableFIFO#(function Bool test_func
                                      (element_type x, element_type key))
                                      (SearchableFIFO#(element_type));

      ...
      method Bool search (element_type key);

            ... apply test_func(x, key) to each element of the FIFO, ...
            ... return OR of all results ...
      endmethod: search
endmodule: mkSearchableFIFO

The SearchableFIFO interface is like a normal FIFO interface (contains usual enq() and deq()
methods), but it has an additional bit of functionality. It has a search() method to which you
can pass a search key key, and it searches the FIFO using that key, returning True if the search
succeeds.

Inside the mkSearchableFIFO module, the method applies some element test predicate test_func to
each element of the FIFO and ORs all the results. The particular element-test function test_func to
be used is passed in as a parameter to mkSearchableFIFO. In one instantiation of mkSearchableFIFO
we might pass in the equality function for this parameter (“search this FIFO for this particular ele-
ment”). In another instantiation of mkSearchableFIFO we might pass in the “greater-than” function
(“search this FIFO for any element greater than the search key”). Thus, a single FIFO deﬁnition cap-
tures the general idea of being able to search a FIFO, and can be customized for diﬀerent applications
by passing in diﬀerent search functions to the module constructor.

A ﬁnal important point is that all this is perfectly synthesizable in BSV, i.e., the compiler can
produce RTL hardware for such descriptions. Since polymporphic modules cannot be synthesized,
for synthesis a non-polymorphic version of the module would have to be instantiated.

15 Embedding Verilog in a BSV design

This section describes how to embed a Verilog module in a BSV module. This is the method to utilize
existing Verilog components, Verilog components generated by other tools or to deﬁne a custom set
of primitives to be used in multiple designs. One example is the BSV primitives (registers, FIFOs,
etc.), which are implemented through BVI import. To embed a Verilog module you create a BSV
wrapper around a Verilog module, deﬁning the Verilog port connections and associating the BSV
parameters with the Verilog ports.

externModuleImport      ::= import &quot;BVI&quot; [ identiﬁer = ] moduleProto
                                   { moduleStmt }
                                   { importBVIStmt }

                             endmodule [ : identiﬁer ]

The body consists of a sequence of importBVIStmts:

importBVIStmt           ::= parameterBVIStmt
                        | methodBVIStmt
                        | portBVIStmt
                        | inputClockBVIStmt
                        | defaultClockBVIStmt
                        | outputClockBVIStmt

                        c 2008 Bluespec, Inc. All rights reserved          123


Reference Guide                                             Bluespec SystemVerilog

                                 | inputResetBVIStmt
                                 | defaultResetBVIStmt
                                 | noResetBVIStmt
                                 | ouputResetBVIStmt
                                 | ancestorBVIStmt
                                 | sameFamilyBVIStmt
                                 | scheduleBVIStmt
                                 | pathBVIStmt
                                 | inoutBVIStmt

The optional identiﬁer immediately following the &quot;BVI&quot; is the name of the Verilog module to be
imported. This will usually be found in a Verilog ﬁle of the same name (identiﬁer.v ). If this identiﬁer
is excluded, it is assumed that the Verilog module name is the same as the BSV name of the module.

The moduleProto is the ﬁrst line in the module deﬁnition as described in Section 5.3.

The BSV wrapper returns an interface. All arguments and return values must be in the Bits class
or be of type Clock, Reset, or a subinterface which meets these requirements. Note that the BSV
module’s parameters have no inherent relationship to the Verilog module’s parameters. The BSV
wrapper is used to connect the Verilog ports to the BSV parameters, performing any data conversion,
such as packs or unpacks, as necessary.

Example of the header of a BVI import statement:

       import &quot;BVI&quot; RWire =
            module RWire (VRWire#(a))
                 provisos (Bits#(a,sa));
            ...
            endmodule: vMkRWire

Since the Verilog module’s name matches the BSV name, the header could be also written as:

     import &quot;BVI&quot;
         module RWire (VRWire#(a))
              provisos (Bits#(a,sa));
         ...
         endmodule: vMkRWire

The module body may contain both moduleStmts and importBVIStmts. Typically when including a
Verilog module, the only module statements would be a few local deﬁnitions. However, all module
statements, except for method deﬁnitions, sub-interface deﬁnitions, and return statements, are valid,
though most are rarely used in this instance. Only the statements speciﬁc to importBVIStmt bodies
are described in this section.

The importBVIStmts must occur at the end of the body, after the moduleStmts. They may be
written in any order.

The following is an example of embedding a Verilog SRAM model in BSV. The Verilog ﬁle is shown
after the BSV wrapper.

import &quot;BVI&quot; mkVerilog_SRAM_model =

     module mkSRAM #(String filename) (SRAM_Ifc #(addr_t, data_t))

     provisos(Bits#(addr_t, addr_width),

                 Bits#(data_t, data_width));

     parameter FILENAME  = filename;

     parameter ADDRESS_WIDTH = valueOf(addr_width);

124              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                       Reference Guide

       parameter DATA_WIDTH = valueof(data_width);
       method request (v_in_address, v_in_data, v_in_write_not_read)

                                 enable (v_in_enable);
       method v_out_data read_response;
       default_clock clk(clk, (*unused*) clk_gate);
       default_reset no_reset;
       schedule (read_response) SB (request);
endmodule

This is the Verilog module being wrapped in the above BVI import statement.

module mkVerilog_SRAM_model (clk,

                            v_in_address, v_in_data,

                            v_in_write_not_read,

                            v_in_enable,

                            v_out_data);

parameter FILENAME          = &quot;Verilog_SRAM_model.data&quot;;

parameter ADDRESS_WIDTH = 10;

parameter DATA_WIDTH = 8;

parameter NWORDS            = (1 &lt;&lt; ADDRESS_WIDTH);

input  [ADDRESS_WIDTH-1:0]  clk;
input  [DATA_WIDTH-1:0]     v_in_address;
input                       v_in_data;
input                       v_in_write_not_read;
input                       v_in_enable;

   output [DATA_WIDTH-1:0]  v_out_data;
   ...
endmodule

15.1 Parameter statement

The parameter statement speciﬁes the parameter values which will be used by the Verilog module.

   parameterBVIStmt ::= parameter identiﬁer = expression ;

The value of expression is supplied to the Verilog module as the parameter named identiﬁer. The
expression must be a compile-time constant. The valid types for parameters are String, Integer
and Bit#(n ). Example:

import &quot;BVI&quot; ClockGen =

module vAbsoluteClock#(Integer start, Integer period)

                        ( ClockGenIfc );

     let halfPeriod = period/2 ;

     parameter initDelay = start;         //the parameters start,

     parameter v1Width = halfPeriod ;     //halfPeriod and period

     parameter v2Width = period - halfPeriod ; //must be compile-time constants

...

endmodule

15.2 Method

The method statement is used to connect methods in a Bluespec interface to the appropriate Verilog
wires. The syntax imitates a function prototype in that it doesn’t deﬁne, but only declares. In the

                        c 2008 Bluespec, Inc. All rights reserved            125


Reference Guide                                                               Bluespec SystemVerilog

case of the method statement, instead of declaring types, it declares ports.

methodBVIStmt    ::= method [ portId ] identifer [ ( [ portId { , portId } ] ) ]
                      [ enable (portId ) ] [ ready ( portId ) ]
                      [ clocked_by ( clockId ) ] [ reset_by ( resetId ) ] ;

The ﬁrst portId is the output port for the method, and is only used when the method has a return
value. The identiﬁer is the method’s name according to the BSV interface deﬁnition. The paren-
thesized list is the input port names corresponding to the method’s arguments, if there are any.
There may follow up to four optional clauses (in any order): enable (for the enable input port if the
method has an Action component), ready (for the ready output port), clocked_by (to indicate the
clock of the method, otherwise the default clock will be assumed) and reset_by (for the associated
reset signal, otherwise the default reset will be assumed). If no ready port is given, the constant
value 1 is used meaning the method is always ready. The names no_clock and no_reset can be used
in clocked_by and reset_by clauses indicating that there is no associated clock and no associated
reset, respectively.

If the input port list is empty and none of the optional clauses are speciﬁed, the list and its paren-
theses may be omitted. If any of the optional clauses are speciﬁed, the empty list () must be shown.
Example:

     method CLOCKREADY_OUT clockready() clocked_by(clk);

If there was no clocked_by statement, the following would be allowed:

     method CLOCKREADY_OUT clockready;

The BSV types of all the method’s arguments and its result (if any) must all be in the Bits typeclass.

Any of the port names may have an attribute attached to them. The allowable attributes are reg,
const, unused, and inhigh. The attributes are translated into port descriptions. Not all port
attributes are allowed on all ports.

For the output ports, the ready port and the method return value, the properties reg and const
are allowed. The reg attribute speciﬁes that the value is coming directly from a register with no
intermediate logic. The const attribute indicates that the value is hardwired to a constant value.

For the input ports, the input arguments and the enable port, reg and unused are allowed. In this
context reg speciﬁes that the value is immediately written to a register without intermediate logic.
The attribute unused indicates that the port is not used inside the module; its value is ignored.

Additionally, for the method enable, there is the inhigh property, which indicates that the method
is always_enabled, as described in Section 13.2.2. Inside the module, the value of the enable is
assumed to be 1 and, as a result, the port doesn’t exist. The user still gives a name for the port as
a placeholder. Note that only Action or ActionValue methods can have an enable signal.

The following code fragment shows an attribute on a method enable:

     method load(flopA, flopB) enable((*inhigh*) EN);

The output ports may be shared across methods (and ready signals).

15.3 Port statement

The port statement declares an input port, which is not part of a method, along with the value to
be passed to the port. While parameters must be compile-time constants, ports can be dynamic.

126              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

The port statements are analogous to arguments to a BSV module, but are rarely needed, since
BSV style is to interact and pass arguments through methods.

portBVIStmt             ::= port identiﬁer [ clocked_by ( clockId ) ]
                             [ reset_by ( resetId ) ] = expression ;

The deﬁning operator &lt;- or = may be used.

The value of expression is supplied to the Verilog port named identiﬁer. The type of expression
must be in the Bits typeclass. The expression may be dynamic (e.g. the _read method of a register
instantiated elsewhere in the module body), which diﬀerentiates it from a parameter statement. The
Bluespec compiler cannot check that the import has speciﬁed the same size as declared in the Verilog
module. If the width of the value is not the same as that expected by the Verilog module, Verilog
will truncate or zero-extend the value to ﬁt.

Example - Setting port widths to a speciﬁc width:

// Tie off the test ports
    port TM = 1’b0 ; // This ties off the port TM to a 1 bit wide 0
    Bit#(w) z = 0;
    port TD = z ; // This ties off the port TD to w bit wide 0

The clocked_by clause is used to specify the clock domain that the port is associated with, named
by clockId. Any clock in the domain may be used. The values no_clock and default_clock, as
described in Section 15.5, may be used. If the clause is omitted, the associated clock is the default
clock.

Example - BVI import statement including port statements

        port BUS_ID clocked_by (clk2) = busId ;

The reset_by clause is used to specify the reset the port is associated with, named by resetId. Any
reset in the domain may be used. The values no_reset and default_reset, as described in Section
15.8 may be used. If the clause is omitted, the associated reset is the default reset.

15.4 Input clock statement

The input_clock statement speciﬁes how an incoming clock to a module is connected. Typically,
there are two ports, the oscillator and the gate, though the connection may use fewer ports.

inputClockBVIStmt ::= input_clock [ identiﬁer ] ( [ portsDef ] ) = expression ;

portsDef                ::= portId [ , [ attributeInstances ] portId ]

portId                  ::= identiﬁer

The deﬁning operator = or &lt;- may be used.

The identiﬁer is the clock name which may be used elsewhere in the import to associate the clock with
resets and methods via a clocked_by clause, as described in Sections 15.7 and 15.2. The portsDef
statement describes the ports that deﬁne the clock. The clock value which is being connected is
given by expression.

If the expression is an identiﬁer being assigned with =, and the user wishes this to be the name of
the clock, then the identiﬁer of the clock can be omitted and the expression will be assumed to be
the name. The clock name can be omitted in other circumstances, but then no name is associated
with the clock. An unamed clock cannot be referred to elsewhere, such as in a method or reset or
other statement. Example:

                        c 2008 Bluespec, Inc. All rights reserved                127


Reference Guide                                                         Bluespec SystemVerilog

     input_clock (OSC, GATE) = clk;

is equivalent to:

     input_clock clk (OSC, GATE) = clk;

The user may leave oﬀ the gate (one port) or the gate and the oscillator (no ports). It is the
designer’s responsibility to ensure that not connecting ports does not lead to incorrect behavior. For
example, if the Verilog module is purely combinational, there is no requirement to connect a clock,
though there may still be a need to associate its methods with a clock to ensure that they are in
the correct clock domain. In this case, the portsDef would be omitted. Example of an input clock
without any connection to the Verilog ports:

     input_clock ddClk() = dClk;

If the clock port is speciﬁed and the gate port is to be unconnected, an attribute, either unused
or inhigh, describing the gate port should be speciﬁed. The attribute unused indicates that the
submodule doesn’t care what the unconnected gate is, while inhigh speciﬁes the gate is assumed in
the module to be logical 1. It is an error if a clock with a gate that is not logical 1 is connected to
an input clock with an inhigh attribute. The default when a gate port is not speciﬁed is inhigh,
though it is recommended style that the designer specify the attribute explicitly.

To add an attribute, the usual attribute syntax, (* attribute_name *) immediately preceeding
the object of the attribute, is used. For example, if a Verilog module has no internal transitions and
responds only to method calls, it might be unnecessary to connect the gating signal, as the implicit
condition mechanism will ensure that no method is invoked if its clock is oﬀ. So the second portId,
for the gate port, would be marked unused.

     input_clock ddClk (OSC, (*unused*) UNUSED) = dClk;

The options for specifying the clock ports in the portsDef clause are:

     ()                     // there are no Verilog ports
     (OSC, GATE)            // both an oscillator port and a gate port are specified
     (OSC, (*unused*)GATE)  // there is no gate port and it’s unused
     (OSC, (*inhigh*)GATE)  // there is no gate port and it’s required to be logical 1
     (OSC)                  // same as (OSC, (*inhigh*) GATE)

In an input_clock statement, it is an error if both the port names and the input clock name are
omitted, as the clock is then unusable.

15.5 Default clock

In BSV, each module has an implicit clock (the current clock ) which is used to clock all instantiated
submodules unless otherwise speciﬁed with a clocked_by clause. Other clocks to submodules must
be explicitly passed as input arguments.

Every BVI import module must declare which input clock (if any) is the default clock. This default
clock is the implicit clock provided by the parent module, or explicitly given via a clocked_by
clause. The default clock is also the clock associated with methods and resets in the BVI import
when no clocked_by clause is speciﬁed.

The simplest deﬁnition for the default clock is:

128                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

   defaultClockBVIStmt ::= default_clock identiﬁer ;
where the identiﬁer speciﬁes the name of an input clock which is designated as the default clock.
The default clock may be unused or not connected to any ports, but it must still be declared.
Example:

      default_clock no_clock;

This statement indicates the implicit clock from the parent module is ignored (and not connected).
Consequently, the default clock for methods and resets becomes no_clock, meaning there is no
associated clock.
To save typing, you can merge the default_clock and input_clock statements into a single line:

   defaultClockBVIStmt ::= default_clock [ identiﬁer ] [ ( portsDef ) ] [ = expression ] ;
The deﬁning operator = or &lt;- may be used.
This is precisely equivalent to deﬁning an input clock and then declaring that clock to be the default
clock. Example:

      default_clock clk_src (OSC, GATE) = sClkIn;

is equivalent to:

      input_clock clk_src (OSC, GATE) = sClkIn;
      default_clock clk_src;

If omitted, the = expression in the default_clock statement defaults to &lt;- exposeCurrentClock.
Example:

      default_clock xclk (OSC, GATE);

is equivalent to:

      default_clock xclk (OSC, GATE) &lt;- exposeCurrentClock;

If the portnames are excluded, the names default to CLK, CLK_GATE. Example:

      default_clock xclk = clk;

is equivalent to:

      default_clock xclk (CLK, CLK_GATE) = clk;

Alternately, if the expression is an identiﬁer being assigned with =, and the user wishes this to be
the name of the default clock, then he can leave oﬀ the name of the default clock and expression
will be assumed to be the name. Example:

      default_clock (OSC, GATE) = clk;

is equivalent to:

      default_clock clk (OSC, GATE) = clk;

If an expression is provided, both the ports and the name cannot be omitted.
However, omitting the entire statement is equivalent to:

      default_clock (CLK, CLK_GATE) &lt;- exposeCurrentClock;

specifying that the current clock is to be associated with all methods which do not specify otherwise.

                        c 2008 Bluespec, Inc. All rights reserved  129


Reference Guide                                               Bluespec SystemVerilog

15.6 Output clock

The output_clock statement gives the port connections for a clock provided in the module’s inter-
face.

   outputClockBVIStmt ::= output_clock identiﬁer [ ( portsDef ) ];
The identiﬁer deﬁnes the name of the output clock, which must match a clock declared in the
module’s interface. Example:

       interface ClockGenIfc;
           interface Clock gen_clk;

       endinterface

       import &quot;BVI&quot; ClockGen =
       module vMkAbsoluteClock #( Integer start,

                                          Integer period
                                         ) ( ClockGenIfc );
            ...
            output_clock gen_clk(CLK_OUT);
       endmodule

It is an error for the same identiﬁer to be declared by more than one output_clock statement.

15.7 Input reset

The input_reset statement deﬁnes how an incoming reset to the module is connected. Typically
there is one port. BSV assumes that the reset is inverted (the reset is asserted with the value 0).

inputResetBVIStmt ::= input_reset [ identiﬁer ] [ ( portId ) ] [ clocked_by ( clockId ) ]
                                   = expression ;

portId             ::= identiﬁer

clockId            ::= identiﬁer

where the = may be replaced by &lt;-.

The reset given by expression is to be connected to the Verilog port speciﬁed by portId. The identiﬁer
is the name of the reset and may be used elsewhere in the import to associate the reset with methods
via a reset_by clause.

The clocked_by clause is used to specify the clock domain that the reset is associated with, named
by clockId. Any clock in the domain may be used. If the clause is omitted, the associated clock is
the default clock. Example:

     input_reset rst(sRST_N) = sRstIn;

is equivalent to:

     input_reset rst(sRST_N) clocked_by(clk) = sRstIn;

where clk is the identiﬁer named in the default_clock statement.

If the user doesn’t care which clock domain is associated with the reset, no_clock may be used. In
this case the compiler will not check that the connected reset is associated with the correct domain.
Example

130                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

      input_reset rst(sRST_N) clocked_by(no_clock) = sRstIn;

If the expression is an identiﬁer being assigned with =, and the user wishes this to be the name of the
reset, then he can leave oﬀ the identiﬁer of the reset and the expression will be assumed to be the
name. The reset name can be left oﬀ in other circumstances, but then no name is associated with
the reset. An unamed reset cannot be referred to elsewhere, such as in a method or other statement.

In the cases where a parent module needs to associate a reset with methods, but the reset is not
used internally, the statement may contain a name, but not specify a port. In this case, there is no
port expected in the Verilog module. Example:

      input_reset rst() clocked_by (clk_src) = sRstIn ;

Example of a BVI import statement containing an input_reset statement:

       import &quot;BVI&quot; SyncReset =
       module vSyncReset#(Integer stages ) ( Reset rstIn, ResetGenIfc rstOut ) ;

            ...
            // we don’t care what the clock is of the input reset
            input_reset rst(IN_RST_N) clocked_by (no_clock) = rstIn ;
            ...
       endmodule

15.8 Default reset

In BSV, when you deﬁne a module, it has an implicit reset (the current reset) which is used to
reset all instantiated submodules (unless otherwise specifed via a reset_by clause). Other resets to
submodules must be explicitly passed as input arguments.

Every BVI import module must declare which reset, if any, is the default reset. The default reset
is the implicit reset provided by the parent module (or explicitly given with a reset_by). The
default reset is also the reset associated with methods in the BVI import when no reset_by clause
is speciﬁed.

The simplest deﬁnition for the default reset is:

   defaultResetBVIStmt ::= default_reset identiﬁer ;

where identiﬁer speciﬁes the name of an input reset which is designated as the default reset.

The reset may be unused or not connected to a port, but it must still be declared. Example:

       default_reset no_reset;

The keyword default_reset may be omitted when declaring an unused reset. The above statement
can thus be written as:

no_reset;               // the default_reset keyword can be omitted

This statement declares that the implicit reset from the parent module is ignored (and not con-
nected). In this case, the default reset for methods becomes no_reset, meaning there is no associated
reset.

To save typing, you can merge the default_reset and input_reset statements into a single line:

   defaultResetBVIStmt ::= default_reset [ identiﬁer ] [ ( portId ) ] [ clocked_by ( clockId ) ]
                                      [ = expression ] ;

The deﬁning operator = or &lt;- may be used.

This is precisely equivalent to deﬁning an input reset and then declaring that reset to be the default.
Example:

                        c 2008 Bluespec, Inc. All rights reserved    131


Reference Guide                                             Bluespec SystemVerilog

      default_reset rst (RST_N) clocked_by (clk) = sRstIn;
is equivalent to:

      input_reset rst (RST_N) clocked_by (clk) = sRstIn;
      default_reset rst;
If omitted, = expression in the default_reset statement defaults to &lt;- exposeCurrentReset.
Example:
      default_reset rst (RST_N);
is equivalent to
      default_reset rst (RST_N) &lt;- exposeCurrentReset;
The clocked_by clause is optional; if omitted, the reset is clocked by the default clock. Example:
      default_reset rst (sRST_N) = sRstIn;
is equivalent to
      default_reset rst (sRST_N) clocked_by(clk) = sRstIn;
where clk is the default_clock.
If no_clock is speciﬁed, the reset is not associated with any clock. Example:
      input_reset rst (sRST_N) clocked_by(no_clock) = sRstIn;
If the portId is excluded, the reset port name defaults to RST_N. Example:
      default_reset rstIn = rst;
is equivalent to:
      default_reset rstIn (RST_N) = rst;
Alternatively, if the expression is an identiﬁer being assigned with =, and the user wishes this to be
the name of the default reset, then he can leave oﬀ the name of the default reset and expression will
be assumed to be the name. Example:
      default_reset (rstIn) = rst;
is equivalent to:
      default_reset rst (rstIn) = rst;
Both the ports and the name cannot be omitted.
However, omitting the entire statement is equivalent to:
      default_reset (RST_N) &lt;- exposeCurrentReset;
specifying that the current reset is to be associated with all methods which do not specify otherwise.

132              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                         Reference Guide

15.9 Output reset

The output_reset statement gives the port connections for a reset provided in the module’s inter-
face.

   outputResetBVIStmt ::= output_reset identiﬁer [ ( portId ) ] [ clocked_by ( clockId ) ];
The identiﬁer deﬁnes the name of the output reset, which must match a reset declared in the
module’s interface. Example:

       interface ResetGenIfc;
           interface Reset gen_rst;

       endinterface

       import &quot;BVI&quot; SyncReset =
       module vSyncReset#(Integer stages ) ( Reset rstIn, ResetGenIfc rstOut ) ;

            ...
            output_reset gen_rst(OUT_RST_N) clocked_by(clk) ;
       endmodule

It is an error for the same identiﬁer to be declared by more than one output_reset statement.

15.10 Ancestor, same family

There are two statements for specifying the relationship between clocks: ancestor and same_family.
   ancestorBVIStmt ::= ancestor ( clockId , clockId ) ;

This statement indicates that the second named clock is an ancestor of the ﬁrst named clock. To
say that clock1 is an ancestor of clock2, means that clock2 is a gated version of clock1. This
is written as:

      ancestor (clock2, clock1);

For clocks which do not have an ancestor relationship, but do share a common ancestor, we have:
   sameFamilyBVIStmt ::= same_family ( clockId , clockId ) ;

This statement indicates that the clocks speciﬁed by the clockIds are in the same family (same clock
domain). When two clocks are in the same family, they have the same oscillator with a diﬀerent
gate. To be in the same family, one does not have to be a gated version of the other, instead they
may be gated versions of a common ancestor. Note that ancestor implies same_family, which then
need not be explicitly stated. For example, a module which gates an input clock:

      input_clock clk_in(CLK_IN, CLK_GATE_IN) = clk_in ;
      output_clock new_clk(CLK_OUT, CLK_GATE_OUT);
      ancestor(new_clk, clk_in);

15.11 Schedule

scheduleBVIStmt         ::= schedule ( identiﬁer { , identiﬁer } ) operatorId
operatorId                   ( identiﬁer { , identiﬁer } );

                        ::= CF
                        | SB

                        c 2008 Bluespec, Inc. All rights reserved              133


Reference Guide                                                           Bluespec SystemVerilog

                                 | SBR
                                 |C

The schedule statement speciﬁes the scheduling constraints between methods in an imported mod-
ule. The operators relate two sets of methods; the speciﬁed relation is understood to hold for each
pair of an element of the ﬁrst set and an element of the second set. The order of the methods in the
lists is unimportant and the parentheses may be omitted if there is only one name in the set.

The meanings of the operators are:

     CF          conﬂict-free

     SB          sequences before

     SBR         sequences before, with range conﬂict (that is, not composable in parallel)

     C           conﬂicts

It is an error to specify two relationships for the same pair of methods. It is an error to specify a
scheduling annotation other than CF for methods clocked by unrelated clocks. For such methods,
CF is the default; for methods clocked by related clocks the default is C. The compiler generates a
warning if an annotation between a method pair is missing. Example:

import &quot;BVI&quot; FIFO2 =

module vFIFOF2_MC                   ( Clock sClkIn, Reset sRstIn,

                                    Clock dClkIn, Reset dRstIn,

                                    Clock realClock, Reset realReset,

                                    FIFOF_MC#(a) ifc )

                                    provisos (Bits#(a,sa));

     ...

     method        enq( D_IN ) enable(ENQ) clocked_by( clk_src ) reset_by( srst ) ;

     method FULL_N notFull          clocked_by( clk_src ) reset_by( srst ) ;

     method        deq()            enable(DEQ) clocked_by( clk_dst ) reset_by( drst ) ;
                                                       clocked_by( clk_dst ) reset_by( drst ) ;
     method D_OUT first                                clocked_by( clk_dst ) reset_by( drst ) ;

     method EMPTY_N notEmpty

    schedule (enq, notFull) CF (deq, first, notEmpty) ;
    schedule (first, notEmpty) CF (first, notEmpty) ;
    // CF: conflict free - methods in the first list can be scheduled
    // in any order or any number of times, with the methods in the
    // second list - there is no conflict between the methods.
    schedule first SB deq ;
    schedule (notEmpty) SB (deq) ;
    schedule (notFull) SB (enq) ;
    // SB indicates the order in which the methods must be scheduled
    // the methods in the first list must occur (be scheduled) before
    // the methods in the second list
    // SB allows these methods to be called from one rule but the
    // SBR relationship does not.
    schedule (enq) C (enq) ;
    schedule (deq) C (deq) ;
    schedule (notFull) CF (notFull) ;
    // C: conflicts - methods in the first list conflict with the
    // methods in the second - they cannot be called in the same clock cycle.
    // if a method conflicts with itself, (enq,deq, and notFull), it
    // cannot be called more than once in a clock cycle
endmodule

134                            c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

15.12 Path

The path statement indicates that there is a combinational path from the ﬁrst port to the second
port.

pathBVIStmt             ::= path ( portId , portId ) ;

It is an error to specify a path between ports that are connected to methods clocked by unrelated
clocks. This would be, by deﬁnition, an unsafe clock domain crossing. Note that the compiler
assumes that there will be a path from a value or ActionValue method’s input parameters to its
result, so this need not be speciﬁed explicitly.

The paths deﬁned by the path statement are used in scheduling. A path may impact rule urgency
by implying an order in how the methods are scheduled. The path is also used in checking for
combinational cycles in a design. The compiler will report an error if it detects a cycle in a design.
In the following example, there is a path declared between WSET and WHAS, as shown in ﬁgure 2.

import &quot;BVI&quot; RWire0 =
    module vMkRWire0 (VRWire0);
         ...
         method wset() enable(WSET) ;
         method WHAS whas ;
         schedule whas CF whas ;
         schedule wset SB whas ;
         path (WSET, WHAS) ;
    endmodule: vMkRWire0

Figure 2: Path in the RWire0 Verilog module between WSET and WHAS ports

15.13 Inout

The following statements describe how to pass an inout port from a wrapped Verilog module through
a BSV module. These ports are represented in BSV by the type Inout. There are two ways that
an Inout can appear in BSV modules: as an argument to the module or as a subinterface of the
interface provided by the module. There are, therefore, two ways to declare an Inout port in a
BVI import: the statement inout declares an argument of the current module; and the statement
ifc_inout declares a subinterface of the provided interface.

inoutBVIStmt            ::= inout portId [ clocked_by ( clockId ) ]
                             [ reset_by ( resetId ) ] = expression ;

The value of portId is the Verilog name of the inout port and expression is the name of an argument
from the module.

inoutBVIStmt            ::= ifc_inout identiﬁer (inoutId ) [ clocked_by ( clockId ) ]
                             [ reset_by ( resetId ) ] ;

Here, the identiﬁer is the name of the subinterface of the provided interface and portId is, again,
the Verilog name of the inout port.

                        c 2008 Bluespec, Inc. All rights reserved                      135


Reference Guide                                                   Bluespec SystemVerilog

The clock and reset associated with the Inout are assumed to be the default clock and default reset
unless explicitly speciﬁed.
Example:

   interface Q;
       interface Inout#(Bit#(13)) q_inout;
       interface Clock c_clock;

   endinterface

   import &quot;BVI&quot; Foo =
   module mkFoo#(Bool b)(Inout#(int) x, Q ifc);

       default_clock ();
       no_reset;

       inout iport = x;

       ifc_inout q_inout(qport);
       output_clock c_clock(clockport);
   endmodule

The wrapped Verilog module is:

   module Foo (iport, clockport, qport);
       input cccport;
       inout [31:0] iport;
       inout [12:0] qport;
       ...

   endmodule

16 Embedding C in a BSV Design

This section describes how to declare a BSV function that is provided as a C function. This is used
when there are existing C functions which the designer would like to include in a BSV module. Using
the importBDPI syntax, the user can specify that the implementation of a BSV function is provided
as a C function.

externCImport    ::= import &quot;BDPI&quot; [ identiﬁer = ] function type
                      identiﬁer ( [ CFuncArgs ] ) [ provisos ] ;

CFuncArgs        ::= CFuncArg { , CFuncArg }

CFuncArg         ::= type [ identiﬁer ]

This deﬁnes a function identiﬁer in the BSV source code which is implemented by a C function of
the same name. A diﬀerent link name (C name) can be speciﬁed immediately after the &quot;BDPI&quot;,
using an optional [identiﬁer = ]. The link name is not bound by BSV case-restrictions on identiﬁers
and may start with a capital letter.

Example of an import statement where the C name matches the BSV name:

       // the C function and the BSV function are both named checksum
       import &quot;BDPI&quot; function Bit#(32) checksum (Bit#(n), Bit#(32));

136              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Example of an import statement where the C name does not match the BSV name:

       // the C function name is checksum
       // the BSV function name is checksum_raw
       import &quot;BDPI&quot; checksum = function Bit#(32) checksum_raw (Bit#(n), Bit#(32));

The ﬁrst type speciﬁes the return type of the function. The optional CFuncArgs specify the argu-
ments of the function, along with an optional identiﬁer to name the arguments.
For instance, in the above checksum example, you might want to name the arguments to indicate
that the ﬁrst argument is the input value and the second argument is the size of the input value.

       import &quot;BDPI&quot; function Bit#(32) checksum (Bit#(n) input_val, Bit#(32) input_size);

16.1 Argument Types

The types for the arguments and return value are BSV types. The following table shows the corre-
lation from BSV types to C types.

BSV Type                C Type

String                  char*
Bit#(0) - Bit#(8)       unsigned char
Bit#(9) - Bit#(32)      unsigned int
Bit#(33) - Bit#(64)     unsigned long long
Bit#(65) -              unsigned int*
Bit#(n)                 unsigned int*

The importBDPI syntax provides the ability to import simple C functions that the user may already
have. A C function with an argument of type char or unsigned char should be imported as a BSV
function with an argument of type Bit#(8). For int or unsigned int, use Bit#(32). For long
long or unsigned long long, use Bit#(64). While BSV creates unsigned values, they can be
passed to a C function which will treat the value as signed. This can be reﬂected in BSV with
Int#(8), Int#(32), Int#(64), etc.

The user may also import new C functions written to match a given BSV function type. For instance,
a function on bit-vectors of size 17 (that is, Bit#(17)) would expect to pass this value as the C type
unsigned int and the C function should be aware that only the ﬁrst 17 bits of the value are valid
data.

Wide data Bit vectors of size 65 or greater are passed by reference, as type unsigned int*. This
is a pointer to an array of 32-bit words, where bit 0 of the BSV vector is bit 0 of the ﬁrst word in
the array, and bit 32 of the BSV vector is bit 0 of the second word, etc. Note that we only pass the
pointer; no size value is passed to the C function. This is because the size is ﬁxed and the C function
could have the size hardcoded in it. If the function needs the size as an additional parameter, then
either a C or BSV wrapper is needed. See the examples below.

Polymorphic data As the above table shows, bit vectors of variable size are passed by reference,
as type unsigned int*. As with wide data, this is a pointer to an array of 32-bit words, where bit
0 of the BSV vector is bit 0 of the ﬁrst word in the array, and bit 32 of the BSV vector is bit 0 of
the second word, etc. No size value is passed to the C function, because the import takes no stance
on how the size should be communicated. The user will need to handle the communication of the
size, typically by adding an additional argument to the import function and using a BSV wrapper
to pass the size via that argument, as follows:

                        c 2008 Bluespec, Inc. All rights reserved  137


Reference Guide                                             Bluespec SystemVerilog

     // This function computes a checksum for any size bit-vector
     // The second argument is the size of the input bit-vector
     import &quot;BDPI&quot; checksum = function Bit#(32) checksum_raw (Bit#(n), Bit#(32));

     // This wrapper handles the passing of the size
     function Bit#(32) checksum (Bit#(n) vec);

         return checksum_raw(vec, fromInteger(valueOf(n)));
     endfunction

16.2 Return types

Imported functions can be value functions, Action functions, or ActionValue functions. The ac-
ceptable return types are the same as the acceptable argument types, except that String is not
permitted as a return type.
Imported functions with return values correlate to C functions with return values, except in the
cases of wide and polymorphic data. In those cases, where the BSV type correlates to unsigned
int*, the simulator will allocate space for the return result and pass a pointer to this memory to
the C function. The C function will not be responsible for allocating memory. When the C function
ﬁnishes execution, the simulator copies the result in that memory to the simulator state and frees
the memory. By convention, this special argument is the ﬁrst argument to the C function.
For example, the following BSV import:

       import &quot;BDPI&quot; function Bit#(32) f (Bit#(8));

would connect to the following C function:

       unsigned int f (unsigned char x);

While the following BSV import with wide data:

       import &quot;BDPI&quot; function Bit#(128) g (Bit#(8));

would connect to the following C function:

       void g (unsigned int* resultptr, unsigned char x);

16.3 Implicit pack/unpack

So far we have only mentioned Bit and String types for arguments and return values. Other types
are allowed as arguments and return values, as long as they can be packed into a bit-vector. These
types include Int, UInt, Bool, and Maybe, all of which have an instance in the Bits class.
For example, this is a valid import:

       import &quot;BDPI&quot; function Bool my_and (Bool, Bool);

Since a Bool packs to a Bit#(1), it would connect to a C function such as the following:

       unsigned char
       my_and (unsigned char x, unsigned char y);

138              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

In this next example, we have two C functions, signedGT and unsignedGT, both of which implement
a greater-than function, returning a Bool indicating whether x is greater than y.

       import &quot;BDPI&quot; function Bool signedGT (Int#(32) x, Int#(32) y);
       import &quot;BDPI&quot; function Bool unsignedGT (UInt#(32) x, UInt#(32) y);

Because the function signedGT assumes that the MSB is a sign bit, we use the type-system to make
sure that we only call that function on signed values by specifying that the function only works on
Int#(32). Similarly, we can enforce that unsignedGT is only called on unsigned values, by requiring
its arguments to be of type UInt#(32).
The C functions would be:

       unsigned char signedGT (unsigned int x, unsigned int y);
       unsigned char unsignedGT (unsigned int x, unsigned int y);

In both cases, the packed value is of type Bit#(32), and so the C function is expected to take the its
arguments as unsigned int. The diﬀerence is that the signedGT function will then treat the values
as signed values while the unsignedGT function will treat them as unsigned values. Both functions
return a Bool, which means the C return type is unsigned char.
Argument and return types to imported functions can also be structs, enums, and tagged unions.
The C function will receive the data in bit form and must return values in bit form.

16.4 Other examples

Shared resources In some situations, several imported functions may share access to a resource,
such as memory or the ﬁle system. If these functions wish to share ﬁle handles, pointers, or other
cookies between each other, they will have to pass the data as a bit-vector, such as unsigned
int/Bit#(32).

When to use Action components If an imported function has a side eﬀect or if it matters
how many times or in what order the function is called (relative to other calls), then the imported
function should have an Action component in its BSV type. That is, the functions should have a
return type of Action or ActionValue.

Removing indirection for polymorphism within a range A polymorphic type will always
become unsigned int* in the C, even if there is a numeric proviso which restricts the size. Consider
the following import:

       import &quot;BDPI&quot; function Bit#(n) f(Bit#(n), Bit#(8)) provisos (Add#(n,j,32));

This is a polymorphic vector, so the conversion rules indicate that it should appear as unsigned
int* in the C. However, the proviso indicates that the value of n can never be greater than 32. To
make the import be a speciﬁc size and not a pointer, you could use a wrapper, as in the example
below.

       import &quot;BDPI&quot; f = function Bit#(32) f_aux(Bit#(32), Bit#(8));

       function Bit#(n) f (Bit#(n) x) provisos (Add#(n,j,32));
            return f_aux(extend(x), fromInteger(valueOf(n)));

       endfunction

                        c 2008 Bluespec, Inc. All rights reserved  139


Reference Guide                                             Bluespec SystemVerilog

References

[Acc04] Accellera. SystemVerilog 3.1a Language Reference Manual: Accellera’s Extensions to Ver-
           ilog (R), 2004. See: www.accelera.org, www.systemverilog.org.

[IEE01] IEEE. IEEE Standard Verilog (R) Hardware Description Language, March 2001. IEEE Std
           1364-2001.

[IEE02] IEEE. IEEE Standard VHDL Language Reference Manual, IEEE Std 1076-1993, 2002.

[Ter03] Terese. Term Rewriting Systems. Cambridge University Press, 2003.

140              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

A Keywords

In general, keywords do not use uppercase letters (the only exception is the keyword valueOf). The
following are the keywords in BSV (and so they cannot be used as identiﬁers).

Action                  endaction
ActionValue             endactionvalue
BVI                     endcase
C
CF                      endfunction
SB
SBR                     endinstance
action                  endinterface
actionvalue             endmethod
ancestor                endmodule
begin                   endpackage
bit
case
clocked_by
default
default_clock
default_reset
dependencies
deriving
determines
else
enable
end
enum
export
for
function
if
ifc_inout
import
inout
input_clock
input_reset
instance
interface
let
match
matches
method
module
numeric
output_clock
output_reset
package
parameter
path
port
provisos
reset_by

                        c 2008 Bluespec, Inc. All rights reserved  141


Reference Guide                                             Bluespec SystemVerilog

   return        endrule
   rule          endrules
   rules
   same_family   endtypeclass
   schedule
   struct
   tagged
   type
   typeclass
   typedef
   union
   valueOf
   valueof
   void
   while

142              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

The following are keywords in SystemVerilog (which includes all the keywords in Verilog). Although
most of them are not used in BSV, for compatibility reasons they are not allowed as identiﬁers in
BSV either.

alias                   expect                   negedge

always                  export                   new

always_comb             extends                  nmos

always_ff               extern                   nor

always_latch            final                    noshowcancelled

and                     first_match              not

assert                  for                      notif0

assert_strobe           force                    notif1

assign                  foreach                  null

assume                  forever                  or

automatic               fork                     output

before                  forkjoin                 package           endpackage

begin end               function endfunction     packed

bind                    generate endgenerate     parameter

bins                    genvar                   pmos

binsof                  highz0                   posedge

bit                     highz1                   primitive endprimitive

break                   if                       priority

buf                     iff                      program           endprogram

bufif0                  ifnone                   property endproperty

bufif1                  ignore_bins              protected

byte                    illegal_bins             pull0

case endcase            import                   pull1

casex                   incdir                   pulldown

casez                   include                  pullup

cell                    initial                  pulsestyle_onevent

chandle                 inout                    pulsestyle_ondetect

class        endclass   input                    pure

clocking endclocking    inside                   rand

cmos                    instance                 randc

config       endconfig  int                      randcase

const                   integer                  randsequence

constraint              interface endinterface   rcmos

context                 intersect                real

continue                join                     realtime

cover                   join_any                 ref

covergroup endgroup     join_none                reg

coverpoint              large                    release

cross                   liblist                  repeat

deassign                library                  return

default                 local                    rnmos

defparam                localparam               rpmos

design                  logic                    rtran

disable                 longint                  rtranif0

dist                    macromodule              rtranif1

do                      matches                  scalared

edge                    medium                   sequence endsequence

else                    modport                  shortint

enum                    module        endmodule  shortreal

event                   nand                     showcancelled

                        c 2008 Bluespec, Inc. All rights reserved              143


Reference Guide                                 Bluespec SystemVerilog

signed      endspecify  time           var
small                   timeprecision  vectored
solve       endtable    timeunit       virtual
specify     endtask     tran           void
specparam               tranif0        wait
static                  tranif1        wait_order
string                  tri            wand
strong0                 tri0           weak0
strong1                 tri1           weak1
struct                  triand         while
super                   trior          wildcard
supply0                 trireg         wire
supply1                 type           with
table                   typedef        within
tagged                  union          wor
task                    unique         xnor
this                    unsigned       xor
throughout              use

144                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

B The Standard Prelude package

This sections describes the type classes, data types, interfaces and functions which are provided by
the Standard Prelude package, and therefore always available to the programmer.
The Standard Prelude package is automatically included in all packages, i.e., the programmer does
not need to take any special action to use any of the features described here. Please see also Section
C for a number of useful libraries that must be explicitly imported into a package in order to use
them.

B.1 Type classes

A type class groups related functions and operators and allows for instances across the various
datatypes which are members of the typeclass. Hence the function names within a type class are
overloaded across the various type class members.

A typeclass declaration creates a type class. An instance declaration deﬁnes a datatype as
belonging to a type class. A datatype may belong to zero or many type classes.

The Prelude package declares the following type classes:

Bits                                    Prelude Type Classes
Eq                      Types that can be converted to bit vectors and back.
Literal                 Types on which equality is deﬁned.
RealLiteral             Types which can be created from integer literals.
Arith                   Types which can be created from real literals.
Ord                     Types on which arithmetic operations are deﬁned.
Bounded                 Types on which comparison operations are deﬁned.
Bitwise                 Types with a ﬁnite range.
BitReduction            Types on which bitwise operations are deﬁned.
                        Types on which bitwise operations on a single operand to produce
BitExtend               a single bit result are deﬁned.
                        Types on which extend operations are deﬁned.

B.1.1 Bits

Bits deﬁnes the class of types that can be converted to bit vectors and back. Membership in this
class is required for a data type to be stored in a state, such as a Register or a FIFO, or to be used
at a synthesized module boundary. Often instance of this class can be automatically derived using
the deriving statement.

    typeclass Bits #(type a, numeric type n)
           function Bit#(n) pack(a x);
           function a unpack(Bit#(n) x);

    endtypeclass

Note: the numeric keyword is not required

The functions pack and unpack are provided to convert elements to Bit#() and to convert Bit#()
elements to another datatype.

pack                                        Bits Functions

                        Converts element a of datatype data_t to a element of datatype
                        Bit#() of size_a.

                        function Bit#(size_a) pack(data_t a);

                        c 2008 Bluespec, Inc. All rights reserved                         145


Reference Guide                                                                  Bluespec SystemVerilog
         unpack
                 Converts an element a of datatype Bit#() and size_a into an
                 element with of element type data_t.
                 function data_t unpack(Bit#(size_a) a);

B.1.2 Eq

Eq deﬁnes the class of types whose values can be compared for equality. Instances of the Eq class
are often automatically derived using the deriving statement.

    typeclass Eq #(type data_t);
           function Bool \== (data_t x, data_t y);
           function Bool \/= (data_t x, data_t y);

    endtypeclass

The equality functions == and != are Boolean functions which return a value of True if the equality
condition is met. When deﬁning an instance of an Eq typeclass, the \== and \/= notations must be
used. If using or referring to the functions, the standard Verilog operators == and != may be used.

                 Eq Functions

     ==          Returns True if x is equal to y.

                 function Bool \== (data_t x, data_t y,);

     !=          Returns True if x is not equal to y.

                 function Bool \/= (data_t x, data_t y,);

B.1.3 Literal

Literal deﬁnes the class of types which can be created from integer literals.

    typeclass Literal #(type data_t);
           function data_t fromInteger(Integer x);
           function Bool inLiteralRange(data_t target, Integer x);

    endtypeclass

The fromInteger function converts an Integer into an element of datatype data_t. Whenever you
write an integer literal in BSV(such as “0” or “1”), there is an implied fromInteger applied to it,
which turns the literal into the type you are using it as (such as Int, UInt, Bit, etc.). By deﬁning
an instance of Literal for your own datatypes, you can create values from literals just as for these
predeﬁned types.

The typeclass also provides a function inLiteralRange that takes an argument of the target type
and an Integer and returns a Bool that indicates whether the Integer argument is in the legal
range of the target type. For example, assuming x has type Bit#(4), inLiteralRange(x, 15)
would return True, but inLiteralRange(x,22) would return False.

146              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                          Reference Guide

fromInteger                               Literal Functions
                        Converts an element x of datatype Integer into an element of data
                        type data_t

                         function data_t fromInteger(Integer x);

inLiteralRange Tests whether an element x of datatype Integer is in the legal
                         range of data type data_t

                           function Bool inLiteralRange(data_t target, Integer x);

B.1.4 RealLiteral

RealLiteral deﬁnes the class of types which can be created from real literals.
    typeclass RealLiteral #(type data_t);
           function data_t fromReal(Real x);
    endtypeclass

The fromReal function converts a Real into an element of datatype data_t. Whenever you write
a real literal in BSV(such as “3.14”), there is an implied fromReal applied to it, which turns the
real into the speciﬁed type. By deﬁning an instance of RealLiteral for a datatype, you can create
values from reals for any type.

fromReal                               RealLiteral Functions
                        Converts an element x of datatype Real into an element of data
                        type data_t

                         function data_t fromReal(Real x);

B.1.5 Arith

Arith deﬁnes the class of types on which arithmetic operations are deﬁned.

    typeclass Arith #(type data_t)
       provisos (Literal#(data_t));
           function data_t \+ (data_t x, data_t y);
           function data_t \- (data_t x, data_t y);
           function data_t negate (data_t x);
           function data_t \* (data_t x, data_t y);
           function data_t \/ (data_t x, data_t y);
           function data_t \% (data_t x, data_t y);
           function data_t abs (data_t x);
           function data_t signum (data_t x);
           function data_t \** (data_t x, data_t y);
           function data_t exp_e (data_t x);
           function data_t log (data_t x);
           function data_t logb (data_t b, data_t x);
           function data_t log2 (data_t x);
           function data_t log10 (data_t x);

    endtypeclass

                        c 2008 Bluespec, Inc. All rights reserved                          147


Reference Guide                                             Bluespec SystemVerilog

The Arith functions provide arithmetic operations. For the arithmetic symbols, when deﬁning an
instance of the Arith typeclasss, the escaped operator names must be used as shown in the tables
below. The negate name may be used instead of the operator for negation. If using or referring to
these functions, the standard (non-escaped) Verilog operators can be used.

                             Arith Functions

     +           Element x is added to element y.

                 function data_t \+ (data_t x, data_t y);

     -           Element y is subtracted from element x.

                 function data_t \- (data_t x, data_t y);

     negate      Change the sign of the number. When using the function the Ver-
     -           ilog negate operator, -, may be used.

                 function data_t negate (data_t x);

     *           Element x is multiplied by y.

                 function data_t \* (data_t x, data_t y);

     /           Element x is divided by y. The deﬁnition depends on the type -

                 many types truncate the remainder . Note: may not be synthesiz-

                 able with downstream tools.

                 function data_t \/ (data_t x, data_t y);

     %           Returns the remainder of x/y. Obeys the identity ((x/y) ∗ y) +

                 (x%y) = x.

                 function data_t \% (data_t x, data_t y);

Note: Division by 0 is undeﬁned. Both x/0 and x%0 will generate errors at compile-time and
run-time for most instances.

     abs         Returns the absolute value of x.

                 function data_t abs (data_t x);

     signum      Returns a unit value with the same sign as x, such that
                 abs(x)*signum(x) = 1. signum(12) returns 1 and signum(-12)
                 returns -1.

                 function data_t signum (data_t x);

148              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                       Reference Guide

**                      The element x is raised to the y power (x**y = xy).

                        function data_t \** (data_t x, data_t y);

log2                    Returns the base 2 logarithm of x (log 2x).
                        function data_t log2(data_t x) ;

exp_e                   e is raised to the power of x (ex).
                        function data_t exp_e (data_t x);

log                     Returns the base e logarithm of x (log ex).

                        function data_t log (data_t x);

logb                    Returns the base b logarithm of x (log bx).
                        function data_t logb (data_t b, data_t x);

log10                   Returns the base 10 logarithm of x (log 10x).
                        function data_t log10(data_t x) ;

B.1.6 Ord
Ord deﬁnes the class of types for which an order is deﬁned, which allows comparison operations.

typpeclass Ord #(type data_t);
      function Bool \&lt; (data_t x, data_t y);
      function Bool \&lt;= (data_t x, data_t y);
      function Bool \&gt; (data_t x, data_t y);
      function Bool \&gt;= (data_t x, data_t y);

endtypeclass

The Ord functions are Boolean functions which return a value of True if the comparison condition
is met.

                        Ord Functions

&lt;                       Returns True if x is less than y.

                        function Bool \&lt; (data_t x, data_t y);

&lt;=                      Returns True if x is less than or equal to y.

                        function Bool \&lt;= (data_t x, data_t y);

                        c 2008 Bluespec, Inc. All rights reserved            149


Reference Guide                                                                  Bluespec SystemVerilog
         &gt;       Returns True if x is greater than y.
                 function Bool \&gt; (data_t x, data_t y);
         &gt;=
                 Returns True if x is greater than or equal to y.
                 function Bool \&gt;= (data_t x, data_t y);

B.1.7 Bounded

Bounded deﬁnes the class of types with a ﬁnite range and provides functions to deﬁne the range.

    typeclass Bounded #(type data_t);
           data_t minBound;
           data_t maxBound;

    endtypeclass

The Bounded functions minBound and maxBound deﬁne the minimum and maximum values for the
type data_t.

     minBound                      Bounded Functions
                 The minimum value the type data_t can have.

                 data_t minBound;

     maxBound    The maximum value the type data_t can have.
                 data_t maxBound;

B.1.8 Bitwise

Bitwise deﬁnes the class of types on which bitwise operations are deﬁned.

    typeclass Bitwise #(type data_t);
           function data_t \&amp; (data_t x1, data_t x2);
           function data_t \| (data_t x1, data_t x2);
           function data_t \^ (data_t x1, data_t x2);
           function data_t \~^ (data_t x1, data_t x2);
           function data_t \^~ (data_t x1, data_t x2);
           function data_t invert (data_t x1);
           function data_t \&lt;&lt; (data_t x1, Nat x2);
           function data_t \&gt;&gt; (data_t x1, Nat x2);

    endtypeclass

The Bitwise functions compare two operands bit by bit to calculate a result. That is, the bit in the
ﬁrst operand is compared to its equivalent bit in the second operand to calculate a single bit for the
result.

150              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

                                      Bitwise Functions

&amp;                       Performs an and operation on each bit in x1 and x2 to calculate

                        the result.

                        function data_t \&amp; (data_t x1, data_t x2);

|                       Performs an or operation on each bit in x1 and x2 to calculate the

                        result.

                        function data_t \| (data_t x1, data_t x2);

^                       Performs an exclusive or operation on each bit in x1 and x2 to

                        calculate the result.

                        function data_t \^ (data_t x1, data_t x2);

~^                      Performs an exclusive nor operation on each bit in x1 and x2 to

                        calculate the result.

^~

                        function data_t \~^ (data_t x1, data_t x2);
                        function data_t \^~ (data_t x1, data_t x2);

~                       Performs a unary negation operation on each bit in x1. When using
invert                  this function, the corresponding Verilog operator, ~, may be used.

                        function data_t invert (data_t x1);

&lt;&lt;                      Performs a left shift operation of x1 by the number of bit positions

                        given by x2.

                        function data_t \&lt;&lt; (data_t x1, Nat x2);

&gt;&gt;                      Performs a right shift operation of x1 by the number of bit positions

                        given by x2.

                        function data_t \&gt;&gt; (data_t x1, Nat x2);

B.1.9 BitReduction

BitReduction deﬁnes the class of types on which the Verilog bit reduction operations are deﬁned.
    typeclass BitReduction #(type x, numeric type n)
           function x#(1) reduceAnd (x#(n) d);
           function x#(1) reduceOr (x#(n) d);
           function x#(1) reduceXor (x#(n) d);
           function x#(1) reduceNand (x#(n) d);
           function x#(1) reduceNor (x#(n) d);
           function x#(1) reduceXnor (x#(n) d);
    endtypeclass

                        c 2008 Bluespec, Inc. All rights reserved                              151


Reference Guide                                             Bluespec SystemVerilog

Note: the numeric keyword is not required

The BitReduction functions take a sized type and reduce it to one element. The most common
example is to operate on a Bit#() to produce a single bit result. The ﬁrst step of the operation
applies the operator between the ﬁrst bit of the operand and the second bit of the operand to produce
a result. The function then applies the operator between the result and the next bit of the operand,
until the ﬁnal bit is processed.

Typically the bit reduction operators will be accessed through their Verilog operators. When deﬁning
a new instance of the BitReduction type class the BSV names must be used. The table below lists
both values. For example, the BSV bit reduction and operator is reduceAnd and the corresponding
Verilog operator is &amp;.

     reduceAnd                 BitReduction Functions
     &amp;           Performs an and bit reduction operation between the elements of
                 d to calculate the result.

                 function x#(1) reduceAnd (x#(n) d);

     reduceOr    Performs an or bit reduction operation between the elements of d
     |           to calculate the result.

                 function x#(1) reduceOr (x#(n) d);

     reduceXor   Performs an xor bit reduction operation between the elements of d
     ^           to calculate the result.

                 function x#(1) reduceXor (x#(n) d);

     reduceNand  Performs an nand bit reduction operation between the elements of
     ^&amp;          d to calculate the result.

                 function x#(1) reduceNand (x#(n) d);

     reduceNor   Performs an nor bit reduction operation between the elements of d
     ~|          to calculate the result.

                 function x#(1) reduceNor (x#(n) d);

     reduceXnor  Performs an xnor bit reduction operation between the elements of
                 d to calculate the result.
     ~^
     ^~          function x#(1) reduceXnor (x#(n) d);

152              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

B.1.10 BitExtend

BitExtend deﬁnes types on which bit extension operations are deﬁned.

typeclass BitExtend #(numeric type m, numeric type n, type x);        // n &gt; m
      function x#(n) extend (x#(m) d);
      function x#(n) zeroExtend (x#(m) d);
      function x#(n) signExtend (x#(m) d);
      function x#(m) truncate (x#(n) d);

endtypeclass

The BitExtend operations take as input of one size and changes it to an input of another size, as
described in the tables below. It is recommended that extend be used in place of zeroExtend or
signExtend, as it will automatically perform the correct operation based on the data type of the
argument.

extend                                  BitExtend Functions
                        Performs either a zeroExtend or a signExtend as appropriate, de-
                        pending on the data type of the argument (zeroExtend for an un-
                        signed argument, signExtend for a signed argument).

                        function x#(n) extend (x#(m) d)
                            provisos (Add#(k, m, n));

zeroExtend              Use of extend instead is recommended. Adds extra zero bits to
                        the MSB of argument d of size m to make the datatype size n.

                        function x#(n) zeroExtend (x#(m) d)
                            provisos (Add#(k, m, n));

signExtend              Use of extend instead is recommended. Adds extra sign bits to
                        the MSB of argument d of size m to make the datatype size n by
                        replicating the sign bit.

                        function x#(n) signExtend (x#(m) d)
                            provisos (Add#(k, m, n));

truncate                Removes bits from the MSB of argument d of size n to make the
                        datatype size m.

                        function x#(m) truncate (x#(n) d)
                            provisos (Add#(k, n, m));

B.2 Data Types

Every variable and every expression in BSV has a type. Prelude deﬁnes the data types which are
always available. An instance declaration deﬁnes a data type as belonging to a type class. Each
data type may belong to one or more type classes; all functions, modules, and operators declared
for the type class are then deﬁned for the data type. A data type does not have to belong to any
type classes.

Data type identiﬁers must always begin with a capital letter. There are three exceptions; bit, int,
and real, which are predeﬁned for backwards compatibility.

                        c 2008 Bluespec, Inc. All rights reserved                         153


Reference Guide                                                             Bluespec SystemVerilog

B.2.1 Bit

To deﬁne a value of type Bit:
    Bit#(type n);

                               Type Classes for Bit

           Bits Eq Literal Arith Ord Bounded Bitwise                         Bit  Bit

     Bit    √√   √             √√       √             √                   Redu√ction Ext√end

                               Bit type aliases

     bit         The data type bit is deﬁned as a single bit. This is a special case

                 of Bit.

                 typedef Bit#(1) bit;

     Nat         The data type Nat is deﬁned as a 32 bit wide bit-vector. This is a

                 special case of Bit.

                 typedef Bit#(32) Nat;

The Bit data type provides functions to concatenate and split bit-vectors.

     {x,y}                            Bit Functions
                 Concatenate two bit vectors, x of size n and y of size m returning a
                 bit vector of size k. The Verilog operator { } is used.

                 function Bit#(k) bitconcat(Bit#(n) x, Bit#(m) y)
                    provisos (Add#(n, m, k));

     split       Split a bit vector into two bit vectors (higher-order bits (n), lower-
                 order bits (m)).

                 function Tuple2 #(Bit#(n), Bit#(m)) split(Bit#(k) x)
                    provisos (Add#(n, m, k));

B.2.2 UInt
The UInt type is an unsigned ﬁxed width representation of an integer value.

                               Type Classes for UInt

           Bits Eq Literal Arith Ord Bounded Bitwise                         Bit  Bit

     UInt   √√   √             √√       √             √                   Redu√ction Ext√end

154                            c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                        Reference Guide

B.2.3 Int
The Int type is a signed ﬁxed width representation of an integer value.

                                   Type Classes for Int

         Bits Eq Literal Arith Ord Bounded Bitwise                       Bit  Bit

Int      √√             √          √√          √             √           Redu√ction Ext√end

                                   Int type aliases

int                     The data type int is deﬁned as a 32-bit signed integer. This is a

                        special case of Int.

                        typedef Int#(32) int;

B.2.4 Integer

The Integer type is a data type used for integer values and functions. Because Integer is not
part of the Bits typeclass, the Integer type is used for static elaboration only; all values must be
resolved at compile time.

                                   Type Classes for Integer

         Bits Eq Literal Arith Ord Bounded Bitwise                       Bit  Bit

             √             √       √√                                    Reduction Extend

Integer

                                   Integer Functions

div                     Element x is divided by element y and the result is rounded toward

                        negative inﬁnity. Division by 0 is undeﬁned.

                        function Integer div(Integer x, Integer y);

mod                     Element x is divided by element y using the div function and the

                        remainder is returned as an Integer value. div and mod satisfy the

                        identity (div(x, y)∗y)+mod(x, y) == x. Division by 0 is undeﬁned.

                        function Integer mod(Integer x, Integer y);

quot                    Element x is divided by element y and the result is truncated
                        (rounded towards 0). Division by 0 is undeﬁned.

                        function Integer quot(Integer x, Integer y);

rem                     Element x is divided by element y using the quot function and the

                        remainder is returned as an Integer value. quot and rem satisfy

                        the identity (quot(x, y) ∗ y) + rem(x, y) == x. Division by 0 is

                        undeﬁned.

                        function Integer rem(Integer x, Integer y);

                        c 2008 Bluespec, Inc. All rights reserved                            155


Reference Guide                                                   Bluespec SystemVerilog

B.2.5 Bool

The Bool type is deﬁned to have two values, True and False.
typedef enum {False, True} Bool;

                               Type Classes for Bool

           Bits Eq Literal Arith Ord Bounded Bitwise                         Bit  Bit

                √√                                                Reduction Extend
     Bool

The Bool functions return either a value of True or False.

                               Bool Functions

      not           Returns True if x is false, returns False if x is true.

      !

                    function Bool not (Bool x);

      &amp;&amp;            Returns True if x and y are true, else it returns False.

                    function Bool \&amp;&amp; (Bool x, Bool y);

      ||            Returns True if x or y is true, else it returns False.

                    function Bool \|| (Bool x, Bool y);

B.2.6 Real

The Real type is a data type used for real values and functions.

Real numbers are of the form:

real number         ::= [ sign ]unsign num[ .unsign num ] exp [ sign ]unsign num
                    | [ sign ]unsign num.unsign num

sign                ::= + | -

exp                 ::= e | E

unsign num          ::= decimal digit { [ ]decimal digit }

decimal digit       ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

If there is a decimal point, there must be digits following the decimal point. An exponent can start
with either an E or an e, followed by an optional sign (+ or -), followed by digits. There cannot be an
exponent or a sign without any digits. Any of the numeric components may include an underscore,
but an underscore cannot be the ﬁrst digit of the number.

Unlike Integer, Real numbers are of limited precision. They are represented as IEEE ﬂoating point
numbers of 64 bit length, as deﬁned by the IEEE standard.

Because Real is not part of the Bits typeclass, the Real type is used for static elaboration only; all
values must be resolved at compile time.

There are many functions deﬁned for Real types, provided in the Real package (Section C.4.1). To
use these functions, the Real package must be imported.

156                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                           Reference Guide

                              Type Classes for Real

      Bits Eq Literal Real Arith Ord Bounded Bitwise                             Bit         Bit

            √           √     Lit√eral √  √                               Reduction Extend

Real

      real                                 Real type aliases
                        The SystemVerilog name real is an alias for Real

                        typedef Real real;

There are two system tasks deﬁned for the Real data type, used to convert between Real and IEEE
standard 64-bit vector representation (Bit#(64)).

      $realtobits                         Real system tasks
                        Converts from a Real to the IEEE 64-bit vector representation.

                        function Bit#(64) $realtobits (Real x) ;

      $bitstoreal       Converts from a 64-bit vector representation to a Real.
                        function Real $bitstoreal (Bit#(64) x) ;

B.2.7 String

Strings are mostly used in system tasks (such as $display). The String type belongs to the Eq type
class; strings can be tested for equality and inequality using the == and != operators. The String
type is also part of the Arith class, but only the addition (+) operator is deﬁned. All other Arith
operators will produce an error message.

                              Type Classes for String

            Bits Eq Literal Arith Ord Bounded Bitwise                     Bit           Bit

                   √       √  √                                       Reduction Extend

String

The strConcat function is provided for combining String values.

      strConcat                            String Functions
      +                 Concatenates two elements of type String, x and y.

                        function String strConcat(String x, String y);

B.2.8 Fmt

The Fmt primitive type provides a representation of arguments to the $display family of system
tasks (Section 12.8.1) that can be manipulated in BSV code. Fmt representations of data objects
can be written hierarchically and applied to polymorphic types.

                           c 2008 Bluespec, Inc. All rights reserved                         157


Reference Guide                                                  Bluespec SystemVerilog

Objects of type Fmt can be supplied directly as arguments to system tasks in the $display family.
An object of type Fmt is returned by the $format (Section 12.8.2) system task.

The Fmt type is part of the Arith class, but only the addition (+) operator is deﬁned. All other
Arith operators will produce an error message.

                         Type Classes for Fmt

          Bits Eq Literal Arith Ord Bounded Bitwise              Bit           Bit

                      √  √                                       Reduction Extend

     Fmt

B.2.9 Maybe

The Maybe type is used for tagging values as either Valid or Invalid. If the value is Valid, the value
contains a datatype data_t.

    typedef union tagged {
           void Invalid;
           data_t Valid;

    } Maybe #(type data_t) deriving (Eq, Bits);

                         Type Classes for Maybe

          Bits Eq Literal Arith Ord Bounded Bitwise              Bit           Bit

                  √√                                             Reduction Extend
     Maybe

The Maybe data type provides functions to check if the value is Valid and to extract the valid value.

     fromMaybe                            Maybe Functions
                      Extracts the Valid value out of a Maybe argument. If the tag is
                      Invalid the default value, defaultval, is returned.

                      function data_t fromMaybe( data_t defaultval,
                                                                Maybe#(data_t) val ) ;

     isValid          Returns a value of True if the Maybe argument is Valid.
                      function Bool isValid( Maybe#(data_t) val ) ;

B.2.10 Tuples

Tuples are predeﬁned structures which group a small number of values together. The following
pseudocode explains the structure of the tuples. You cannot deﬁne your own tuples, but must use
the six predeﬁned tuples, Tuple2 through Tuple7. As shown, Tuple2 groups two items together,
Tuple3 groups three items together, up through Tuple7 which groups seven items together.

 typedef struct{
       a tpl_1;
       b tpl_2;

    } Tuple2 #(type a, type b) deriving (Bits, Eq, Bounded);

158                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

typedef struct{
      a tpl_1;
      b tpl_2;
      c tpl_3;

 } Tuple3 #(type a, type b, type c) deriving (Bits, Eq, Bounded);

typedef struct{
      a tpl_1;
      b tpl_2;
      c tpl_3;
      d tpl_4;

 } Tuple4 #(type a, type b, type c, type d) deriving (Bits, Eq, Bounded);

typedef struct{
      a tpl_1;
      b tpl_2;
      c tpl_3;
      d tpl_4;
      e tpl_5;

 } Tuple5 #(type a, type b, type c, type d, type e)
    deriving (Bits, Eq, Bounded);

typedef struct{
      a tpl_1;
      b tpl_2;
      c tpl_3;
      d tpl_4;
      e tpl_5;
      f tpl_6;

 } Tuple6 #(type a, type b, type c, type d, type e, type f)
    deriving (Bits, Eq, Bounded);

typedef struct{
      a tpl_1;
      b tpl_2;
      c tpl_3;
      d tpl_4;
      e tpl_5;
      f tpl_6;
      g tpl_7;

 } Tuple7 #(type a, type b, type c, type d, type e, type f, type g)
    deriving (Bits, Eq, Bounded);

                        Type Classes for Tuples

Bits Eq Literal Arith Ord Bounded Bitwise                          Bit     Bit

               √√       √  √                                       Reduction Extend
TupleN

Tuples cannot be manipulated like normal structures; you cannot create values of and select ﬁelds
from tuples as you would a normal structure. Values of these types can be created only by applying
a predeﬁned family of constructor functions.

                        c 2008 Bluespec, Inc. All rights reserved                    159


Reference Guide                                                         Bluespec SystemVerilog

                             Tuple Constructor Functions

     tuple2 (e1, e2)                  Creates a variable of type Tuple2 with com-
                                      ponent values e1 and e2.

     tuple3 (e1, e2, e3)              Creates a variable of type Tuple3 with values
     tuple4 (e1, e2, e3, e4)          e1, e2, and e3.
     tuple5 (e1, e2, e3, e4, e5)      Creates a variable of type Tuple4 with com-
     tuple6 (e1, e2, e3, e4, e5, e6)  ponent values e1, e2, e3, and e4.
                                      Creates a variable of type Tuple5 with com-
                                      ponent values e1, e2, e3, e4, and e5.
                                      Creates a variable of type Tuple6 with com-
                                      ponent values e1, e2, e3, e4, e5, and e6.

     tuple7 (e1, e2, e3, e4, e5, e6, e7) Creates a variable of type Tuple7 with com-
                                                                 ponent values e1, e2, e3, e4, e5, e6, and e7.

Fields of these types can be extracted only by applying a predeﬁned family of selector functions.

     tpl_1 (x)                                Tuple Extract Functions
     tpl_2 (x)
     tpl_3 (x)               Extracts the ﬁrst ﬁeld of x from a Tuple2 to Tuple7.
     tpl_4 (x)               Extracts the second ﬁeld of x from a Tuple2 to Tuple7.
     tpl_5 (x)               Extracts the third ﬁeld of x from a Tuple3 to Tuple7.
     tpl_6 (x)               Extracts the fourth ﬁeld of x from a Tuple4 to Tuple7.
     tpl_7 (x)               Extracts the ﬁfth ﬁeld of x from a Tuple5, Tuple 6, or Tuple7.
                             Extracts the sixth ﬁeld of x from a Tuple6 or Tuple7.
                             Extracts the seventh ﬁeld of x from a Tuple7.

B.2.11 Clock
Clock is an abstract type of two components: a single Bit oscillator and a Bool gate.

       typedef ... Clock ;

Clock is in the Eq type class, meaning two values can be compared for equality.

                             Type Classes for Clock

     Bits Eq Literal Arith Ord Bounded Bitwise                          Bit                  Bit

                          √                                             Reduction Extend
     Clock

B.2.12 Reset
Reset is an abstract type.

       typedef ... Reset ;

Reset is in the Eq type class, meaning two ﬁelds can be compared for equality.

                             Type Classes for Reset

     Bits Eq Literal Arith Ord Bounded Bitwise                          Bit                  Bit

                          √                                             Reduction Extend
     Reset

160                          c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                         Reference Guide

B.2.13 Inout
An Inout type is a ﬁrst class type that is used to pass Verilog inouts through a BSV module.

Inout#(a);

Example of declaring a variable named foo of the type Inout:

    Inout#(int) foo;

An Inout type is a valid subinterface type (like Clock and Reset). A value of an Inout type is
clocked_by and reset_by a particular Clock and Reset.
Inouts are connectable via the Connectable typeclass. The use of mkConnection instantiates a
Verilog module InoutConnect. The Inouts must be on the same clock and the same reset. The
clock and reset of the Inouts may be diﬀerent than the clock and reset of the parent module of the
mkConnection.

   instance Connectable#(Inout#(a, x1), Inout#(a, x2))
       provisos (Bit#(a,sa));

B.2.14 Action/ActionValue

Any expression that is intended to act on the state of the circuit (at circuit execution time) is called
an action and has type Action or ActionValue#(a). The type parameter a represents the type of
the returned value.

                        Type Classes for Action/ActionValue

        Bits Eq Literal Arith Ord Bounded Bitwise                  Bit         Bit

                                                                   Reduction Extend

Action

The types Action and ActionValue are special keywords, and therefore cannot be redeﬁned.
         typedef · · · abstract · · · struct ActionValue#(type a);

Action                                ActionValue type aliases
                        The Action type is a special case of the more general type
                        ActionValue where nothing is returned. That is, the returns type
                        is (void).

                        typedef ActionValue#(void) Action;

noAction                                   Action Functions
                        An empty Action, this is an Action that does nothing.

                        function Action noAction();

                        c 2008 Bluespec, Inc. All rights reserved                             161


Reference Guide                                                Bluespec SystemVerilog

B.2.15 Rules

A rule expression has type Rules and consists of a collection of individual rule constructs. Rules
are ﬁrst class objects, hence variables of type Rules may be created and manipulated. Rules values
must eventually be added to a module in order to appear in synthesized hardware.

                    Type Classes for Rules

            Bits Eq Literal Arith Ord Bounded Bitwise          Bit  Bit

                                                               Reduction Extend

     Rules

The Rules data type provides functions to create, manipulate, and combine values of the type Rules.

     emptyRules                         Rules Functions
                    An empty rules variable.

                    function Rules emptyRules();

     addRules       Takes rules r and adds them into a module. This function may only
                    be called from within a module. The return type void indicates
                    that the instantiation does not return anything.

                    function module addRules#(Rules r) (void);

     rJoin          Symmetric union of two sets of rules. A symmetric union means
                    that neither set is implied to have any relation to the other: not
                    more urgent, not execute before, etc.

                    function Rules rJoin(Rules x, Rules y);

     rJoinPreempts  Union of two sets of rules, with rules on the left getting scheduling
                    precedence and blocking the rules on the right.That is, if a rule in
                    set x ﬁres, then all rules in set y are prevented from ﬁring. This is
                    the same as specifying descending_urgency plus a forced conﬂict.

                    function Rules rJoinPreempts(Rules x, Rules y);

     rJoinDescendingUrgency
                     Union of two sets of rule, with rules in the left having higher urgency.That
                     is, if some rules compete for resources, then scheduling will select rules in
                     set x set before set y. If the rules do not conﬂict, no conﬂict is added; the
                     rules can ﬁre together.

                     function Rules rJoinDescendingUrgency(Rules x, Rules y);

162                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

rJoinMutuallyExclusive
                Union of two sets of rule, with rules in the all rules in the left set anno-
                tated as mutually exclusive with all rules in the right set.No relationship
                between the rules in the left set or between the rules in the right set
                is assumed. This annotation is used in scheduling and checked during
                simulation.

                function Rules rJoinMutuallyExclusive(Rules x, Rules y);

rJoinExecutionOrder
                Union of two sets of rule, with the rules in the left set executing before the
                rules in the right set.No relationship between the rules in the left set or
                between the rules in the right set is assumed. If any pair of rules cannot
                execute in the speciﬁed order in the same clock cycle, that pair of rules
                will conﬂict.

                function Rules rJoinExecutionOrder(Rules x, Rules y);

rJoinConflictFree
                Union of two sets of rule, with the rules in the left set annotated as
                conﬂict-free with the rules in the right set. This assumption is used during
                scheduling and checked during simulation. No relationship between the
                rules in the left set or between the rules in the right set is assumed.

                function Rules rJoinConflictFree(Rules x, Rules y);

B.3 Operations on Numeric Types

B.3.1 Size Relationship/Provisos

These classes are used in provisos to express constraints between the sizes of types.

Class  Proviso                    Description

Add    Add#(n1,n2,n3)             Assert n1 + n2 = n3
Mul    Mul#(n1,n2,n3)             Assert n1 ∗ n2 = n3
Div    Div#(n1,n2,n3)             Assert ceiling n1/n2 = n3
Max    Max#(n1,n2,n3)             Assert max(n1, n2) = n3
Log    Log#(n1,n2)                Assert ceiling log2(n1) = n2.

Examples of Provisos using size relationships:

instance Bits #( Vector#(vsize, element_type), tsize)

provisos (Bits#(element_type, sizea),

       Mul#(vsize, sizea, tsize));              // vsize * sizea = tsize

function Vector#(vsize1, element_type)

       cons (element_type elem, Vector#(vsize, element_type) vect)

provisos (Add#(1, vsize, vsize1));              // 1 + vsize = vsize1

function Vector#(mvsize,element_type)

       concat(Vector#(m,Vector#(n,element_type)) xss)

provisos (Mul#(m,n,mvsize));                    // m * n = mvsize

                        c 2008 Bluespec, Inc. All rights reserved                               163


Reference Guide                                                    Bluespec SystemVerilog

B.3.2 Size Relationship Type Functions

These type functions are used when “deﬁning” size relationships between data types, where the
deﬁned value need not (or cannot) be named in a proviso. They may be used in datatype deﬁnition
statements when the size of the datatype may be calculated from other parameters.

        Type Function   Size Relationship   Description

        TAdd            TAdd#(n1,n2)        Calculate n1 + n2
        TSub            TSub#(n1,n2)        Calculate n1 − n2
        TMul            TMul#(n1,n2)        Calculate n1 ∗ n2
        TDiv            TDiv#(n1,n2)        Calculate ceiling n1/n2
        TLog            TLog#(n1)           Calculate ceiling log2(n1)
        TExp            TExp#(n1)           Calculate 2n1

Examples using other arithmetic functions:

     Int#(TAdd#(5,n));                      // defines a signed integer n+5 bits wide
                                            // n must be in scope somewhere

     typedef TAdd#(vsize, 8) Bigsize;       // defines a new type Bigsize which
                                            // is 8 bits wider than vsize

     typedef Bit#(TLog#(n)) CBToken#(numeric type n);
                                                                      // defines a new parameterized type,
                                                                      // CBToken, which is log(n) bits wide.

     typedef 8 Wordsize;                    // Blocksize is based on Wordsize
     typedef TAdd#(Wordsize, 1) Blocksize;

B.3.3 valueOf and SizeOf pseudo-functions

Prelude provides these pseudo-functions to convert between types and numeric values. The pseudo-
function valueof (or valueOf) is used to convert a numeric type into the corresponding Integer
value. The pseudo-function SizeOf is used to convert a type t into the numeric type representing
its bit size.

valueof          Converts a numeric type into its Integer value.
valueOf          function Integer valueOf (t) ;

Example:
    module mkFoo (Foo#(n));
       UInt#(n) x;
       Integer y = valueOf(n);
    endmodule

SizeOf           Converts a type into a numeric type representing its bit size.

                 function t SizeOf#(any_type)
                     provisos (Bits#(any_type, sa)) ;

164                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Example:
    any_type x = structIn;
    Bit#(SizeOf#(any_type)) = pack(structIn);

B.4 Registers and Wires

Name        Section           Register and Wire Interfaces
Reg         B.4.1       Description
RWire       B.4.2
                        Register interface.
Wire        B.4.3       Similar to a register with output wrapped in a Maybe type to indi-
BypassWire  B.4.4       cate validity.
                        Interchangeable with a Reg interface, validity of the data is implicit.
DWire       B.4.5       Implementation of the Wire interface where the write method is
                        always enabled.
PulseWire   B.4.6       Implementation of the Wire interface where the read method is
ReadOnly    B.4.7       always ready.
                        RWire without any data.
                        Interface which provides a value.

B.4.1 Reg

The most elementary module available in BSV is the register, which has a Reg interface. Registers
are polymorphic, i.e., in principle they can hold a value of any type but, of course, ultimately registers
store bits. Thus, the provisos on register modules indicate that the type of the value stored in the
register must be in the Bits type class, i.e., the operations pack and unpack are deﬁned on the type
to convert into bits and back.

Note that all Bluespec registers are considered atomic units, which means that even if one bit is
updated (written), then all the bits are considered updated. This prevents multiple rules from
updating register ﬁelds in an inconsistent manner.

Interfaces and Methods

The Reg interface contains two methods, _write and _read.

    interface Reg #(type a_type);
           method Action _write(a_type x1);
           method a_type _read();

    endinterface: Reg

The _write and _read methods are rarely used. Instead, for writes, one uses the non-blocking
assignment notation and, for reads, one just mentions the register interface in an expression.

                                     Reg Interface

                        Method                              Arguments
                                                                  Description
Name        Type        Description                 Name
_write      Action                                  x1    data to be written
_read       a_type      writes a value x1

                        returns the value of the

                        register

Modules

Prelude provides three modules to create a register: mkReg creates a register with a given reset value,
mkRegU creates a register without any reset, and mkRegA creates a register with a given reset value
and with asynchronous reset logic.

                        c 2008 Bluespec, Inc. All rights reserved              165


Reference Guide                                                                    Bluespec SystemVerilog
  mkReg
                 Make a register with a given reset value. Reset logic is synchronous.
                 module mkReg#(a_type resetval)(Reg#(a_type))

                    provisos (Bits#(a_type, sizea));

mkRegU           Make a register without any reset; initial simulation value is alternating
mkRegA           01 bits.
                 module mkRegU(Reg#(a_type))

                    provisos (Bits#(a_type, sizea));

                 Make a register with a given reset value. Reset logic is asynchronous.
                 module mkRegA#(a_type resetval)(Reg#(a_type))

                    provisos (Bits#(a_type, sizea));

                 Scheduling Annotations

                 mkReg, mkRegU, mkRegA

                        read write

                 read   CF SB

                 write  SA SBR

Functions

Three functions are provided for using registers: asReg returns the register interface instead of the
value of the register; readReg reads the value of a register, useful when managing arrays or lists of
registers; and writeReg to write a value into a register, also useful when managing arrays or lists of
registers.

asReg            Treat a register as a register, i.e., suppress the normal behavior where the
                 interface name implicitly represents the value that the register contains
                 (the _read value). This function returns the register interface, not the
                 value of the register.

                 function Reg#(a_type) asReg(Reg#(a_type) regIfc);

  readReg          Read the value out of a register. Useful for giving as the argument to
  writeReg         higher-order array and list functions.
166                function a_type readReg(Reg#(a_type) regIfc);

                 Write a value into a register. Useful for giving as the argument to higher-
                 order array and list functions.
                 function Action writeReg(Reg#(a_atype) regIfc, a_type din);

                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

B.4.2 RWire

An RWire is a primitive stateless module whose purpose is to allow data transfer between methods
and rules without the cycle latency of a register. That is, a RWire may be written in a cycle and
that value can be read out in the same cycle; values are not stored across clock cycles.

Interfaces and Methods

The RWire interface is conceptually similar to a register’s interface, but the output value is wrapped
in a Maybe type. The wset method places a value on the wire and sets the valid signal. The read-like
method, wget, returns the value and a valid signal in a Maybe type. The output is only Valid if a
write has a occurred in the same clock cycle, otherwise the output is Invalid.

                                      RWire Interface              Arguments
                        Method
Name     Type           Description                         Name   Description
wset     Action
                        writes a value and sets the valid   datain data to be sent
wget     Maybe          signal                                            on the wire
                        returns the value and the valid
                        signal

interface RWire#(type element_type) ;
    method Action wset(element_type datain) ;
    method Maybe#(element_type) wget() ;

endinterface: RWire

Modules The mkRWire module is proivded to create an RWire.

mkRWire                 Creates an RWire. Output is only valid if a write has occurred in
                        the same clock cycle.

                        module mkRWire(RWire#(element_type))
                            provisos (Bits#(element_type, element_width)) ;

                        Scheduling Annotations
                                 mkRWire
                                         wget wset

                        wget  CF SA

                        wset  SB C

B.4.3 Wire

The Wire interface and module are simular to RWire, but the valid bit is hidden from the user and
the validity of the read is considered an implicit condition. The Wire interface works like the Reg
interface, so mentioning the name of the wire gets (reads) its contents whenever they’re valid, and
using &lt;= writes the wire. Wire is an RWire that is designed to be interchangeable with Reg. You
can replace a Reg with an Wire without changing the syntax.

    typedef Reg#(element_type) Wire#(type element_type);

Modules
The mkWire module is provided to create a Wire.

                        c 2008 Bluespec, Inc. All rights reserved                          167


Reference Guide                                                                    Bluespec SystemVerilog
         mkWire
                   Creates a Wire. Validity of the output is automatically checked as
                   an implicit condition of the read method.
                   module mkWire(Wire#(element_type))

                       provisos (Bits#(element_type, element_width));

                   Scheduling Annotations
                             mkWire
                                    read write

                   read   CF SA

                   write  SB C

B.4.4 BypassWire

BypassWire is an implementation of the Wire interface where the _write method is an always_enabled
method. The compiler will issue a warning if the method does not appear to be called every clock
cycle. The advantage of this tradeoﬀ is that the _read method of this interface does not carry
any implicit condition (so it can satisfy a no_implicit_conditions assertion or an always_ready
method).

     mkBypassWire  Creates a BypassWire. The write method is always enabled.

                   module mkBypassWire(Wire#(element_type))
                       provisos (Bits#(element_type, element_width));

                   Scheduling Annotations
                        mkBypassWire

                          read write

                   read   CF SA
                   write  SB C

B.4.5 DWire

DWire is an implementation of the Wire interface where the _read method is an always_ready
method and thus has no implicit conditions. Unlike the BypassWire however, the _write method
need not be always enabled. On cycles when a DWire is written to, the _read method returns that
value. On cycles when no value is written, the _read method instead returns a default value that is
speciﬁed as an argument during instantiation.

     mkDWire       Creates a DWire. The read method is always ready.

                   module mkDWire#(a_type defaultval)(Wire#(element_type))
                       provisos (Bits#(element_type, element_width));

                   Scheduling Annotations

                          mkDWire

                          read write

                   read   CF SA

                   write  SB C

168                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

B.4.6 PulseWire

Interfaces and Methods

The PulseWire interface is an RWire without any data. It is useful within rules and action methods
to signal other methods or rules in the same clock cycle. Note that because the read method is called
_read, the register shorthand can be used to get its value without mentioning the method _read (it
is implicitly added).

                                  PulseWire Interface

             Name         Type        Description
             send
             _read        Action      sends a signal down the wire

                          Bool        returns the valid signal

interface PulseWire;
   method Action send();
   method Bool _read();

endinterface

Modules

The mkPulseWire and mkPulseWireOR modules are provided to create a PulseWire. The mkPulseWireOR
is nearly identical to the mkPulseWire module except that the send method in the mkPulseWireOR
does not conﬂict with itself. Calling the send method for a mkPulseWire from 2 rules causes the two
rules to conﬂict while in the mkPulseWireOR there is no conﬂict. In other words, the mkPulseWireOR
acts a logical ”OR”.

mkPulseWire             The writing to this type of wire is used in rules and action methods
                        to send a single bit to signal other methods or rules in the same
                        clock cycle.

                        module mkPulseWire(PulseWire);

mkPulseWireOR           Returns a PulseWire which acts like a logical ”Or”. The send
                        method of the same wire can be used in two diﬀerent rules without
                        conﬂict.

                        module mkPulseWireOR(PulseWire);

                                Scheduling Annotations

                                      mkPulseWire

                                      read send

                                read  CF SA

                          send        SB C

                                Scheduling Annotations

                                      mkPulseWireOR

                                      read send

                                read  CF SA

                          send        SB SBR

                        c 2008 Bluespec, Inc. All rights reserved                             169


Reference Guide                                                 Bluespec SystemVerilog

Counter Example - Using Reg and PulseWire

interface Counter#(type size_t);
      method Bit#(size_t) read();
      method Action load(Bit#(size_t) newval);
      method Action increment();
      method Action decrement();

endinterface

module mkCounter(Counter#(size_t));                    // define a Reg
      Reg#(Bit#(size_t)) value &lt;- mkReg(0);

     PulseWire increment_called &lt;- mkPulseWire(); // define the PulseWires used
     PulseWire decrement_called &lt;- mkPulseWire(); // to signal other methods or rules

     // whether rules fire is based on values of PulseWires
     rule do_increment(increment_called &amp;&amp; !decrement_called);

           value &lt;= value + 1;
     endrule

     rule do_decrement(!increment_called &amp;&amp; decrement_called);
           value &lt;= value - 1;

     endrule

     method Bit#(size_t) read();                // read the register
           return value;

     endmethod

     method Action load(Bit#(size_t) newval);   // load the register
           value &lt;= newval;                     // with a new value

     endmethod

     method Action increment();                 // sends the signal on the
           increment_called.send();             // PulseWire increment_called

     endmethod

      method Action decrement();                / sends the signal on the
            decrement_called.send();            // PulseWire decrement_called

      endmethod
endmodule

B.4.7 ReadOnly

ReadOnly is an interface which provides a value. The _read shorthand can be used to read the
value.

Interfaces and Methods

                                   ReadOnly Interface          Arguments
                    Method
     Name   Type                                       Name     Description
     _read  a_type    Description
                                                       a_type Data to be read, of
                      Reads the data                               datatype type.

170                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

interface ReadOnly #( type a_type ) ;
    method a_type _read() ;

endinterface

B.5 Miscellaneous Functions

B.5.1 Compile-time Messages

error                   Generate a compile-time error message, s, and halt compilation.
                        function a_type error(String s);

warning                 When applied to a value v of type a, generate a compile-time warn-
                        ing message, s, and continue compilation, returning v.

                        function a_type warning(String s, a_type v);

message                 When applied to a value v of type a, generate a compile-time in-
                        formative message, s, and continue compilation, returning v.

                        function a_type message(String s, a_type v);

B.5.2 Arithmetic Functions

max                     Returns the maximum of two values, x and y.

                        function a_type max(a_type x, a_type y)
                           provisos (Ord#(a_type));

min                     Returns the minimum of two values, x and y.

                        function a_type min(a_type x, a_type y)
                           provisos (Ord#(a_type));

abs                     Returns the absolute value of x.

                        function a_type abs(a_type x)
                           provisos (Arith#(a_type), Ord#(a_type));

signedMul               Performs full precision multiplication on two Int#(n) operands of
                        diﬀerent sizes.

                        function Int#(m) signedMul(Int#(n) x, Int#(k) y)
                           provisos (Add#(n,k,m));

                        c 2008 Bluespec, Inc. All rights reserved                           171


Reference Guide                                                                       Bluespec SystemVerilog
         unsignedMul
                      Performs full precision multiplication on two unsigned UInt#(n)
                      operands of diﬀerent sizes.
                      function UInt#(m) unsignedMul(UInt#(n) x, UInt#(k) y)

                         provisos (Add#(n,k,m));

B.5.3 Operations on Functions
These are useful with higher-order list and array functions.

     compose          Creates a new function, c, made up of functions, f and g.
                      c(a) = f(g(a))

                      function (function c_type (a_type x0))
                                          compose(function c_type f(b_type x1),
                                                       function b_type g(a_type x2));

     composeM         Creates a new monadic function, m#(c), made up of functions, f
                      and g. c(a) = f(g(a))

                      function (function m#(c_type) (a_type x0))
                                          composeM(function m#(c_type) f(b_type x1),
                                                        function m#(b_type) g(a_type x2))

                          provisos # (Monad#(m));

     id               Identity function, returns x when given x. This function is useful

                      when the argument requrires a function which doesn’t do anything.

                      function a_type id(a_type x);

     constFn          Constant function, returns x.
                      function a_type constFn(a_type x, b_type y);

     flip             Flips the arguments x and y.

                      function (function c_type new (b_type y, a_type x))
                             flip (function c_type old (a_type x, b_type y));

Example - using function constFn to set the initial values of the registers in a list:
    List#(Reg#(Resource)) items &lt;- mapM( constFn(mkReg(initRes)), upto(1,numAdd) );

172                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

B.5.4 Bit Functions
The following functions operate on Bit#(n) variables.

msb                     Returns the most signiﬁcant bit of x

                        function Bit#(1) msb(Bit#(n) x)
                            provisos(Add#(1,k,n));

parity                  Returns the parity of the bit argument v. Example: parity( 5’b1)
                        = 1, parity( 5’b3) = 0;

                        function Bit#(1) parity(Bit#(n) v);

reverseBits             Reverses the order of the bits in the argument x.
                        function Bit#(n) reverseBits(Bit#(n) x);

countOnes               Returns the count of the number of 1’s in the bit vector bin.

                        function UInt#(lgn1) countOnes ( Bit#(n) bin )
                           provisos (Add#(1, n, n1), Log#(n1, lgn1),
                                           Add#(1, xx, lgn1) );

countZerosMSB           For the bit vector bin, count the number of 0s until the ﬁrst 1,
                        starting from the most signiﬁcant bit (MSB).

                        function UInt#(lgn1) countZerosMSB ( Bit#(n) bin )
                           provisos (Add#(1, n, n1), Log#(n1, lgn1) );

countZerosLSB           For the bit vector bin, count the number of 0s until the ﬁrst 1,
                        starting from the least signiﬁcant bit (LSB).

                        function UInt#(lgn1) countZerosLSB ( Bit#(n) bin )
                           provisos (Add#(1, n, n1), Log#(n1, lgn1) );

truncateLSB             Truncates a Bit#(m) to a Bit#(n) by dropping bits starting with
                        the LSB.

                        function Bit#(n) truncateLSB(Bit#(m) x)
                            provisos(Add#(n,k,m));

                        c 2008 Bluespec, Inc. All rights reserved                         173


Reference Guide                                                       Bluespec SystemVerilog

B.5.5 Control Flow Function

     while            Repeat a function while a predicate holds.

                      function a_type while(function Bool pred(a_type x1),
                                         function a_type f(a_type x1), a_type x);

     when             Adds an implicit condition onto an expression.
                      function a when(Bool condition, a arg);

Example - adding the implicit condition readCount==0 to the action

     function Action startReadSequence (BAddr startAddr,
                                                            UInt#(6) count);

         return when ((readCount == 0), // implicit condition of the action
         (action

                readAddr &lt;= startAddr ;
                readCount &lt;= count ;
           endaction));
     endfunction

     rule readSeq;    // readCount==0 is an implicit condition

     startReadSequence (addr, count);

     endrule

B.6 Environment Values

The Environment section of the Prelude contains some value deﬁnitions that remain static within a
compilation, but may vary between compilations.
Test whether the compiler is generating C.

     genC             Returns True if the compiler is generating C.
                      function Bool genC();

Test whether the compiler is generating Verilog.

     genVerilog       Returns True if the compiler is generating Verilog.
                      function Bool genVerilog();

Return the version of the compiler.

     compilerVersion  Returns a String containing the compiler version. This si the same
                      string used with the -v ﬂag.

                      String compilerVersion;

174                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

Example:

   the statement:
           $display(&quot;compilerversion = %d&quot;, compilerVersion);

   produces this output:
           Bluespec Compiler, version 3.8.56 (build 7084, 2005-07-22)

Get the current date and time.

date                    Returns a String containing the date.
                        String date;

Example:

   the statement:
           $display(&quot;date = %s&quot;, date);

   produces this output:
           &quot;Mon Feb 6 08:39:59 EST 2006&quot;

                        c 2008 Bluespec, Inc. All rights reserved      175


Reference Guide                                             Bluespec SystemVerilog

C Foundation Libraries

Section B deﬁned the Standard Prelude package, which is automatically imported into every package.
This section describes BSV’s large and continuously growing collection of AzureIPTM Foundation
libraries. To use any of these libraries in a package you must explicitly import the package using an
import clause.
Bluespec’s AzureIPTM intellectual property (IP) accelerates hardware design and modeling. There
are two AzureIP library families, Foundation and Premium:

    • Foundation is an extensive family of components, types and functions that are included with
       the Bluespec toolsets for use in your models and designs – they serve as a foundational base
       for your modeling and implementation work.

    • Premium is the designation for Bluespec’s fee-based AzureIP.

C.1 Storage and Data Structures

C.1.1 Register File

Package Name
import RegFile :: * ;
Description
This package provides 5-read-port 1-write-port register array modules.
Note: In a design that uses RegFiles, some of the read ports may remain unused. This may generate
a warning in various downstream tool. Downstream tools should be instructed to optimize away the
unused ports.
Interfaces and Methods
The RegFile package deﬁnes one interface, RegFile. The RegFile interface provides two methods,
upd and sub. The upd method is an Action method used to modify (or update) the value of an
element in the register ﬁle. The sub method (from ”sub”script) is a Value method which reads and
returns the value of an element in the register ﬁle. The value returned is of a datatype data_t.

Interface Name Parameter name Parameter Description         Restrictions

RegFile          index type  datatype of the index          must be in the Bits class
                 data t
                             datatype of the element values must be in the Bits class

interface RegFile #(type index_t, type data_t);
      method Action upd(index_t addr, data_t d);
      method data_t sub(index_t addr);

endinterface: RegFile

Name     Type    Method                          Name         Arguments
upd      Action       Description                addr               Description

sub                   Change or update an el-    d     index of the element to be
                      ement within the register        changed, with a datatype of
                      ﬁle.                             index_t
                                                       new value to be stored, with a
         data t  Read an element from addr             datatype of data_t
                 the register ﬁle and re-
                 turn it.                              index of the element, with a
                                                       datatype of index_t

176              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Modules

The RegFile package provides three modules: mkRegFile creates a RegFile with registers allocated
from the lo_index to the hi_index; mkRegFileFull creates a RegFile from the minimum index to
the maximum index; and mkRegFileWCF creates a RegFile from lo_index to hi_index for which
the reads and the write are scheduled conﬂict-free. There is a second set of these modules, the
RegFileLoad variants, which take as an argument a ﬁle containing the initial contents of the array.

mkRegFile               Create a RegFile with registers allocated from lo_index to hi_index.
                        lo_index and hi_index are of the index_t datatype and the elements
                        are of the data_t datatype.

                        module mkRegFile#( index_t lo_index, index_t hi_index )
                                                  ( RegFile#(index_t, data_t) )

                           provisos (Bits#(index_t, size_index),
                                           Bits#(data_t, size_data));

mkRegFileFull           Create a RegFile from min to max index where the index is of a datatype
                        index_t and the elements are of datatype data_t. The min and max are
                        speciﬁed by the Bounded typeclass instance (0 to N-1 for N-bit numbers).

                        module mkRegFileFull#( RegFile#(index_t, data_t) )
                           provisos (Bits#(index_t, size_index),
                                           Bits#(data_t, size_data)
                                           Bounded#(index_t) );

mkRegFileWCF            Create a RegFile from lo_index to hi_index for which the reads and the
                        write are scheduled conﬂict-free. For the implications of this scheduling,
                        see the documentation for ConfigReg (Section C.1.5).

                        module mkRegFileWCF#( index_t lo_index, index_t hi_index )
                                                       ( RegFile#(index_t, data_t) )

                           provisos (Bits#(index_t, size_index),
                                           Bits#(data_t, size_data));

The RegFileLoad variants provide the same functionality as RegFile, but each constructor function
takes an additional ﬁle name argument. The ﬁle contains the initial contents of the array using the
Verilog hex memory ﬁle syntax, which allows white spaces (including new lines, tabs, underscores,
and form-feeds), comments, binary and hexadecimal numbers. Length and base format must not be
speciﬁed for the numbers.

mkRegFileLoad           Create a RegFile using the ﬁle to provide the initial contents of the array.

                        module mkRegFileLoad#
                                         ( String file, index_t lo_index, index_t hi_index)
                                         ( RegFile#(index_t, data_t) )

                           provisos (Bits#(index_t, size_index),
                                           Bits#(data_t, size_data));

                        c 2008 Bluespec, Inc. All rights reserved  177


Reference Guide                                              Bluespec SystemVerilog

mkRegFileFullLoad Create a RegFile from min to max index using the ﬁle to provide the initial
                             contents of the array. The min and max are speciﬁed by the Bounded
                             typeclass instance (0 to N-1 for N-bit numbers).

                             module mkRegFileFullLoad#( String file)
                                                                     ( RegFile#(index_t, data_t))

                                 provisos (Bits#(index_t, size_index),
                                                Bits#(data_t, size_data),
                                                Bounded#(index_t) );

mkRegFileWCFLoad  Create a RegFile from lo_index to hi_index for which the reads and
                  the write are scheduled conﬂict-free (see Section C.1.5), using the ﬁle to
                  provide the initial contents of the array.

                  module mkRegFileWCFLoad#
                                   ( String file, index_t lo_index, index_t hi_index)
                                   ( RegFile#(index_t, data_t) )

                     provisos (Bits#(index_t, size_index),
                                     Bits#(data_t, size_data));

Examples
Use mkRegFileLoad to create Register ﬁles and then read the values.

    Reg#(Cntr) count &lt;- mkReg(0);

    // Create Register files to use as inputs in a testbench
    RegFile#(Cntr, Fp64) vecA &lt;- mkRegFileLoad(&quot;vec.a.txt&quot;, 0, 9);
    RegFile#(Cntr, Fp64) vecB &lt;- mkRegFileLoad(&quot;vec.b.txt&quot;, 0, 9);

    //read the values from the Register files
    rule drivein (count &lt; 10);

              Fp64 a = vecA.sub(count);
              Fp64 b = vecB.sub(count);
              uut.start(a, b);
              count &lt;= count + 1;
    endrule

Verilog Modules
RegFile modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

     BSV Module Name    Verilog Module Name                  Deﬁned in File
                        RegFile                              RegFile.v
     mkRegFile
     mkRegFileFull      RegFileLoad                          RegFileLoad.v
     mkRegFileWCF
     mkRegFileLoad
     mkRegFileFullLoad
     mkRegFileWCFLoad

178               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

C.1.2 FIFO Overview

There are three FIFO packages, FIFO, FIFOF, and FIFOLevel. The following table shows when to use
each FIFO, and which methods are in implemented in each FIFO. All FIFOs include the methods
enq, deq, first, clear. These are referred to as the common methods in the table.

       Package Name     Description                            Methods
       All FIFO         common methods in all FIFOs
       packages                                                enq
                        Implicit full and empty signals        deq
       FIFO             Explicit full and empty signals        first
       FIFOF                                                   clear
                        Indicates the level or current number  common methods
       FIFOLevel        of items stored in the FIFO            common methods
                                                               notFull
                                                               notEmpty
                                                               common methods
                                                               notFull
                                                               notEmpty
                                                               isLessThan
                                                               isGreaterThan

Common Methods
The following four methods are provided in all FIFO packages.

Name   Type             Method                       Name             Argument
enq    Action                Description                                    Description
deq
first                   adds an entry to the FIFO x1           variable to be added to the FIFO
clear                                                          must be of type element type
       Action           removes ﬁrst entry from
                                                               the entry returned is of
                        the FIFO                               element type

       element type returns ﬁrst entry

       Action           clears all entries from the
                        FIFO

C.1.3 FIFO and FIFOF packages

Package Name
import FIFO :: * ;
import FIFOF :: * ;

Description
The FIFO package deﬁnes the FIFO interface and four module constructors. The FIFO package is
for FIFOs with implicit full and empty signals.
The FIFOF package deﬁnes FIFOs with explicit full and empty signals.
The standard version of FIFOF has FIFOs with the enq, deq and ﬁrst methods guarded by the
appropriate (notFull or notEmpty) implicit condition for safety and improved scheduling.
Unguarded (UG) versions of FIFOF are available for the rare cases when implicit conditions are not
desired.

                        c 2008 Bluespec, Inc. All rights reserved              179


Reference Guide                                               Bluespec SystemVerilog

Guarded (G) versions of FIFOF are available which allow more control over implicit conditions. With
the guarded versions the user can specify whether the enqueue or dequeue side is guarded.

Interfaces and methods

Interface Name   Parameter name  Parameter Description  Restrictions
FIFO             element type                           must be in Bits class
                                 type of the elements
FIFOF            element type    stored in the FIFO     must be in Bits class
                                 type of the elements
                                 stored in the FIFO

The four common methods, enq, deq, first and clear are provided by the FIFO and FIFOF inter-
faces.

Name   Type      Method                       Name                   Argument
enq    Action         Description                                          Description
deq
first            adds an entry to the FIFO x1                 variable to be added to the FIFO
clear                                                         must be of type element type
       Action    removes ﬁrst entry from
                                                              the entry returned is of ele-
                 the FIFO                                     ment type

       element type returns ﬁrst entry

       Action    clears all entries from the
                 FIFO

interface FIFO #(type element_type);
      method Action enq(element_type x1);
      method Action deq();
      method element_type first();
      method Action clear();

endinterface: FIFO

FIFOF provides two additional methods, notFull and notEmpty.

Name Type               Method                                      Argument
notFull Bool     Description                                  Name Description
                 returns a True value if there is space,
notEmpty Bool    you can enqueue an entry into the FIFO
                 returns a True value if there are elements
                 in the FIFO, you can dequeue from the
                 FIFO

interface FIFOF #(type element_type);
      method Action enq(element_type x1);
      method Action deq();
      method element_type first();
      method Bool notFull();
      method Bool notEmpty();
      method Action clear();

endinterface: FIFOF

The FIFO and FIFOF interfaces belong to the toGet and toPut typeclasses. You can use the toGet
and toPut functions to convert FIFO and FIFOF interfaces to Get and Put interfaces (Section C.6.1).

180              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

Modules

The FIFO and FIFOF interface types are provided by the module constructors: mkFIFO, mkFIFO1,
mkSizedFIFO, mkDepthParamFIFO, and mkLFIFO. Each FIFO is safe with implicit conditions; it does
not allow an enq when the FIFO is full and does not allow a deq or first when the FIFO is empty.
Most FIFOs do not allow simultaneous enqueue and dequeue operations when the FIFO is full.
The exception is the pipeline FIFO (mkLFIFO), which does allow simultaneous enqueue and dequeue
operations in the same clock cycle when full, as shown in the following table.

                           Simultaneous enq and deq behavior

                  FIFO type  Condition

                             empty not empty full

                  mkFIFO     not full
                                √

                  mkFIFOF

                  mkFIFO1

                  mkFIFOF1   √                                     √
                  mkLFIFO

                  mkLFIFOF                                         √

                  mkLFIFO1

                  mkLFIFOF1

For creating a FIFOF interface use the &quot;F&quot; version of the module, such as mkFIFOF.

Unguarded (UG) versions of FIFOF are available for the rare cases when implicit conditions are not
desired. During rule and method processing the implicit conditions for correct FIFO operations are
NOT considered. That is, with an unguarded FIFO, it is possible to enqueue when full, and to
dequeue when empty. The Unguarded versions of the FIFOF modules provide the FIFOF interface.

There is also available a guarded (G) version of each of the FIFOFs. The guarded FIFOF takes two
Boolean parameters; ugenq and ugdeq. Setting either parameter TRUE indicates the method (enq for
ugenq, deq for ugdeq) is unguarded. If both are TRUE the FIFOF behaves the same as an unguarded
FIFOF. If both are FALSE the behavior is the same as a regular FIFOF.

Module Name       BSV Module Declaration
                  For all modules, width_any may be 0
FIFO of depth 2.
mkFIFO            module mkFIFO (FIFO#(element_type))
mkFIFOF               provisos (Bits#(element_type, width_any));
mkUGFIFOF

Guarded FIFOF of depth 2.

mkGFIFOF          module mkGFIFOF (Bool ugenq, Bool ugdeq)(FIFOF#(element_type))
                      provisos (Bits#(element_type, width_any));

FIFO of depth 1   module mkFIFO1(FIFO#(element_type))
                      provisos (Bits#(element_type, width_any));
mkFIFO1
mkFIFOF1
mkUGFIFOF1

                        c 2008 Bluespec, Inc. All rights reserved     181


Reference Guide                                                      Bluespec SystemVerilog

Guarded FIFOF of depth 1

mkGFIFOF1          module mkGFIFOF1(Bool ugenq, Bool ugdeq)(FIFOF#(element_type))
                       provisos (Bits#(element_type, width_any));

FIFO of given depth n

mkSizedFIFO        module mkSizedFIFO(Integer n)(FIFO#(element_type))
mkSizedFIFOF       provisos (Bits#(element_type, width_any));
mkUGSizedFIFOF

Guarded FIFOF of given depth n

mkGSizedFIFOF      module mkGSizedFIFOF(Bool ugenq, Bool ugdeq, Integer n)
                                                  (FIFOF#(element_type))

                      provisos (Bits#(element_type, width_any));

FIFO of given depth n where n is a Verilog parameter or computed from
compile-time constants and Verilog parameters.

mkDepthParamFIFO module mkDepthParamFIFO(UInt#(32) n)(FIFO#(element_type))

mkDepthParamFIFOF         provisos (Bits#(element_type, width_any));

mkUGDepthParamFIFOF

Guarded FIFOF of given depth n where n is a Verilog parameter or computed from
compile-time constants and Verilog parameters.

mkGDepthParamFIFOF     module mkGDepthParamFIFOF
                                        (Bool ugenq, Bool ugdeq, UInt#(32) n)
                                        (FIFOF#(element_type))

                          provisos (Bits#(element_type, width_any));

Pipeline FIFO of depth 1. deq and enq can be simultaneously applied in the same clock
cycle when the FIFO is full.

mkLFIFO          module mkLFIFO (FIFO#(element_type))
mkLFIFOF            provisos (Bits#(element_type, width_any));
mkUGLFIFOF

182                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Guarded pipeline FIFOF of depth 1. deq and enq can be simultaneously applied in the same
clock cycle when the FIFOF is full.

mkGLFIFOF    module mkGLFIFOF (Bool ugenq, Bool ugdeq)(FIFOF#(element_type))
                provisos (Bits#(element_type, width_any));

Functions

The FIFO package provides a function fifofToFifo to convert an interface of type FIFOF to an
interface of type FIFO.

Converts a FIFOF interface to a FIFO interface.

fifofToFifo  function FIFO#(a) fifofToFifo (FIFOF#(a) f);

Example using the FIFO package
This example creates 2 input FIFOs and moves data from the input FIFOs to the output FIFOs.

    import FIFO::*;

    typedef Bit#(24) DataT;

    // define a single interface into our example block
    interface BlockIFC;

         method Action push1 (DataT a);
         method Action push2 (DataT a);
         method ActionValue#(DataT) get();
    endinterface

    module mkBlock1( BlockIFC );
         Integer fifo_depth = 16;

         // create the first inbound FIFO instance
         FIFO#(DataT) inbound1 &lt;- mkSizedFIFO(fifo_depth);

         // create the second inbound FIFO instance
         FIFO#(DataT) inbound2 &lt;- mkSizedFIFO(fifo_depth);

         // create the outbound instance
         FIFO#(DataT) outbound &lt;- mkSizedFIFO(fifo_depth);

         // rule for enqueue of outbound from inbound1
         // implicit conditions ensure correct behavior
         rule enq1 (True);

              DataT in_data = inbound1.first;
              DataT out_data = in_data;
              outbound.enq(out_data);
              inbound1.deq;
         endrule: enq1

         // rule for enqueue of outbound from inbound2
         // implicit conditions ensure correct behavior

                        c 2008 Bluespec, Inc. All rights reserved                         183


Reference Guide                                                   Bluespec SystemVerilog

         rule enq2 (True);
              DataT in_data = inbound2.first;
              DataT out_data = in_data;
              outbound.enq(out_data);
              inbound2.deq;

         endrule: enq2

         //Add an entry to the inbound1 FIFO
         method Action push1 (DataT a);

                   inbound1.enq(a);
         endmethod

         //Add an entry to the inbound2 FIFO
         method Action push2 (DataT a);

                   inbound2.enq(a);
         endmethod

         //Remove first value from outbound and return it
         method ActionValue#(DataT) get();

                   outbound.deq();
                   return outbound.first();
         endmethod
     endmodule

Scheduling Annotations

Scheduling constraints describe how methods interact within the schedule. For example, a clear to
a given FIFO must be sequenced after (SA) an enq to the same FIFO. That is, when both enq and
clear execute in the same cycle, the resulting FIFO state is empty. For correct rule behavior the
rule executing enq must be scheduled before the rule calling clear.

The table below lists the scheduling annotations for the FIFO modules mkFIFO, mkSizedFIFO, and
mkFIFO1.

                        Scheduling Annotations
                 mkFIFO, mkSizedFIFO, mkFIFO1

                                  enq ﬁrst deq clear

                 enq    C CF CF SB

                 ﬁrst   CF CF SB SB
                 deq    CF SA C SB
                 clear  SA SA SA SBR

The table below lists the scheduling annotations for the pipeline FIFO module, mkLFIFO. The pipeline
FIFO has a few more restrictions since there is a combinational path between the deq side and the
enq side, thus restricting deq calls before enq.

                 enq    Scheduling Annotations             clear
                 ﬁrst            mkLFIFO
                 deq             enq ﬁrst deq               SB
                 clear                                      SB
                                  C SA SAR                  SB
                                 SB CF SB                  SBR
                                SBR SA C
                                 SA SA SA

184              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

The FIFOF modules add the notFull and notEmpty methods. These methods have SB annotations
with the Action methods that change FIFO state. These SB annotations model the atomic behavior
of a FIFO, that is when enq, deq, or clear are called the state of notFull and notEmpty are
changed. This is no diﬀerent than the annotations on mkReg (which is read SB write), where
actions are atomic and the execution module is one rule ﬁres at a time. This does diﬀer from a pure
hardware module of a FIFO or register where the state does not change until the clock edge.

                                  Scheduling Annotations

                         mkFIFOF, mkSizedFIFOF, mkFIFOF1

                         enq notFull ﬁrst deq notEmpty              clear

                enq      C SA CF CF                       SA         SB
                                                                     SB
                notFull  SB CF CF SB                      CF         SB
                                                                     SB
                ﬁrst     CF CF CF SB                      CF         SB
                                                                    SBR
                deq      CF SA SA C                       SA

                notEmpty SB CF CF SB                      CF

                clear    SA SA SA SA                      SA

Verilog Modules

FIFO and FIFOF modules correspond to the following Verilog modules, which are found in the Blue-
spec Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name          Verilog Module Names             Comments

mkFIFO                   FIFO2.v      FIFO20.v
mkFIFOF
mkUGFIFOF
mkGFIFOF

mkFIFO1                  FIFO1.v      FIFO10.v
mkFIFOF1
mkUGFIFOF1
mkGFIFOF1

mkSizedFIFO              SizedFIFO.v  SizedFIFO0.v        If the depth of the FIFO = 1,
mkSizedFIFOF             FIFO1.v      FIFO10.v            then FIFO1.v and FIFO10.v
mkUGSizedFIFOF           FIFO2.v      FIFO20.v            are used, if the depth = 2,
mkGSizedFIFOF                                             then FIFO2.v and FIFO20.v
                                      SizedFIFO0.v        are used.

mkDepthParamFIFOF        SizedFIFO.v
mkUGDepthParamFIFOF
mkGDepthParamFIFOF

mkLFIFO                  FIFOL1.v     FIFOL10.v
mkLFIFOF
mkUGLFIFOF
mkGLFIFOF

                         c 2008 Bluespec, Inc. All rights reserved         185


Reference Guide                                                      Bluespec SystemVerilog

C.1.4 FIFOLevel

Package Name

import FIFOLevel :: * ;

Description

The BSV FIFOLevel library provides enhanced FIFO interfaces and modules which include methods
to indicate the level or the current number of items stored in the FIFO. Both single clock and dual
clock (separate clocks for the enqueue and dequeue sides) versions are included in this package.

Interfaces and methods

The FIFOLevelIfc interface deﬁnes methods to compare the current level to Integer constants for
a single clock. The SyncFIFOLevelIfc deﬁnes the same methods for dual clocks; thus it provides
methods for both the source (enqueue) and destination (dequeue) clock domains. Instead of methods
to compare the levels, the FIFOCountIfc and SyncFIFOCountIfc deﬁne methods to return counts
of the FIFO contents, for single clocks and dual clocks respectively.

Interface Name      Parameter     Parameter Description        Requirements of modules
FIFOLevelIfc        name                                       implementing the ifc
FIFOCountIfc        element type  type of the elements stored  must be in Bits class
SyncFIFOLevelIfc    ﬁfoDepth      in the FIFO
                    element type  the depth of the FIFO        must be numeric type and
SyncFIFOCountIfc    ﬁfoDepth                                   &gt;2
                    element type  type of the elements stored  must be in Bits class
                    ﬁfoDepth      in the FIFO
                                  the depth of the FIFO        must be numeric type and
                    element type                               &gt;2
                    ﬁfoDepth      type of the elements stored  must be in Bits class
                                  in the FIFO
                                  the depth of the FIFO        must be numeric type and
                                                               must be a power of 2 and
                                  type of the elements stored  &gt;=2
                                  in the FIFO                  must be in Bits class
                                  the depth of the FIFO
                                                               must be numeric type and
                                                               must be a power of 2 and
                                                               &gt;=2

In addition to common FIFO methods, the FIFOLevelIfc interface deﬁnes methods to compare the
current level to Integer constants. See Section C.1.2 for details on enq, deq, first, clear, notFull,
and notEmpty. Note that FIFOLevelIfc interface has a type parameter for the fifoDepth. This
numeric type parameter is needed, since the width of the counter is dependent on the FIFO depth.
The fifoDepth parameter must be &gt; 2.

     Name           Type                    FIFOLevelIfc   Name       Argument
     isLessThan     Bool  Method                           c1              Description

     isGreaterThan  Bool     Description                   c1        an Integer compile-
                                                                     time constant
                             Returns True if the depth
                             of the FIFO is less than the            an Integer compile-
                             Integer constant, c1.                   time constant
                             Returns True if the depth of
                             the FIFO is greater than the
                             Integer constant, c1.

186                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

interface FIFOLevelIfc#( type element_type, numeric type fifoDepth ) ;
    method Action enq( element_type x1 );
    method Action deq();
    method element_type first();
    method Action clear();

    method Bool notFull ;
    method Bool notEmpty ;

    method Bool isLessThan ( Integer c1 ) ;
    method Bool isGreaterThan( Integer c1 ) ;
endinterface

In addition to common FIFO methods, the FIFOCountIfc interface deﬁnes a method to return the
current number of elements as an bit-vector. See Section C.1.2 for details on enq, deq, first,
clear, notFull, and notEmpty. Note that the FIFOCountIfc interface has a type parameter for the
fifoDepth. This numeric type parameter is needed, since the width of the counter is dependent on
the FIFO depth. The fifoDepth parameter must be &gt; 2.

                        FIFOCountIfc
                            Method

Name   Type             Description
count
       UInt#(TLog#(TAdd#(ﬁfoDepth,1))) Returns the number of items in the FIFO.

interface FIFOCountIfc#( type element_type, numeric type fifoDepth) ;
    method Action enq ( element_type sendData ) ;
    method Action deq () ;
    method element_type first () ;

    method Bool notFull ;
    method Bool notEmpty ;

    method UInt#(TLog#(TAdd#(fifoDepth,1))) count;

    method Action clear;
endinterface

The interfaces SyncFIFOLevelIfc and SyncFIFOCountIfc are dual clock versions of the FIFOLevelIfc
and FIFOCountIfc. Methods are provided for both source and destination clock domains. The fol-
lowing table describes the dual clock notFull and notEmpty methods, as well as the dual clock
clear methods, which are common to both interfaces. Note that the SyncFIFOLevelIfc and
SyncFIFOCountIfc interfaces each have a type parameter for fifoDepth. This numeric type pa-
rameter is needed, since the width of the counter is dependent on the FIFO depth. The fifoDepth
parameter must be a power of 2 and &gt;= 2.

                        c 2008 Bluespec, Inc. All rights reserved       187


Reference Guide                                                      Bluespec SystemVerilog

     Name                        Common Dual Clock Methods
     sNotFull          Type Description

     sNotEmpty         Bool    Returns True if the FIFO appears as not full from the
                       Bool    source side clock.
     dNotFull          Bool    Returns True if the FIFO appears as not empty from the
                       Bool    source side clock.
     dNotEmpty         Action  Returns True if the FIFO appears as not full from the des-
                       Action  tination side clock.
     sClear                    Returns True if the FIFO appears as not empty from the
     dClear                    destination side clock.
                               Clears the FIFO from the source side.
                               Clears the FIFO from the destination side.

In addition to common FIFO methods (Section C.1.2) and the common dual clock methods above,
the SyncFIFOLevelIfc interface deﬁnes methods to compare the current level to Integer constants.
Methods are provided for both the source (enqueue side) and destination (dequeue side) clock do-
mains.

Name             Type           SyncFIFOLevelIfc Methods       Name   Argument
sIsLessThan      Bool  Method                                  c1          Description

sIsGreaterThan   Bool    Description                           c1    an Integer compile-
                                                                     time constant
dIsLessThan      Bool    Returns True if the depth of          c1
                         the FIFO, as appears on the                 an Integer compile-
dIsGreaterThan   Bool    source side clock, is less than the   c1    time constant.
                         Integer constant, c1.
                         Returns True if the depth of the            an Integer compile-
                         FIFO, as it appears on the source           time constant
                         side clock, is greater than the
                         Integer constant, c1.                       an Integer compile-
                         Returns True if the depth of the            time constant.
                         FIFO, as it appears on the desti-
                         nation side clock, is less than the
                         Integer constant, c1.
                         Returns True if the depth of the
                         FIFO, as appears on the destina-
                         tion side clock, is greater than the
                         Integer constant, c1.

interface SyncFIFOLevelIfc#( type element_type, numeric type fifoDepth ) ;
    method Action enq ( element_type sendData ) ;
    method Action deq () ;
    method element_type first () ;

    method Bool sNotFull ;
    method Bool sNotEmpty ;
    method Bool dNotFull ;
    method Bool dNotEmpty ;

    method Bool sIsLessThan ( Integer c1 ) ;
    method Bool sIsGreaterThan( Integer c1 ) ;
    method Bool dIsLessThan ( Integer c1 ) ;
    method Bool dIsGreaterThan( Integer c1 ) ;

188                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

    method Action sClear;
    method Action dClear;
endinterface

In addition to common FIFO methods (Section C.1.2) and the common dual clock methods above,
the SyncFIFOCountIfc interface deﬁnes methods to return the current number of elements. Methods
are provided for both the source (enqueue side) and destination (dequeue side) clock domains.

                         SyncFIFOCountIfc
                                Method

Name    Type                             Description
sCount
        UInt#(TLog#(TAdd#(ﬁfoDepth,1)))  Returns the number of items in the FIFO
dCount  UInt#(TLog#(TAdd#(ﬁfoDepth,1)))  from the source side.
                                         Returns the number of items in the FIFO
                                         from the destination side.

interface SyncFIFOCountIfc#( type element_type, numeric type fifoDepth) ;
    method Action enq ( element_type sendData ) ;
    method Action deq () ;
    method element_type first () ;

method Bool sNotFull ;
method Bool sNotEmpty ;
method Bool dNotFull ;
method Bool dNotEmpty ;

method UInt#(TLog#(TAdd#(fifoDepth,1))) sCount;
method UInt#(TLog#(TAdd#(fifoDepth,1))) dCount;

    method Action sClear;
    method Action dClear;
endinterface

The FIFOLevelIFC, SyncFIFOLevelIfc, FIFOCountIfc, and SyncFIFOCountIfc interfaces belong
to the toGet and toPut typeclasses. You can use the toGet and toPut functions to convert these
interfaces to Get and Put interfaces (Section C.6.1).

Modules

The module mkFIFOLevel provides the FIFOLevelIfc interface. Note that the implementation allows
any number of isLessThan and isGreaterThan method calls. Each call with a unique argument
adds an additional comparator to the design.

There is also available a guarded (G) version of FIFOLevel which takes three Boolean parameters;
ugenq, ugdeq, and ugcount. Setting any of the parameters to TRUE indicates the method (enq for
ugenq, deq for ugdeq, and isLessThan, isGreaterThan for ugcount) is unguarded. If all three are
FALSE the behavior is the same as a regular FIFOLevel.

Module Name   BSV Module Declaration
mkFIFOLevel
              module mkFIFOLevel (
                             FIFOLevelIfc#(element_type, fifoDepth) )

                  provisos( Bits#(element_type, width_element )
                                  Log#(TAdd#(fifoDepth,1),cntSize) ) ;

              Comment: width_element may be 0

                        c 2008 Bluespec, Inc. All rights reserved          189


Reference Guide                                                  Bluespec SystemVerilog

     Module Name   BSV Module Declaration
     mkGFIFOLevel
                   module mkGFIFOLevel#(Bool ugenq, Bool ugdeq, Bool ugcount)
                                    ( FIFOLevelIfc#(element_type, fifoDepth) )

                       provisos( Bits#(element_type, width_element ),
                                      Log#(TAdd#(fifoDepth,1),cntSize));

                   Comment: width_element may be 0

The module mkFIFOCount provides the interface FIFOCountIfc. There is also available a guarded (G)
version of FIFOCount which takes three Boolean parameters; ugenq, ugdeq, and ugcount. Setting
any of the parameters to TRUE indicates the method (enq for ugenq, deq for ugdeq, and count for
ugcount) is unguarded. If all three are FALSE the behavior is the same as a regular FIFOCount.

     Module Name   BSV Module Declaration
     mkFIFOCount
                   module mkFIFOCount(
                                  FIFOCountIfc#(element_type, fifoDepth) ifc )

                       provisos (Bits#(element_type, width_element));

                   Comment: width_element may be 0

     Module Name   BSV Module Declaration
     mkGFIFOCount
                   module mkGFIFOCount#(Bool ugenq, Bool ugdeq, Bool ugcount)
                                 ( FIFOCountIfc#(element_type, fifoDepth) ifc )

                       provisos (Bits#(element_type, width_element));

                   Comment: width_element may be 0

The modules mkSyncFIFOLevel and mkSyncFIFOCount are dual clock FIFOs, where enqueue and
dequeue methods are in separate clocks domains, sClkIn and dClkIn respectively. Because of the
synchronization latency, the ﬂag indicators will not necessarily be identical between the source and
the destination clocks. Note however, that the sNotFull and dNotEmpty ﬂags always give proper
(pessimistic) indications for the safe use of enq and deq methods; these are automatically included
as implicit condition in the enq and deq (and first) methods.

The module mkSyncFIFOLevel provides the SyncFIFOLevelIfc interface.

     Module Name      BSV Module Declaration
     mkSyncFIFOLevel
                      module mkSyncFIFOLevel(
                                     Clock sClkIn, Reset sRstIn,
                                     Clock dClkIn,
                                     SyncFIFOLevelIfc#(element_type, fifoDepth) ifc )

                          provisos( Bits#(element_type, width_element),
                                         Add#(1,fifoDepth,fifoDepth1),
                                         Log#(fifoDepth1,cntSz) ) ;

                      Comment: width_element may be 0

190                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                        Figure 3: SyncFIFOCount

The module mkSyncFIFOCount, as shown in Figure 3 provides the SyncFIFOCountIfc interface.
Because of the synchronization latency, the count reports may be diﬀerent between the source and
the destination clocks. Note however, that the sCount and dCount reports give pessimistic values
with the appropriate side. That is, the count sCount (on the enqueue clock) will report the exact
count of items in the FIFO or a larger count. The larger number is due to the synchronization
delay in observing the dequeue action. Likewise, the dCount (on the dequeue clock) returns the
exact count or a smaller count. The maximum disparity between sCount and dCount depends on
the diﬀerence in clock periods between the source and destination clocks.

The module provides sClear and dClear methods, both of which cause the contents of the FIFO
to be removed. Since the clears must be synchronized and acknowledged from one domain to the
other, there is a non-trivial delay before the FIFO recovers from the clear and can accept additional
enqueues or dequeues (depending on which side is cleared). The calling of either method immediately
disables other activity in the calling domain. That is, calling sClear in cycle n causes the enqueue
to become unready in the next cycle, n+1. Likewise, calling dClear in cycle n causes the dequeue to
become unready in the next cycle, n+1.

After the sClear method is called, the FIFO appears empty on the dequeue side after three dClock
edges. Three sClock edges later, the FIFO returns to a state where new items can be enqueued. The
latency is due to the full handshaking synchronization required to send the clear signal to dClock
and receive the acknowledgement back.

For the dClear method call, the enqueue side is cleared in three sClkIn edges and items can be
enqueued at the fourth edge. All items enqueued at or before the clear are removed from the FIFO.

Note that there is a ready signal associated with both sClear and dClear methods to ensure that
the clear is properly sent between the clock domains. Also, sRstIn must be synchronized with the
sClkIn.

                        c 2008 Bluespec, Inc. All rights reserved  191


Reference Guide                                                  Bluespec SystemVerilog

     Module Name      BSV Module Declaration
     mkSyncFIFOCount
                      module mkSyncFIFOCount(
                                     Clock sClkIn, Reset sRstIn,
                                     Clock dClkIn,
                                     SyncFIFOCountIfc#(element_type, fifoDepth) ifc )

                          provisos( Bits#(element_type, width_element));

                      Comment: width_element may be 0

Example

The following example shows the use of SyncFIFOLevel as a way to collect data into a FIFO, and
then send it out in a burst mode. The portion of the design shown, waits until the FIFO is almost
full, and then sets a register, burstOut which indicates that the FIFO should dequeue. When the
FIFO is almost empty, the ﬂag is cleared, and FIFO ﬁlls again.

    ...
    // Define a fifo of Int(#23) with 128 entries
    SyncFIFOLevelIfc#(Int#(23),128) fifo &lt;- mkSyncFIFOLevel(sclk, rst, dclk ) ;

    // Define some constants
    let sFifoAlmostFull = fifo.sIsGreaterThan( 120 ) ;
    let dFifoAlmostFull = fifo.dIsGreaterThan( 120 ) ;
    let dFifoAlmostEmpty = fifo.dIsLessThan( 12 ) ;

    // a register to indicate a burst mode
    Reg#(Bool) burstOut &lt;- mkReg( False, clocked_by (dclk)) ;

    ...
    // Set and clear the burst mode depending on fifo status
    rule timeToDeque( dFifoAlmostFull &amp;&amp; ! burstOut ) ;

         burstOut &lt;= True ;
    endrule

    rule moveData ( burstOut ) ;
         let dataToSend = fifo.first ;
         fifo.deq ;
         ...
         burstOut &lt;= !dFifoAlmostEmpty;

    endrule

Verilog Modules

The modules described in this section correspond to the following Verilog modules, which are found
in the Bluespec Verilog library, $BLUESPECDIR/Verilog/.

192                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

BSV Module Name                      Verilog Module Names

mkFIFOLevel             SizedFIFO.v      SizedFIFO0.v
mkFIFOCount
                        SyncFIFOLevel.v
mkSyncFIFOLevel
mkSyncFIFOCount

C.1.5 ConﬁgReg

Package Name

import ConﬁgReg :: * ;

Description

The ConfigReg package provides a way to create registers where each update clobbers the current
value, but the precise timing of updates is not important. These registers are identical to the mkReg
registers except that their scheduling annotations allows reads and writes to occur in either order
during rule execution.

Rules which ﬁre during the clock cycle where the register is written read a stale value (that is the
value from the beginning of the clock cycle) regardless of ﬁring order and writes which have occurred
during the clock cycle. Thus if rule r1 writes to a ConﬁgReg cr and rule r2 reads cr later in the
same cycle, the old or stale value of cr is read, not the value written in r1. If a standard register
is used instead, rule r2’s execution will be blocked by r1’s execution or the scheduler may create a
diﬀerent rule execution order.

The hardware implementation is identical for the more common registers (mkReg, mkRegU and
mkRegA), and the module constructors parallel these as well.

Interfaces

The ConfigReg interface is an alias of the Reg interface (section B.4.1).
typedef Reg#(a_type) ConfigReg #(type a_type);

Modules

The ConfigReg package provides three modules; mkConfigReg creates a register with a given re-
set value and synchronous reset logic, mkConfigRegU creates a register without any reset, and
mkConfigRegA creates a register with a given reset value and asynchronous reset logic.

mkConfigReg             Make a register with a given reset value. Reset logic is synchronous

                        module mkConfigReg#(a_type resetval)(Reg#(a_type))
                           provisos (Bits#(a_type, sizea));

mkConfigRegU            Make a register without any reset; initial simulation value is alternating
                        01 bits.

                        module mkConfigRegU(Reg#(a_type))
                           provisos (Bits#(a_type, sizea));

                        c 2008 Bluespec, Inc. All rights reserved                             193


Reference Guide                                        Bluespec SystemVerilog

mkConfigRegA     Make a register with a given reset value. Reset logic is asynchronous.

                 module mkConfigRegA#(a_type, resetval)(Reg#(a_type))
                    provisos (Bits#(a_type, sizea));

                        Scheduling Annotations

                 mkConﬁgReg, mkConﬁgRegU, mkConﬁgRegA

                        read  write

                 read   CF    CF

                 write  CF    SBR

C.1.6 DReg

Package Name

import DReg :: * ;

Description

The DReg package allows a designer to create registers which store a written value for only a single
clock cycle. The value written to a DReg is available to read one cycle after the write. If more than
one cycle has passed since the register has been written however, the value provided by the register
is instead a default value (that is speciﬁed during module instantiation). These registers are useful
when wanting to send pulse values that are only asserted for a single clock cycle. The DReg is the
register equivalent of a DWire B.4.5.

Modules

The DReg package provides three modules; mkDReg creates a register with a given reset/default value
and synchronous reset logic, mkDRegU creates a register without any reset (but which still takes a
default value as an argument), and mkDRegA creates a register with a given reset/default value and
asynchronous reset logic.

mkDReg           Make a register with a given reset/default value. Reset logic is syn-
                 chronous

                 module mkDReg#(a_type dflt_rst_val)(Reg#(a_type))
                    provisos (Bits#(a_type, sizea));

mkDRegU          Make a register without any reset but with a speciﬁed default; initial
                 simulation value is alternating 01 bits.

                 module mkDRegU#(a_type dflt_val)(Reg#(a_type))
                    provisos (Bits#(a_type, sizea));

 mkDRegA         Make a register with a given reset/default value. Reset logic is asyn-
194              chronous.
                 module mkDRegA#(a_type, dflt_rst_val)(Reg#(a_type))

                    provisos (Bits#(a_type, sizea));

                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                                Scheduling Annotations
                           mkDReg, mkDRegU, mkDRegA

                                  read write

                           read   CF             SB
                           write
                                  SA             SBR

C.1.7 RevertingVirtualReg

Package Name
import RevertingVirtualReg :: * ;
Description
The RevertingVirtualReg package allows a designer to force a schedule when scheduling attributes
cannot be used. Since scheduling attributes cannot be put on methods, this allows a designer to
control the schedule between two methods, or between a method and a rule by adding a virtual
register between the two. The module RevertingVirtualReg creates a virtual register; no actual
state elements are generated.
Modules
The RevertingVirtualReg package provides the module mkRevertingVirtualReg. The properties
of the module are:

    • it schedules exactly like an ordinary register;

    • it reverts to its reset value at the end of each clock cycle.

These imply that all allowed reads will return the reset value (since they precede any writes in the
cycle); thus the module neither needs nor instantiates any actual state element.

 mkRevertingVirtualReg Creates a virtual register reverting to the reset value at the end of
                                      each clock cycle.

                                      module mkRevertingVirtualReg#(a_type rst)(Reg#(a_type))
                                         provisos (Bits#(a_type, sizea));

                           Scheduling Annotations
                           mkRevertingVirtualReg

                                  read write

                           read   CF SB

                           write  SA SBR

Example Use mkRevertingVirtualReg to create the execution order of the rule followed by the method

Reg#(Bool) virtualReg &lt;- mkRevertingVirtualReg(True);

rule the_rule (virtualReg); // reads virtualReg
    ...

endrule

method Action the_method;  // writes virtualReg
    virtualReg &lt;= False;
    ...

endmethod

                        c 2008 Bluespec, Inc. All rights reserved  195


Reference Guide                                                  Bluespec SystemVerilog

In a given cycle, reads always precede writes for a register. Therefore the reading of virtualReg
by the_rule will precede the writing of virtualReg in the_method. The execution order will be
the_rule followed by the_method.

C.1.8 BRAM

Package Name
import BRAM :: * ;
Description
This package provides Block RAMS for use in Xilinx FPGAs. The ClientServer package must also
be imported when using the BRAM package.
Types and type classes
The BRAM package deﬁnes a structure, BRAMRequest, along with types BRAMServer and BRAMClient.

typedef struct {Bool write;
                         addr address;
                         data datain;

                       } BRAMRequest#(type addr_t, type data_t) deriving(Bits, Eq);

typedef Server#(BRAMRequest#(addr_t, data_t), data_t)
                         BRAMServer#(type addr_t, type data_t);

typedef Client#(BRAMRequest#(addr_t, data_t), data_t)
                         BRAMClient#(type addr_t, type data_t);

Interfaces and Methods
The BRAM package deﬁnes the BRAM interface.

interface BRAM#(type addr_t type data_t);
    interface BRAMServer#(addr_t, data_t) portA;
    interface BRAMServer#(addr_t, data_t) portB;

endinterface: BRAM

Modules

The BRAM package provides the following modules: mkSyncBRAM, mkBRAM, and mkSyncBRAMLoadEither.
These modules correspond to the Xilinx Dual-Port Block RAM with two write ports.

mkSyncBRAM       Creates a 2-port BRAM with two clocks; clkA is shared by the primary
                 read and write port, clkB is shared by the secondary read and write
                 port. Resets must be synched to the clock domains. There is no default
                 clock or reset domain.

                 module mkSyncBRAM#
                          (Clock clkA, Reset rstNA, Clock clkB, Reset rstNB)
                          (BRAM#(addr_t, data_t))

                     provisos (Bits(addr_t, addr_sz), Bits#(data_t, data_sz),
                             Add#(z, 1, addr_sz), Add#(x, 1, data_sz),
                             Bounded#(addr_t));

196              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkBRAM                  Creates a 2-port BRAM with a single clock.

                        module mkBRAM(BRAM#(addr_t, data_t))
                            provisos(Bits#(addr_t, addr_sz),Bits#(data_t, data_sz),
                                   Add#(z, 1, addr_sz),Add#(x, 1, data_sz),
                                   Bounded#(addr_t) );

 mkSyncBRAMLoadEither Creates a dual-clock, two port BRAM and loads the initial values from
                                    a ﬁle containing either hex or binary values. Resets must be synched
                                    to the clock domains. There is no default clock or reset domain.

                                    module mkSyncBRAMLoadEither#
                                                   (Clock clkA,Reset rstNA,Clock clkB,
                                                     Reset rstNB, String file, Integer binary)
                                                   (BRAM#(addr_t, data_t))

                                        provisos(Bits#(addr_t, addr_sz),Bits#(data_t, data_sz),
                                               Add#(z, 1, addr_sz), Add#(x, 1, data_sz),
                                               Bounded#(addr_t));

Verilog Modules

BRAM modules correspond to the following Verilog modules, which are found in the Bluespec Verilog
library, $BLUESPECDIR/Verilog/.

BSV Module Name         Verilog Module Names
                        BRAM.v
mkSyncBRAM              BRAMLoad.v
mkBRAM
mkSyncBRAMLoadEither

C.1.9 BRAMFIFO

Description
The BRAMFIFOs are FIFOs which utilize the Xilinx Block RAMs, as implemented in the BRAM
package, described in Section C.1.8.
This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.
Packages
To include a package in your design, use the import syntax.

       import BRAMFIFO :: * ;

Interfaces
The BRAMFIFO package uses FIFOF, FIFO, and SyncFIFOIfc interfaces, as deﬁned in the FIFOF, FIFO,
(both in Section C.1.3) and Clocks (Section C.8.7) packages.

                        c 2008 Bluespec, Inc. All rights reserved  197


Reference Guide                                                                   Bluespec SystemVerilog
Modules
                    Provides a Xilinx BRAM based FIFOF of a given depth, n.
 mkSizedBRAMFIFOF   module mkSizedBRAMFIFOF#(Integer n) (FIFOF#(element_type))

                        provisos (Bits(element_type, width_any),
                                        Add#(1,z,width_any));

mkSizedBRAMFIFO     Provides a Xilinx BRAM based FIFO of a given depth, n.

                    module mkSizedBRAMFIFO#(Integer n)(FIFO#(element_type))
                        provisos(Bits#(t, width_element),
                                       Add#(1, z, width_element) );

mkSyncBRAMFIFO      Provides a Xilinx BRAM based FIFO for sending data across clock
                    domains. The enq method is in the source sClkIn domain, while the
                    deq and first methods are in the destination dClkIn domain. The
                    input and output clocks, along with the input and output resets, are
                    explicitly provided. The default clock and reset are ignored.

                    module mkSyncBRAMFIFO#(Integer depth,
                                                        Clock sClkIn, Reset sRstIn,
                                                        Clock dClkIn, Reset dRstIn)
                                                        (SyncFIFOIfc#(element_type))

                        provisos(Bits#(element_type, width_element),
                                       Add#(1, z, width_element));

mkSyncBRAMFIFOToCC  Provides a Xilinx BRAM based FIFO to send data from a second clock
                    domain into the current clock domain. The output clock and reset are
                    the current clock and reset.

                    module mkSyncBRAMFIFOToCC#(Integer depth,
                                                              Clock sClkIn, Reset sRstIn)
                                                              (SyncFIFOIfc#(element_type))

                        provisos(Bits#(element_type, width_element),
                                       Add#(1, z, width_element));

mkSyncBRAMFIFOFromCC Provides a Xilinx BRAM based FIFO to send data from the current
                                  clock domain into a second clock domain. The input clock and reset
                                  are the current clock and reset.

                                  module mkSyncBRAMFIFOFromCC#(Integer depth,
                                                                                Clock dClkIn, Reset dRstIn)
                                                                                (SyncFIFOIfc#(element_type))

                                       provisos(Bits#(element_type, width_element),
                                                     Add#(1, z, width_element));

198                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                          Reference Guide

C.2 Aggregation: Vectors

Package Name

import Vector :: * ;

Description

The Vector package deﬁnes an abstract data type which is a container of a speciﬁc length, holding
elements of one type. Functions which create and operate on this type are also deﬁned within this
package. Because it is abstract, there are no constructors available for this type (like Cons and Nil
for the List type).

       typedef struct Vector#(type numeric vsize, type element_type);

Here, the type variable element_type represents the type of the contents of the elements while the
numeric type variable vsize represents the length of the vector.

If the elements are in the Bits class, then the vector is as well. Thus a vector of these elements can
be stored into Registers or FIFOs; for example a Register holding a vector of type int. Note that a
vector can also store abstract types, such as a vector of Rules or a vector of Reg interfaces. These
are useful during static elaboration although they have no hardware implementation.

Typeclasses

                                  Type Classes for Vector

            Bits Eq Literal Arith Ord Bounded Bitwise Bit                       Bit

               √√                                    √             Reduction Extend
Vector

A vector can be turned into bits if the individual elements can be turned into bits. When packed
and unpacked, the zeroth element of the vector is stored in the least signiﬁcant bits. The size of the
resulting bits is given by tsize = vsize ∗ SizeOf#(element type) which is speciﬁed in the provisos.

instance Bits #( Vector#(vsize, element_type), tsize)
    provisos (Bits#(element_type, sizea),
                    Mul#(vsize, sizea, tsize));

Vectors are zero-indexed; the ﬁrst element of a vector v, is v[0]. When vectors are packed, they are
packed in order from the LSB to the MSB.

Example. Vector#(5, Bit#(7)) v1;

From the type, you can see that this will back into a 35-bit vector (5 elements, each with 7 bits).

MSB  34                 bit positions         v1[0] 0 LSB
     v1[4]
            v1[3]       v1[2]          v1[1]

Example. A vector with a structure:
typedef struct { Bool a, UInt#(5) b} Newstruct deriving (Bits);
Vector#(3, NewStruct) v2;

The structure, Newstruct packs into 6 bits. Therefore v2 will pack into an 18-bit vector. And its
structure would look as follows:

     17     16 - 12               11          10 - 6          5                 0
                                                           v2[0].a v2[0].b          LSB
MSB v2[2].a v2[2].b               v2[1].a v2[1].b
                                                                         v2[0]
            v2[2]                             v2[1]

Vectors can be compared for equality if the elements can. That is, the operators == and != are
deﬁned.

Vectors are bounded if the elements are.

                        c 2008 Bluespec, Inc. All rights reserved                    199


Reference Guide                                                       Bluespec SystemVerilog

C.2.1 Creating and Generating Vectors

The following functions are used to create new vectors, with and without deﬁned elements. There
are no Bluespec SystemVerilog constructors available for this abstract type (and hence no pattern-
matching is available for this type) but the following functions may be used to construct values of
the Vector type.

newVector Generate a vector with undeﬁned elements, typically used when vectors are de-
                  clared.

         function Vector#(vsize, element_type) newVector();

genVector Generate a vector containing integers 0 through n-1, vector[0] will have value 0.
                  function Vector#(vsize, Integer) genVector();

replicate Generate a vector of elements by replicating the given argument (c).
                  function Vector#(vsize, element_type) replicate(element_type c);

genWith  Generate a vector of elements by applying the given function to 0 through n-1.
         The argument to the function is another function which has one argument of type
         Integer and returns an element_type.

         function Vector#(vsize, element_type)
                       genWith(function element_type func(Integer x1));

cons     Adds an element to a vector creating a vector one element larger. The new element
         will be at the 0th position. This function can lead to large compile times, so it
         can be an ineﬃcient way to create and populate a vector. Instead, the designer
         should build a vector, then set each element to a value.

         function Vector#(vsize1, element_type)
                cons (element_type elem, Vector#(vsize, element_type) vect)

            provisos (Add#(1, vsize, vsize1));

 nil     Deﬁnes a vector of size zero.
200      function Vector#(0, element_type) nil;

                           c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                       Reference Guide

append  Append two vectors containing elements of the same type, returning the combined
        vector. The resulting vector will contain all the elements of vecta followed by all
        the elements of vectb.

        function Vector#( vsize, element_type )
                 append( Vector#(v0size,element_type) vecta
                              Vector#(v1size,element_type) vectb

           provisos (Add#(v0size, v1size, vsize)); //vsize = vsize0 + v1size

concat  Append (concatenate) many vectors, that is a vector of vectors into one vector.

        function Vector#(mvsize,element_type)
                 concat(Vector#(m,Vector#(n,element_type)) xss)

           provisos (Mul#(m,n,mvsize));

Examples - Creating and Generating Vectors
Create a new vector, my_vector, of 5 elements of datatytpe Int#(32), with elements which are
undeﬁned.

       Vector #(5, Int#(32)) my_vector;

Create a new vector, my_vector, of 5 elements of datatytpe Integer with elements 0, 1, 2, 3 and 4.

Vector #(5, Integer) my_vector = genVector;
// my_vector is a 5 element vector {0,1,2,3,4}

Create a vector, my vector, of ﬁve 1’s.

       Vector #(5,Int #(32)) my_vector = replicate (1);
       // my_vector is a 5 element vector {1,1,1,1,1}

Create a vector, my_vector, by applying the given function add2 to 0 through n-1.

       function Integer add2 (Integer a);
              Integer c = a + 2;

       return(c);
       endfunction

Vector #(5,Integer) my_vector = genWith(add2);

// a is the index of the vector, 0 to n-1
// my_vector = {2,3,4,5,6,}

Add an element to my_vector, creating a bigger vector my_vector1.

       Vector#(3, Integer) my_vector = genVector();
       // my_vector = {0, 1, 2, 3}

let my_vector1 = cons(4, a);
// my_vector1 = {4, 0, 1, 2, 3}

Append vectors, my_vector and my_vector1, resulting in a vector my_vector2.

                        c 2008 Bluespec, Inc. All rights reserved                        201


Reference Guide                                                    Bluespec SystemVerilog

       Vector#(3, Integer) my_vector = genVector();
       // my_vector = {0, 1, 2, 3}

       Vector#(3, Integer) my_vector1 = genVector();
       // my_vector1 = {5, 6, 7, 8}

       let my_vector2 = append(my_vector, my_vector1);
       // my_vector2 = {0, 1, 2, 3, 5, 6, 7, 8}

Obtain a vector, my_vector, from a two dimensions vector, matrix.

       Vector#(3, Vector#(3, Integer)) matrix;
       for (Integer i = 0; i &lt; 3; i = i + 1)
       matrix[i] = genVector;

       // matrix[0] = {0, 1, 2}
       // matrix[1] = {3, 4, 5}
       // matrix[2] = {6, 7, 8}

       let my_vector = concat (matrix);
       // my_vector = {0, 1, 2, 3, 4, 5, 6, 7, 8}

C.2.2 Extracting Elements and Sub-Vectors

These functions are used to select elements or vectors from existing vectors, while retaining the input
vector.

[i]     The square-bracket notation is available to extract an element from a vector or

        update an element within it. Extracts or updates the ith element, where the ﬁrst

        element is [0]. Index i must be of an indexable type; (e.g. Integer, Bit#(n),

        Int#(n) or UInt#(n).). The square-bracket notation for vectors can also be used

        with register writes.

        anyVector[i];
        anyVector[i] = newValue;

select  The select function is another form of the subscript notation ([i]), mainly provided
        for backwards-compatibility. The select function is also useful as an argument to
        higher-order functions. The subscript notation is generally recommended because
        it will report a more useful position for any selection errors.

        function element_type
                 select(Vector#(vsize,element_type) vect, idx_type index);

202     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

update  Update an element in a vector returning a new vector with one element
        changed/updated. This function does not change the given vector. This is an-
        other form of the subscript notation (see above), mainly provided for backwards
        compatibility. The update function may also be useful as an argument to a higher-
        order function. The subscript notation is generally recommended because it will
        report a more useful position for any update errors.

        function Vector#(vsize, element_type)
                 update(Vector#(vsize, element_type) vectIn,
                            idx_type index,
                            element_type newElem);

head    Extract the zeroth (head) element of a vector. The vector must have at least one
        element.

        function element_type
                 head (Vector#(vsize, element_type) vect)

           provisos(Add#(1,xxx,vxize)); // vsize &gt;= 1

last    Extract the highest (tail) element of a vector. The vector must have at least one
        element.

        function element_type
                 last (Vector#(vsize, element_type) vect)

           provisos(Add#(1,xxx,vxize)); // vsize &gt;= 1

tail    Remove the head element of a vector leaving its tail in a smaller vector.

        function Vector#(vsize,element_type)
                 tail (Vector#(vsize1, element_type) xs)

           provisos (Add#(1, vsize, vsize1));

init    Remove the last element of a vector leaving its initial part in a smaller vector.

        function Vector#(vsize,element_type)
                 init (Vector#(vsize1, element_type) xs)

           provisos (Add#(1, vsize, vsize1));

                        c 2008 Bluespec, Inc. All rights reserved                          203


Reference Guide                                                          Bluespec SystemVerilog

take      Take a number of elements from a vector starting from index 0. The number of
          elements to take is indicated by the type of the context where this is called, and
          is not speciﬁed as an argument to the function.

          function Vector#(vxize2,element_type)
                   take (Vector#(vsize,element_type) vect)

             provisos (Add#(vsize2,xxx,vsize)); // vsize2 &lt;= vsize.

drop      Drop a number of elements from the vector starting at the 0th position. The
takeTail  elements in the result vector will be in the same order as the input vector.

          function Vector#(vxize2,element_type)
                   drop (Vector#(vsize,element_type) vect)

             provisos (Add#(vsize2,xxx,vsize)); // vsize2 &lt;= vsize.

          function Vector#(vxize2,element_type)
                   takeTail (Vector#(vsize,element_type) vect)

             provisos (Add#(vsize2,xxx,vsize)); // vsize2 &lt;= vsize.

takeAt    Take a number of elements starting at startPos. startPos must be a compile-
          time constant. If the startPos and vector size cause the function to go past the
          end of the vector, an error will be returned.

          function Vector#(vsize2,element_type)
                     takeAt (Integer startPos, Vector#(vsize,element_type) vect)

             provisos (Add#(vsize2,xxx,vsize)); // vsize2 &lt;= vsize

Examples - Extracting Elements and Sub-Vectors

Extract the element from a vector, my_vector, at the position of index.

       // my_vector is a vector of elements {6,7,8,9,10,11}
       // index = 3
       // select or [ ] will generate a MUX

       newvalue = select (my_vector, index);
       newvalue = myvalue[index];
       // newvalue = 9

Update the element of a vector, my_vector, at the position of index.

       // my_vector is a vector of elements {6,7,8,9,10,11}
       // index = 3

       my_vector = update (my_vector, index, 0);
       my_vector[index] = 0;
       // my_vector = {6,7,8,0,10,11}

Extract the zeroth element of the vector my_vector.

204              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

       // my_vector is a vector of elements {6,7,8,9,10,11}

       newvalue = head(my_vector);
       // newvalue = 6

Extract the last element of the vector my_vector.
       // my_vector is a vector of elements {6,7,8,9,10,11}

       newvalue = last(my_vector);
       // newvalue = 11

Create a vector, my_vector2, of size 4 by removing the head (zeroth) element of the vector my_vector1.

       // my_vector1 is a vector with 5 elements {0,1,2,3,4}
       Vector #(4, Int#(32)) my_vector2 = tail (my_vector1);
       // my_vector2 is a vector of 4 elements {1,2,3,4}

Create a vector, my_vector2, of size 4 by removing the tail (last) element of the vector my_vector1.

       // my_vector1 is a vector with 5 elements {0,1,2,3,4}

       Vector #(4, Int#(32)) my_vector2 = init (my_vector1);
       // my_vector2 is a vector of 4 elements {0,1,2,3}

Create a 2 element vector, my_vector2, by taking the ﬁrst two elements of the vector my_vector1.
       // my_vector1 is vector with 5 elements {0,1,2,3,4}

       Vector #(2, Int#(4)) my_vector2 = take (my_vector1);
       // my_vector2 is a 2 element vector {0,1}

Create a 3 element vector, my_vector2, by taking the last 3 elements of vector, my_vector1. using
takeTail

       // my_vector1 is Vector with 5 elements {0,1,2,3,4}

       Vector #(3,Int #(4)) my_vector2 = takeTail (my_vector1);
       // my_vector2 is a 3 element vector {2,3,4}

Create a 3 element vector, my_vector2, by taking the 1st - 3rd elements of vector, my_vector1.
using takeAt

       // my_vector1 is Vector with 5 elements {0,1,2,3,4}

       Vector #(3,Int #(4)) my_vector2 = takeAt (1, my_vector1);
       // my_vector2 is a 3 element vector {1,2,3}

C.2.3 Vector to Vector Functions
The following functions generate a new vector by changing the position of elements within the vector.

                        c 2008 Bluespec, Inc. All rights reserved  205


Reference Guide                                                         Bluespec SystemVerilog

rotate    Move the zeroth element to the highest and shift each element lower by one. For
          example, the element at index n moves to index n-1.

          function Vector#(vsize,element_type)
                   rotate (Vector#(vsize,element_type) vect);

rotateR   Move last element to the zeroth element and shift each element up by one. For
          example, the element at index n moves to index n+1.

          function Vector#(vsize,element_type)
                   rotateR (Vector#(vsize,element_type) vect);

rotateBy  Shift each element n places. The last n elements are moved to the begining, the
          element at index 0 moves to index n, index 1 to index n+1, etc.

          function Vector#(vsize, element_type)
                   rotateBy (Vector#(vsize,element_type) vect, UInt#(log(v)) n)

             provisos (Log#(vsize, logv);

shiftInAt0 Shift a new element into the vector at index 0, bumping the index of all other
                  element up by one. The highest element is dropped.

                  function Vector#(vsize,element_type)
                            shiftInAt0 (Vector#(vsize,element_type) vect,
                                               element_type newElement);

shiftInAtN Shift a new element into the vector at index n, bumping the index of all other
                  elements down by one. The 0th element is dropped.

                  function Vector#(vsize,element_type)
                            shiftInAtN (Vector#(vsize,element_type) vect,
                                               element_type newElement);

reverse Reverse element order

                  function Vector#(vsize,element_type)
                            reverse(Vector#(vsize,element_type) vect);

206              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

transpose Matrix transposition of a vector of vectors.

                  function Vector#(m,Vector#(n,element_type))
                            transpose ( Vector#(n,Vector#(m,element_type)) matrix );

 transposeLN Matrix transposition of a vector of Lists.

                      function Vector#(vsize, List#(element_type))
                                transposeLN( List#(Vector#(vsize, element_type)) lvs );

Examples - Vector to Vector Functions
Create a vector by moving the last element to the ﬁrst, then shifting each element to the right.

       // my_vector1 is a vector of elements with values {1,2,3,4,5}

       my_vector2 = rotateR (my_vector1);
       // my_vector2 is a vector of elements with values {5,1,2,3,4}

Create a vector which is the input vector rotated by 2 places.
       // my_vector1 is a vector of elements {1,2,3,4,5}

       my_vector2 = rotateBy {my_vector1, 2};
       // my_vector2 = {4,5,1,2,3}

Create a vector which is the reverse of the input vector.
       // my_vector1 is a vector of elements {1,2,3,4,5}

       my_vector2 = reverse (my_vector1);
       // my_vector2 is a vector of elements {5,4,3,2,1}

Use transpose to create a new vector.
       // my_vector1 is a Vector#(3, Vector#(5, Int#(8)))
       // the result, my_vector2, is a Vector #(5,Vector#(3,Int #(8)))

       // my_vector1 has the values:
       // {{0,1,2,3,4},{5,6,7,8,9},{10,11,12,13,14}}

       my_vector2 = transpose(my_vector1);
       // my_vector2 has the values:
       // {{0,5,10},{1,6,11},{2,7,12},{3,8,13},{4,9,14}}

C.2.4 Tests on Vectors

The following functions are used to test vectors. The ﬁrst three functions are Boolean functions, i.e.
they return True or False values.

                        c 2008 Bluespec, Inc. All rights reserved                                 207


Reference Guide                                                    Bluespec SystemVerilog

elem      Check if a value is an element of a vector.

          function Bool elem (element_type x,
                                         Vector#(vsize,element_type) vect )

             provisos (Eq#(element_type));

any       Test if a predicate holds for any element of a vector.

          function Bool any(function Bool pred(element_type x1),
                                      Vector#(vsize,element_type) vect );

all       Test if a predicate holds for all elements of a vector.

          function Bool all(function Bool pred(element_type x1),
                                      Vector#(vsize,element_type) vect );

The following two functions return the number of elements in the vector which match a condition.

 countElem Returns the number of elements in the vector which are equal to a given value.
                    The return value is in the range of 0 to vsize.

          function UInt#(logv1) countElem (element_type x,
                                                              Vector#(vsize, element_type) vect)

             provisos (Eq#(element_type), Add#(vsize, 1, vsize1),
                             Log#(vsize1, logv1));

countIf   Returns the number of elements in the vector which satisfy a given predicate
          function. The return value is in the range of 0 to vsize.

          function UInt#(logv1) countIf (function Bool pred(element_type x1)
                                                           Vector#(vsize, element_type) vect)

             provisos (Add#(vsize, 1, vsize1), Log#(vsize1, logv1));

The following two functions return the index of an element.

findElem  Returns the index of the ﬁrst element in the vector which equals a given value.
          Returns an Invalid if not found or Valid with a value of 0 to vsize-1 if found.

          function Maybe#(UInt#(logv)) findElem (element_type x,
                                                        Vector#(vsize, element_type) vect)

             provisos (Eq#(element_type), Add#(xx1, 1, vsize),
                             Log#(vsize, logv));

208              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

findIndex Returns the index of the ﬁrst element in the vector which satisﬁes a given predicate.
                  Returns an Invalid if not found or Valid with a value of 0 to vsize-1 if found.

function Maybe#(UInt#(logv)) findIndex
                                         (function Bool pred(element_type x1)
                                          Vector#(vsize, element_type) vect)

   provisos (Add#(xx1,1,vsize), Log#(vsize, logv));

Examples -Tests on Vectors

Test that all elements of the vector my_vector1 are positive integers.
       function Bool isPositive (Int #(32) a);
               return (a &gt; 0)
       endfunction

       // function isPositive checks that &quot;a&quot; is a positive integer
       // if my_vector1 has n elements, n instances of the predicate
       // function isPositive will be generated.

       if (all(isPositive, my_vector1))
            $display (&quot;Vector contains all negative values&quot;);

Test if any elements in the vector are positive integers.
       // function isPositive checks that &quot;a&quot; is a positive integer
       // if my_vector1 has n elements, n instances of the predicate
       // function isPositive will be generated.

       if (any(isPositive, my_vector1))
            $display (&quot;Vector contains some negative values&quot;);

Check if the integer 5 is in my_vector.
       // if my_vector contains n elements, elem will generate n copies
       // of the eq test
       if (elem(5,my_vector))
            $display (&quot;Vector contains the integer 5&quot;);

Count the number of elements which match the integer provided.
       // my_vector1 is a vector of {1,2,1,4,3}
       x = countElem ( 1, my_vector1);
       // x = 2
       y = countElem (4, my_vector1);
       // y = 1

Find the index of an element which equals a predicate.
       let f = findIndex ( beIsGreaterThan( 3 ) , my_vector );
         if ( f matches tagged Valid .indx )
              begin
                   printBE ( my_vector[indx] ) ;
                   $display (&quot;Found data &gt; 3 at index %d &quot;, indx ) ;
         else
              begin
                   $display ( &quot;Did not find data &gt; 3&quot; ) ;
              end

                        c 2008 Bluespec, Inc. All rights reserved              209


Reference Guide                                             Bluespec SystemVerilog

C.2.5 Bit-Vector Functions
The following functions operate on bit-vectors.

rotateBitsBy Shift each bit to a higher index by n places. The last n bits are moved to the
                       begininng and the bit at index (0) moves to index (n).

                 function Bit#(n) rotateBitsBy (Bit#(n) bvect, UInt#(logn) n)
                    provisos (Log#(n,logn), Add#(1,xxx,n));

countOnesAlt Returns the number of elements equal to 1 in a bit-vector. (This function
                       diﬀers slightly from the Prelude version of countOnes and has fewer provisos.)

                       function UInt#(logn1) countOnesAlt (Bit#(n) bvect)
                          provisos (Add#(1,n,n1), Log#(n1,logn1));

C.2.6 Functions on Vectors of Registers

 readVReg Returns the values from reading a vector of registers (interfaces).
                    function Vector#(n,a) readVReg ( Vector#(n, Reg#(a)) vrin) ;

 writeVReg Returns an Action which is the write of all registers in vr with the data from
                    vdin.
                    function Action writeVReg ( Vector#(n, Reg#(a)) vr,
                                                                 Vector#(n,a) vdin) ;

C.2.7 Combining Vectors with Zip

The family of zip functions takes two or more vectors and combines them into one vector of Tuples.
Several variations are provided for diﬀerent resulting Tuples, as well as support for mis-matched
vector sizes.

zip  Combine two vectors into a vector of Tuples.

     function Vector#(vsize,Tuple2 #(a_type, b_type))
              zip( Vector#(vsize, a_type) vecta,
                      Vector#(vsize, b_type) vectb);

210              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

zip3    Combine three vectors into a vector of Tuple3.

        function Vector#(vsize,Tuple3 #(a_type, b_type, c_type))
                 zip3( Vector#(vsize, a_type) vecta,
                           Vector#(vsize, b_type) vectb,
                           Vector#(vsize, c_type) vectc);

zip4    Combine four vectors into a vector of Tuple4.

        function Vector#(vsize,Tuple4 #(a_type, b_type, c_type, d_type))
                 zip4( Vector#(vsize, a_type) vecta,
                           Vector#(vsize, b_type) vectb,
                           Vector#(vsize, c_type) vectc,
                           Vector#(vsize, d_type) vectd);

zipAny  Combine two vectors into one vector of pairs (2-tuples); result is as long as the
        smaller vector.

        function Vector#(vsize,Tuple2 #(a_type, b_type))
                 zipAny(Vector#(m,a_type) vect1,
                            Vector#(n,b_type) vect2);

           provisos (Max#(m,vsize,m), Max#(n, vsize, n));

unzip   Separate a vector of pairs (i.e. a Tuple2#(a,b)) into a pair of two vectors.

        function Tuple2#(Vector#(vsize,a_type), Vector#(vsize, b_type))
                 unzip(Vector#(vsize,Tuple2 #(a_type, b_type)) vectab);

Examples - Combining Vectors with Zip
Combine two vectors into a vector of Tuples.

       // my_vector1 is a vector of elements {0,1,2,3,4}
       // my_vector2 is a vector of elements {5,6,7,8,9}

       my_vector3 = zip(my_vector1, my_vector2);
       // my_vector3 is a vector of Tuples {(0,5),(1,6),(2,7),(3,8),(4,9)}

Separate a vector of pairs into a Tuple of two vectors.

       // my_vector3 is a vector of pairs {(0,5),(1,6),(2,7),(3,8),(4,9)}

       Tuple2#(Vector #(5,Int #(5)),Vector #(5,Int #(5))) my_vector4 =
                                                                                  unzip(my_vector3);

       // my_vector4 is ({0,1,2,3,4},{5,6,7,8,9})

                        c 2008 Bluespec, Inc. All rights reserved                                     211


Reference Guide                                             Bluespec SystemVerilog

C.2.8 Mapping Functions over Vectors

A function can be applied to all elements of a vector, using high-order functions such as map. These
functions take as an argument a function, which is applied to the elements of the vector.

map  Map a function over a vector, returning a new vector of results.

     function Vector#(vsize,b_type)
              map (function b_type func(a_type x),
                      Vector#(vsize, a_type) vect);

Example - Mapping Functions over Vectors

Consider the following code example which applies the extend function to each element of avector
into a new vector, resultvector.

         Vector#(13,Bit#(5)) avector;
         Vector#(13,Bit#(10)) resultvector;
         ...
         resultvector = map( extend, avector ) ;

This is equivalent to saying:

         for (Integer i=0; i&lt;13; i=i+1)
               resultvector[i] = extend(avector[i]);

Map a negate function over a Vector
       // my_vector1 is a vector of 5 elements {0,1,2,3,4}
       // negate is a function which makes each element negative
       Vector #(5,Int #(32)) my_vector2 = map (negate, my_vector1);
       // my_vector2 is a vector of 5 elements {0,-1,-2,-3,-4}

C.2.9 ZipWith Functions

The zipWith functions combine two or more vectors with a function and generate a new vector.
These functions combine features of map and zip functions.

 zipWith Combine two vectors with a function.

                    function Vector#(vsize,c_type)
                                   zipWith (function c_type func(a_type x, b_type y),
                                                 Vector#(vsize,a_type) vecta,
                                                 Vector#(vsize,b_type) vectb );

212              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

zipWithAny Combine two vectors with a function; result is as long as the smaller vector.

                  function Vector#(vsize,c_type)
                                 zipWithAny (function c_type func(a_type x, b_type y),
                                                     Vector#(m,a_type) vecta,
                                                     Vector#(n,b_type) vectb )

                      provisos (Max#(n, vsize, n), Max#(m, vsize, m));

zipWith3 Combine three vectors with a function.

                  function Vector#(vsize,d_type)
                               zipWith3(function d_type func(a_type x, b_type y, c_type z),
                                             Vector#(vsize,a_type) vecta,
                                             Vector#(vsize,b_type) vectb,
                                             Vector#(vsize,c_type) vectc );

zipWithAny3 Combine three vectors with a function; result is as long as the smallest vector.

function Vector#(vsize,c_type)
    zipWithAny3(function d_type func(a_type x, b_type y, c_type z),
                       Vector#(m,a_type) vecta,
                       Vector#(n,b_type) vectb,
                       Vector#(o,c_type) vectc )

provisos (Max#(n, vsize, n), Max#(m, vsize, m), Max#(o, vsize, o));

Examples - ZipWith

Create a vector by applying a function over the elements of 3 vectors.
       // the function add3 adds 3 values
       function Int#(n) add3 (Int #(n) a,Int #(n) b,Int #(n) c);
              Int#(n) d = a + b +c ;
              return d;
       endfunction

       // Create the vector my_vector4 by adding the ith element of each of
       // 3 vectors (my_vector1, my_vector2, my_vector3) to generate the ith
       // element of my_vector4.

       // my_vector1 = {0,1,2,3,4}
       // my_vector2 = {5,6,7,8,9}
       // my_vector3 = {10,11,12,13,14}

       Vector #(5,Int #(8)) my_vector4 = zipWith3(add3, my_vector1, my_vector2, my_vector3);
       // creates 5 instances of the add3 function in hardware.
       // my_vector4 = {15,18,21,24,27}

       // This is equivalent to saying:
            for (Integer i=0; i&lt;5; i=i+1)

                        c 2008 Bluespec, Inc. All rights reserved                         213


Reference Guide                                             Bluespec SystemVerilog

        my_vector4[i] = my_vector1[i] + my_vector2[i] + my_vector3[i];

C.2.10 Fold Functions

The fold family of functions reduces a vector to a single result by applying a function over all its
elements. That is, given a vector of element_type, V0, V1, V2, ..., Vn−1, a seed of type b_type, and
a function func, the reduction for foldr is given by

                              f unc(V0, f unc(V1, ..., f unc(Vn−2, f unc(Vn−1, seed))));

Note that foldr start processing from the highest index position to the lowest, while foldl starts
from the lowest index (zero), i.e. foldl is:

                                     f unc(...(f unc(f unc(seed, V0), V1), ...)Vn−1)

foldr   Reduce a vector by applying a function over all its elements. Start processing
        from the highest index to the lowest.

        function b_type foldr(function b_type func(a_type x, b_type y),
                                          b_type seed, Vector#(vsize,a_type) vect);

foldl   Reduce a vector by applying a function over all its elements. Start processing
        from the lowest index (zero).

        function b_type foldl (function b_type func(b_type y, a_type x),
                                            b_type seed, Vector#(vsize,a_type) vect);

The functions foldr1 and foldl1 use the ﬁrst element as the seed. This means they only work on
vectors of at least one element. Since the result type will be the same as the element type, there is
no b_type as there is in the foldr and foldl functions.

foldr1  foldr function for a non-zero sized vector, using element Vn−1 as a seed. Vector
        must have at least 1 element. If there is only one element, it is returned.

        function element_type foldr1(
                      function element_type func(element_type x, element_type y),
                      Vector#(vsize,element_type) vect)

           provisos (Add#(1, xxx, vsize));

foldl1  foldl function for a non-zero sized vector, using element V0as a seed. Vector must
        have at least 1 element. If there is only one element, it is returned.

        function element_type foldl1 (
                      function element_type func(element_type y, element_type x),
                      Vector#(vsize,element_type) vect)

           provisos (Add#(1, xxx, vsize));

214              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

The fold function also operates over a non-empty vector, but processing is accomplished in a binary
tree-like structure. Hence the depth or delay through the resulting function will be O(log2(vsize)
rather than O(vsize).

fold       Reduce a vector by applying a function over all its elements, using a binary tree-
           like structure. The function returns the same type as the arguments.

           function element_type fold (
                         function element_type func(element_type y, element_type x),
                         Vector#(vsize,element_type) vect )

              provisos (Add#(1, xxx, vsize));

mapPairs   Map a function over a vector consuming two elements at a time. Any straggling
           element is processed by the second function.

           function Vector#(vsize2,b_type)
                         mapPairs (
                              function b_type func1(a_type x, a_type y),
                              function b_type func2(a_type x),
                              Vector#(vsize,a_type) vect )

              provisos (Div#(vsize, 2, vsize2));

joinActions Join a number of actions together. joinActions is used for static elaboration
                     only, no hardware is generated.

                     function Action joinActions (Vector#(vsize,Action) vactions);

joinRules  Join a number of rules together.joinRules is used for static elaboration only,
           no hardware is generated.

           function Rules joinRules (Vector#(vsize,Rules) vrules);

Example - Folds

Use fold to ﬁnd the sum of the elements in a vector.

       // my_vector1 is a vector of five integers {1,2,3,4,5}
       // \+ is a function which returns the sum of the elements
       // make sure you leave a space after the \+ and before the ,

// This will build an adder tree, instantiating 4 adders, with a maximum
// depth or delay of 3. If foldr1 or foldl1 were used, it would
// still instantiate 4 adders, but the delay would be 4.

my_sum = fold (\+ , my_vector1));
// my_sum = 15

Use fold to ﬁnd the element with the maximum value.

                        c 2008 Bluespec, Inc. All rights reserved         215


Reference Guide                                                Bluespec SystemVerilog

     // my_vector1 is a vector of five integers {2,45,5,8,32}

     my_max = fold (max, my_vector1);
     // my_max = 45

Create a new vector using mapPairs. The function sum is applied to each pair of elements (the ﬁrst
and second, the third and fourth, etc.). If there is an uneven number of elements, the function pass
is applied to the remaining element.

       // sum is defined as c = a+b
       function Int#(4) sum (Int #(4) a,Int #(4) b);

               Int#(4) c = a + b;
               return(c);
       endfunction

       // pass is defined as a
       function Int#(4) pass (Int #(4) a);

               return(a);
       endfunction

       // my_vector1 has the elements {0,1,2,3,4}

       my_vector2 = mapPairs(sum,pass,my_vector1);
       // my_vector2 has the elements {1,5,4}
       // my_vector2[0] = 0 + 1
       // my_vector2[1] = 2 + 3
       // my_vector2[3] = 4

C.2.11 Scan Functions

The scan family of functions applies a function over a vector, creating a new vector result. The
scan function is similar to fold, but the intermediate results are saved and returned in a vector,
instead of returning just the last result. The result of a scan function is a vector. That is, given a
vector of element_type, V0, V1, ..., Vn−1, an initial value initb of type b_type, and a function func,
application of the scanr functions creates a new vector W , where

                                               Wn = init;
                                            Wn−1 = f unc(Vn−1, Wn);
                                            Wn−2 = f unc(Vn−2, Wn−1);

                                                 ...
                                                W1 = f unc(V1, W2);
                                                W0 = f unc(V0, W1);

216              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                              Reference Guide

scanr   Apply a function over a vector, creating a new vector result. Processes elements
        from the highest index position to the lowest, and ﬁll the resulting vector in the
        same way. The result vector is 1 element longer than the input vector.

        function Vector#(vsize1,b_type)
                      scanr(function b_type func(a_type x1, b_type x2),
                               b_type initb,
                               Vector#(vsize,a_type) vect)

           provisos (Add#(1, vsize, vsize1));

sscanr  Apply a function over a vector, creating a new vector result. The elements are pro-
        cessed from the highest index position to the lowest. The Wn element is dropped
        from the result. Input and output vectors are the same size.

        function Vector#(vsize,b_type)
                      sscanr(function b_type func(a_type x1, b_type x2),
                                 b_type initb,
                                 Vector#(vsize,a_type) vect );

The scanl function creates the resulting vector in a similar way as scanr except that the processing
happens from the zeroth element up to the nth element.

                                                W0 = init;
                                                W1 = f unc(W0, V0);
                                                W2 = f unc(W1, V1);

                                                 ...
                                            Wn−1 = f unc(Wn−2, Vn−2);

                                               Wn = f unc(Wn−1, Vn−1);

The sscanl function drops the ﬁrst result, init, shifting the result index by one.

scanl   Apply a function over a vector, creating a new vector result. Processes elements
        from the zeroth element up to the nth element. The result vector is 1 element
        longer than the input vector.

        function Vector#(vsize1,a_type)
                      scanl(function a_type func(a_type x1, b_type x2),
                               a_type q,
                               Vector#(vsize, b_type) vect)

           provisos (Add#(1, vsize, vsize1));

                        c 2008 Bluespec, Inc. All rights reserved                   217


Reference Guide                                             Bluespec SystemVerilog

sscanl  Apply a function over a vector, creating a new vector result. Processes elements
        from the zeroth element up to the nth element. The ﬁrst result, init, is dropped,
        shifting the result index up by one. Input and output vectors are the same size.

        function Vector#(vsize,a_type)
                      sscanl(function a_type func(a_type x1, b_type x2),
                                 a_type q,
                                 Vector#(vsize, b_type) vect );

mapAccumL Map a function, but pass an accumulator from head to tail.

                     function Tuple2 #(a_type, Vector#(vsize,c_type))
                                   mapAccumL (function Tuple2 #(a_type, c_type)
                                                    func(a_type x, b_type y), a_type x0,
                                                    Vector#(vsize,b_type) vect );

mapAccumR Map a function, but pass an accumulator from tail to head.

                      function Tuple2 #(a_type, Vector#(vsize,c_type))
                                     mapAccumR(function Tuple2 #(a_type, c_type)
                                                     func(a_type x, b_type y), a_type x0,
                                                      Vector#(vsize,b_type) vect );

Examples - Scan

Create a vector of factorials.
       // \* is a function which returns the result of a multiplied by b
       function Bit #(16) \* (Bit #(16) b, Bit #(8) a);
            return (extend (a) * b);
       endfunction

       // Create a vector of factorials by multiplying each input list element
       // by the previous product (the output list element), to generate
       // the next product. The seed is a Bit#(16) with a value of 1.
       // The elements are processed from the zeroth element up to the $n^{th}$ element.

       // my_vector1 = {1,2,3,4,5,6,7}
       Vector#(8,Bit #(16)) my_vector2 = scanl (\*, 16’d1, my_vector1);
       // 7 multipliers are generated

       // my_vector2 = {1,1,2,6,24,120,720,5040}
       // foldr with the same arguments would return just 5040.

C.2.12 Monadic Operations

Within Bluespec, there are some functions which can only be invoked in certain contexts. Two
common examples are: ActionValue, and module instantiation. ActionValues can only be invoked

218              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

within an Action context, such as a rule block or an Action method, and can be considered as two
parts - the action and the value. Module instantiation can similarly be considered, modules can only
be instantiated in the module context, while the two parts are the module instantiation (the action
performed) and the interface (the result returned). These situations are considered monadic.

When a monadic function is to be applied over a vector using map-like functions such as map,
zipWith, or replicate, the monadic versions of these functions must be used. Moreover, the context
requirements of the applied function must hold. The common application for these functions is in
the generation (or instantiation) of vectors of hardware components.

mapM       Takes a monadic function and a vector, and applies the function to all vector
           elements returning the vector of corresponding results.

           function m#(Vector#(vsize, b_type))
                         mapM ( function m#(b_type) func(a_type x),
                                     Vector#(vsize, a_type) vecta )

               provisos (Monad#(m));

mapM_      Takes a monadic function and a vector, applies the function to all vector elements,
           and throws away the resulting vector leaving the action in its context.

           function m#(void) mapM_(function m#(b_type) func(a_type x),
                                                 Vector#(vsize, a_type) vect)

              provisos (Monad#(m));

zipWithM   Take a monadic function (which takes two arguments) and two vectors; the func-
           tion applied to the corresponding element from each vector would return an action
           and result. Perform all those actions and return the vector of corresponding re-
           sults.

           function m#(Vector#(vsize, c_type))
                         zipWithM( function m#(c_type) func(a_type x, b_type y),
                                         Vector#(vsize, a_type) vecta,
                                         Vector#(vsize, b_type) vectb )

              provisos (Monad#(m));

zipWithM_  Take a monadic function (which takes two arguments) and two vectors; the func-
           tion is applied to the corresponding element from each vector. This is the same as
           zipWithM but the resulting vector is thrown away leaving the action in its context.

           function m#(void)
                         zipWithM_(function m#(c_type) func(a_type x, b_type y),
                                         Vector#(vsize, a_type) vecta,
                                         Vector#(vsize, b_type) vectb )

              provisos (Monad#(m));

                        c 2008 Bluespec, Inc. All rights reserved                 219


Reference Guide                                             Bluespec SystemVerilog

zipWith3M  Same as zipWithM but combines three vectors with a function. The function is
           applied to the corresponding element from each vector and returns an action and
           the vector of corresponding results.

           function m#(Vector#(vsize, c_type))
                  zipWith3M( function m#(d_type)
                                    func(a_type x, b_type y, c_type z),
                                    Vector#(vsize, a_type) vecta,
                                    Vector#(vsize, b_type) vectb,
                                    Vector#(vsize, c_type) vectc )

              provisos (Monad#(m));

genWithM   Generate a vector of elements by applying the given monadic function to 0 through
           n-1.

           function m#(Vector#(vsize, element_type))
                         genWithM(function m#(element_type) func(Integer x))

              provisos (Monad#(m));

replicateM Generate a vector of elements by using the given monadic value repeatedly.

           function m#(Vector#(vsize, element_type))
                         replicateM( m#(element_type) c)

              provisos (Monad#(m));

Examples - Creating a Vector of Registers

The following example shows some common uses of the Vector type. We ﬁrst create a vector of
registers, and show how to populate this vector. We then continue with some examples of accessing
and updating the registers within the vector, as well as alternate ways to do the same.

    // First define a variable to hold the register interfaces.
    // Notice the variable is really a vector of Interfaces of type Reg,
    // not a vector of modules.
    Vector#(10,Reg#(DataT)) vectRegs ;

    // Now we want to populate the vector, by filling it with Reg type
    // interfaces, via the mkReg module.
    // Notice that the replicateM function is used instead of the
    // replicate function since mkReg function is creating a module.
    vectRegs &lt;- replicateM( mkReg( 0 ) ) ;

    // ...

    // A rule showing a read and write of one register within the
    // vector.
    // The readReg function is required since the selection of an
    // element from vectRegs returns a Reg#(DType) interface, not the
    // value of the register. The readReg functions converts from a

220              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

// Reg#(DataT) type to a DataT type.
rule zerothElement ( readReg( vectRegs[0] ) &gt; 20 ) ;

    // set 0 element to 0
    // The parentheses are required in this context to give
    // precedence to the selection over the write operation.
    (vectRegs[0]) &lt;= 0 ;

    // Set the 1st element to 5
    // An alternate syntax
    vectRegs[1]._write( 5 ) ;
endrule

rule lastElement ( readReg( vectRegs[9] ) &gt; 200 ) ;
    // Set the 9th element to -10000
    (vectRegs[9]) &lt;= -10000 ;

endrule

// These rules defined above can execute simultaneously, since
// they touch independent registers

// Here is an example of dynamic selection, first we define a
// register to be used as the selector.
Reg#(UInt#(4)) selector &lt;- mkReg(0) ;

// Now define another Reg variable which is selected from the
// vectReg variable. Note that no register is created here, just
// an alias is defined.
Reg#(DataT) thisReg = select(vectRegs, selector ) ;

//The above statement is equivalent to:
//Reg#(DataT) thisReg = vectRegs[selector] ;

// If the selected register is greater than 20’h7_0000, then its
// value is reset to zero. Note that the vector update function is
// not required since we are changing the contents of a register
// not the vector vectReg.
rule reduceReg( thisReg &gt; 20’h7_0000 ) ;

    thisReg &lt;= 0 ;
    selector &lt;= ( selector &lt; 9 ) ? selector + 1 : 0 ;
endrule

// As an alternative, we can define N rules which each check the
// value of one register and update accordingly. This is done by
// generating each rule inside an elaboration-time for-loop.

Integer i; // a compile time variable
for ( i = 0 ; i &lt; 10 ; i = i + 1 ) begin

    rule checkValue( readReg( vectRegs[i] ) &gt; 20’h7_0000 ) ;
         (vectRegs[i]) &lt;= 0 ;

    endrule
end

                        c 2008 Bluespec, Inc. All rights reserved   221


Reference Guide                                                       Bluespec SystemVerilog

C.2.13 Converting to and from Vectors
There are functions which convert to and from List and Vector.

toList           Convert a Vector to a List.

                 function List#(element_type)
                               toList (Vector#(vsize, element_type) vect);

toVector         Convert a List to a Vector.

                 function Vector#(vsize, element_type)
                               toVector ( List#(element_type) lst);

There are functions which convert to and from array and Vector.

arraytoVector Convert an array to a Vector.

                 function Vector#(vsize, element_type)
                               arrayToVector ( element_type[ ] arr);

vectorToArray Convert a Vector to an array.

                         function element_type[ ]
                                 vectorToArray (Vector#(vsize, element_type) vect);

Example - Converting to and from Vectors
Convert the vector my_vector to a list named my_list.

       Vector#(5,Int#(13)) my_vector;
       List#(Int#(13)) my_list = toList(my_vector);

C.2.14 ListN

Package name

import ListN :: * ;

Description

ListN is an alternative implementation of Vector which is preferred for list processing functions, such
as head, tail, map, fold, etc. All Vector functions are available, by substituting ListN for Vector. See
the Vector documentation (C.2) for details. If the implementation requires random access to items
in the list, the Vector construct is recommended. Using ListN where Vectors is recommended (and
visa-versa) can lead to very long static elaboration times.

The ListN package deﬁnes an abstract data type which is a ListN of a speciﬁc length. Functions
which create and operate on this type are also deﬁned within this package. Because it is abstract,
there are no constructors available for this type (like Cons and Nil for the List type).

222              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

    struct ListN#(vsize,a_type)
              · · · abstract · · ·

Here, the type variable “a_type” represents the type of the contents of the listN while type variable
“vsize” represents the length of the ListN.

C.3 Aggregation: Lists

Package Name

import List :: * ;

Description

The List package deﬁnes a data type and functions which create and operate on this data type. Lists
are similar to Vectors, but are used when the number of items on the list may vary at compile-time

or need not be strictly enforced by the type system. All elements of a list must be of the same type.

The list type is deﬁned as a tagged union as follows.

typedef union tagged {

void Nil;

struct {

      a             head;

      List #(a) tail;

} Cons;

} List #(type a);

A list is tagged Nil if it has no elements, otherwise it is tagged Cons. Cons is a structure of a single
element and the rest of the list.

Lists are most often used during static elaboration (compile-time) to manipulate collections of ob-
jects. Since List#(element_type) is not in the Bits typeclass, lists cannot be stored in registers
or other dynamic elements. However, one can have a list of registers or variables corresponding to
hardware functions.

C.3.1 Creating and Generating Lists

cons         Adds an element to a list. The new element will be at the 0th position.

             function List#(element_type)
                    cons (element_type x, List#(element_type) xs);

upto         Create a list of Integers counting up over a range of numbers, from m to n. If m
             &gt; n, an empty list (Nil) will be returned.

             List#(Integer) upto(Integer m, Integer n);

replicate Generate a list of n elements by replicating the given argument, elem.

                  function List#(element_type)
                            replicate(Integer n, element_type elem);

                           c 2008 Bluespec, Inc. All rights reserved                  223


Reference Guide                                             Bluespec SystemVerilog

append  Append two lists, returning the combined list. The elements of both lists must be
        the same datatype, element_type. The combined list will contain all the elements
        of xs followed in order by all the elements of ys.

        function List#(element_type)
                 append(List#(element_type) xs, List#(element_type) ys);

concat  Append (concatenate) many lists, that is a list of lists, into one list.

                    function List# (element_type)
                              concat (List#(List#(element_type)) xss);

Examples - Creating and Generating Lists
Create a new list, my_list, of elements of datatytpe Int#(32) which are undeﬁned

       List #(Int#(32)) my_list;

Create a list, my_list, of ﬁve 1’s
       List #(Int #(32)) my_list = replicate (5,32’d1);

       //my_list = {1,1,1,1,1}

Create a new list using the upto function
       List #(Integer) my_list2 = upto (1, 5);

       //my_list2 = {1,2,3,4,5}

C.3.2 Extracting Elements and Sub-Lists

[i]     The square-bracket notation is available to extract an element from a list or update

        an element within it. Extracts or updates the ith element, where the ﬁrst element

        is [0]. Index i must be of an indexable type; (e.g. Integer, Bit#(n), Int#(n) or

        UInt#(n).). The square-bracket notation for lists can also be used with register

        writes.

        anyList[i];
        anyList[i] = newValue;

select  The select function is another form of the subscript notation ([i]), mainly provided
        for backwards-compatibility. The select function is also useful as an argument to
        higher-order functions. The subscript notation is generally recommended because
        it will report a more useful position for any selection errors.

        function element_type
                 select(List#(element_type) alist, idx_type index);

224              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

update  Update an element in a list returning a new list with one element
        changed/updated. This function does not change the given list. This is another
        form of the subscript notation (see above), mainly provided for backwards compat-
        ibility. The update function may also be useful as an argument to a higher-order
        function. The subscript notation is generally recommended because it will report
        a more useful position for any update errors.

        function List#(element_type)
                 update(List#(element_type) alist,
                                      idx_type index,
                                      element_type newElem);

oneHotSelect  Select a list element with a Boolean list. The Boolean list should have exactly
              one element that is True, otherwise the result is undeﬁned. The returned
              element is the one in the corresponding position to the True element in the
              Boolean list.

              function element_type
                       oneHotSelect (List#(Bool) bool_list,
                                             List#(element_type) alist);

head    Extract the ﬁrst element of a list. The input list must have at least 1 element, or
last    an error will be returned.
tail
init    function element_type head (List#(element_type) listIn);

        Extract the last element of a list. The input list must have at least 1 element, or
        an error will be returned.

        function element_type last (List#(element_type) alist);

        Remove the head element of a list leaving the remaining elements in a smaller list.
        The input list must have at least 1 element, or an error will be returned.

        function List#(element_type) tail (List#(element_type) alist);

        Remove the last element of a list the remaining elements in a smaller list. The
        input list must have at least one element, or an error will be returned.

        function List#(element_type) init (List#(element_type) alist);

                        c 2008 Bluespec, Inc. All rights reserved         225


Reference Guide                                             Bluespec SystemVerilog

take       Take a number of elements from a list starting from index 0. The number to take
           is speciﬁed by the argument n. If the argument is greater than the number of
           elements on the list, the function stops taking at the end of the list and returns
           the entire input list.

           function List#(element_type)
                    take (Integer n, List#(element_type) alist);

drop       Drop a number of elements from a list starting from index 0. The number to drop
           is speciﬁed by the argument n. If the argument is greater than the number of
           elements on the list, the entire input list is dropped, returning an empty list.

           function List#(element_type)
                    drop (Integer n, List#(element_type) alist);

filter     Create a new list from a given list where the new list has only the elements which
           satisfy the predicate function.

           function List#(element_type)
                    filter (function Bool pred(element_type),
                                 List#(element_type) alist);

takeWhile Returns the ﬁrst set of elements of a list which satisfy the predicate function.

                  function List#(element_type)
                            takeWhile (function Bool pred(element_type x),
                                             List#(element_type) alist);

takeWhileRev Returns the last set of elements on a list which satisfy the predicate function.

                       function List#(element_type)
                                takeWhileRev (function Bool pred(element_type x),
                                                       List#(element_type) alist);

dropWhile        Removes the ﬁrst set of elements on a list which satisfy the predicate function,
                 returning a list with the remaining elements.

                 function List#(element_type)
                          dropWhile (function Bool pred(element_type x),
                                           List#(element_type) alist);

226              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

dropWhileRev Removes the last set of elements on a list which satisfy the predicate function,
                       returning a list with the remaining elements.

function List#(element_type)
         dropWhileRev (function Bool pred(element_type x),
                               List#(element_type) alist);

Examples - Extracting Elements and Sub-Lists
Extract the element from a list, my_list, at the position of index.

       //my_list = {1,2,3,4,5}, index = 3

       newvalue = select (my_list, index);

       //newvalue = 4

Extract the zeroth element of the list my_list.
       //my_list = {1,2,3,4,5}

       newvalue = head(my_list);

       //newvalue = 1

Create a list, my_list2, of size 4 by removing the head (zeroth) element of the list my_list1.
       //my_list1 is a list with 5 elements, {0,1,2,3,4}

       List #(Int #(32)) my_list2 = tail (my_list1);
       List #(Int #(32)) my_list3 = tail(tail(tail(tail(tail(my_list1);

       //my_list2 = {1,2,3,4}
       //my_list3 = Nil

Create a 2 element list, my_list2, by taking the ﬁrst two elements of the list my_list1.
       //my_list1 is list with 5 elements, {0,1,2,3,4}
       List #(Int #(4)) my_list2 = take (2,my_list1);

       //my_list2 = {0,1}

The number of elements speciﬁed to take in take can be greater than the number of elements on
the list, in which case the entire input list will be returned.

       //my_list1 is list with 5 elements, {0,1,2,3,4}
       List #(Int #(4)) my_list2 = take (7,my_list1);

       //my_list2 = {0,1,2,3,4}

Select an element based on a boolean list.
       //my_list1 is a list of unsigned integers, {1,2,3,4,5}
       //my_list2 is a list of Booleans, only one value in my_list2 can be True.
       //my_list2 = {False, False, True, False,False, False, False}.

       result = oneHotSelect (my_list2, my_list1));

       //result = 3

                        c 2008 Bluespec, Inc. All rights reserved  227


Reference Guide                                             Bluespec SystemVerilog

Create a list by removing the initial segment of a list that meets a predicate.
       //the predicate function is a &lt; 2

       function Bool lessthan2 (Int #(4) a);
              return (a &lt; 2);

       endfunction

       //my_list1 = {0,1,2,0,1,7,8}

         List #(Int #(4)) my_result = (dropWhile(lessthan2, my_list1));

       //my_result = {2,0,1,7,8}

C.3.3 List to List Functions

rotate  Move the ﬁrst element to the last and shift each element to the next higher index.
        function List#(element_type) rotate (List#(element_type) alist);

rotateR Move last element to the beginning and shift each element to the next lower index.
                  function List#(element_type) rotateR (List#(element_type) alist);

reverse Reverse element order
                  function List#(element_type) reverse(List#(element_type) alist);

 transpose Matrix transposition of a list of lists.

                    function List#(List#(element_type))
                                   transpose ( List#(List#(element_type)) matrix );

Examples - List to List Functions
Create a list by moving the last element to the ﬁrst, then shifting each element to the right.

       //my_list1 is a List of elements with values {1,2,3,4,5}
       my_list2 = rotateR (my_list1);
       //my_list2 is a List of elements with values {5,1,2,3,4}

Create a list which is the reverse of the input List
       //my_list1 is a List of elements {1,2,3,4,5}

228              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                            Reference Guide

       my_list2 = reverse (my_list1);
       //my_list2 is a List of elements {5,4,3,2,1}

Use transpose to create a new list
       //my_list1 has the values:
       //{{0,1,2,3,4},{5,6,7,8,9},{10,11,12,13,14}}
       my_list2 = transpose(my_list1);
       //my_list2 has the values:
       //{{0,5,10},{1,6,11},{2,7,12},{3,8,13},{4,9,14}}

C.3.4 Tests on Lists

==      Lists can be compared for equality if the elements in the list can be compared.

!=

        instance Eq #( List#(element_type) )
            provisos( Eq#( element_type ) ) ;

elem    Check if a value is an element in a list.

        function Bool elem (element_type x, List#(element_type) alist )
           proviso (Eq#(element_type));

isNull  Check if a list is empty. Returns True if the list is empty, that is if there are zero
        elements.

        function Bool isNull (element_type x, List#(element_type) alist );

length  Determine the length of a list. Can be done at elaboration time only.
        function Integer length (List#(element_type) alist );

any     Test if a predicate holds for any element of a list.

        function Bool any(function Bool pred(element_type x1),
                                    List#(element_type) alist );

                      c 2008 Bluespec, Inc. All rights reserved                          229


Reference Guide                                                  Bluespec SystemVerilog

all  Test if a predicate holds for all elements of a list.

     function Bool all(function Bool pred(element_type x1),
                                 List#(element_type) alist );

or   Combine all elements in a Boolean list with a logical or.

     function Bool or (List# (Bool) bool_list);

and  Combine all elements in a Boolean list with a logical and.

                    function Bool and (List# (Bool) bool_list);

Examples - Tests on Lists
Test that all elements of the list my_list1 are positive integers

       function Bool isPositive (Int #(32) a);
               return (a &gt; 0)

       endfunction

       // function isPositive checks that &quot;a&quot; is a positive integer
       // if my_list1 has n elements, n instances of the predicate
       // function isPositive will be generated.

       if (all(isPositive, my_list1))
            $display (&quot;List contains all negative values&quot;);

Test if any elements in the list are positive integers.
       // function isPositive checks that &quot;a&quot; is a positive integer
       // if my_list1 has n elements, n instances of the predicate
       // function isPositive will be generated.

       if (any(pos, my_list1))
            $display (&quot;List contains some negative values&quot;);

Check if the integer 5 is in my_list
       // if my_list contains n elements, elem will generate n copies
       // of the eqt Test
       if (elem(5,my_list))
            $display (&quot;List contains the integer 5&quot;);

C.3.5 Combining Lists with Zip Functions

The family of zip functions takes two or more lists and combines them into one list of Tuples.
Several variations are provided for diﬀerent resulting Tuples. All variants can handle input lists of
diﬀerent sizes. The resulting lists will be the size of the smallest list.

230              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

zip    Combine two lists into a list of Tuples.

       function List#(Tuple2 #(a_type, b_type))
                     zip( List#(a_type) lista,
                             List#(b_type) listb);

zip3   Combine 3 lists into a list of Tuple3.

       function List#(Tuple3 #(a_type, b_type, c_type))
                     zip3( List#(a_type) lista,
                              List#(b_type) listb,
                              List#(c_type) listc);

zip4   Combine 4 lists into a list of Tuple4.

       function List#(Tuple4 #(a_type, b_type, c_type, d_type))
                     zip4( List#(a_type) lista,
                              List#(b_type) listb,
                              List#(c_type) listc,
                              List#(d_type) listd);

unzip  Separate a list of pairs (i.e. a Tuple2#(a,b)) into a pair of two lists.

       function Tuple2#(List#(a_type), List#(b_type))
                     unzip(List#(Tuple2 #(a_type, b_type)) listab);

Examples - Combining Lists with Zip
Combine two lists into a list of Tuples

       //my_list1 is a list of elements {0,1,2,3,4,5,6,7}
       //my_list2 is a list of elements {True,False,True,True,False}

       my_list3 = zip(my_list1, my_list2);

       //my_list3 is a list of Tuples {(0,True),(1,False),(2,True),(3,True),(4,False)}
Separate a list of pairs into a Tuple of two lists

       //my_list is a list of pairs {(0,5),(1,6),(2,7),(3,8),(4,9)}

       Tuple2#(List#(Int#(5)),List#(Int#(5))) my_list2 = unzip(my_list);

       //my_list2 is ({0,1,2,3,4},{5,6,7,8,9})

C.3.6 Mapping Functions over Lists

A function can be applied to all elements of a list, using high-order functions such as map. These
functions take as an argument a function, which is applied to the elements of the list.

                        c 2008 Bluespec, Inc. All rights reserved                231


Reference Guide                                                         Bluespec SystemVerilog

map       Map a function over a list, returning a new list of results.

                    function List#(b_type) map (function b_type func(a_type),
                                                                 List#(a_type) alist);

Example - Mapping Functions over Lists
Consider the following code example which applies the extend function to each element of alist
creating a new list, resultlist.

         List#(Bit#(5)) alist;
         List#(Bit#(10)) resultlist;
         ...
         resultlist = map( extend, alist ) ;

This is equivalent to saying:
         for (Integer i=0; i&lt;13; i=i+1)
               resultlist[i] = extend(alist[i]);

Map a negate function over a list
       //my_list1 is a list of 5 elements {0,1,2,3,4}
       //negate is a function which makes each element negative

       List #(Int #(32)) my_list2 = map (negate, my_list1);

       //my_list2 is a list of 5 elements {0,-1,-2,-3,-4}

C.3.7 ZipWith Functions

The zipWith functions combine two or more lists with a function and generate a new list. These
functions combine features of map and zip functions.

zipWith   Combine two lists with a function. The lists do not have to have the same number
          of elements.

          function List#(c_type)
                   zipWith (function c_type func(a_type x, b_type y),
                                 List#(a_type) listx,
                                 List#(b_type) listy );

zipWith3  Combine three lists with a function. The lists do not have to have the same
          number of elements.

          function List#(d_type)
                   zipWith3(function d_type func(a_type x, b_type y, c_type z),
                                 List#(a_type) listx,
                                 List#(b_type) listy,
                                 List#(c_type) listz );

232              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

zipWith4  Combine four lists with a function. The lists do not have to have the same number
          of elements.

          function List#(e_type) zipWith4
                   (function e_type func(a_type x, b_type y, c_type z, d_type w),
                     List#(a_type) listx,
                     List#(b_type) listy,
                     List#(c_type) listz
                     List#(d_type) listw );

Examples - ZipWith

Create a list by applying a function over the elements of 3 lists.

       //the function add3 adds 3 values
       function Int#(8) add3 (Int #(8) a,Int #(8) b,Int #(8) c);

              Int#(8) d = a + b +c ;
              return(d);
       endfunction

       //Create the list my_list4 by adding the ith element of each of
       //3 lists (my_list1, my_list2, my_list3) to generate the ith
       //element of my_list4.

       //my_list1 = {0,1,2,3,4}
       //my_list2 = {5,6,7,8,9}
       //my_list3 = {10,11,12,13,14}

       List #(Int #(8)) my_list4 = zipWith3(add3, my_list1, my_list2, my_list3);

       //my_list4 = {15,18,21,24,27}

       // This is equivalent to saying:
            for (Integer i=0; i&lt;5; i=i+1)
                 my_list4[i] = my_list1[i] + my_list2[i] + my_list3[i];

C.3.8 Fold Functions

The fold family of functions reduces a list to a single result by applying a function over all its
elements. That is, given a list of element_type, L0, L1, L2, ..., Ln−1, a seed of type b_type, and a
function func, the reduction for foldr is given by

                             f unc(L0, f unc(L1, ..., f unc(Ln−2, f unc(Ln−1, seed))));

Note that foldr start processing from the highest index position to the lowest, while foldl starts
from the lowest index (zero), i.e.,

                                    f unc(...(f unc(f unc(seed, L0), L1), ...)Ln−1)

                        c 2008 Bluespec, Inc. All rights reserved                 233


Reference Guide                                             Bluespec SystemVerilog

foldr   Reduce a list by applying a function over all its elements. Start processing from
        the highest index to the lowest.

        function b_type foldr(b_type function func(a_type x, b_type y),
                                          b_type seed,
                                          List#(a_type) alist);

foldl   Reduce a list by applying a function over all its elements. Start processing from
        the lowest index (zero).

        function b_type foldl (b_type function func(b_type y, a_type x),
                                            b_type seed,
                                            List#(a_type) alist);

The functions foldr1 and foldl1 use the ﬁrst element as the seed. This means they only work on
lists of at least one element. Since the result type will be the same as the element type, there is no
b_type as there is in the foldr and foldl functions.

foldr1  foldr function for a non-zero sized list. Uses element Ln−1 as the seed. List must
        have at least 1 element.

        function element_type foldr1
                 (element_type function func(element_type x, element_type y),
                   List#(element_type) alist);

foldl1  foldl function for a non-zero sized list. Uses element L0 as the seed. List must
        have at least 1 element.

        function element_type foldl1
                 (element_type function func(element_type y, element_type x),
                   List#(element_type) alist);

The fold function also operates over a non-empty list, but processing is accomplished in a binary
tree-like structure. Hence the depth or delay through the resulting function will be O(log2(lsize)
rather than O(lsize).

fold    Reduce a list by applying a function over all its elements, using a binary tree-like
        structure. The function returns the same type as the arguments.

        function element_type fold
                 (element_type function func(element_type y, element_type x),
                   List#(element_type) alist );

234              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

joinActions Join a number of actions together.
                     function Action joinActions (List#(Action) list_actions);

joinRules Join a number of rules together.
                  function Rules joinRules (List#(Rules) list_rules);

mapPairs  Map a function over a list consuming two elements at a time. Any straggling
          element is processed by the second function.

          function List#(b_type)
                        mapPairs (
                             function b_type func1(a_type x, a_type y),
                             function b_type func2(a_type x),
                             List#(a_type) alist );

Example - Folds
       // my_list1 is a list of five integers {1,2,3,4,5}
       // \+ is a function which returns the sum of the elements

       my_sum = foldr (\+ , 0, my_list1));

       // my_sum = 15

Use fold to ﬁnd the element with the maximum value
       // my_list1 is a list of five integers {2,45,5,8,32}

       my_max = fold (max, my_list1);

       // my_max = 45

Create a new list using mapPairs. The function sum is applied to each pair of elements (the ﬁrst
and second, the third and fourth, etc.). If there is an uneven number of elements, the function pass
is applied to the remaining element.

       //sum is defined as c = a+b
       function Int#(4) sum (Int #(4) a,Int #(4) b);

               Int#(4) c = a + b;
                   return(c);

       endfunction

       //pass is defined as a
       function Int#(4) pass (Int #(4) a);

                   return(a);
       endfunction

       //my_list1 has the elements {0,1,2,3,4}

                        c 2008 Bluespec, Inc. All rights reserved               235


Reference Guide                                             Bluespec SystemVerilog

       my_list2 = mapPairs(sum,pass,my_list1);

       //my_list2 has the elements {1,5,4}
       //my_list2[0] = 0 + 1
       //my_list2[1] = 2 + 3
       //my_list2[3] = 4

C.3.9 Scan Functions

The scan family of functions applies a function over a list, creating a new List result. The scan
function is similar to fold, but the intermediate results are saved and returned in a list, instead
of returning just the last result. The result of a scan function is a list. That is, given a list
of element_type, L0, L1, ..., Ln−1, an initial value initb of type b_type, and a function func,
application of the scanr functions creates a new list W , where

                                               Wn = init;
                                            Wn−1 = f unc(Ln−1, Wn);
                                            Wn−2 = f unc(Ln−2, Wn−1);

                                                 ...
                                                W1 = f unc(L1, W2);
                                                W0 = f unc(L0, W1);

scanr   Apply a function over a list, creating a new list result. Processes elements from
        the highest index position to the lowest, and ﬁlls the resulting list in the same
        way. The result list is one element longer than the input list.

        function List#(b_type)
                      scanr(function b_type func(a_type x1, b_type x2),
                               b_type initb,
                               List#(a_type) alist);

sscanr  Apply a function over a list, creating a new list result. The elements are processed
        from the highest index position to the lowest. Drops the Wn element from the
        result. Input and output lists are the same size.

        function List#(b_type)
                      sscanr(function b_type func(a_type x1, b_type x2),
                                 b_type initb,
                                 List#(a_type) alist );

The scanl function creates the resulting list in a similar way as scanr except that the processing
happens from the zeroth element up to the nth element.

                                                W0 = init;
                                                W1 = f unc(W0, L0);

236              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                                 Reference Guide

                           W2 = f unc(W1, L1);
                             ...

                        Wn−1 = f unc(Wn−2, Ln−2);
                           Wn = f unc(Wn−1, Ln−1);

The sscanl function drops the ﬁrst result, init, shifting the result index by one.

scanl   Apply a function over a list, creating a new list result. Processes elements from
        the zeroth element up to the nth element. The result list is 1 element longer than
        the input list.

        function List#(a_type)
                      scanl(function a_type func(a_type x1, b_type x2),
                               a_type inita,
                               List#(b_type) alist);

sscanl  Apply a function over a list, creating a new list result. Processes elements from
        the zeroth element up to the nth element. Drop the ﬁrst result, init, shifting the
        result index by one. The length of the input and output lists are the same.

        function List#(a_type)
                      sscanl(function a_type func(a_type x1, b_type x2),
                                 a_type inita,
                                 List#(b) alist );

mapAccumL Map a function, but pass an accumulator from head to tail.

                  function Tuple2 #(a_type, List#(c_type))
                                 mapAccumL (function Tuple2 #(a_type, c_type)
                                                  func(a_type x, b_type y),a_type x0,
                                                  List#(b_type) alist );

mapAccumR Map a function, but pass an accumulator from tail to head.

        function Tuple2 #(a_type, List#(c_type))
                      mapAccumR(function Tuple2 #(a_type, c_type)
                                      func(a_type x, b_type y),a_type x0,
                                      List#(b_type) alist );

Examples - Scan

Create a list of factorials
       //the function my_mult multiplies element a by element b
       function Bit #(16) my_mult (Bit #(16) b, Bit #(8) a);
            return (extend (a) * b);

                        c 2008 Bluespec, Inc. All rights reserved                      237


Reference Guide                                             Bluespec SystemVerilog

     endfunction

     // Create a list of factorials by multiplying each input list element
     // by the previous product (the output list element), to generate
     // the next product. The seed is a Bit#(16) with a value of 1.
     // The elements are processed from the zeroth element up to the nth element.
     //my_list1 = {1,2,3,4,5,6,7}

     List #(Bit #(16)) my_list2 = scanl (my_mult, 16’d1, my_list1);

     //my_list2 = {1,1,2,6,24,120,720,5040}

C.3.10 Monadic Operations

Within Bluespec, there are some functions which can only be invoked in certain contexts. Two
common examples are: ActionValue, and module instantiation. ActionValues can only be invoked
within an Action context, such as a rule block or an Action method, and can be considered as two
parts - the action and the value. Module instantiation can similarly be considered, modules can only
be instantiated in the module context, while the two parts are the module instantiation (the action
performed) and the interface (the result returned). These situations are considered monadic.

When a monadic function is to be applied over a list using map-like functions such as map, zipWith,
or replicate, the monadic versions of these functions must be used. Moreover, the context require-
ments of the applied function must hold.

mapM      Takes a monadic function and a list, and applies the function to all list elements
          returning the list of corresponding results.

          function m#(List#(b_type))
                        mapM ( function m#(b_type) func(a_type x),
                                    List#(a_type) alist )

              provisos (Monad#(m));

mapM_     Takes a monadic function and a list, applies the function to all list elements, and
          throws away the resulting list leaving the action in its context.

          function m#(List#(b_type) mapM_(m#(b_type) c_type)
             provisos (Monad#(m));

zipWithM  Take a monadic function (which takes two arguments) and two lists; the function
          applied to the corresponding element from each list would return an action and
          result. Perform all those actions and return the list of corresponding results.

          function m#(List#(c_type))
                        zipWithM( function m#(c_type) func(a_type x, b_type y),
                                        List#(a_type) alist,
                                        List#(b_type) blist )

             provisos (Monad#(m));

238              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

zipWith3M  Same as zipWithM but combines three lists with a function. The function is
           applied to the corresponding element from each list and returns an action and the
           list of corresponding results.

           function m#(List#(d_type))
                  zipWith3M( function m#(d_type)
                                    func(a_type x, b_type y, c_type z),
                                    List#(a_type) alist ,
                                    List#(b_type) blist,
                                    List#(c_type) clist )

              provisos (Monad#(m));

replicateM Generate a list of elements by using the given monadic value repeatedly.

                  function m#(List#(element_type))
                                 replicateM( Integer n, m#(element_type) c)

                      provisos (Monad#(m));

C.4 Math

C.4.1 Real

Package Name
import Real :: * ;
Description
The Real library package deﬁnes functions to operate on and manipulate real numbers. Real numbers
are numbers with a fractional component. They are also of limited precision. The Real data type
is described in section B.2.6.
Constants
The constant pi (π) is deﬁned.

pi         The value of the constant pi (π).

           Real pi;

Trigonometric Functions

The following trigonometric functions are provided: sin, cos, tan, sinh, cosh, tanh, asin, acos,
atan, asinh, acosh, atanh, and atan2.

sin        Returns the sine of x.

           function Real sin (Real x);

                        c 2008 Bluespec, Inc. All rights reserved                    239


Reference Guide                                               Bluespec SystemVerilog

cos              Returns the cosine of x.

                 function Real cos (Real x);

tan              Returns the tangent of x.

                 function Real tan (Real x);

sinh             Returns the hyperbolic sine of x.
                 function Real sinh (Real x);

cosh             Returns the hyperbolic cosine of x.
                 function Real cosh (Real x);

tanh             Returns the hyperbolic tangent of x.
                 function Real tanh (Real x);

asinh            Returns the inverse hyperbolic sine of x.
                 function Real asinh (Real x);

acosh            Returns the inverse hyperbolic cosine of x.
                 function Real acosh (Real x);

240              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

atanh  Returns the inverse hyperbolic tangent of x.
       function Real atanh (Real x);

atan2  Returns atan(x/y). atan2(1,x) is equivalent to atan(x), but provides more
       precision when required by the division of x/y.

       function Real atan2 (Real y, Real x);

Arithmetic Functions

pow    The element x is raised to the y power. An alias for **. pow(x,y) = x**y =

       xy .

       function Real pow (Real x, Real y);

sqrt   Returns the square root of x. Returns an error if x is negative.
       function Real sqrt (Real x);

Conversion Functions
The following four functions are used to convert a Real to an Integer.

trunc  Converts a Real to an Integer by removing the fractional part of x, which
       can be positive or negative. trunc(1.1) = 1, trunc(-1.1)= -1.

       function Integer trunc (Real x);

round  Converts a Real to an Integer by rounding to the nearest whole number. .5
       rounds up in magnitude. round(1.5) = 2, round(-1.5)= -2.

       function Integer round (Real x);

                        c 2008 Bluespec, Inc. All rights reserved        241


Reference Guide                                                  Bluespec SystemVerilog

ceil             Converts a Real to an Integer by rounding to the higher number, regardless
                 of sign. ceil(1.1) = 2, ceil(-1.1) = -1.

                 function Integer ceil (Real x);

floor            Converts a Real to an Integer by rounding to the lower number, regardless
                 of sign. floor(1.1) = 1, floor(-1.1) = -2.

                 function Integer floor (Real x);

There are also two system functions $realtobits and $bitstoreal, deﬁned in the Prelude (section
B.2.6) which provide conversion to and from IEEE 64-bit vectors (Bit#(64)).

Introspection Functions

isInfinite Returns True if the value of x is inﬁnite, False if x is ﬁnite.
                     function Bool isInfinite (Real x);

isNegativeZero Returns True if the value of x is negative zero.
                         function Bool isNegativeZero (Real x);

splitReal        Returns a Tuple containing the whole (n) and fractional (f ) parts of x such
                 that n + f = x. Both values have the same sign as x. The absolute value of
                 the fractional part is guaranteed to be in the range [0,1).

                 function Tuple2#(Integer, Real) splitReal (Real x);

decodeReal       Returns a Tuple3 containing the sign, the fraction, and the exponent of a real
                 number. The Bool represents the sign and is True for positive and False for
                 negative. The second part (the ﬁrst Integer) represents the fractional part as
                 a signed Integer value. This can be converted to an Int#(54) (52 bits, plus
                 hidden plus sign). The last value is a signed Integer representing the exponent,
                 which can be be converted to an Int#(12) . The real number is represented
                 exactly as (f ractional × 2exp).

                 function Tuple3#(Bool, Integer, Integer) decodeReal (Real x);

242              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

C.4.2 Complex

Package Name

import Complex :: * ;

Description

The Complex package provides a representation for complex numbers plus functions to operate on
variables of this type. The basic representation is the Complex structure, which is polymorphic
on the type of data it holds. For example, one can have complex numbers of type Int or of type
FixedPoint. A Complex number is represented in two part, the real part (rel) and the imaginary
part (img). These ﬁelds are accessible though standard structure addressing, i.e., foo.rel and
foo.img where foo is of type Complex.

typedef struct {
            any_t rel ;
            any_t img ;
            } Complex#(type any_t)

deriving ( Bits, Eq ) ;

Types and type classes

The Complex type belongs to the Arith and Literal type classes. Each type class deﬁnition includes
functions which are then also deﬁned for the data type. The Prelude library deﬁnitions (Section B)
describes which functions are deﬁned for each type class.

                        Type Classes used by Complex

         Bits Eq Literal Arith Ord Bounded Bit                     Bit  Bit

         √√             √  √                          wise Reduction Extend

Complex

Arith The type Complex belongs to the Arith type class, hence the common inﬁx operators (+,
-, *, and /) are deﬁned and can be used to manipulate variables of type Complex. The remaining
arithmetic operators are not deﬁned for the Complex type. Note however, that some functions
generate more hardware than may be expected. The complex multiplication (*) produces four
multipliers in a combinational function; some other modules could accomplish the same function with
less hardware but with greater latency. The complex division operator (/) produces 6 multipliers,
and a divider and may not always be synthesizable with downstream tools.

instance Arith#( Complex#(any_type) )
         provisos( Arith#(any_type) ) ;

Literal The Complex type is a member of the Literal class, which deﬁnes a conversion from the
compile-time Integer type to Complex type with the fromInteger function. This function converts
the Integer to the real part, and sets the imaginary part to 0.
instance Literal#( Complex#(any_type) )

    provisos( Literal#(any_type) );

Functions

cmplx    A simple constructor function is provided to set the ﬁelds.
         function Complex#(a_type) cmplx( a_type realA, a_type imagA ) ;

                        c 2008 Bluespec, Inc. All rights reserved            243


Reference Guide                                             Bluespec SystemVerilog

cmplxMap         Applies a function to each part of the complex structure. This is useful for
                 operations such as extend, truncate, etc.

                 function Complex#(b_type) cmplxMap(
                                                          function b_type mapFunc( a_type x),
                                                          Complex#(a_type) cin ) ;

cmplxSwap Exchanges the real and imaginary parts.
                  function Complex#(a_type) cmplxSwap( Complex#(a_type) cin ) ;

cmplxWrite       Displays a complex number given a preﬁx string, an inﬁx string, a postscript
                 string, and an Action function which writes each part. cmplxWrite is of type
                 Action and can only be invoked in Action contexts such as Rules and Actions
                 methods.

                 function Action cmplxWrite(String pre,
                                                           String infix,
                                                           String post,
                                                           function Action writeaFunc( a_type x ),
                                                           Complex#(a_type) cin );

Examples - Complex Numbers

    // The following utility function is provided for writing data
    // in decimal format. An example of its use is show below.

    function Action writeInt( Int#(n) ain ) ;
         $write( &quot;%0d&quot;, ain ) ;

    endfunction

    // Set the fields of the complex number using the constructor function cmplx
    Complex#(Int#(6)) complex_value = cmplx(-2,7) ;

    // Display complex_value as ( -2 + 7i ).
    // Note that writeInt is passed as an argument to the cmplxWrite function.
    cmplxWrite( &quot;( &quot;, &quot; + &quot;, &quot;i)&quot;, writeInt, complex_value );

    // Swap the real and imaginary parts.
    swap_value = cmplxSwap( complex_value ) ;

    // Display the swapped values. This will display ( -7 + 2i).
    cmplxWrite( &quot;( &quot;, &quot; + &quot;, &quot;i)&quot;, writeInt, swap_value );

244              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

C.4.3 FixedPoint

Package Name

import FixedPoint :: * ;

Description

The FixedPoint library package deﬁnes a type for representing ﬁxed-point numbers and correspond-
ing functions to operate and manipulate variables of this type.

A ﬁxed-point number represents signed real numbers which have a ﬁxed number of binary digits
(bits) before and after the binary point. The type constructor for a ﬁxed-point number takes two
numeric types as argument; the ﬁrst (isize) deﬁnes the number of bits to the left of the binary point
(the integer part), while the second (fsize) deﬁnes the number of bits to the right of the binary point,
(the fractional part).

The following data structure deﬁnes this type, while some utility functions provide the reading of
the integer and fractional parts.

typedef struct {
                         Int#(TAdd#(isize,fsize)) fxpt ;
                         }

FixedPoint#(numeric type isize, numeric type fsize )
         deriving( Eq, Bits ) ;

Types and type classes

The FixedPoint type belongs to the following type classes; Bits, Eq, Literal, RealLiteral, Arith,
Ord, Bounded, and Bitwise. Each type class deﬁnition includes functions which are then also deﬁned
for the data type. The Prelude library deﬁnitions (Section B) describes which functions are deﬁned
for each type class.

                           Type Classes used by FixedPoint

            Bits Eq Literal Real Arith Ord Bounded Bit Bit         Bit

FixedPoint  √√          √  Lit√eral √           √           √      wi√se Reduce Extend

Literal The type FixedPoint belongs to the Literal type class, which allows conversion from
(compile-time) type Integer to type FixedPoint. Note that only the integer part is assigned.

instance Literal#( FixedPoint#(isize, fsize) )

provisos( Add#(isize, fsize, TAdd#(isize,fsize) ),

            Add#(1, xxx, isize) ) ;  // isize &gt;= 1

RealLiteral The type FixedPoint belongs to the RealLiteral type class, which allows conversion
from type Real to type FixedPoint.

Example:

FixedPoint#(3,10) p = 3.14159;

instance RealLiteral#( FixedPoint# (isize, fsize) )

provisos( Add#(isize, fsize, TAdd#(isize,fsize) ),

            Add#(1, xxx, isize) ) ;  // isize &gt;= 1

                        c 2008 Bluespec, Inc. All rights reserved  245


Reference Guide                                                                      Bluespec SystemVerilog

Arith The type FixedPoint belongs to the Arith type class, hence the common inﬁx operators (+,
-, and *) are deﬁned and can be used to manipulate variables of type FixedPoint. The arithmetic
operators / and % are not deﬁned.

instance Arith#( FixedPoint#(isize, fsize) )

     provisos( Add#(isize, fsize, TAdd#(isize,fsize) ),

               Add#(1, xxx, isize) ) ;              // isize &gt;= 1

Ord In addition to equality and inequality comparisons, FixedPoint variables can be compared
by the relational operators provided by the Ord type class. i.e., &lt;, &gt;, &lt;=, and &gt;=.

instance Ord#( FixedPoint#(isize, fsize) )

     provisos( Add#(1, xxx, isize) ) ;              // isize &gt;= 1

Bounded The type FixedPoint belongs to the Bounded type class. The range of values, v, rep-

resentable with a signed ﬁxed-point number of type FixedPoint#(isize, fsize) is +(2isize−1 −

2−fsize) ≤ v ≤ −2isize−1. The function epsilon returns the smallest representable quantum by

a speciﬁc type, 2−fsize. For example, a variable v of type FixedPoint#(2,3) type can repre-

sent  numbers  from  1.875  (1  7  )  to  −2.0  in  intervals  of  1  = 0.125, i.e.  epsilon is 0.125.  The type
                                8                                  8

FixedPoint#(5,0) is equivalent to Int#(5).

instance Bounded#( FixedPoint#(isize, fsize) ) ;

     provisos( Add#(1, xxx, isize) ) ;              // isize &gt;= 1

      epsilon               Returns the value of epsilon which is the smallest representable
                            quantum by a speciﬁc type, 2−fsize.

                            function FixedPoint#(isize, fsize) epsilon () ;

Bitwise Left and right shifts are provided for FixedPoint variables as part of the Bitwise type
class. Note that the shift right (&gt;&gt;) function does an arithmetic shift, thus preserving the sign of
the operand. Note that a right shift of 1 is equivalent to a division by 2, except when the operand
is equal to −epsilon. The other methods of Bitwise type class are not provided since they have
no operational meaning on FixedPoint variables; the use of these generates an error message.

instance Bitwise#( FixedPoint#(isize, fsize) )

     provisos( Add#(1, xxx, isize) ) ;              // isize &gt;= 1

Functions
Utility functions are provided to extract the integer and fractional parts.

fxptGetInt Extracts the integer part of the FixedPoint number.

                 function Int#(isize) fxptGetInt ( FixedPoint#(isize, fsize) x )

                     provisos( Add#(1, xxx, isize) ) ;                // isize &gt;= 1

246                             c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

fxptGetFrac Extracts the factional part of the FixedPoint number.
                     function UInt#(fsize) fxptGetFrac ( FixedPoint#(isize, fsize) x );

To convert run-time Int and UInt values to type FixedPoint, the following conversion functions
are provided. Both of these functions invoke the necessary extension of the source operand.

fromInt       Converts run-time Int values to type FixedPoint.

              function FixedPoint#(ir,fr) fromInt( Int#(ia) inta )

                        provisos ( Add#(1, xxA, ir ),              // ir &gt;= 1

                        Add#(ia,xxB, ir ) );                       // ir &gt;= ia

fromUInt      Converts run-time UInt values to type FixedPoint.

              function FixedPoint#(ir,fr) fromUInt( UInt#(ia) uinta )

                        provisos ( Add#(ia, 1, ia1),               // ia1 = ia + 1

                        Add#(ia1,xxB, ir ) );                      // ir &gt;= ia1

Non-integer compile time constants may be speciﬁed by a rational number which is a ratio of two
integers. For example, one-third may be speciﬁed by fromRational(1,3).

fromRational  Specify a FixedPoint with a rational number which is the ratio of two
              integers.

              function FixedPoint#(isize, fsize) fromRational(

                        Integer numerator, Integer denominator)

                        provisos ( Add#(1, xxA, isize ) ) ;        // isize &gt;= 1

At times, a full precision multiplication may be required, where the result is sum of the ﬁeld sizes
of the operands. Note that the operand do not have to be the same type (sizes), as is required for
the inﬁx multiplication (*) operator.

fxptMult      Function for full precision multiplication, where the result is the sum of the
              ﬁeld sizes of the operands.

              function FixedPoint#(ri,rf) fxptMult( FixedPoint#(ai,af) x,
                                                                           FixedPoint#(bi,bf) y )

                  provisos( Add#(ai,bi,ri), // ri = ai + bi
                                    Add#(af,bf,rf), // rf = af + bf
                                    Add#(TAdd#(ai,af), TAdd#(bi,bf), TAdd#(ri,rf)) );

                        c 2008 Bluespec, Inc. All rights reserved                   247


Reference Guide                                               Bluespec SystemVerilog

fxptTruncate is a general truncate function which converts variables to FixedPoint#(ai,af) to
type FixedPoint#(ri,rf), where ai ≥ ri and af ≥ rf . This function truncates bits as appropriate
from the most signiﬁcant integer bits and the least signiﬁcant fractional bits.

fxptTruncate     Truncates bits as appropriate from the most signiﬁcant integer bits and the
                 least signiﬁcant fractional bits.

                 function FixedPoint#(ri,rf) fxptTruncate(
                                     FixedPoint#(ai,af) a )

                     provisos( Add#(xxA,ri,ai), // ai &gt;= ri
                                     Add#(xxB,rf,af), // af &gt;= rf
                                     Add#(xxC,TAdd#(ri,rf),TAdd#(ai,af)) );
                                                                     // ai+af &gt;= ri+rf

fxptSignExtend is a general sign extend function which converts variables of type FixedPoint#(ai,af)
to type FixedPoint#(ri,rf), where ai ≤ ri and af ≤ rf . The integer part is sign extended, while
additional 0 bits are added to least signiﬁcant end of the fractional part.

fxptSignExtend General sign extend function where the integer part is sign extended while
                         additional 0 bits are added to the least signiﬁcant end of the fractional part.

                 function FixedPoint#(ri,rf) fxptSignExtend(

                 FixedPoint#(ai,af) a )

                 provisos( Add#(xxA,ai,ri),  // ri &gt;= ai

                 Add#(fdiff,af,rf), // rf &gt;= af

                 Add#(xxC,TAdd#(ai,af),TAdd#(ri,rf)) );

                                             // ri+rf &gt;= ai+af

fxptZeroExtend A general zero extend function.

                         function FixedPoint#(ri,rf) fxptZeroExtend(
                                              FixedPoint#(ai,af) a )

                              provisos( Add#(xxA,ai,ri), // ri &gt;= ai
                                              Add#(xxB,af,rf), // rf &gt;= af
                                              Add#(xxC,TAdd#(ai,af),TAdd#(ri,rf)) ) ;
                                                                             // ri+rf &gt;= ai+af

Displaying FixedPoint values in a simple bit notation would result in a diﬃcult to read pattern.
The following write utility function is provided to ease in their display. Note that the use of this
function adds many multipliers and adders into the design which are only used for generating the
output and not the actual circuit.

248              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

fxptWrite  Displays a FixedPoint value in a decimal format, where fwidth give the
           number of digits to the right of the decimal point. fwidth must be in
           the inclusive range of 0 to 10. The displayed result is truncated without
           rounding.

           function Action fxptWrite( Integer fwidth,
                                                     FixedPoint#(isize, fsize) a )

Examples - Fixed Point Numbers
    // The following code writes &quot;x is 0.5156250&quot;
    FixedPoint#(1,6) x = half + epsilon ;
    $write( &quot;x is &quot; ) ; fxptWrite( 7, x ) ; $display(&quot;&quot; ) ;

A Real value can automatically be converted to a FixedPoint value:
    FixedPoint#(3,10) foo = 2e-3;

    FixedPoint#(2,3) x = 1.625 ;

C.4.4 OInt

Package Name
import OInt :: * ;
Description
The OInt#(n) type is an abstract type that can store a number in the range “0..n-1”. The repre-
sentation of a OInt#(n) takes up n bits, where exactly one bit is a set to one, and the others are
zero, i.e., it is a one-hot decoded version of the number. The reason to use a OInt number is that
the select operation is more eﬃcient than for a binary-encoded number; the code generated for
select takes advantage of the fact that only one of the bits may be set at a time.
Types and type classes
Deﬁnition of OInt
typedef ... OInt #(numeric type n) ... ;

                           Type Classes used by OInt

           Bits Eq Literal Arith Ord Bounded Bit                    Bit  Bit

           √√           √                             √  wise Reduction Extend

OInt

Functions
A binary-encoded number can be converted to an OInt.

toOInt                  Converts from a bit-vector in unsigned binary format to an OInt.
                        An out-of-range number gives an unspeciﬁed result.

                        function OInt#(n) toOInt(Bit#(k) k)
                           provisos( Log#(n,k)) ;

                        c 2008 Bluespec, Inc. All rights reserved                         249


Reference Guide                                                   Bluespec SystemVerilog

An OInt can be converted to a binary-encoded number.

     fromOInt          Converts an OInt to a bit-vector in unsigned binary format.

                       function Bit#(k) fromOInt(OInt#(n) o)
                          provisos( Log#(n,k)) ;

An OInt can be used to select an element from a Vector in an eﬃcient way.

     select            The Vector select function, where the type of the index is an
                       OInt.

                       function a_type select(Vector#(vsize, a_type) vecta,
                                                           OInt#(vsize) index)

                          provisos (Bits#(a_type, sizea));

C.5 FSM

C.5.1 StmtFSM

Package Name

import StmtFSM :: * ;

Description

The StmtFSM package provides a procedural way of deﬁning ﬁnite state machines (FSMs) which are
automatically synthesized.

First, one uses the Stmt sublanguage to compose the actions of an FSM using sequential, parallel,
conditional and looping structures. This sublanguage is within the expression syntactic category,
i.e., a term in the sublanguage is an expression whose value is of type Stmt. This value can be bound
to identiﬁers, passed as arguments and results of functions, held in static data structures, etc., like
any other value. Finally, the FSM can be instantiated into hardware, multiple times if desired, by
passing the Stmt value to the module constructor mkFSM. The resulting module interface has type
FSM, which has methods to start the FSM and to wait until it completes.

The Stmt sublanguage

The state machine is automatically constructed from the procedural description given in the Stmt
deﬁnition. Appropriate state counters are created and rules are generated internally, corresponding
to the transition logic of the state machine. The use of rules for the intermediate state machine
generation ensures that resource conﬂicts are identiﬁed and resolved, and that implicit conditions
are properly checked before the execution of any action.

The names of generated rules (which may appear in conﬂict warnings) have suﬃxes of the form
“l&lt;nn&gt;c&lt;nn&gt;”, where the &lt;nn&gt; are line or column numbers, referring to the statement which gave
rise to the rule.

A term in the Stmt sublanguage is an expression, introduced at the outermost level by the keywords
seq or par. Note that within the sublanguage, if, while and for statements are interpreted
as statements in the sublanguage and not as ordinary statements, except when enclosed within
action/endaction keywords.

exprPrimary            ::= seqFsmStmt | parFsmStmt

fsmStmt                ::= exprFsmStmt
                       | seqFsmStmt

250                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

                        | parFsmStmt
                        | ifFsmStmt
                        | whileFsmStmt
                        | repeatFsmStmt
                        | forFsmStmt
                        | returnFsmStmt

exprFsmStmt             ::= regWrite ;
                        | expression ;

seqFsmStmt              ::= seq fsmStmt { fsmStmt } endseq

parFsmStmt              ::= par fsmStmt { fsmStmt } endpar

ifFsmStmt               ::= if expression fsmStmt
                              [ else fsmStmt ]

whileFsmStmt            ::= while ( expression )
                                    loopBodyFsmStmt

forFsmStmt              ::= for ( fsmStmt ; expression ; fsmStmt )
                                    loopBodyFsmStmt

returnFsmStmt           ::= return ;

repeatFsmStmt           ::= repeat ( expression )
                                    loopBodyFsmStmt

loopBodyFsmStmt         ::= fsmStmt
                        | break ;
                        | continue ;

The simplest kind of statement is an exprFsmStmt, which can be a register assignment or, more
generally, any expression of type Action (including action method calls and action-endaction
blocks or of type Stmt. Statements of type Action execute within exactly one clock cycle, but of
course the scheduling semantics may aﬀect exactly which clock cycle it executes in. For example, if
the actions in a statement interfere with actions in some other rule, the statement may be delayed
by the schedule until there is no interference. In all the descriptions of statements below, the
descriptions of time taken by a construct are minimum times; they could take longer because of
scheduling semantics.

Statements can be composed into sequential, parallel, conditional and loop forms. In the sequential
form (seq-endseq), the contained statements are executed one after the other. The seq block
terminates when its last contained statement terminates, and the total time (number of clocks) is
equal to the sum of the individual statement times.

In the parallel form (par-endpar), the contained statements (“threads”) are all executed in parallel.
Statements in each thread may or may not be executed simultaneously with statements in other
threads, depending on scheduling conﬂicts; if they cannot be executed simultaneously they will be
interleaved, in accordance with normal scheduling. The entire par block terminates when the last
of its contained threads terminates, and the minimum total time (number of clocks) is equal to the
maximum of the individual thread times.

In the conditional form (if (b) s1 else s2), the boolean expression b is ﬁrst evaluated. If true,
s1 is executed, otherwise s2 (if present) is executed. The total time taken is t cycles, if the chosen
branch takes t cycles.

In the while (b) s loop form, the boolean expression b is ﬁrst evaluated. If true, s is executed, and
the loop is repeated. Each time the condition evaluates true , the loop body is executed, so the total
time is n × t cycles, where n is the number of times the loop is executed (possibly zero) and t is the
time for the loop body statement.

The for (s1;b;s2) sB loop form is equivalent to:

                        c 2008 Bluespec, Inc. All rights reserved   251


Reference Guide                                               Bluespec SystemVerilog

s1; while (b) seq sB; s2 endseq

i.e., the initializer s1 is executed ﬁrst. Then, the condition b is executed and, if true, the loop body
sB is executed followed by the “increment” statement s2. The b, sB, s2 sequence is repeated as long
as b evaluates true.

Similarly, the repeat (n) sB loop form is equivalent to:

while (repeat_count &lt; n) seq sB; repeat_count &lt;= repeat_count + 1 endseq

where the value of repeat count is initialized to 0. During execution, the condition (repeat count &lt;
n) is executed and, if true, the loop body sB is executed followed by the “increment” statement
repeat count &lt;= repeat count + 1. The sequence is repeated as long as repeat count &lt; n evaluates
true.

In all the loop forms, the loop body statements can contain the keywords continue or break, with
the usual semantics, i.e., continue immediately jumps to the start of the next iteration, whereas
break jumps out of the loop to the loop sequel.

It is important to note that this use of loops, within a Stmt context, expresses time-based (temporal)
behavior.

Interfaces and Methods

Two interfaces are deﬁned with this package, FSM and Once. The FSM interface deﬁnes a basic state
machine interface while the Once interface encapsulates the notion of an action that should only be
performed once. A Stmt value can be instatiated into a module that presents an interface of type
FSM.

Name                                         Interfaces
FSM                Description
Once
                   The state machine interface
                   Used when an action should only be performed once

     • FSM Interface

        The FSM interface provides three methods; start, waitTillDone, and done. Once instantiated,
        the FSM can be started by calling the start method. One can wait for the FSM to stop running
        by waiting explicitly on the boolean value returned by the done method. Alternatively, one
        can use the waitTillDone method in any action context (including from within another FSM),
        which (because of an implicit condition) cannot execute until this FSM is done. The user must
        not use waitTillDone until after the FSM has been started because the FSM comes out of a
        reset as done.

     interface FSM;
           method Action start();
           method Action waitTillDone();
           method Bool done();

     endinterface: FSM

     Name          Type                FSM Interface
     start         Action                 Methods

     waitTillDone  Action        Description

     done          Bool          Begins state machine execution. This can only be called
                                 when the state machine is not executing.
                                 Does not do any action, but is only ready when the state
                                 machine is done.
                                 Asserted when the state machine is done and is ready to
                                 rerun.

252                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

• Once Interface

   The Once interface encapsulates the notion of an action that should only be performed once.
   The start method performs the action that has been encapuslated in the Once module. After
   start has been called start cannot be called again (an implicit condition will enforce this).
   If the clear method is called, the start method can be called once again.

interface Once;
      method Action start();
      method Action clear();
      method Bool done() ;

endinterface: Once

Name                    Type         Once Interface
start                   Action           Methods

clear                   Action  Description
done                    Bool
                                Performs the action that has been encapsulated in the
                                Once module, but once start has been called it cannot
                                be called again (an implicit condition will enforce this).
                                If the clear method is called, the start method can be
                                called once again.
                                Asserted when the state machine is done and is ready to
                                rerun.

Modules

Instantiation is performed by passing a Stmt value into the module constructor mkFSM. The state
machine is automatically constructed from the procedural decription given in the deﬁnition described
by state machine of type Stmt named seq_stmt. During construction, one or more registers of
appropriate widths are created to track state execution. Upon start action, the registers are loaded
and subsequent state changes then decrement the registers.

      module mkFSM#( Stmt seq_stmt ) ( FSM );

The mkFSMWithPred module is like mkFSM above, except that the module constructor takes an ad-
ditional boolean argument (the predicate). The predicate condition is added to the condition of
each rule generated to create the FSM. This capability is useful when using the FSM in conjuction
with other rules and/or FSMs. It allows the designer to explicitly specify to the compiler the condi-
tions under which the FSM will run. This can be used to eliminate spurious rule conﬂict warnings
(between rules in the FSM and other rules in the design).

      module mkFSMWithPred#( Stmt seq_stmt, Bool pred ) ( FSM );

The mkAutoFSM module is also like mkFSM above, except the state machine runs automatically im-
mediately after reset and a $finish(0) is called upon completion. This is useful for test benches.
Thus, it has no interface, that is, it has an empty interface.

      module mkAutoFSM#( seq_stmt ) ();

The mkOnce function is used to create a Once interface where the action argument has been encap-
sulated and will be performed when start is called.

      module mkOnce#( Action a ) ( Once );

                        c 2008 Bluespec, Inc. All rights reserved  253


Reference Guide                                                      Bluespec SystemVerilog

The implementation for Once is a 1 bit state machine (with a state register named onceReady)
allowing the action argument to occur only one time. The ready bit is initially True and then
cleared when the action is performed. It might not be performed right away, because of implicit
conditions or scheduling conﬂicts.

Name             BSV Module Declaration                              Description
mkFSM            module mkFSM#(Stmt seq_stmt)(FSM);
                                                                     Instantiate a Stmt value into a mod-
                                                                     ule that presents an interface of type
                                                                     FSM.

mkFSMWithPred    module mkFSMWithPred#(Stmt seq_stmt,                Like mkFSM, except that the module
mkAutoFSM                                          Bool pred)(FSM);  constructor takes an additional pred-
mkOnce                                                               icate condition as an argument. The
                 module mkAutoFSM#(Stmt seq_stmt)();                 predicate condition is added to the
                                                                     condition of each rule generated to
                 module mkOnce#( Action a )( Once );                 create the FSM.
                                                                     Like mkFSM, except that state ma-
                                                                     chine simulation is automatically
                                                                     started and a $finish(0)) is called
                                                                     upon completion.
                                                                     Used to create a Once interface where
                                                                     the action argument has been encap-
                                                                     sulated and will be performed when
                                                                     start is called.

Functions

There are two functions, await and delay, provided by the StmtFSM package.

The await function is used to create an action which can only execute when the condition is True.
The action does not do anything. await is useful to block the execution of an action until a condition
becomes True.

The delay function is used to execute noAction for a speciﬁed number of cycles. The function is
provided the value of the delay and returns a Stmt.

Name   Function Declaration                          Description
await  function Action await( Bool cond ) ;
       function Stmt delay( a_type value ) ;         Creates an Action which does nothing,
delay                                                but can only execute when the condi-
                                                     tion is True.

                                                     Creates a Stmt which executes
                                                     noAction for value number of cycles.
                                                     a_type must be in the Arith class and
                                                     Bits class and &lt; 32 bits.

Example - Initializing a single-ported SRAM.

Since the SRAM has only a single port, we can write to only one location in each clock. Hence, we
need to express a temporal sequence of writes for all the locations to be initialized.

     Reg#(int) i, j;  // instantiate two register interfaces
     mkRegU ri (i);   // create register with interface i

254                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

mkRegU rj (j);           // create register with interface j

// Define fsm behavior
Stmt s = seq

                    for (i &lt;= 0; i &lt; M; i &lt;= i + 1)
                          for (j &lt;= 0; j &lt; N; j &lt;= j + 1)
                                 sram.write (i, j, i+j);

              endseq

FSM fsm();               // instantiate FSM interface
mkFSM#(s) (fsm);         // create fsm with interface fsm and behavior s

...

rule initSRAM (start_reset);

     fsm.start;          // Start the fsm

endrule

When the start_reset signal is true, the rule kicks oﬀ the SRAM initialization. Other rules can
wait on fsm.done, if necessary, for the SRAM initialization to be completed.

In this example, the seq-endseq brackets are used to enter the Stmt sublanguage, and then for
represents Stmt sequencing (instead of its usual role of static generation). Since seq-endseq contains
only one statement (the loop nest), par-endpar brackets would have worked just as well.

Example - Deﬁning and instantiating a state machine.

import StmtFSM :: *;
import FIFO :: *;

module testSizedFIFO();

// Instantiation of DUT
FIFO#(Bit#(16)) dut &lt;- mkSizedFIFO(5);

// Instantiation of reg’s i and j

Reg#(Bit#(4))           i &lt;- mkRegA(0);

Reg#(Bit#(4))           j &lt;- mkRegA(0);

// Action description with stmt notation
Stmt driversMonitors =

 (seq
    // Clear the fifo
    dut.clear;

// Two secuential blocks running in parallel
par

   // Enque 2 times the Fifo Depth
    for(i &lt;= 1; i &lt;= 10; i &lt;= i + 1)
    seq
       dut.enq({0,i});
       $display(&quot; Enque %d&quot;, i);
    endseq

// Wait until the fifo is full and then deque

                         c 2008 Bluespec, Inc. All rights reserved        255


Reference Guide                                             Bluespec SystemVerilog

           seq
              while (i &lt; 5)
              seq
                 noAction;
              endseq
              while (i &lt;= 10)
              action
                 dut.deq;
                 $display(&quot;Value read %d&quot;, dut.first);
              endaction

           endseq

       endpar

       $finish(0);
    endseq);

    // stmt instantiation
    FSM test &lt;- mkFSM(driversMonitors);

    // A register to control the start rule
    Reg#(Bool) going &lt;- mkReg(False);

    // This rule kicks off the test FSM, which then runs to completion.
    rule start (!going);

         going &lt;= True;
         test.start;
    endrule
endmodule

Example - Deﬁning and instantiating a state machine to control speed changes
import StmtFSM::*;
import Common::*;

interface SC_FSM_ifc;
    method Speed xcvrspeed;
    method Bool devices_ready;
    method Bool out_of_reset;

endinterface

module mkSpeedChangeFSM(Speed new_speed, SC_FSM_ifc ifc);
    Speed initial_speed = FS;

    Reg#(Bool) outofReset_reg &lt;- mkReg(False);
    Reg#(Bool) devices_ready_reg &lt;- mkReg(False);
    Reg#(Speed) device_xcvr_speed_reg &lt;- mkReg(initial_speed);

    // the following lines define the FSM using the Stmt sublanguage
    // the state machine is of type Stmt, with the name speed_change_stmt
    Stmt speed_change_stmt =
    (seq

           action outofReset_reg &lt;= False; devices_ready_reg &lt;= False; endaction
           noAction; noAction; // same as: delay(2);

256              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

           device_xcvr_speed_reg &lt;= new_speed;
           noAction; noAction; // same as: delay(2);

           outofReset_reg &lt;= True;
           if (device_xcvr_speed_reg==HS)

               seq noAction; noAction; endseq
               // or seq delay(2); endseq
           else
               seq noAction; noAction; noAction; noAction; noAction; noAction; endseq
              // or seq delay(6); endseq
           devices_ready_reg &lt;= True;
      endseq);
    // end of the state machine definition

    // the statemachine is instantiated using mkFSM
    FSM speed_change_fsm &lt;- mkFSM(speed_change_stmt);

    // the rule change_speed starts the state machine
    // the rule checks that previous actions of the state machine have completed
    rule change_speed ((device_xcvr_speed_reg != new_speed || !outofReset_reg) &amp;&amp;

         speed_change_fsm.done);
         speed_change_fsm.start;
    endrule

    method xcvrspeed = device_xcvr_speed_reg;
    method devices_ready = devices_ready_reg;
    method out_of_reset = outofReset_reg;
endmodule

Example - Deﬁning a state machine and using the await function

// This statement defines this brick’s desired behavior as a state machine:
// the subcomponents are to be executed one after the other:
Stmt brickAprog =

   seq
       // Since the following loop will be executed over many clock
       // cycles, its control variable must be kept in a register:
       for (i &lt;= 0; i &lt; 0-1; i &lt;= i+1)
            // This sequence requests a RAM read, changing the state;
            // then it receives the response and resets the state.
            seq
                 action
                      // This action can only occur if the state is Idle
                      // the await function will not let the statements
                      // execute until the condition is met
                      await(ramState==Idle);
                      ramState &lt;= DesignReading;
                      ram.request.put(tagged Read i);
                 endaction
                 action
                      let rs &lt;- ram.response.get();
                      ramState &lt;= Idle;
                      obufin.put(truncate(rs));
                 endaction

                        c 2008 Bluespec, Inc. All rights reserved            257


Reference Guide                                                   Bluespec SystemVerilog

                 endseq
            // Wait a little while:
            for (i &lt;= 0; i &lt; 200; i &lt;= i+1)

                 action
                 endaction
            // Set an interrupt:
            action
                 inrpt.set;
            endaction
        endseq
        );
     // end of the state machine definition

     FSM brickAfsm &lt;- mkFSM#(brickAprog); //instantiate the state machine

     // A register to remember whether the FSM has been started:
     Reg#(Bool) notStarted();
     mkReg#(True) the_notStarted(notStarted);

     // The rule which starts the FSM, provided it hasn’t been started

     // previously and the brick is enabled:

     rule start_Afsm (notStarted &amp;&amp; enabled);

     brickAfsm.start;          //start the state machine

     notStarted &lt;= False;

     endrule

Creating FSM Server Modules

Instantiation of an FSM server module is performed in a manner analogous to that of a standard FSM
module constructor (such as mkFSM). Whereas mkFSM takes a Stmt value as an argument, howver,
mkFSMServer takes a function as an argument. More speciﬁcally, the argument to mkFSMServer is a
function which takes an argument of type a and returns a value of type RStmt#(b).

     module mkFSMServer#(function RStmt#(b) seq_func (a input)) ( FSMServer#(a, b) );

The RStmt type is a polymorphic generalization of the Stmt type. A sequence of type RStmt#(a)
allows valued return statements (where the return value is of type a). Note that the Stmt type is
equivalent to RStmt#(Bit#(0)).

typedef RStmt#(Bit#(0)) Stmt;

The mkFSMServer module constructor provides an interface of type FSMServer#(a, b).

interface FSMServer#(type a, type b);;
      interface Server#(a, b) server;
      method Action abort();

endinterface

The FSMServer interface has one subinterface of type Server#(a, b) (from the ClientServer
package) as well as an Action method called abort; The abort method allows the FSM inside the
FSMServer module to be halted if the client FSM is halted.

An FSMServer module is accessed using the callServer function. callServer takes two arguments.
The ﬁrst is the interface of the FSMServer module. The second is the input value being passed to
the module.

258                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

result &lt;- callServer(serv_ifc, value);

Note the special left arrow notation that is used pass the server result to a register (or more generally
to any state element with a Reg interface). A simple example follows showing the deﬁnition and use
of a mkFSMServer module.

Example - Deﬁning and instantiating an FSM Server Module

    // State elements to provide inputs and store results
    Reg#(Bit#(8)) count &lt;- mkReg(0);
    Reg#(Bit#(16)) partial &lt;- mkReg(0);
    Reg#(Bit#(16)) result &lt;- mkReg(0);

    // A function which creates a server sequence to scale a Bit#(8)
    // input value by and integer scale factor. The scaling is accomplished
    // by a sequence of adds.
    function RStmt#(Bit#(16)) scaleSeq (Integer scale, Bit#(8) value);

         seq
              partial &lt;= 0;
              repeat (fromInteger(scale))
                   action
                       partial &lt;= partial + {0,value};
                   endaction
              return partial;

         endseq;
    endfunction

    // Instantiate a server module to scale the input value by 3
    FSMServer#(Bit#(8), Bit#(16)) scale3_serv &lt;- mkFSMServer(scaleSeq(3));

    // A test sequence to apply the server
    let test_seq = seq

                                  result &lt;- callServer(scale3_serv, count);
                                  count &lt;= count + 1;
                              endseq;

    let test_fsm &lt;- mkFSM(test_seq);

    // A rule to start test_fsm
    rule start;

         test_fsm.start;
    endrule
    // finish after 6 input values
    rule done (count == 6);

         $finish;
    endrule

C.6 Connectivity

The packages in this section provide useful components, primarily interfaces, to connect hardware
elements in a design.
The basic interfaces, Get and Put are deﬁned in the package GetPut. The typeclass Connectable
indicates that two related types can be connected together. The package ClientServer provides

                        c 2008 Bluespec, Inc. All rights reserved  259


Reference Guide                                             Bluespec SystemVerilog

interfaces using Get and Put for modules that have a request-response type of interface. The package
CGetPut deﬁnes a type of the Get and Put interfaces that is implemented with a credit based FIFO.

C.6.1 GetPut

Package Name
import GetPut :: *;
Description
Get and Put are simple interfaces, consisting of one method each, get and put, respectively. This
package provides the interfaces Get, Put, and GetPut. This package also provides modules which
provide the GetPut interface as a FIFO implementation, but these interfaces can be used in many
additional hardware implementations.
Typeclasses
The GetPut package deﬁnes two typeclasses; ToGet and ToPut.
ToGet deﬁnes the class to which the function toGet can be applied to create an associated Get
interface.

typeclass ToGet#(a, b);
    function Get#(b) toGet(a ax);

endtypeclass

ToPut deﬁnes the class to which the function toPut can be applied to create an associated Put
interface.

typeclass ToPut#(a, b);
    function Put#(b) toPut(a ax);

endtypeclass

Instances of ToGet and ToPut are deﬁned for the following interfaces. The toGet and toPut functions
convert these interfaces to a Get and Put interface respectively.

      FIFO
      FIFOF
      SyncFIFOIfc
      FIFOLevelIfc
      SyncFIFOLevelIfc
      FIFOCountIfc
      SyncFIFOCountIfc

Interfaces and methods

The Get interface deﬁnes a get method, similar to a dequeue, which retrieves an item from an
interface and removes it at the same time. The Put interface deﬁnes a put method, similar to an
enqueue, which gives an item to an interface. A module providing these interfaces can be designed
to have implicit conditions on the get/put to ensure that the get/put is not performed when the
module is not ready. This would ensure that a rule containing get method would not ﬁre if the
element associated with it is empty and that a rule containing put method would not ﬁre if the
element is full.

260              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Interface Name          Parameter           Interfaces             Restrictions
Get                     name          Parameter Description        must be in Bits class
Put                     element type                               must be in Bits class
GetPut                                type of the element          must be in Bits class
                        element type  being retrieved by the Get
                                      type of the element
                        element type  being added by the Put
                                      type of the element
                                      being retrieved and added

Get

The Get interface is where you retrieve (get) data from an object. The Get interface is provides
a single method, get, which retrieves an item of data from an interface and removes it from the
object. A get is similar to a dequeue, but it can be associated with any interface. A Get interface
is more abstract than a FIFO interface; it does not describe the underlying hardware.

                                           Get

                        Method                                     Argument
                                                                        Description
     Name       Type          Description                   Name
     get
                ActionValue returns an item from an
                                  interface and removes it
                                  from the object

interface Get#(type element_type);
      method ActionValue#(element_type) get();

endinterface: Get

Example - adding your own Get interface:

module mkMyFifoUpstream (Get#(int));
...

    method ActionValue#(int) get();
           f.deq;
           return f.first;

    endmethod

Put

The Put interface is where you can give (put) data to an object. The Put interface provices a single
method, put, which gives an item to an interface. A put is similar to a enqueue, but it can be
associated with any interface. A Put interface is more abstract than a FIFO interface; it does not
describe the underlying hardware.

                                           Put

                      Method                                         Argument
                                                                          Description
     Name  Type    Description                  Name
     put   Action                                           data to be added to the object
                   gives an item to an interface x1         must be of type element_type

interface Put#(type element_type);
      method Action put(element_type x1);

endinterface: Put

Example - adding your own Put interface:

                        c 2008 Bluespec, Inc. All rights reserved                           261


Reference Guide                                             Bluespec SystemVerilog

module mkMyFifoDownstream (Put#(int));
...

    method Action put(int x);
           F.enq(x);

    endmethod

GetPut
The library also deﬁnes an interface GetPut which associates Get and Put interfaces into a Tuple2.
typedef Tuple2#(Get#(element_type), Put#(element_type)) GetPut#(type element_type);

Type classes
The class Connectable (Section C.6.2) is meant to indicate that two related types can be connected
in some way. It does not specify the nature of the connection.
A Get and Put is an example of connectable items. One object will put an element into the interface
and the other object will get the element from the interface.

instance Connectable#(Get#(element_type), Put#(element_type));

Modules

There are three modules provided by the GetPut package which provide the GetPut interface with
a type of FIFO. These FIFOs use Get and Put interfaces instead of the usual enq interfaces. To use
any of these modules the FIFO package must be imported. You can also write your own modules
providing a GetPut interface for other hardware structures.

mkGPFIFO         Creates a FIFO of depth 2 with a GetPut interface.

                 module mkGPFIFO (GetPut#(element_type))
                    provisos (Bits#(element_type, width_elem));

mkGPFIFO1        Creates a FIFO of depth 1 with a GetPut interface.

                 module mkGPFIFO1 (GetPut#(element_type))
                    provisos (Bits#(element_type, width_elem));

mkGPSizedFIFO    Creates a FIFO of depth n with a GetPut interface.

                 module mkGPSizedFIFO# (Integer n) (GetPut#(element_type))
                    provisos (Bits#(element_type, width_elem));

262              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

Functions

There are two functions deﬁned in the GetPut package that change a FIFO interface to a Get or
Put interface. Given a FIFO we can use the function fifoToGet to obtain a Get interface, which
is a combination of deq and first. Given a FIFO we can use the function fifoToPut to obtain a
Put interface using enq. The functions toGet and toPut (C.6.1) are recommended instead of the
fifoToGet and fifoToPut functions.

The package deﬁnes an additional function, peekGet, which returns the ﬁrst item without removing
it from the object. There are scheduling concerns when using peekGet; because of the implicit
condition, it will only ﬁre if there is data available.

fifoToGet  Returns a Get interface. It is recommended that you use the function toGet
           (C.6.1) instead of this function.

           function Get#(element_type) fifoToGet(FIFO#(element_type) f);

fifoToPut  Returns a Put interface. It is recommended that you use the function toPut
           (C.6.1) instead of this function.

           function Put#(element_type) fifoToPut(FIFO#(element_type) f);

peekGet    Returns ﬁrst item without removing it from the object. Will not ﬁre if data
           is not available.

           function element_type peekGet(Get#(element_type) g;)

Example of creating a FIFO with a GetPut interface

       import GetPut::*;
       import FIFO::*;

       ...
       module mkMyModule (MyInterface);

            GetPut#(StatusInfo) aFifoOfStatusInfoStructures &lt;- mkGPFIFO;
       ...
       endmodule: mkMyModule

Example of a protocol monitor
This is an example of how you might write a protocol monitor that watches bus traﬃc between a
bus and a bus target device

       import GetPut::*;
       import FIFO::*;

       // Watch bus traffic beteween a bus and a bus target
       interface ProtocolMonitorIfc;

                        c 2008 Bluespec, Inc. All rights reserved         263


Reference Guide                                             Bluespec SystemVerilog

         // These subinterfaces are defined inside the module
         interface Put#(Bus_to_Target_Request) bus_to_targ_req_ifc;
         interface Put#(Target_to_Bus_Response) targ_to_bus_resp_ifc;
     endinterface
     ...
     module mkProtocolMonitor (ProtocolMonitorIfc);
         // Input FIFOs that have Put interfaces added a few lines down
         FIFO#(Bus_to_Target_Request) bus_to_targ_reqs &lt;- mkFIFO;
         FIFO#(Target_To_Bus_Response) targ_to_bus_resps &lt;- mkFIFO;
     ...
         // Define the subinterfaces: attach Put interfaces to the FIFOs, and
         // then make those the module interfaces
         interface bus_to_targ_req_ifc = fifoToPut (bus_to_targ_reqs);
         interface targ_to_bus_resp_ifc = fifoToPut (targ_to_bus_resps);
     end module: mkProtocolMonitor

     // Top-level module: connect mkProtocolMonitor to the system:
     module mkSys (Empty);

         ProtocolMonitorIfc pmon &lt;- mkProtocolInterface;
     ...

         rule pass_bus_req_to_interface;
                let x &lt;- bus.bus_ifc.get; // definition not shown
                pmon.but_to_targ_ifc.put (x);

         endrule
     ...
     endmodule: mkSys

C.6.2 Connectable

Package Name
import Connectable :: * ;
Description
The Connectable package contains the deﬁnitions for the class Connectable and two instances of
Connectables; Tuples and Vectors.
Types and Type-Classes
The class Connectable is meant to indicate that two related types can be connected in some way.
It does not specify the nature of the connection. The Connectables type class deﬁnes the module
mkConnection, which is used to connect the pairs.

typeclass Connectable#(type a, type b);
      module mkConnection#(a x1, b x2)(Empty);

endtypeclass

Instances

Get and Put One instance of the typeclass of Connectable is Get and Put. One object will put
an element into an interface and the other object will get the element from the interface.

instance Connectable#(Get#(a), Put#(a));

264              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

Tuples If we have Tuple2 of connectable items then the pair is also connectable, simply by con-
necting the individual items.

instance Connectable#(Tuple2#(a, c), Tuple2#(b, d))
   provisos (Connectable#(a, b), Connectable#(c, d));

The proviso shows that the ﬁrst component of one tuple connects to the ﬁrst component of the other
tuple, likewise, the second components connect as well. In the above statement, a connects to b and
c connects to d. This is used by ClientServer (Section C.6.3) to connect the Get of the Client to
the Put of the Server and visa-versa.

This is extensible to all Tuples (Tuple3, Tuple4, etc.). As long as the items are connectable, the
Tuples are connectable.

Vector Two Vectors are connectable if their elements are connectable.

instance Connectable#(Vector#(n, a), Vector#(n, b))
   provisos (Connectable#(a, b));

InOut Inouts are connectable via the Connectable typeclass. The use of mkConnection instan-
tiates a Verilog module InoutConnect. The Inouts must be on the same clock and the same reset.
The clock and reset of the Inouts may be diﬀerent than the clock and reset of the parent module of
the mkConnection.

instance Connectable#(Inout#(a, x1), Inout#(a, x2))
    provisos (Bit#(a,sa));

C.6.3 ClientServer

Package Name

import ClientServer :: * ;

Description

The ClientServer package provides two interfaces, Client and Server which can be used to deﬁne
modules which have a request-response type of interface. The GetPut package must be imported
when using this package because the Get and Put interface types are used.

Interfaces and methods

The interfaces Client and Server can be used for modules that have a request-response type of
interface (e.g. a RAM). The server accepts requests and generates responses, the client accepts
responces and generates requests. There are no assumptions about how many (if any) responses a
request generates

Interface Name  Parameter name      Interfaces               Restrictions
Client                          Parameter Description
                req type                                     must be in the Bits class
Server          resp type       type of the client request   must be in the Bits class
                req type        type of the client response  must be in the Bits class
                resp type       type of the server request   must be in the Bits class
                                type of the server response

Client

The Client interface provides two sub-interfaces, request and response. From a Client, one gets
a request and puts a response.

                            c 2008 Bluespec, Inc. All rights reserved                   265


Reference Guide                                                   Bluespec SystemVerilog

                       Client SubInterface

     Name        Type                 Description
     request
                 Get#(req_type)       the interface through which the outside world
     response    Put#(resp_type)      retrieves (gets) a request
                                      the interface through which the outside world
                                      returns (puts) a response

interface Client#(type req_type, type resp_type);
      interface Get#(req_type) request;
      interface Put#(resp_type) response;

endinterface: Client

Server

The Server interface provides two sub-interfaces, request and response. From a Server, one puts
a request and gets a response.

     Name        Type  Server SubInterface
     request                   Description

     response    Put#(req_type)       the interface through which the outside world
                                      returns (puts) a request

                 Get#(resp_type) the interface through which the outside world
                                              retrieves (gets) a response

interface Server#(type req_type, type resp_type);
      interface Put#(req_type) request;
      interface Get#(resp_type) response;

endinterface: Server

ClientServer

A Client can be connected to a Server and vice versa. The request (which is a Get interface)
of the client will connect to response (which is a Put interface) of the Server. By making the
ClientServer tuple an instance of the Connectable typeclass, you can connect the Get of the client
to the Put of the server, and the Put of the client to the Get of the server.

instance Connectable#(Client#(req_type, resp_type), Server#(req_type, resp_type));
instance Connectable#(Server#(req_type, resp_type), Client#(req_type, resp_type));

This Tuple2 can be redeﬁned to be called ClientServer

typedef Tuple2#(Client#(req_type, resp_type), Server#(req_type,resp_type))
                         ClientServer#(type req_type, type resp_type);

Example Connecting a bus to a target

interface Bus_Ifc;
    interface Server#(RQ, RS) to_targ ;
    interface Client#(RQ, RS) to_initor;

endinterface

typedef Server#(RQ, RS) Target_Ifc;
typedef Client#(RQ, RS) Initiator_Ifc;

266                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

module mkSys (Empty);

// Instantiate subsystems

Bus_Ifc                 bus           &lt;- mkBus;
                                      &lt;- mkTarget;
Target_Ifc              targ          &lt;- mkInitiator;

Initiator_Ifc           initor

// Connect bus and targ (&quot;to_targ&quot; is a Get ifc, targ is a Put ifc)
Empty x &lt;- mkConnection (bus.to_targ, targ);

// Connect bus and initiator (&quot;to_initor&quot; is a Out ifc, initor is a Get ifc)
mkConnection (bus.to_initor, initor);
// Since mkConnection returns an interface of type Empty, it does
// not need to be specified (but may be as above)

...
endmodule: mkSys

C.6.4 CGetPut

Package Name

import CGetPut :: * ;

Description

The interfaces CGet and CPut are similar to Get and Put, but the interconnection of them (via
Connectable) is implemented with a credit-based FIFO. This means that the CGet and CPut inter-
faces have completely registered input and outputs, and furthermore that additional register buﬀers
can be introduced in the connection path without any ill eﬀect (except an increase in latency, of
course).

In the absence of additional register buﬀers, the round-trip time for communication between the two
interfaces is 4 clock cycles. Call this number r. The ﬁrst argument to the type, n, speciﬁes that
transfers will occur for a fraction n/r of clock cycles (note that the used cycles will not necessarily be
evenly spaced). n also speciﬁes the depth of the buﬀer used in the receiving interface (the transmitter
side always has only a single buﬀer). So (in the absence of additional buﬀers) use n = 4 to allow
full-bandwidth transmission, at the cost of suﬃcient registers for quadruple buﬀering at one end;
use n = 1 for minimal use of registers, at the cost of reducing the bandwidth to one quarter; use
intermediate values to select the optimal trade-oﬀ if appropriate.

Interfaces and methods

The interface types are abstract to avoid any non-proper use of the credit signaling protocol.

Interface Name          Parameter           Interfaces                    Restrictions
CGet                    name          Parameter Description
                        n
CPut                                  depth of the buﬀer used in the re-  must be a numeric
                        element type  ceiving interface                   type
                                      type of the element                 must be in Bits class
                        n             being retrieved by the CGet
                                      depth of the buﬀer used in the re-  must be a numeric
                        element type  ceiving interface                   type
                                      type of the element                 must be in Bits class
                                      being added by the CPut

• CGet

                        c 2008 Bluespec, Inc. All rights reserved                               267


Reference Guide                                             Bluespec SystemVerilog

       interface CGet#(numeric type n, type element_type);
                 ...Abstract...

    • CPut
       interface CPut#(numeric type n, type element_type);
                 ...Abstract...

    • Connectables
       The CGet and CPut interfaces are connectable.
       instance Connectable#(CGet#(n, element_type), CPut#(n, element_type));

       instance Connectable#(CPut#(n, element_type), CGet#(n, element_type));

    • CClient and CServer
       The same idea may be extended to clients and servers.
       interface CClient#(type n, type req_type, type resp_type);
       interface CServer#(type n, type req_type, type resp_type);

Modules

mkCGetPut        Create an n depth FIFO with a CGet interface on the dequeue side and a
                 Put interface on the enqueue side.

                 module mkCGetPut(Tuple2#(CGet#(n, element_type),
                                                        Put#(element_type)))

                    provisos (Bits#(element_type));

mkGetCPut        Create an n depth FIFO with a Get interface on the dequeue side and a
                 CPut interface on the enqueue side.

                 module mkGetCPut(Tuple2#(Get#(element_type),
                                                        CPut#(n, element_type)))

                    provisos (Bits#(element_type));

mkClientCServer Create a CServer with a mkCGetPut and a mkGetCPut. Provides a CServer
                         interface and a regular Client interface.

                         module mkClientCServer(
                                                 Tuple2#(Client#(req_type, resp_type),
                                                              CServer#(n, req_type, resp_type)))

                            provisos (Bits#(req_type),
                                            Bits#(resp_type));

268              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

mkCClientServer Create a CClient with a mkCGetPut and a mkGetCPut. Provides a CClient
                         interface and a regular Server interface.

                         module mkCClientServer(
                                                  Tuple2#(CClient#(n, req_type, resp_type),
                                                               Server#(req_type, resp_type)))

                            provisos (Bits#(req_type),
                                            Bits#(resp_type));

C.7 Utilities

C.7.1 LFSR

Package

import LFSR :: * ;

Description

The LFSR package implements Linear Feedback Shift Registers (LFSRs). LFSRs can be used to
obtain reasonable pseudo-random numbers for many purposes (though not good enough for cryp-
tography). The seed method must be called ﬁrst, to prime the algorithm. Then values may be
read using the value method, and the algorithm stepped on to the next value by the next method.
When a LFSR is created the start value, or seed, is 1.

Interfaces and Methods

The LFSR package provides an interface, LFSR, which contains three methods; seed, value, and
next. To prime the LFSR the seed method is called with the parameter seed_value, of datatype
a_type. The value is read with the value method. The next method is used to shift the register
on to the next value.

                                               LFSR Interface            Arguments
                            Method
Name   Type             Description                              Name    Description
seed   Action           Sets the value of the shift register.
                                                                 a_type  datatype of the
value  a_type           returns the value of the shift register
next   Action           signals the shift register to shift to           seed value
                        the next value.
                                                                 seed_value the initial value

interface LFSR #(type a_type);
      method Action seed(a_type seed_value);
      method a_type value();
      method Action next();

endinterface: LFSR

Modules

The module mkFeedLFSR creates a LFSR where the polynomial is speciﬁed by the mask used for
feedback.

                        c 2008 Bluespec, Inc. All rights reserved                              269


Reference Guide                                              Bluespec SystemVerilog

mkFeedLFSR       Creates a LFSR where the polynomial is speciﬁed by the mask (feed ) used
                 for feedback.

                 module mkFeedLFSR#( Bit#(n) feed )( LFSR#(Bit#(n)) );

For example, the polynominal x7+x3+x2+x+1 is deﬁned by the expression mkFeedLFSR#(8’b1000_1111)
Using the module mkFeedLFSR, the following maximal length LFSR’s are deﬁned in this package.

Module Name feed               Module Deﬁnition

mkLFSR_4         4’h9          module mkLFSR_4 (LFSR#(Bit#(4)));
                 x3 + 1
mkLFSR_8                       module mkLFSR_8 (LFSR#(Bit#(8)));
mkLFSR_16        8’h8E         module mkLFSR_16 (LFSR#(Bit#(16)));
mkLFSR_32                      module mkLFSR_32 (LFSR#(Bit#(32)));
                 16’h8016

                 32’h80000057

For example,
mkLFSR_4 = mkFeedLFSR( 4’h9 );

The module mkLFSR_4 instantiates the interface LFSR with the value Bit#(4) to produce a 4 bit
shift register. The module uses the polynomial deﬁned by the mask 4’h9 (x3 + 1) and the module
mkFeedLFSR.

The mkRCounter function creates a counter with a LFSR interface. This is useful during debugging
when a non-random sequence is desired. This function can be used in place of the other mkLFSR
module constructors, without changing any method calls or behavior.

mkRCounter       Creates a counter with a LFSR interface.
                 module mkRCounter#( Bit#(n) seed ) ( LFSR#(Bit#(n)) );

Example - Random Number Generator

import GetPut::*;
import FIFO::*;
import LFSR::*;

// We want 6-bit random numbers, so we will use the 16-bit version of
// LFSR and take the most significant six bits.

// The interface for the random number generator is parameterized on bit
// length. It is a &quot;get&quot; interface, defined in the GetPut package.

typedef Get#(Bit#(n)) RandI#(type n);

module mkRn_6(RandI#(6));

270               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

   // First we instantiate the LFSR module
   LFSR#(Bit#(16)) lfsr &lt;- mkLFSR_16 ;

   // Next comes a FIFO for storing the results until needed
   FIFO#(Bit#(6)) fi &lt;- mkFIFO ;

   // A boolean flag for ensuring that we first seed the LFSR module
   Reg#(Bool) starting &lt;- mkReg(True) ;

   // This rule fires first, and sends a suitable seed to the module.
   rule start (starting);

         starting &lt;= False;
         lfsr.seed(’h11);
   endrule: start

   // After that, the following rule runs as often as it can, retrieving
   // results from the LFSR module and enqueing them on the FIFO.
   rule run (!starting);

         fi.enq(lfsr.value[10:5]);
         lfsr.next;
   endrule: run

   // The interface for mkRn_6 is a Get interface. We can produce this from a
   // FIFO using the fifoToGet function. We therefore don’t need to define any
   // new methods explicitly in this module: we can simply return the produced
   // Get interface as the &quot;result&quot; of this module instantiation.
   return fifoToGet(fi);
endmodule

C.7.2 Randomizable

Description

The Randomizable package includes interfaces and modules to generate random values of a given
data type.

This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.

Packages

To include a package in your design, use the import syntax.

import Randomizable :: * ;

Interfaces and Methods

Name   Type                   Randomize Interface
cntrl  Interface            Description
next   ActionValue
                            Control interface provided by the module.
                            Returns the next value of type a.

                        c 2008 Bluespec, Inc. All rights reserved               271


Reference Guide                                                       Bluespec SystemVerilog

interface Randomize#(type a);
    interface Control cntrl;
    method ActionValue#(a) next();

endinterface

     Name        Type          Control Interface
     init        Control   Description
                           Action method to initialize the randomizer.

interface Control ;
    method Action init();

endinterface

Modules

The Randomizable package includes two modules which return random values of type a. The
diﬀerence between the two modules is how the min and max values are determined. The module
mkGenericRandomizer uses the min and max values of the type, while the module mkConstrainedRandomizer
uses arguments to set the min and max values. The type a must be in the Bounded class for both
modules.

mkGenericRandomizer        This module provides a Randomize interface, which will return the next ran-
                           dom value when the next method is invoked. The min and max values are
                           the values deﬁned by the type a which must be in the Bounded class.

                           module mkGenericRandomizer (Randomize#(a))
                               provisos (Bits#(a, sa), Bounded#(a));

mkConstrainedRandomizer This module provides a Randomize interface, which will give the next random
                                      value when the next method is invoked. When instantiated, the min and max
                                      values are provided as arguments. Type a must be in the Bounded class.

                                      module mkConstrainedRandomizer#(a min, a max) (Randomize#(a))
                                           provisos (Bits#(a, sa), Bounded#(a));

Example

The mkTLMRandomizer module, deﬁned within the TLM package (Section C.10.1), uses the Random-
ize package to generate random values for TLM packets. The mkConstrainedRandomizer module is
for ﬁelds with speciﬁc allowed values or ranges, while the mkGenericRandomizer module is for ﬁeld
where all values of the type are allowed.

module mkTLMRandomizer#(Maybe#(TLMCommand) m_command) (Randomize#(TLMRequest#(‘TLM_TYPES)))
    provisos(Bits#(RequestDescriptor#(‘TLM_TYPES), s0),
      Bounded#(RequestDescriptor#(‘TLM_TYPES)),
      Bits#(RequestData#(‘TLM_TYPES), s1),

272                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Bounded#(RequestData#(‘TLM_TYPES))
);

...

// Use mkGeneric Randomizer - entire range valid

Randomize#(RequestDescriptor#(‘TLM_TYPES)) descriptor_gen &lt;- mkGenericRandomizer;

Randomize#(Bit#(2))                   log_wrap_gen &lt;- mkGenericRandomizer;

Randomize#(RequestData#(‘TLM_TYPES))  data_gen                     &lt;- mkGenericRandomizer;

// Use mkConstrainedRandomizer to Avoid UNKNOWN
Randomize#(TLMCommand) command_gen &lt;- mkConstrainedRandomizer(READ, WRITE);
Randomize#(TLMBurstMode) burst_mode_gen &lt;- mkConstrainedRandomizer(INCREMENT, WRAP);

// Use mkConstrainedRandomizer to set legal sizes between 1 and 16
Randomize#(TLMUInt#(‘TLM_TYPES)) burst_length_gen &lt;- mkConstrainedRandomizer(1,16);

C.7.3 Arbiter

Description
The Arbiter package includes interfaces and modules to implement two diﬀerent arbiters: a fair
arbiter with changing priorities (round robin) and a sticky arbiter, also round robin, but which gives
the current owner priority.
This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.
Packages
To include a package in your design, use the import syntax.

       import Arbiter :: * ;

Interfaces and Methods
The Arbiter package includes three interfaces: a arbiter client interface, an arbiter request interface
and an arbiter interface which is a vector of client interfaces.

ArbiterClient IFC The ArbiterClient_IFC interface has two methods: an Action method to
make the request and a Boolean value method to indicate the request was granted. The lock method
is unused in this implementation.

interface ArbiterClient_IFC;
    method Action request();
    method Action lock();
    method Bool grant();

endinterface

ArbiterRequest IFC The ArbiterRequest_IFC interface has two methods: an Action method
to grant the request and a Boolean value method to indicate there is a request. The lock method is
unused in this implementation.

                        c 2008 Bluespec, Inc. All rights reserved  273


Reference Guide                                             Bluespec SystemVerilog

interface ArbiterRequest_IFC;
    method Bool request();
    method Bool lock();
    method Action grant();

endinterface

The ArbiterClient_IFC interface and the ArbiterRequest_IFC interface are connectable.

instance Connectable#(ArbiterClient_IFC, ArbiterRequest_IFC);

Arbiter IFC The Arbiter_IFC has a subinterface which is a vector of ArbiterClient_IFC in-
terfaces. The number of items in the vector equals the number of clients.

interface Arbiter_IFC#(type count);
    interface Vector#(count, ArbiterClient_IFC) clients;

endinterface

Modules
The mkArbiter module is a fair arbiter with changing priorities (round robin). The mkStickyArbiter
gives the current owner priority - they can hold priority as long as they keep requesting it. The
modules all provide a Arbiter_IFC interface.

mkArbiter        This module is a fair arbiter with changing priorities (round robin). If fixed is
                 True, the current client holds the priority, if fixed is False, it moves to the next
                 client. mkArbiter provides a Arbiter_IFC interface. Initial priority is given to
                 client 0.

                 module mkArbiter#(Bool fixed) (Arbiter_IFC#(count));

mkStickyArbiter  As long as the client currently with the grant continues to assert request, it can
                 hold the grant. It provides a Arbiter_IFC interface.

                 module mkStickyArbiter (Arbiter_IFC#(count));

C.7.4 GrayCounter

Description

The GrayCounter package provides an interface and a module to implement a gray-coded counter
with methods for both binary and Gray code. This package is designed for use in the BRAMFIFO
module, Section C.1.9. Since BRAMs have registered address inputs, the binary outputs are not
registered. The counter has two domains, source and destination. Binary and Gray code values are
written in the source domain. Both types of values can be read from the source and the destination
domains.

274              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.
Package Name
To include a package in your design, use the import syntax.

       import GrayCounter :: * ;

Types
The GrayCounter package uses the type Gray, deﬁned in the Gray package, Section C.7.5. The Gray
package is imported by the GrayCounter package.
Interfaces and Methods
The GrayCounter package includes one interface, GrayCounter.

                              GrayCounter Interface Methods

Name                    Type         Description
incr
decr                    Action       Increments the counter by 1
sWriteBin               Action       Decrements the counter by 1
                        Action       Writes a binary value into the counter in the source
sReadBin                             domain.
                        Bit#(n)      Returns a binary value from the source domain of
sWriteGray              Action       the counter. The output is not registered
                                     Writes a Gray code value into the counter in the
sReadGray               Gray#(n)     source domain.
                                     Returns the Gray code value from the source do-
dReadBin                Bit#(n)      main of the counter. The output is registered.
                                     Returns the binary value from the destination do-
dReadGray               Gray#(n)     main of the counter. The output is not registered.
                                     Returns the Gray code value from the destination
                                     domain of the counter. The output is registered.

interface GrayCounter#(numeric type n);

method Action                 incr;

method Action                 decr;

method Action                 sWriteBin(Bit#(n) value);

method Bit#(n) sReadBin;

method Action                 sWriteGray(Gray#(n) value);

method Gray#(n) sReadGray;

method Bit#(n) dReadBin;

method Gray#(n) dReadGray;

endinterface: GrayCounter

Modules

The module mkGrayCounter instantiates a Gray code counter with methods for both binary and
Gray code.

                        c 2008 Bluespec, Inc. All rights reserved                          275


Reference Guide                                                                Bluespec SystemVerilog
 mkGrayCounter
                 Instantiates a Gray counter with an initial value initval.
                 module mkGrayCounter#(Gray#(n) initval,

                                                   Clock dClk, Reset dRstN)
                                                  (GrayCounter#(n))
                               provisos(Add#(1, msb, n));

C.7.5 Gray

Description

The Gray package deﬁnes a datatype, Gray and functions for working with the Gray type. This type
is used by the GrayCounter package.

This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.

Package Name

To include a package in your design, use the import syntax.

import Gray :: * ;

Types and type classes

The datatype Gray is a representation for Gray code values. The basic representation is the Gray
structure, which is polymorphic on the size of the value.

typedef struct {
                         Bit#(n) code;

                       } Gray#(numeric type n) deriving (Bits, Eq);

Functions

grayEncode       This function takes a binary value of type Bit#(n) and returns a Gray
                 type with the Gray code value.

                 function Gray#(n) grayEncode(Bit#(n) value)
                                provisos(Add#(1, msb, n));

 grayDecode      This function takes a Gray code value of size n and returns the binary
276              value.
                 function Bit#(n) grayDecode(Gray#(n) value)

                                provisos(Add#(1, msb, n));

                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

grayIncrDecr            This functions takes a Gray code value and a Boolean, decrement. If
                        decrement is True, the value returned is one less than the input value.
                        If decrement is False, the value returned is one greater.

                        function Gray#(n) grayIncrDecr(Bool decrement,
                                                                         Gray#(n) value)

                                       provisos(Add#(1, msb, n));

grayIncr                Takes a Gray code value and returns a Gray code value incremented
                        by 1.

                        function Gray#(n) grayIncr(Gray#(n) value)
                                       provisos(Add#(1, msb, n));

grayDecr                Takes a Gray code value a returns a Gray code value decremented by
                        1.

                        function Gray#(n) grayDecr(Gray#(n) value)
                                       provisos(Add#(1, msb, n));

C.7.6 CompletionBuﬀer

Package

import CompletionBuﬀer :: * ;

Description

A CompletionBuffer is like a FIFO except that the order of the elements in the buﬀer is independent
of the order in which the elements are entered. Each element obtains a token, which reserves a slot
in the buﬀer. Once the element is ready to be entered into the buﬀer, the token is used to place the
element in the correct position. When removing elements from the buﬀer, the elements are delivered
in the order speciﬁed by the tokens, not in the order that the elements were written.

Completion Buﬀers are useful when multiple tasks are running, which may complete at diﬀerent
times, in any order. By using a completion buﬀer, the order in which the elements are placed in the
buﬀer can be controlled, independent of the order in which the data becomes available.

Interface and Methods

The CompletionBuﬀer interface provides three subinterfaces. The reserve interface, a Get, allows
the caller to reserve a slot in the buﬀer by returning a token holding the identity of the slot. When
data is ready to be placed in the buﬀer, it is added to the buﬀer using the complete interface of type
Put. This interface takes a pair of values as its argument - the token identifying its slot, and the
data itself. Finally, using the drain interface, of type Get, data may be retrieved from the buﬀer in
the order in which the tokens were originally allocated. Thus the results of quick tasks might have
to wait in the buﬀer while a lengthy task ahead of them completes.

The type of the elements to be stored is element_type. The type of the required size of the buﬀer
is a numeric type n, which is also the type argument for the type for the tokens issued, CBToken.
This allows the type-checking phase of the synthesis to ensure that the tokens are the appropriate
size for the buﬀer, and that all the buﬀer’s internal registers are of the correct sizes as well.

                        c 2008 Bluespec, Inc. All rights reserved  277


Reference Guide                                                   Bluespec SystemVerilog

Name   Type                   CompletionBuffer Interface
                 Description

reserve Get      Used to reserve a slot in the buﬀer. Returns a token, CBToken #(n),
                 identifying the slot in the buﬀer.
complete Put
                 Enters the element into the buﬀer. Takes as arguments the slot in the
drain  Get       buﬀer, CBToken#(n), and the element to be stored in the buﬀer.

                 Removes an element from the buﬀer. The elements are returned in the
                 order the tokens were allocated.

interface CompletionBuffer #(numeric type n, type element_type);

     interface Get#(CBToken#(n))                          reserve;

     interface Put#(Tuple2 #(CBToken#(n), element_type)) complete;

     interface Get#(element_type)                         drain;

endinterface: CompletionBuffer

Datatypes
The CBToken type is abstract to avoid misuse.
typedef union tagged { ... } CBToken #(numeric type n) ...;

Modules
The mkCompletionBuffer module is used to instantiate a completion buﬀer. It takes no size argu-
ments, as all that information is already contained in the type of the interface it produces.

mkCompletionBuffer Creates a completion buﬀer.

                               module mkCompletionBuffer(CompletionBuffer#(n, element_type))
                                  provisos (Bits#(element_type, sizea))

Example- Using a Completion Buﬀer in a server farm of multipliers

A server farm is a set of identical servers, which can each perform the same task, together with
a controller. The controller allocates incoming tasks to any server which happens to be available
(free), and sends results back to its caller.

The time needed to complete each task depends on the value of the multiplier argument; there is
therefore no guarantee that results will become available in the order the tasks were started. It is
required, however, that the controller return results to its caller in the order the tasks were received.
The controller accordingly must instantiate a special mechanism for this purpose. The appropriate
mechanism is a Completion Buﬀer.

import List::*;
import FIFO::*;
import GetPut::*;
import CompletionBuffer::*;

typedef Bit#(16) Tin;
typedef Bit#(32) Tout;

278              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

// Multiplier interface
interface Mult_IFC;

      method Action start (Tin m1, Tin m2);
      method ActionValue#(Tout) result();
endinterface

typedef Tuple2#(Tin,Tin) Args;
typedef 8 BuffSize;
typedef CBToken#(BuffSize) Token;

// This is a farm of multipliers, mkM. The module
// definition for the multipliers mkM is not provided here.
// The interface definition, Mult_IFC, is provided.
module mkFarm#( module#(Mult_IFC) mkM ) ( Mult_IFC );

    // make the buffer twice the size of the farm
    Integer n = div(valueof(BuffSize),2);

    // Declare the array of servers and instantiate them:
    Mult_IFC mults[n];
    for (Integer i=0; i&lt;n; i=i+1)

         begin
              Mult_IFC s &lt;- mkM;
              mults[i] = s;

         end

    FIFO#(Args) infifo &lt;- mkFIFO;

    // instantiate the Completion Buffer, cbuff, storing values of type Tout
    // buffer size is Buffsize, data type of values is Tout
    CompletionBuffer#(BuffSize,Tout) cbuff &lt;- mkCompletionBuffer;

    // an array of flags telling which servers are available:
    Reg#(Bool) free[n];
    // an array of tokens for the jobs in progress on the servers:
    Reg#(Token) tokens[n];
    // this loop instantiates n free registers and n token registers
    // as well as the rules to move data into and out of the server farm
    for (Integer i=0; i&lt;n; i=i+1)

         begin
              // Instantiate the elements of the two arrays:
              Reg#(Bool) f &lt;- mkReg(True);
              free[i] = f;
              Reg#(Token) t &lt;- mkRegU;
              tokens[i] = t;

              Mult_IFC s = mults[i];

              // The rules for sending tasks to this particular server, and for
              // dealing with returned results:
              rule start_server (f); // start only if flag says it’s free

                   // Get a token
                   CBToken#(BuffSize) new_t &lt;- cbuff.reserve.get;

                        c 2008 Bluespec, Inc. All rights reserved                279


Reference Guide                                             Bluespec SystemVerilog

                   Args a = infifo.first;
                   Tin a1 = tpl_1(a);
                   Tin a2 = tpl_2(a);
                   infifo.deq;

                   f &lt;= False;
                   t &lt;= new_t;
                   s.start(a1,a2);
              endrule

              rule end_server (!f);
                   Tout x &lt;- s.result;
                   // Put the result x into the buffer, at the slot t
                   cbuff.complete.put(tuple2(t,x));
                   f &lt;= True;

              endrule
         end

    method Action start (m1, m2);
         infifo.enq(tuple2(m1,m2));

    endmethod

    // Remove the element from the buffer, returning the result
    // The elements will be returned in the order that the tokens were obtained.
    method result = cbuff.drain.get;
endmodule

C.7.7 UniqueWrappers

Package

import UniqueWrappers :: * ;

Description

The UniqueWrappers package takes a piece of combinational logic which is to be shared and puts it
into its own protective shell or wrapper to prevent its duplication. This is used in instances where a
separately synthesized module is not possible. It allows the designer to use a piece of logic at several
places in a design without duplicating it at each site.

There are times where it is desired to use a piece of logic at several places in a design, but it is too
bulky or otherwise expensive to duplicate at each site. Often the right thing to do is to make the
piece of logic into a separately synthesized module – then, if this module is instantiated only once,
it will not be duplicated, and the tool will automatically generate the scheduling and multiplexing
logic to share it among the sites which use its methods. Sometimes, however, this is not convenient.
One reason might be that the logic is to be incorporated into a sub-module of the design which is
itself polymorphic – this will probably cause diﬃculties in observing the constraints necessary for a
module which is to be separately synthesized. And if a module is not separately synthesized, the
tool will inline its logic freely wherever it is used, and thus duplication will not be prevented as
desired.

This package covers the case where the logic to be shared is combinational and cannot be put
into a separately synthesized module. It may be thought of as surrounding this combinational
function with a protective shell, a unique wrapper, which will prevent its duplication. The module
mkUniqueWrapper takes a one-argument function as a parameter; both the argument type a and the
result type b must be representable as bits, that is, they must both be in the Bits typeclass.

280              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Interfaces

The UniqueWrappers package provides an interface, Wrapper, with one actionvalue method, func,
which takes an argument of type a and produces a method of type ActionValue#(b). If the module
is instantiated only once, the logic implementing its parameter will be instantiated just once; the
module’s method may, however, be used freely at several places.

Although the function supplied as the parameter is purely combinational and does not change state,
the method is of type ActionValue. This is because actionvalue methods have enable signals and
these signals are needed to organize the scheduling and multiplexing between the calling sites.

Variants of the interface Wrapper are also provided for handling functions of two or three arguments;
the interfaces have one and two extra parameters respectively. In each case the result type is the
ﬁnal parameter, following however many argument type parameters are required.

                                                    Wrapper Interfaces

Wrapper  This interface has one actionvalue method, func, which takes an argument of type
         a_type and produces an actionvalue of type ActionValue#(b_type).

         interface Wrapper#(type a_type, type b_type);
            method ActionValue#(b_type) func (a_type x);

Wrapper2 Similar to the Wrapper interface, but it takes two arguments.

                interface Wrapper2#(type a1_type, type a2_type, type b_type);
                   method ActionValue#(b_type) func (a1_type x, a2_type y);

 Wrapper3 Similar to the Wrapper interface, but it takes three arguments.
                  interface Wrapper3#(type a1_type, type a2_type, type a3_type,
                                                  type b_type);
                     method ActionValue#(b_type) func (a1_type x, a2_type y, a3_type z);

Modules

The interfaces Wrapper, Wrapper2, and Wrapper3 are provided by the modules mkUniqueWrapper,
mkUniqueWrapper2, and mkUniqueWrapper3. These modules vary only in the number of aguments
in the parameter function.

If a function has more than three arguments, it can always be rewritten or wrapped as one which
takes the arguments as a single tuple; thus the one-argument version mkUniqueWrapper can be used
with this function.

 mkUniqueWrapper

                Takes a function, func, with a single parameter x and provides the interface Wrapper.
                module mkUniqueWrapper#(function b_type func(a_type x))

                                                    (Wrapper#(a_type, b_type))
                     provisos (Bits#(a_type, sizea), Bits#(b_type, sizeb));

                        c 2008 Bluespec, Inc. All rights reserved              281


Reference Guide                                                   Bluespec SystemVerilog

mkUniqueWrapper2

              Takes a function, func, with a two parameters, x and y, and provides the interface
              Wrapper2.

              module mkUniqueWrapper2#(function b_type func(a1_type x, a2_type y))
                                                    (Wrapper2#(a1_type, a2_type, b_type))

                   provisos (Bits#(a1_type, sizea1), Bits#(a2_type, sizea2),
                                   Bits#(b_type, sizeb));

mkUniqueWrapper3

              Takes a function, func, with a three parameters, x, y, and z, and provides the interface
              Wrapper3.

              module mkUniqueWrapper3#(function b_type
                                                         func(a1_type x, a2_type y, a3_type z))

                                                    (Wrapper3#(a1_type, a2_type, a3_type, b_type))
                   provisos (Bits#(a1_type, sizea1), Bits#(a2_type, sizea2),

                                   Bits#(a3_type, sizea3), Bits#(b_type, sizeb));

Example: Complex Multiplication

// This module defines a single hardware multiplier, which is then
// used by multiple method calls to implement complex number
// multiplication (a + bi)(c + di)

typedef Int#(18) CFP;

module mkComplexMult1Fifo( ArithOpGP2#(CFP) ) ;
   FIFO#(ComplexP#(CFP)) infifo1 &lt;- mkFIFO;
   FIFO#(ComplexP#(CFP)) infifo2 &lt;- mkFIFO;
   let arg1 = infifo1.first ;
   let arg2 = infifo2.first ;

FIFO#(ComplexP#(CFP)) outfifo &lt;- mkFIFO;

Reg#(CFP)  rr &lt;- mkReg(0) ;
Reg#(CFP)  ii &lt;- mkReg(0) ;
Reg#(CFP)  ri &lt;- mkReg(0) ;
Reg#(CFP)  ir &lt;- mkReg(0) ;

// Declare and instantiate an interface that takes 2 arguments, multiplies them
// and returns the result. It is a Wrapper2 because there are 2 arguments.
Wrapper2#(CFP,CFP, CFP) smult &lt;- mkUniqueWrapper2( \* ) ;

// Define a sequence of actions
// Since smult is a UnqiueWrapper the method called is smult.func
Stmt multSeq =
seq

    action
         let mr &lt;- smult.func( arg1.rel, arg2.rel ) ;

282                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                              Reference Guide

            rr &lt;= mr ;
       endaction
       action

            let mr &lt;- smult.func( arg1.img, arg2.img ) ;
            ii &lt;= mr ;
       endaction
       action
            // Do the first add in this step
            let mr &lt;- smult.func( arg1.img, arg2.rel ) ;
            ir &lt;= mr ;
            rr &lt;= rr - ii ;
       endaction
       action
            let mr &lt;- smult.func( arg1.rel, arg2.img );
            ri &lt;= mr ;
            // We are done with the inputs so deq the in fifos
            infifo1.deq ;
            infifo2.deq ;
       endaction
       action
            let ii2 = ri + ir ;
            let res = Complex{ rel: rr , img: ii2 } ;
            outfifo.enq( res ) ;
       endaction
   endseq;

   // Now convert the sequence into a FSM ;
   // Bluespec can assign the state variables, and pick up implict
   // conditions of the actions
   FSM multfsm &lt;- mkAutoFSM;
   rule startFSM;

       multfsm.start;
   endrule
endmodule

C.7.8 FShow

Package

import FShow :: * ;

Description

The FShow package deﬁnes the typeclass FShow. FShow includes a single member function, fshow.
When applied to an object which is an instance of FShow, the fshow function returns an object of
type Fmt (Section B.2.8).

This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.

Typeclasses

FShow deﬁnes the class of types to which the function fshow can be applied to create an associated
Fmt representation.

                        c 2008 Bluespec, Inc. All rights reserved   283


Reference Guide                                               Bluespec SystemVerilog

typeclass FShow#(type t);
    function Fmt fshow(t value);

endtypeclass

The package deﬁnes instances of FShow for many commonly used datatypes. Users can create their
own FShow instances for other types (or redeﬁne the instances included in the FShow package).

String                                   FShow Instances
                 Returns a Fmt object showing the value of the string.

                 instance FShow#(String);

Bool             Returns a Fmt object showing True or False.
                 instance FShow#(Bool);

Maybe#(a)        Returns a Fmt object showing Valid and the value, or just Invalid.

                 instance FShow#(Maybe#(a))
                     provisos(FShow#(a));

Int#(n)          Returns a Fmt object showing n in a decimal format.
                 instance FShow#(Int#(n));

Bit#(n)          Returns a Fmt object showing n in a hexadecimal format.
                 instance FShow#(Bit#(n));

FIFOF_#(a)       Returns a Fmt object showing the ﬁrst element and Empty/Full state of the
FIFOF#(a)        FIFO.

                 instance FShow#(FIFOF_#(a))
                     provisos(FShow#(a));

Vector#(n, a)    Returns a Fmt object showing &lt;V elem1 elem2 ...&gt;, where the elemn are
                 the elements of the vector.

                 instance FShow#(Vector#(n, a))
                     provisos(FShow#(a));

List#(a)         Returns a Fmt object showing &lt;List elem1 elem2 ...&gt;, where the elemn
                 are the elements of the list.

                 instance FShow#(List#(a))
                     provisos(FShow#(a));

284              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

FixedPoint#(i,f) Returns a Fmt object showing FP int.frac where int is the integer part
                           and frac is the fractional part of the ﬁxed point number.

                           instance FShow#(FixedPoint#(i,f))
                                provisos(Add#(i,f, TAdd#(i,f)),Add#(1,ignore, i));

Tuple2#(a,b)    Returns a Fmt object showing Tuple2(a, b).

                instance FShow#(Tuple2#(a, b))
                    provisos(FShow#(a), FShow#(b));
                    function Fmt fshow (Tuple2#(a, b) value);
                         return $format(&quot;Tuple2(&quot;, fshow(tpl_1(value)), &quot;,&quot;,
                                                                  fshow(tpl_2(value)),&quot;)&quot;);

Tuple3#(a,b,c)  Returns a Fmt object showing Tuple3(a, b, c).

                instance FShow#(Tuple3#(a, b, c))
                    provisos(FShow#(a), FShow#(b), FShow#(c));
                    function Fmt fshow (Tuple3#(a, b, c) value);
                         return $format(&quot;Tuple3(&quot;, fshow(tpl_1(value)), &quot;,&quot;,
                                                                  fshow(tpl_2(value)),&quot;,&quot;,
                                                                  fshow(tpl_3(value)),&quot;)&quot;);

Functions       Returns a Fmt representation when applied to a value
  fshow             function Fmt fshow(t value);

concatWith      Concantenates a String (x) with two other arguments a and b, both of
                type Fmt.

                function Fmt concatWith(String x, Fmt a, Fmt b);
                    return (a + $format(x) + b);

Modules         This module is used like a Probe except that the sampled value (to be
  dbgProbe      viewed in waves) is the ascii representation of fshow(value).

                module dbgProbe (Probe#(a))
                    provisos(FShow#(a));

Example

package FShowExample;
import Probe::*;

                        c 2008 Bluespec, Inc. All rights reserved                            285


Reference Guide                                               Bluespec SystemVerilog

import FShow::*;
import Vector::*;

/// Define some types ....

typedef Vector#(3,Bool) VOB;
typedef Tuple2#(Bit#(2), Bit#(2)) TUP;

typedef enum {READ, WRITE, UNKNOWN} OpCommand deriving(Bounded, Bits, Eq);

typedef struct {OpCommand command;

Bit#(8) addr;

Bit#(8) data;

Bit#(8) length;

Bool  lock;

} Header deriving (Eq, Bits, Bounded);

typedef union tagged {Header Descriptor;
         Bit#(8) Data;
         } Request deriving(Eq, Bits, Bounded);

/// Define FShow instances for the ones that aren’t already in FShow.bsv

instance FShow#(OpCommand);
    function Fmt fshow (OpCommand label);
         case (label)

 READ: return fshow(&quot;READ &quot;);
 WRITE: return fshow(&quot;WRITE&quot;);
 UNKNOWN: return fshow(&quot;UNKNOWN&quot;);

         endcase
    endfunction
endinstance

instance FShow#(Header);
    function Fmt fshow (Header value);
         return ($format(&quot;&lt;HEAD &quot;)
         +
         fshow(value.command)
         +
         $format(&quot; (%0d)&quot;, value.length)
         +
         $format(&quot; A:%h&quot;, value.addr)
         +
         $format(&quot; D:%h&gt;&quot;, value.data));
    endfunction

endinstance

instance FShow#(Request);
    function Fmt fshow (Request request);
         case (request) matches

 tagged Descriptor .a:
      return fshow(a);

 tagged Data .a:
      return $format(&quot;&lt;DATA %h&gt;&quot;, a);

286                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

         endcase
    endfunction
endinstance

(* synthesize *)
module mkFShowExample (Empty);

Reg#(Bit#(32)) value &lt;- mkReg(1234);
Reg#(Bit#(16)) count &lt;- mkReg(0);

// Probes to send &quot;fshow&quot; strings to waves
Probe#(VOB) vob_probe &lt;- dbgProbe;
Probe#(TUP) tup_probe &lt;- dbgProbe;
Probe#(Request) req_probe &lt;- dbgProbe;

rule every;

// generate some values

VOB v_of_bools = unpack(truncate(count));

TUP a_tuple             = unpack(truncate(count));

Request request = unpack(truncate(value));

// send signals to waves.
vob_probe &lt;= v_of_bools;
tup_probe &lt;= a_tuple;
req_probe &lt;= request;

// show use with $display
$display(&quot; A Vector: &quot;, fshow(v_of_bools));
$display(&quot; A Tuple: &quot;, fshow(a_tuple));
$display(&quot; A Request: &quot;, fshow(request));
$display(&quot;----------------------------------&quot;);

    // update values
    value &lt;= (value &lt;&lt; 1) | {0, (value[31] ^ value[21] ^ value[1] ^ value[01])};
    count &lt;= count + 1;
    if (count == 30) $finish;
endrule

endmodule

C.7.9 Assert

Package
import Assert :: *;
Description
The Assert package contains deﬁnitions to test assertions in the code.
Functions

                        c 2008 Bluespec, Inc. All rights reserved       287


Reference Guide                                                 Bluespec SystemVerilog

staticAssert         Compile time assertion. Can be used anywhere a compile-time statement
                     is valid.

                     module staticAssert(Bool b, String s);

dynamicAssert        Run time assertion. Can be used anywhere an Action is valid, and is
                     tested whenever it is executed.

                     function Action dynamicAssert(Bool b, String s);

 continuousAssert Continuous run-time assertion (expected to be True on each clock). Can
                               be used anywhere a module instantiation is valid.

                               function Action continuousAssert(Bool b, String s);

Examples using Assertions:

import Assert:: *;
module mkAssert_Example ();

   // A static assert is checked at compile-time
   // This code checks that the indices are within range
   for (Integer i=0; i&lt;length(cs); i=i+1)

         begin
            Integer new_index = (cs[i]).index;
            staticAssert(new_index &lt; valueOf(n),
                   strConcat(&quot;Assertion index out of range: &quot;, integerToString(new_index)));

         end

   rule always_fire (True);
           counter &lt;= counter + 1;

   endrule
   // A continuous assert is checked on each clock cycle
   continuousAssert (!fail, &quot;Failure: Fail becomes True&quot;);

   // A dynamic assert is checked each time the rule is executed
   rule test_assertion (True);

       dynamicAssert (!fail, &quot;Failure: Fail becomes True&quot;);
   endrule
endmodule: mkAssert_Example

C.7.10 Probe         c 2008 Bluespec, Inc. All rights reserved
Package
import Probe :: * ;
Description

288


Bluespec SystemVerilog                                             Reference Guide

A Probe is a primitive used to ensure that a signal of interest is not optimized away by the compiler
and that it is given a known name. In terms of BSV syntax, the Probe primitive it used just like
a register except that only a write method exists. Since reads are not possible, the use of a Probe
has no eﬀect on scheduling. In the generated Verilog, the associated signal will be named just like
the port of any Verilog module, in this case &lt;instance_name&gt;$PROBE. No actual Probe instance will
be created however. The only side eﬀects of a BSV Probe instantiation relate to the naming and
retention of the associated signal in the generated Verilog.

Interfaces

interface Probe #(type a_type);
      method Action _write(a_type x1);

endinterface: Probe

Modules
The module mkProbe is used to instantiate a Probe.

mkProbe                 Instantiates a Probe

                        module mkProbe(Probe#(a_type))
                           provisos (Bits#(a_type, sizea));

Example - Creating and writing to registers and probes

import FIFO::*;
import ClientServer::*;
import GetPut::*;
import Probe::*;

typedef Bit#(32) LuRequest;
typedef Bit#(32) LuResponse;

module mkMesaHwLpm(ILpm);
    // Create registers for requestB32 and responseB32
    Reg#(LuRequest) requestB32 &lt;- mkRegU();
    Reg#(LuResponse) responseB32 &lt;- mkRegU();

// Create a probe responseB32_probe

Probe#(LuResponse) responseB32_probe &lt;- mkProbe();

....

// Define the interfaces:

....

interface Get response;

      method get() ;

      actionvalue

         let resp &lt;- completionBuffer.drain.get();

         // record response for debugging purposes:

         let {r,t} = resp;

         responseB32 &lt;= r;           // a write to a register

         responseB32_probe &lt;= r; // a write to a probe

          // count responses in status register
          return(resp);
      endactionvalue

                        c 2008 Bluespec, Inc. All rights reserved  289


Reference Guide                                                       Bluespec SystemVerilog

              endmethod: get
         endinterface: response
      .....
endmodule

C.7.11 Reserved

Package
import Reserved :: * ;
Description
Reserved deﬁnes an abstract data type which only has the purpose of taking up space. It is useful
when deﬁning a struct where you need to enforce a certain layout and want to use the type checker
to enfoce that the value is not accidently used. One can enforce a layout unsafely with Bit#(n),
but Reserved#(n) gives safety. A value of type Reserved#(n) takes up exactly n bits.

    typedef · · · abstract · · · Reserved#(type n);
Type classes

                                 Type Classes used by Reserved

           Bits Eq Literal Arith Ord Bounded Bit                      Bit  Bit

                       √√                   √  √                wise Reduction Extend
     Reserved

     • Bits
        Converting Reserved to or from bits yields a don’t care (?).
        The only purpose is to allow the value to exist in hardware (at port boundaries and in states).
        The user should have no reason to use pack/unpack directly.

     • Eq and Ord
        Any two Reserved values are considered to be equal.

     • Bounded
        The upper and lower bound return don’t care (?) values.

Example: Structure with a 8 bits reserved.

typedef struct {           header;   // Frame.header
    Bit#(8)                payload;  // Frame.payload
    Vector#(2, Bit#(8))    dummy;    // Can’t access 8 bits reserved
    Reserved#(8)           trailer;  // Frame.trailer
    Bit#(8)

} Frame;

header payload0 payload1 dummy trailer

     8  8  8                     8   8

290                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                             Figure 4: TriState Buﬀer

C.7.12 TriState

Package

import TriState :: * ;

Description

The TriState package implements a tri-state buﬀer, as shown in Figure 4. Depending on the value
of the output_enable, inout can be an input or an output.

The buﬀer has two inputs, an input of type value_type and a Boolean output_enable which
determines the direction of inout. If output_enable is True, the signal is coming in from input
and out through inout and output. If output_enable is False, then a value can be driven in from
inout, and the output value will be the value of inout. The behavior is described in the tables
below.

                             output enable = 0

                                output = inout

                                Inputs

                             input inout output

                             0          0       0

                             0          1       1

                             1          0       0

                             1          1       1

                             output enable = 1

                                output = in

                                inout = in

                                           Outputs

                             input inout output

                             0          0       0

                             1          1       1

This module is not supported in Bluesim.

Interfaces and Methods

The TriState interface is composed of an InOut interface and a _read method. The _read method
is similar to the _read method of a register in that to read the method you reference the interface
in an expression.

                             TriState Interface

Name             Type           Description
inout
                 InOut#(value_type) Inout subinterface providing a value of type
_read
                 value_type     value_type
                                Returns the value of output

                        c 2008 Bluespec, Inc. All rights reserved  291


Reference Guide                                                    Bluespec SystemVerilog

(* always_ready, always_enabled *)

interface TriState#(type value_type);

     interface Inout#(value_type) inout;

     method value_type  _read;

endinterface: TriState

Modules and Functions

The TriState package provides a module constructor function, mkTriState, which provides the
TriState interface. The interface includes an InOut subinterface and the value of output.

mkTriState       Creates a module which provides the TriState interface.

                 module mkTriState#(Bool output_enable, value_type input)
                                             (TriState#(value_type))

                     provisos(Bits#(value_type, size_value));

Verilog Modules

The TriState module is implemented by the Verilog module TriState.v which can be found in the
Bluespec Verilog library, $BLUESPECDIR/Verilog/.

C.7.13 ZBus

Package

import ZBus :: * ;

Description

BSV provides the ZBus library to allow users to implement and use tri-state buses. Since BSV does
not support high-impedance or undeﬁned values internally, the library encapsulates the tri-state bus
implementation in a module that can only be accessed through predeﬁned interfaces which do not
allow direct access to internal signals (which could potentially have high-impedance or undeﬁned
values).

The Verilog implementation of the tri-state module includes a number of primitive sub-modules
that are implemented using Verilog tri-state wires. The BSV representation of the bus, however,
only models the values of the bus at the associated interfaces and thus the need to represent high-
impedance or undeﬁned values in BSV is avoided.

A ZBus consists of a series of clients hanging oﬀ of a bus. The combination of the client and the
bus is provided by the ZBusDualIFC interface which consists of 2 subinterfaces, the client and the
bus. The client subinterface is provided by the ZBusClientIFC interface. The bus subinterface is
provided by the ZBusBusIFC interface. The user never needs to manipulate the bus side, this is all
done internally. The user builds the bus out of ZBusDualIFCs and then drives values onto the bus
and reads values from the bus using the ZBusClientIFC.

Interfaces and Methods

There are three interfaces are deﬁned in this package; ZBusDualIFC, ZBusClientIFC, and ZBusBusIFC.

The ZBusDualIFC interface provides two subinterfaces; a ZBusBusIFC and a ZBusClientIFC. For a
given bus, one ZBusDualIFC interface is associated with each bus client.

292                     c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                                     ZBusDualIFC

Name           Type                      Description
busIFC
               ZBusBusIFC#()             The subinterface providing the bus side of the
clientIFC      ZBusClientIFC#(t)         ZBus.
                                         The subinterface providing the client side to the
                                         ZBus.

interface ZBusDualIFC #(type value_type) ;
    interface ZBusBusIFC#(value_type) busIFC;
    interface ZBusClientIFC#(value_type) clientIFC;

endinterface

The ZBusClientIFC allows a BSV module to connect to the tri-state bus. The drive method is
used to drive a value onto the bus. The get() and fromBusValid() methods allow each bus client
to access the current value on the bus. If the bus is in an invalid state (i.e. has a high-impedance
value or an undeﬁned value because it is being driven by more than one client simultaneously), then
the get() method will return 0 and the fromBusValid() method will return False. In all other
cases, the fromBusValid() method will return True and the get() method will return the current
value of the bus.

                                     ZBusClientIFC

                        Method                                        Argument
                                                                           Description
Name           Type        Description                Name
drive                                                 value        The value being put on
               Action      Drives a current value on               the bus, datatype of
get                                                                value_type.
fromBusValid               to the bus

               value_type  Returns the current
               Bool        value on the bus.
                           Returns False if the bus
                           has a high-impedance
                           value or is undeﬁned.

interface ZBusClientIFC #(type value_type) ;

method Action           drive(value_type value);

method value_type get();

method Bool             fromBusValid();

endinterface

The ZBusBusIFC interface connects to the bus structure itself using tri-state values. This interface
is never accessed directly by the user.

interface ZBusBusIFC #(type value_type) ;

method Action           fromBusSample(ZBit#(value_type) value, Bool isValid);

method ZBit#(t) toBusValue();

method Bool             toBusCtl();

endinterface

Modules and Functions

The library provides a module constructor function, mkZBusBuffer, which allows the user to create
a module which provides the ZBusDualIFC interface. This module provides the functionality of a
tri-state buﬀer.

                        c 2008 Bluespec, Inc. All rights reserved              293


Reference Guide                                                         Bluespec SystemVerilog

mkZBusBuffer     Creates a module which provides the ZBusDualIFC interface.

                 module mkZBusBuffer (ZBusDualIFC #(value_type))
                     provisos (Eq#(value_type), Bits#(value_type, size_value));

The mkZBus module constructor function takes a list of ZBusBusIFC interfaces as arguments and
creates a module which ties them all together in a bus.

mkZBus           Ties a list of ZBusBusIFC interfaces together in a bus.

                 module mkZBus#(List#(ZBusBusIFC#(value_type)) ifc_list)(Empty)
                     provisos (Eq#(value_type), Bits#(value_type, size_value));

Examples - ZBus
Creating a tri-state buﬀer for a 32 bit signal. The interface is named buffer_0.

    ZBusDualIFC#(Bit#(32)) buffer_0();
    mkZBusBuffer inst_buffer_0(buffer_0);

Drive a value of 12 onto the associated bus.
    buffer_0.clientIFC.drive(12);

The following code fragment demonstrates the use of the module mkZBus.
    ZBusDualIFC#(Bit#(32)) buffer_0();
    mkZBusBuffer inst_buffer_0(buffer_0);

    ZBusDualIFC#(Bit#(32)) buffer_1();
    mkZBusBuffer inst_buffer_1(buffer_1);

    ZBusDualIFC#(Bit#(32)) buffer_2();
    mkZBusBuffer inst_buffer_2(buffer_2);

    List#(ZBusIFC#(Bit#(32))) ifc_list;

    bus_ifc_list = cons(buffer_0.busIFC,
                                      cons(buffer_1.busIFC,
                                              cons(buffer_2.busIFC,
                                                             nil)));

    Empty bus_ifc();
    mkZBus#(bus_ifc_list) inst_bus(bus_ifc);

C.7.14 OVLAssertions

Package
import OVLAssertions :: * ;
Description

294                          c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

The OVLAssertions package provides the BSV interfaces and wrapper modules necessary to al-
low BSV designs to include assertion checkers from the Open Veriﬁcation Library (OVL). The
OVL includes a set of assertion checkers that verify speciﬁc properties of a design. For more
details on the complete OVL, refer to the Accellera Standard OVL Library Reference Manual
(http://www.accellera.org).

Interfaces and Methods

The following interfaces are deﬁned for use with the assertion modules. Each interface has one or
more Action methods. Each method takes a single argument which is either a Bool or polymorphic.

AssertTest IFC Used for assertions that check a test expression on every clock cycle.

       Method                       AssertTest_IFC
                                                        Argument

Name   Type             Name        Type        Description
                        test_value
test   Action                       a_type      Expression to be checked.

interface AssertTest_IFC #(type a_type);
    method Action test(a_type test_value);

endinterface

AssertSampleTest IFC Used for assertions that check a test expression on every clock cycle only
if the sample, indicated by the boolean value sample_test is asserted.

                              AssertSampleTest_IFC

       Method                                   Argument

Name   Type             Name        Type        Description

sample Action           sample_test Bool        Assertion only checked if sample_test is
                                                asserted.

test   Action           test_value a_type       Expression to be checked.

interface AssertSampleTest_IFC #(type a_type);
    method Action sample(Bool sample_test);
    method Action test(a_type test_value);

endinterface

AssertStartTest IFC Used for assertions that check a test expression only subsequent to a
start event, speciﬁed by the Boolean value start_test.

                                    AssertStartTest_IFC

       Method                                   Argument

Name   Type             Name        Type        Description

start  Action           start_test Bool         Assertion only checked after start is as-
                                                serted.

test   Action           test_value a_type       Expression to be checked.

interface AssertStartTest_IFC #(type a_type);
    method Action start(Bool start_test);
    method Action test(a_type test_value);

endinterface

                        c 2008 Bluespec, Inc. All rights reserved                      295


Reference Guide                                              Bluespec SystemVerilog

AssertStartStopTest IFC Used to check a test expression between a start event and a stop event.

                       AssertStartStopTest_IFC

       Method                        Argument

Name   Type      Name  Type          Description

start  Action    start_test Bool     Assertion only checked after start is as-
                                     serted.

stop   Action    stop_test Bool      Assertion only checked until the stop is
                 test_value a_type   asserted.
test   Action                        Expression to be checked.

interface AssertStartStopTest_IFC #(type a_type);
    method Action start(Bool start_test);
    method Action stop(Bool stop_test);
    method Action test(a_type test_value);

endinterface

AssertTransitionTest IFC Used to check a test expression that has a speciﬁed start state and
next state, i.e. a transition.

       Method          AssertTransitionTest_IFC
                                                   Argument

Name   Type      Name  Type          Description

test   Action    test_value a_type   Expression that should transition to the
                 start_test a_type   next_value.
start  Action                        Expression that indicates the start state
                 next_value a_type   for the assertion check. If the value
next   Action                        of start_test equals the value of
                                     test_value, the check is performed.
                                     Expression that indicates the only valid
                                     next state for the assertion check.

interface AssertTransitionTest_IFC #(type a_type);
    method Action test(a_type test_value);
    method Action start(a_type start_value);
    method Action next(a_type next_value);

endinterface

AssertQuiescentTest IFC Used to check that a test expression is equivalent to the speciﬁed
expression when the sample state is asserted.

                       AssertQuiescentTest_IFC

       Method                        Argument

Name   Type      Name  Type          Description

sample Action    sampe_test Bool     Expression which initiates the quiescent
                                     assertion check when it transistions to
                                     true.

state  Action    state_value a_type  Expression that should have the same
check  Action                        value as check_value

                 check_value a_type  Expression state_value is compared to.

296              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                        Reference Guide

interface AssertQuiescentTest_IFC #(type a_type);
    method Action sample(Bool sample_test);
    method Action state(a_type state_value);
    method Action check(a_type check_value);

endinterface

AssertFifoTest IFC Used with assertions checking a FIFO structure.

      Method           AssertFifoTest_IFC
                                              Argument

Name  Type       Name  Type         Description

push  Action     push_value a_type  Expression which indicates the number of
                 pop_value a_type   push operations that will occur during the
pop   Action                        current cycle.
                                    Expression which indicates the number of
                                    pop operations that will occur during the
                                    current cycle.

interface AssertFifoTest_IFC #(type a_type, type b_type);
    method Action push(a_type push_value);
    method Action pop(b_type pop_value);

endinterface

Datatypes

The parameters severity_level, property_type, msg, and coverage_level are common to all
assertion checkers.

      Parameter  Common Parameters for all Assertion Checkers
                                            Valid Values
                                            * indicates default value

      severity_level         OVL_FATAL
                             *OVL_ERROR
      property_type          OVL_WARNING
      msg                    OVL_Info
      coverage_level         *OVL_ASSERT
                             OVL_ASSUME
                             OVL_IGNORE
                             *VIOLATION
                             OVL_COVER_NONE
                             *OVL_COVER_ALL
                             OVL_COVER_SANITY
                             OVL_COVER_BASIC
                             OVL_COVER_CORNER
                             OVL_COVER_STATISTIC

Each assertion checker may also use some subset of the following parameters.

                      c 2008 Bluespec, Inc. All rights reserved               297


Reference Guide                                                 Bluespec SystemVerilog

     Parameter   Other Parameters for Assertion Checkers
                                        Valid Values

     action_on_new_start    OVL_IGNORE_NEW_START
     edge_type              OVL_RESET_ON_NEW_START
     necessary_condition    OVL_ERROR_ON_NEW_START
     inactive               OVL_NOEDGE
                            OVL_POSEDGE
                            OVL_NEGEDGE
                            OVL_ANYEDGE
                            OVL_TRIGGER_ON_MOST_PIPE
                            OVL_TRIGGER_ON_FIRST_PIPE
                            OVL_TRIGGER_ON_FIRST_NOPIPE
                            OVL_ALL_ZEROS
                            OVL_ALL_ONES
                            OVL_ONE_COLD

     Parameter   Other Parameters for Assertion Checkers
                                        Valid Values

     num_cks                Int#(32)
     min_cks                Int#(32)
     max_cks                Int#(32)
     min_ack_cycle          Int#(32)
     max_ack_cycle          Int#(32)
     max_ack_length         Int#(32)
     req_drop               Int#(32)
     deassert_count         Int#(32)
     depth                  Int#(32)
     value                  a_type
     min                    a_type
     max                    a_type
     check_overlapping      Bool
     check_missing_start    Bool
     simultaneous_push_pop  Bool

Setting Assertion Parameters

Each assertion checker module has a set of associated parameter values that can be customized for
each module instantiation. The values for these parameters are passed to each checker module in
the form of a single struct argument of type OVLDefaults#(a) A typical use scenario is illustrated
below:

let defaults = mkOVLDefaults;

defaults.min_clks = 2;
defaults.max_clks = 3;

AssertTest_IFC#(Bool) assertWid &lt;- bsv_assert_width(defaults);

The defaults struct (created by mkOVLDefaults) includes one ﬁeld for each possible parameter.
Initially each ﬁeld includes the associated default value. By editing ﬁelds of the struct, individual
parameter values can be modiﬁed as needed to be non-default values. The modiﬁed defaults struct
is then provided as a module argument during instantiation.

298              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Modules

Each module in this package corresponds to an assertion checker from the Open Veriﬁcation Library
(OVL). The BSV name for each module is the same as the OVL name with bsv_ appended to the
beginning of the name.

Module                  bsv_assert_always
Description             Concurrent assertion that the value of the expression is always True.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
Module Declaration
                        module bsv_assert_always#(OVLDefaults#(Bool) defaults)
                                               (AssertTest_IFC#(Bool));

Module                  bsv_assert_always_on_edge
Description             Checks that the test expression evaluates True whenever the sample
                        method is asserted.
Interface Used          AssertSampleTest_IFC
Parameters              common assertion parameters
                        edge_type (default value = OVL_NOEDGE)
Module Declaration
                        module bsv_assert_always_on_edge#(OVLDefaults#(Bool)
                                               defaults)(AssertSampleTest_IFC#(Bool));

Module                  bsv_assert_change
Description             Checks that once the start method is asserted, the expression will change
Interface Used          value within num_cks cycles.
Parameters              AssertStartTest_IFC
                        common assertion parameters
Module Declaration      action_on_new_start (default value = OVL_IGNORE_NEW_START)
                        num_cks (default value = 1)

                        module bsv_assert_change#(OVLDefaults#(a_type) defaults)
                                               (AssertStartTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_cycle_sequence
Description             Ensures that if a speciﬁed necessary condition occurs,it is followed by a
                        speciﬁed sequence of events.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
                        necessary_condition (default value = OVL_TRIGGER_ON_MOST_PIPE)
Module Declaration
                        module bsv_assert_cycle_sequence#(OVLDefaults#(a_type)
                                               defaults)(AssertTest_IFC#(a_type))

                               provisos (Bits#(a_type, sizea),
                                               Bounded#(a_type), Eq#(a_type));

                        c 2008 Bluespec, Inc. All rights reserved                              299


Reference Guide                                                Bluespec SystemVerilog

Module              bsv_assert_decrement
Description         Ensures that the expression decrements only by the value speciﬁedR.
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
                    value (default value = 1)
Module Declaration
                    module bsv_assert_decrement#(OVLDefaults#(a_type) defaults)
                                           (AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea), Literal#(a_type),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_delta
Description         Ensures that the expression always changes by a value within the range
Interface Used      speciﬁed by min and max.
Parameters          AssertTest_IFC
                    common assertion parameters
Module Declaration  min (default value = 1)
                    max (default value = 1)

                    module bsv_assert_delta#(OVLDefaults#(a_type) defaults)
                                           (AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea), Literal#(a_type),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_even_parity
Description         Ensures that value of a speciﬁed expression has even parity, that is an
                    even number of bits in the expression are active high.
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_even_parity#(OVLDefaults#(a_type)
                                           defaults) (AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_fifo_index
Description         Ensures that a FIFO-type structure never overﬂows or underﬂows. This
                    checker can be conﬁgured to support multiple pushes (FIFO writes) and
Interface Used      pops (FIFO reads) during the same clock cycle.
Parameters          AssertFifoTest_IFC
                    common assertion parameters
Module Declaration  depth (default value = 1)
                    simultaneous_push_pop (default value = True)

                    module bsv_assert_fifo_index#(OVLDefaults#(Bit#(0))
                                       defaults)(AssertFifoTest_IFC#(a_type, b_type))

                          provisos (Bits#(a_type, sizea), Bits#(b_type, sizeb));

300                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Module                  bsv_assert_frame
Description             Checks that once the start method is asserted, the test expression eval-
                        uates true not before min_cks clock cycles and not after max_cks clock
Interface Used          cycles.
Parameters              AssertStartTest_IFC
                        common assertion parameters
Module Declaration      action_on_new_start (default value = OVL_IGNORE_NEW_START)
                        min_cks (default value = 1)
                        max_cks (default value = 1)

                        module bsv_assert_frame#(OVLDefaults#(Bool) defaults)
                                               (AssertStartTest_IFC#(Bool));

Module                  bsv_assert_handshake
Description             Ensures that the speciﬁed request and acknowledge signals follow a spec-
Interface Used          iﬁed handshake protocol.
Parameters              AssertStartTest_IFC
                        common assertion parameters
Module Declaration      action_on_new_start (default value = OVL_IGNORE_NEW_START)
                        min_ack_cycle (default value = 1)
                        max_ack_cycle (default value = 1)

                        module bsv_assert_handshake#(OVLDefaults#(Bool) defaults)
                                               (AssertStartTest_IFC#(Bool));

Module                  bsv_assert_implication
Description             Ensures that a speciﬁed consequent expression is True if the speciﬁed
                        antecedent expression is True.
Interface Used          AssertStartTest_IFC
Parameters              common assertion parameters
Module Declaration
                        module bsv_assert_implication#(OVLDefaults#(Bool) defaults)
                                               (AssertStartTest_IFC#(Bool));

Module                  bsv_assert_increment
Description             ensure that the test expression always increases by the value of speciﬁed
                        by value.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
                        value (default value = 1)
Module Declaration
                        module bsv_assert_increment#(OVLDefaults#(a_type) defaults)
                                               (AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea), Literal#(a_type),
                                              Bounded#(a_type), Eq#(a_type));

                        c 2008 Bluespec, Inc. All rights reserved  301


Reference Guide                                                Bluespec SystemVerilog

Module              bsv_assert_never
Description         Ensures that the value of a speciﬁed expression is never True.
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_never#(OVLDefaults#(Bool) defaults)
                                           (AssertTest_IFC#(Bool));

Module              bsv_assert_never_unknown
Description         Ensures that the value of a speciﬁed expression contains only 0 and 1
                    bits when a qualifying expression is True.
Interface Used      AssertStartTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_never_unknown#(OVLDefaults#(a_type)
                                           defaults)(AssertStartTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_never_unknown_async
Description         Ensures that the value of a speciﬁed expression always contains only 0
                    and 1 bits
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_never_unknown_async#(OVLDefaults#(a_type)
                                           defaults)(AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea), Literal#(a_type),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_next
Description         Ensures that the value of the speciﬁed expression is true a speciﬁed
Interface Used      number of cycles after a start event.
Parameters          AssertStartTest_IFC
                    common assertion parameters
Module Declaration  num_cks (default value = 1)
                    check_overlapping (default value = True)
                    check_missing_start (default value = False)

                    module bsv_assert_next#(OVLDefaults#(Bool) defaults)
                                           (AssertStartTest_IFC#(Bool));

302                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Module                  bsv_assert_no_overflow
Description             Ensures that the value of the speciﬁed expression does not overﬂow.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
                        min (default value = minBound)
Module Declaration      max (default value = maxBound)

                        module bsv_assert_no_overflow#(OVLDefaults#(a_type)
                                               defaults) (AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_no_transition
Description             Ensures that the value of a speciﬁed expression does not transition from
                        a start state to the speciﬁed next state.
Interface Used          AssertTransitionTest_IFC
Parameters              common assertion parameters
Module Declaration
                        module bsv_assert_no_transition#(OVLDefaults#(a_type)
                                            defaults) (AssertTransitionTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_no_underflow
Description             Ensures that the value of the speciﬁed expression does not underﬂow.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
                        min (default value = minBound)
Module Declaration      max (default value = maxBound)

                        module bsv_assert_no_underflow#(OVLDefaults#(a_type)
                                               defaults)(AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_odd_parity
Description             Ensures that the speciﬁed expression had odd parity; that an odd num-
                        ber of bits in the expression are active high.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
Module Declaration
                        module bsv_assert_odd_parity#(OVLDefaults#(a_type)
                                               defaults)(AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

                        c 2008 Bluespec, Inc. All rights reserved                             303


Reference Guide                                                Bluespec SystemVerilog

Module              bsv_assert_one_cold
Description         Ensures that exactly one bit of a variable is active low.
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
                    inactive (default value = OLV_ONE_COLD)
Module Declaration
                    module bsv_assert_one_cold#(OVLDefaults#(a_type) defaults)
                                           (AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type))

Module              bsv_assert_one_hot
Description         Ensures that exactly one bit of a variable is active high.
Interface Used      AssertTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_one_hot#(OVLDefaults#(a_type) defaults)
                                           (AssertTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_proposition
Description         Ensures that the test expression is always combinationally True. Like
                    assert_always except that the test expression is not sampled by the
Interface Used      clock.
Parameters          AssertTest_IFC
Module Declaration  common assertion parameters

                    module bsv_assert_proposition#(OVLDefaults#(Bool) defaults)
                                           (AssertTest_IFC#(Bool));

Module              bsv_assert_quiescent_state
Description         Ensures that the value of a speciﬁed state expression equals a corre-
                    sponding check value if a speciﬁed sample event has transitioned to
Interface Used      TRUE.
Parameters          AssertQuiescentTest_IFC
Module Declaration  common assertion parameters

                    module bsv_assert_quiescent_state#(OVLDefaults#(a_type)
                                           defaults)(AssertQuiescentTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

304                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

Module                  bsv_assert_range
Description             Ensure that an expression is always within a speciﬁed range.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
                        min (default value = minBound)
Module Declaration      max (default value = maxBound)

                        module bsv_assert_range#(OVLDefaults#(a_type) defaults)
                                               (AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_time
Description             Ensures that the expression remains True for a speciﬁed number of clock
Interface Used          cycles after a start event.
Parameters              AssertStartTest_IFC
                        common assertion parameters
Module Declaration      action_on_new_start (default value = OVL_IGNORE_NEW_START)
                        num_cks (default value = 1)

                        module bsv_assert_time#(OVLDefaults#(Bool) defaults)
                                               (AssertStartTest_IFC#(Bool));

Module                  bsv_assert_transition
Description             Ensures that the value of a speciﬁed expression transitions properly
                        froma start state to the speciﬁed next state.
Interface Used          AssertTransitionTest_IFC
Parameters              common assertion parameters
Module Declaration
                        module bsv_assert_transition#(OVLDefaults#(a_type)
                                               defaults)(AssertTransitionTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Module                  bsv_assert_unchange
Description             Ensures that the value of the speciﬁed expression does not change during
Interface Used          a speciﬁed number of clock cycles after a start event initiates checking.
Parameters              AssertStartTest_IFC
                        common assertion parameters
Module Declaration      action_on_new_start (default value = OVL_IGNORE_NEW_START)
                        num_cks (default value = 1)

                        module bsv_assert_unchange#(OVLDefaults#(a_type) defaults)
                                               (AssertStartTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

                        c 2008 Bluespec, Inc. All rights reserved                     305


Reference Guide                                                Bluespec SystemVerilog

Module              bsv_assert_width
Description         Ensures that when the test expression goes high it stays high for at least
Interface Used      min and at most max clock cycles.
Parameters          AssertTest_IFC
                    common assertion parameters
Module Declaration  min_cks (default value = 1)
                    max_cks (default value = 1)

                    module bsv_assert_width#(OVLDefaults#(Bool) defaults)
                                           (AssertTest_IFC#(Bool));

Module              bsv_assert_win_change
Description         Ensures that the value of a speciﬁed expression changes in a speciﬁed
                    window between a start event and a stop event.
Interface Used      AssertStartStopTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_win_change#(OVLDefaults#(a_type)
                                           defaults)(AssertStartStopTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_win_unchange
Description         Ensures that the value of a speciﬁed expression does not change in a
                    speciﬁed window between a start event and a stop event.
Interface Used      AssertStartStopTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_win_unchange#(OVLDefaults#(a_type)
                                           defaults)(AssertStartStopTest_IFC#(a_type))

                          provisos (Bits#(a_type, sizea),
                                          Bounded#(a_type), Eq#(a_type));

Module              bsv_assert_window
Description         Ensures that the value of a speciﬁed event is True between a speciﬁed
                    window between a start event and a stop event.
Interface Used      AssertStartStopTest_IFC
Parameters          common assertion parameters
Module Declaration
                    module bsv_assert_window#(OVLDefaults#(Bool) defaults)
                                           (AssertStartStopTest_IFC#(Bool));

306                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

Module                  bsv_assert_zero_one_hot
Description             ensure that exactly one bit of a variable is active high or zero.
Interface Used          AssertTest_IFC
Parameters              common assertion parameters
Module Declaration
                         module bsv_assert_zero_one_hot#(OVLDefaults#(a_type)
                                                 defaults)(AssertTest_IFC#(a_type))

                              provisos (Bits#(a_type, sizea),
                                              Bounded#(a_type), Eq#(a_type));

Example using bsv assert increment
This example checks that a test expression is always incremented by a value of 3. The assertion
passes for the ﬁrst 10 increments and then starts failing when the increment amount is changed from
3 to 1.
import OVLAssertions::*; // import the OVL Assertions package

module assertIncrement (Empty);

    Reg#(Bit#(8)) count &lt;- mkReg(0);
    Reg#(Bit#(8)) test_expr &lt;- mkReg(0);

// set the default values
let defaults = mkOVLDefaults;

// override the default increment value and set = 3
defaults.value = 3;

// instantiate an instance of the module bsv_assert_increment using
// the name assert_mod and the interface AssertTest_IFC
AssertTest_IFC#(Bit#(8)) assert_mod &lt;- bsv_assert_increment(defaults);

rule every (True);             // Every clock cycle

assert_mod.test(test_expr); // the assertion is checked

endrule

rule increment (True);

count &lt;= count + 1;

if (count &lt; 10)                // for 10 cycles

           test_expr &lt;= test_expr + 3; // increment the expected amount

else if (count &lt; 15)

           test_expr &lt;= test_expr + 1; // then start incrementing by 1

else

           $finish;

endrule

endmodule

Using The Library

In order to use the OVLAssertions package, a user must ﬁrst download the source OVL library from
Accellera (http://www.accellera.org). In addition, that library must be made available when
building a simulation executable from the BSV generated Verilog.

                        c 2008 Bluespec, Inc. All rights reserved                          307


Reference Guide                                                        Bluespec SystemVerilog

If the bsc compiler is being used to generate the Verilog simulation executable, the BSC_VSIM_FLAGS
environment variable can be used to set the required simulator ﬂags that enable use of the OVL
library.
For instance, if the iverilog simulator is being used and the OVL library is located in the directory
shared/std_ovl, the BSC_VSIM_FLAGS environment variable can be set to ¨-I shared/std_ovl -Y
.vlib -y shared/std_ovl -DOVL_VERILOG=1 -DOVL_ASSERT_ON=1¨. These ﬂags:

    • Add shared/std_ovl to the Verilog and include search paths.

    • Set .vlib as a possible ﬁle suﬃx.

    • Set ﬂags used in the OVL source code.

The exact ﬂags to be used will diﬀer based on what OVL behavior is desired and which Verilog
simulator is being used.

C.8 Multiple Clock Domains and Clock Generators

Package Name

Import Clocks :: * ;

Description

The BSV Clocks library provide features to access and change the default clock. Moreover, there
are hardware primitives to generate clocks of various shapes, plus several primitives which allow the
safe crossing of signals and data from one clock domain to another.

The Clocks package uses the data types Clock and Reset as well as clock functions which are
described below but deﬁned in the Prelude package.

Each section describes a related group of modules, followed by a table indicating the Verilog modules
used to implement the BSV modules.

Types and typeclasses

The Clocks package uses the abstract data types Clock and Reset, which are deﬁned in the Prelude
package. These are ﬁrst class objects. Both Clock and Reset are in the Eq type class, meaning two
values can be compared for equality.

Clock is an abstract type of two components: a single Bit oscillator and a Bool gate.

       typedef ... Clock ;

Reset is an abstract type.
       typedef ... Reset ;

                            Type Classes for Clock and Reset

            Bits Eq Literal Arith Ord Bounded Bitwise                  Bit  Bit

                 √                                                     Reduction Extend

     Clock       √

     Reset

Example: Declaring a new clock
    Clock clk0;

Example: Instantiating a register with clock and reset

308                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

    Reg#(Byte) a &lt;- mkReg(0, clocked_by clks0, reset_by rst0);

Functions
The following functions are deﬁned in the Prelude package but are used with multiple clock domains.

                        Clock Functions

exposeCurrentClock      This function returns a value of type Clock, which is the current clock
                        of the module.

                               module exposeCurrentClock ( Clock c );

exposeCurrentReset      This function returns a value of type Reset, which is the current reset
                        of the module.

                               module exposeCurrentReset ( Reset r );

Both exposeCurrentClock and exposeCurrentReset use the module instantiation syntax (&lt;-) to
return the value. Hence these can only be used from within a module.
Example: setting a reset to the current reset

       Reset reset_value &lt;- exposeCurrentReset;

Example: setting a clock to the current clock
      Clock clock_value &lt;- exposeCurrentClock;

sameFamily              A Boolean function which returns True if the clocks are in the same
                        family, False if the clocks are not in the same family. Clocks in the
                        same family have the same oscillator but may have diﬀerent gate con-
                        ditions.

                        function Bool sameFamily ( Clock clka, Clock clkb ) ;

isAncestor              A Boolean function which returns True if clka is an ancestor of clkb,
                        that is clkb is a gated version of clka (clka itself may be gated) or if
                        clka and clkb are the same clock. The ancestry relation is a partial
                        order (ie., reﬂexive, transitive and antisymmetric).

                        function Bool isAncestor ( Clock clka, Clock clkb ) ;

clockOf                 Returns the current clock of the object obj.
                        function Clock clockOf ( a_type obj ) ;

                        c 2008 Bluespec, Inc. All rights reserved     309


Reference Guide                                                                        Bluespec SystemVerilog
  noClock
                         Speciﬁes a null clock, a clock where the oscillator never rises.
                         function Clock noClock() ;

resetOf                  Returns the current reset of the object obj.
                         function Reset resetOf ( a_type obj ) ;

noReset                  Speciﬁes a null reset, a reset which is never asserted.
                         function Reset noReset() ;

C.8.1 Clock Generators and Clock Manipulation

Description

This section provides modules to generate new clocks and to modify the existing clock.

The modules mkAbsoluteClock, mkAbsoluteClockFull, mkClock, and mkUngatedClock all deﬁne a
new clock, one not based on the current clock. Both mkAbsoluteClock and mkAbsoluteClockFull
deﬁne new oscillators and are not synthesizable. mkClock and mkUngatedClock use an existing oscil-
lator to create a clock, and is synthesizable. The modules, mkGatedClock and mkGatedClockFromCC
use existing clocks to generate another clock in the same family.

Interfaces and Methods

The MakeClockIfc supports user-deﬁned clocks with irregular waveforms created with mkClock
and mkUngatedClock, as opposed to the ﬁxed-period waveforms created with the mkAbsoluteClock
family.

                            MakeClockIfc Interface

                 Method and subinterfaces                              Arguments
                                                                            Description
Name             Type       Description                    Name
setClockValue                                              value       Value the clock will
                 Action     Changes the value of the                   be set to, must be a
getClockValue               clock at the next edge of      gate        one bit type
setGateCond                 the clock
getGateCond                                                            Must be of the type
new_clk          one_bit_type Retrieves the last value of              Bool
                                        the clock

                 Action     Changes the gating condi-
                            tion

                 Bool       Retrieves the last gating
                            condition set

                 Interface  Clock interface provided
                            by the module

     interface MakeClockIfc#(type one_bit_type);

     method Action          setClockValue(one_bit_type value) ;

     method one_bit_type getClockValue() ;

310                      c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                   Reference Guide

    method Action       setGateCond(Bool gate) ;
    method Bool         getGateCond() ;
    interface Clock     new_clk ;
endinterface

The GatedClockIfc is used for adding a gate to an existing clock.

                                   GatedClockIfc Interface               Arguments
             Method and subinterfaces                                         Description

Name         Type       Description                                Name  Must be of the type
setGateCond                                                        gate  Bool
             Action     Changes the gating condi-
getGateCond  Bool       tion
             Interface  Retrieves the last gating
new_clk                 condition set
                        Clock interface provided
                        by the module

       interface GatedClockIfc ;
            method Action setGateCond(Bool gate) ;
            method Bool getGateCond() ;
            interface Clock new_clk ;

       endinterface

Modules

The mkClock module creates a Clock type from a one-bit oscillator and a Boolean gate condition.
There is no family relationship between the current clock and the clock generated by this module.
The initial values of the oscillator and gate are passed as parameters to the module. When the
module is out of reset, the oscillator value can be changed using the setClockValue method and the
gate condition can be changed by calling the setGateCond method. The oscillator value and gate
condition can be queried with the getClockValue and getGateCond methods, respectively. The
clock created by mkClock is available as the new_clk subinterface. When setting the gate condition,
the change does not aﬀect the generated clock until it is low, to prevent glitches.

The mkUngatedClock module is an ungated version of the mkClock module. It takes only an oscillator
argument (no gate argument) and returns the same new_clock interface. Since there is no gate,
an error is returned if the design calls the setGetCond method. The getGateCond method always
returns True.

                        Figure 5: Clock Generator

                        c 2008 Bluespec, Inc. All rights reserved        311


Reference Guide                                             Bluespec SystemVerilog

mkClock          Creates a Clock type from a one-bit oscillator input, and a Boolean gate
                 condition. There is no family relationship between the current clock and the
                 clock generated by this module.

                 module mkClock #( one_bit_type initVal, Bool initGate)
                                        ( MakeClockIfc#(one_bit_type) ifc )

                     provisos( Bits#(one_bit_type, 1) ) ;

  mkUngatedClock Creates an ungated Clock type from a one-bit oscillator input. There is no
                            family relationship between the current clock and the clock generated by this
                            module.

                            module mkUngatedClock #( one_bit_type initVal)
                                                   ( MakeClockIfc#(one_bit_type) ifc )

                                provisos( Bits#(one_bit_type, 1) ) ;

The mkGatedClock module adds (logic and) a Boolean gate condition to an existing clock, thus
creating another clock in the same family. The source clock is provided as the argument clk_in.
The gate condition is controlled by an asynchronously-reset register inside the module. The register
is set with the setGateCond Action method of the interface and can be read with getGateCond
method. The reset value of the gate condition register is provided as an instantiation parameter.
The clock for the register (and thus these set and get methods) is the default clock of the module;
to specify a clock other than the default clock, use the clocked_by directive.

                 Figure 6: Gated Clock Generator

mkGatedClock Creates another clock in the same family by adding logic and a Boolean gate
                       condition to the current clock.

                       module mkGatedClock#(Bool v) ( Clock clk_in, GatedClockIfc ifc );

For convenience, we provide an alternate version in which the source clock is the default clock of the
module

312              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkGatedClockFromCC An alternate interface for the module mkGatedClock in which the source
                                clock is the default clock of the module.

                                module mkGatedClockFromCC#(Bool v) ( GatedClockIfc ifc );

The modules mkAbsoluteClock and mkAbsoluteClockFull provide parametizable clock generation
modules which are not synthesizable, but may be useful for testbenches. In mkAbsoluteClock,
the ﬁrst rising edge (start) and the period are deﬁned by parameters. Additional parameters are
provided by mkAbsoluteClockFull.

mkAbsoluteClock         The ﬁrst rising edge (start) and period are deﬁned by parameters.
                        This module is not synthesizable.

                        module mkAbsoluteClock #( Integer start,
                                                                 Integer period )
                                                                 ( Clock );

mkAbsoluteClockFull     The value initValue is held until time start, and then the clock
                        oscillates. The value not(initValue) is held for time compValTime,
                        followed by initValue held for time initValTime. Hence the clock
                        period after startup is compValTime + initValTime. This module is
                        not synthesizable.

                        module mkAbsoluteClockFull #( Integer start,
                                                                       Bit#(1) initValue,
                                                                       Integer compValTime,
                                                                       Integer initValTime )
                                                                       ( Clock );

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name         Verilog Module Name
                        ClockGen.v
mkAbsoluteClock         MakeClock.v
mkAbsoluteClockFull     GatedClock.v
mkClock
mkUngatedClock
mkGatedClock
mkGatedClockFromCC

                        c 2008 Bluespec, Inc. All rights reserved                             313


Reference Guide                                                        Bluespec SystemVerilog

C.8.2 Clock Multiplexing

Description

Bluespec provides two gated clock multiplexing primitives: a simple combinational multiplexor and
a stateful module which generates an appropriate reset signal when the clock changes. The ﬁrst
multiplexor uses the interface MuxClockIfc, which includes an Action method to select the clock
along with a Clock subinterface. The second multiplexor uses the interface SelectClockIfc which
also has a Reset subinterface.

Ungated versions of these modules are also provided. The ungated versions are identical to the gated
versions, except that the input and output clocks are ungated.

Interfaces and Methods

                            MuxClockIfc Interface

                 Method and subinterfaces                               Arguments
                                                                              Description
Name             Type       Description                 Name
select                                                  ab             if True, clock_out is
                 Action     Method used to select the                  taken from aclk
clock_out        Interface  clock based on the Boolean
                            value ab
                            Clock interface

     interface MuxClkIfc ;                  ab ) ;
         method Action select ( Bool
         interface Clock clock_out ;

     endinterface

                            SelectClockIfc Interface

                 Method and subinterfaces                               Arguments
                                                                              Description
Name             Type       Description                 Name
select                                                  ab             if True, clock out is
                 Action     Method used to select the                  taken from aclk
clock_out        Interface  clock based on the Boolean
reset_out                   value ab
                            Clock interface

                 Interface Reset interface

     interface SelectClkIfc ;               ab ) ;
         method Action select ( Bool
         interface Clock clock_out ;
         interface Reset reset_out ;

     endinterface

Modules

The mkClockMux module is a simple combinational multiplexor with a registered clock selection
signal, which selects between clock inputs aClk and bClk. The provided Verilog module does not
provide any glitch detection or removal logic; it is the responsibility of the user to provide additional
logic to provide glitch-free behavior. The mkClockMux module uses two arguments and provides a
Clock interface. The aClk is selected if ab is True, while bClk is selected otherwise.

The mkUngatedClockMux module is identical to the mkClockMux module except that the input and
output clocks are ungated. The signals aClkgate, bClkgate, and outClkgate in ﬁgure 7 don’t exist.

314                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkClockMux                        Figure 7: Clock Multiplexor

                        Simple combinational multiplexor, which selects between aClk and
                        bClk.
                        module mkClockMux ( Clock aClk, Clock bClk )

                                                    ( MuxClkIfc ) ;

mkUngatedClockMux       Simple combinational multiplexor, which selects between aClk and
                        bClk. None of the clocks are gated.

                        module mkUngatedClockMux ( Clock aClk, Clock bClk )
                                                               ( MuxClkIfc ) ;

The mkClockSelect module is a clock multiplexor containing additional logic which generates a
reset whenever a new clock is selected. As such, the interface for the module includes an Action
method to select the clock (if ab is True clock out is taken from aClk), provides a Clock interface,
and also a Reset interface.

The constructor for the module uses two clock arguments, and provides the MuxClockIfc interface.
The underlying Verilog module is ClockSelect.v; it is expected that users can substitute their own
modules to meet any additional requirements they may have. The parameter stages is the number
of clock cycles in which the reset is asserted after the clock selection changes.

The mkUngatedClockSelect module is identical to the mkClockSelect module except that the input
and output clocks are ungated. The signals aClkgate, bClkgate, and outClk_gate in ﬁgure 8 don’t
exist.

mkClockSelect           Clock Multiplexor containing additional logic which generates a reset
                        whenever a new clock is selected.

                        module mkClockSelect #( Integer stages,
                                                                 Clock aClk,
                                                                 Clock bClk,

                                                              ( SelectClockIfc ) ;

                        c 2008 Bluespec, Inc. All rights reserved  315


Reference Guide                                                  Bluespec SystemVerilog

                      Figure 8: Clock Multiplexor with reset

mkUngatedClockSelect Clock Multiplexor containing additional logic which generates a reset
                                  whenever a new clock is selected. The input and output clocks are
                                  ungated.

                                  module mkUngatedClockSelect #( Integer stages,
                                                                                   Clock aClk,
                                                                                   Clock bClk,

                                                                                ( SelectClockIfc ) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name       Verilog Module Name

mkClockMux            ClockMux.v
mkClockSelect         ClockSelect.v
mkUngatedClockMux     UngatedClockMux.v
mkUngatedClockSelect  UngatedClockSelect.v

C.8.3 Clock Division

Description

A clock divider provides a derived clock and also a ClkNextRdy signal, which indicates that the
divided clock will rise in the next cycle. This signal is associated with the input clock, and can only
be used within that clock domain.

See mkSyncRegToSlow, mkSyncRegToFast, mkSyncFIFOToSlow, and mkSyncFIFOToFast in Section
C.8.10 for some specialized synchronizers which can be used with divided clocks, and other systems
when the clock edges are known to be aligned.

Data Types

The ClkNextRdy is a Boolean signal which indicates that the slow clock will rise in the next cycle.

316                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

typedef Bool ClkNextRdy ;

Interfaces and Methods

Name            Type          ClockDividerIfc Interface
                           Description
fastClock       Interface
slowClock       Interface  The original clock
clockReady      Bool       The derived clock
                           Boolean value which indicates that the slow clock will rise
                           in the next cycle. The method is in the clock domain of the
                           fast clock.

interface ClockDividerIfc ;

interface Clock            fastClock ;

interface Clock            slowClock ;

method ClkNextRdy clockReady() ;

endinterface

Modules

The divider parameter may be any integer greater than 1. For even dividers the generated clock’s
duty cycle is 50%, while for odd dividers, the duty cycle is (divider/2)/divider. The current clock
(or the clocked_by argument) is used as the source clock.

                           Figure 9: Clock Divider

mkClockDivider             Basic clock divider.

                           module mkClockDivider #( Integer divisor )
                                                               ( ClockDividerIfc ) ;

mkGatedClockDivider        A gated verison of the basic clock divider.

                           module mkGatedClockDivider #( Integer divisor
                                                                       )( ClockDividerIfc ) ;

The mkClockDividerOffset module provides a clock divider where the rising edge can be deﬁned
relative to other clock dividers which have the same divisor. An oﬀset of value 2 will produce a rising
edge one fast clock after a divider with oﬀset 1. mkClockDivider is just mkClockDividerOffset
with an oﬀset of value 0.

                        c 2008 Bluespec, Inc. All rights reserved                              317


Reference Guide                                                  Bluespec SystemVerilog

mkClockDividerOffset  Provides a clock divider, where the rising edge can be deﬁned rel-
                      ative to other clock dividers which have the same divisor.

                      module mkClockDividerOffset #( Integer divisor,
                                                                       Integer offset )

                                                                    ( ClockDividerIfc ) ;

The mkClockInverter and mkGatedClockInverter modules generate an inverted clock having the
same period but opposite phase as the current clock. The mkGatedClockInverter is a gated version
of mkClockInverter. The output clock includes a gate signal derived from the gate of the input
clock.

mkClockInverter       Generates an inverted clock having the same period but opposite
                      phase as the current clock.

                      module mkClockInverter ( ClockDividerIfc ) ;

mkGatedClockInverter  A gated version of mkClockInverter.
                      module mkGatedClockInverter ( ClockDividerIfc ifc ) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name       Verilog Module Name

mkClockDivider        ClockDiv.v
mkClockDividerOffset
mkGatedClockDivider   GatedClockDiv.v
mkClockInverter       ClockInverter.v
mkGatedClockInverter  GatedClockInverter.v

C.8.4 Bit Synchronizers

Description
Bit synchronizers are used to safely transfer one bit of data from one clock domain to another. More
complicated synchronizers are provided in later sections.
Interfaces and Methods
The SyncBitIfc interface provides a send method which transmits one bit of information from one
clock domain to the read method in a second domain.

318                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                                     SyncBitIfc Interface

                        Methods                                    Arguments
                                                                           Description
Name  Type              Description                        Name
send                                                               One bit of information
      Action            Transmits information from bitData         transmitted
read                    one clock domain to the sec-
                        ond domain

      one_bit_type Reads one bit of data sent
                           from a diﬀerent clock domain

interface SyncBitIfc #(type one_bit_type) ;

      method Action     send ( one_bit_type bitData ) ;

      method one_bit_type read () ;

endinterface

Modules

The mkSyncBit, mkSyncBitFromCC and mkSyncBitToCC modules provide a SyncBitIfc across clock
domains. The send method is in one clock domain, and the read method is in a second clock
domain, as shown in Figure 10. The FromCC and ToCC versions diﬀer in that the FromCC module
moves data from the current clock (module’s clock), while the ToCC module moves data to the current
clock domain. The hardware implementation is a two register synchronizer, which can be found in
SyncBit.v in the Bluespec Verilog library directory.

mkSyncBit                         Figure 10: Bit Synchronizer

                        Moves data across clock domains. The in and out clocks, along with
                        the input reset, are explicitly provided. The default clock and reset
                        are ignored.
                        module mkSyncBit #( Clock sClkIn, Reset sRst,

                                                       Clock dClkIn )
                                                    ( SyncBitIfc #(one_bit_type) )
                            provisos( Bits#(one_bit_type, 1)) ;

mkSyncBitFromCC         Moves data from the current clock (the module’s clock) to a diﬀerent
                        clock domain. The input clock and reset are the current clock and
                        reset.

                        module mkSyncBitFromCC #( Clock dClkIn )
                                                              ( SyncBitIfc #(one_bit_type) )

                            provisos( Bits#(one_bit_type, 1)) ;

                        c 2008 Bluespec, Inc. All rights reserved  319


Reference Guide                                               Bluespec SystemVerilog

mkSyncBitToCC      Moves data into the current clock domain. The output clock is the
                   current clock. The current reset is ignored.

                   module mkSyncBitToCC #( Clock sClkIn, Reset sRstIn )
                                                     ( SyncBitIfc #(one_bit_type) )

                       provisos( Bits#(one_bit_type, 1)) ;

The mkSyncBit15 module (one and a half) and its variants provide the same interface as the
mkSyncBit modules, but the underlying hardware is slightly modiﬁed, as shown in Figure 11. For
these synchronizers, the ﬁrst register clocked by the destination clock triggers on the falling edge of
the clock.

     Figure 11: Bit Synchronizer 1.5 - ﬁrst register in destination domain triggers on falling edge

mkSyncBit15        Similar to mkSyncBit except it triggers on the falling edge of the clock.
                   The in and out clocks, along with the input reset, are explicitly pro-
                   vided. The default clock and reset are ignored.

                   module mkSyncBit15 #( Clock sClkIn, Reset sRst,
                                                     Clock dClkIn )

                                                  ( SyncBitIfc #(one_bit_type) )
                       provisos( Bits#(one_bit_type, 1)) ;

mkSyncBit15FromCC  Moves data from the current clock and is triggered on the falling edge
                   of the clock. The input clock and reset are the current clock and reset.

                   module mkSyncBit15FromCC #(Clock dClkIn)
                                                            (SyncBitIfc #(one_bit_type))

                       provisos( Bits#(one_bit_type, 1)) ;

mkSyncBit15ToCC    Moves data into the current clock domain and is triggered on the falling
                   edge of the clock. The output clock is the current clock. The current
                   reset is ignored.

                   module mkSyncBit15ToCC #( Clock sClkIn, Reset sRstIn )
                                                         ( SyncBitIfc #(one_bit_type) )

                       provisos( Bits#(one_bit_type, 1)) ;

320                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

The mkSyncBit1 module, shown in Figure 12, also provides the same interface but only uses one
register in the destination domain. Synchronizers like this, which use only one register, are not
generally used since meta-stable output is more probable. However, one can use this synchronizer
provided special meta-stable resistant ﬂops are selected during physical synthesis or (for example) if
the output is immediately registered.

            Figure 12: Bit Synchronizer 1.0 - single register in destination domain

mkSyncBit1              Moves data from one clock domain to another clock domain, with only
                        one register in the destination domain. The in and out clocks, along
                        with the input reset, are explicitly provided. The default clock and
                        reset are ignored.

                        module mkSyncBit1 #( Clock sClkIn, Reset sRst,
                                                         Clock dClkIn )

                                                      ( SyncBitIfc #(one_bit_type) )
                            provisos( Bits#(one_bit_type, 1)) ;

mkSyncBit1FromCC        Moves data from the current clock domain, with only one register in
                        the destination domain. The input clock and reset are the current
                        clock and reset.

                        module mkSyncBit1FromCC #( Clock dClkIn )
                                                               ( SyncBitIfc #(one_bit_type) )

                            provisos( Bits #(one_bit_type, 1)) ;

mkSyncBit1ToCC          Moves data into the current clock domain, with only one register in
                        the destination domain. The output clock is the current clock. The
                        current reset is ignored.

                        module mkSyncBit1ToCC #( Clock sClkIn, Reset sRstIn )
                                                            ( SyncBitIfc #(one_bit_type) )

                            provisos( Bits#(one_bit_type, 1)) ;

The mkSyncBit05 module is similar to mkSyncBit1, but the destination register triggers on the
falling edge of the clock, as shown in Figure 13.

                        c 2008 Bluespec, Inc. All rights reserved                    321


Reference Guide                                               Bluespec SystemVerilog

     Figure 13: Bit Synchronizer .5 - ﬁrst register in destination domain triggers on falling edge

mkSyncBit05        Moves data from one clock domain to another clock domain, with
                   only one register in the destination domain. The destination register
                   triggers on the falling edge of the clock. The in and out clocks, along
                   with the input reset, are explicitly provided. The default clock and
                   reset are ignored.

                   module mkSyncBit05 #( Clock sClkIn, Reset sRst,
                                                     Clock dClkIn )

                                                  ( SyncBitIfc #(one_bit_type) )
                       provisos( Bits#(one_bit_type, 1)) ;

mkSyncBit05FromCC  Moves data from the current clock domain, with only one register in
                   the destination domain, the destination register triggers on the falling
                   edge of the clock. The input clock and reset are the current clock and
                   reset.

                   module mkSyncBit05FromCC #( Clock dClkIn )
                                                            (SyncBitIfc #(one_bit_type) )

                       provisos( Bits#(one_bit_type, 1)) ;

mkSyncBit05ToCC    Moves data into the current clock domain, with only one register in
                   the destination domain, the destination register triggers on the falling
                   edge of the clock. The output clock is the current clock. The current
                   reset is ignored.

                   module mkSyncBit05ToCC #( Clock sClkIn, Reset sRstIn )
                                                         ( SyncBitIfc #(one_bit_type) )

                       provisos( Bits#(one_bit_type, 1)) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

322                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

BSV Module Name              Verilog Module Name
                             SyncBit.v
mkSyncBit                    SyncBit15.v
mkSyncBitFromCC              SyncBit1.v
mkSyncBitToCC                SyncBit05.v
mkSyncBit15
mkSyncBit15FromCC
mkSyncBit15ToCC
mkSyncBit1
mkSyncBit1FromCC
mkSyncBit1ToCC
mkSyncBit05
mkSyncBit05FromCC
mkSyncBit05ToCC

C.8.5 Pulse Synchronizers

Description
Pulse synchronizers are used to transfer a pulse from one clock domain to another.
Interfaces and Methods
The SyncPulseIfc interface provides an Action method, send, which when invoked generates a True
value on the pulse method in a second clock domain.

Name Type                         SyncPulseIfc Interface
send Action                                Methods

pulse Bool                 Description

                           Starts transmittling a pulse from one clock domain to the
                           second clock domain.
                           Where the pulse is received in the second domain. pulse is
                           True if a pulse is recieved in this cycle.

interface SyncPulseIfc ;
    method Action send () ;
    method Bool pulse () ;

endinterface

Modules

The mkSyncPulse, mkSyncPulseFromCC and mkSyncPulseToCC modules provide clock domain cross-
ing modules for pulses. When the send method is called from the one clock domain, a pulse will be
seen on the read method in the second. Note that there is no handshaking between the domains,
so when sending data from a fast clock domain to a slower one, not all pulses sent may be seen in
the slower receiving clock domain. The pulse delay is two destination clocks cycles.

mkSyncPulse             Sends a pulse from one clock domain to another. The in and out
                        clocks, along with the input reset, are explicitly provided. The default
                        clock and reset are ignored.

                        module mkSyncPulse #( Clock sClkIn, Reset sRstIn,
                                                          Clock dClkIn )

                                                       ( SyncPulseIfc ) ;

                        c 2008 Bluespec, Inc. All rights reserved                      323


Reference Guide                                                   Bluespec SystemVerilog

                   Figure 14: Pulse Synchronizer - no handshake

mkSyncPulseFromCC      Sends a pulse from the current clock domain to the other clock domain.
                       The input clock and reset are the current clock and reset.

                       module mkSyncPulseFromCC #( Clock dClkIn )
                                                                ( SyncPulseIfc ) ;

mkSyncPulseToCC        Sends a pulse from the other clock domain to the current clock domain.
                       The output clock is the current clock. The current reset is ignored.

                       module mkSyncPulseToCC #( Clock sClkIn, Reset sRstIn )
                                                             ( SyncPulseIfc ) ;

The mkSyncHandshake, mkSyncHandshakeFromCC and mkSyncHandshakeToCC modules provide clock
domain crossing modules for pulses in a similar way as mkSyncPulse modules, except that a hand-
shake is provided in the mkSyncHandshake versions. The handshake enforces that another send does
not occur before the ﬁrst pulse crosses to the other domain. Note that this only guarantees that the
pulse is seen in one clock cycle of the destination; it does not guarantee that the system on that side
reacted to the pulse before it was gone. It is up to the designer to ensure this, if necessary.

The pulse delay from the send method to the read method is two destination clocks. The send
method is re-enabled in two destination clock cycles plus two source clock cycles after the send
method is called.

mkSyncHandshake        Sends a pulse from one clock domain to another clock domain with
                       handshaking. The in and out clocks, along with the input reset, are
                       explicitly provided. The default clock and reset are ignored.

                       module mkSyncHandshake #( Clock sClkIn, Reset sRstIn,
                                                                Clock dClkIn )

                                                             ( SyncPulseIfc ) ;

mkSyncHandShakeFromCC  Sends a pulse with a handshake from the current clock domain.
                       The input clock and reset are the current clock and reset.

                       module mkSyncHandshakeFromCC #( Clock dClkIn )
                                                                      ( SyncPulseIfc ) ;

324                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

                        Figure 15: Pulse Synchronizer with handshake

mkSyncHandshakeToCC     Sends a pulse with a handshake to the current clock domain. The
                        output clock is the current clock. The current reset is ignored.

                        module mkSyncHandshakeToCC #( Clock sClkIn,
                                                                       Reset sRstIn )

                                                                    ( SyncPulseIfc ) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name         Verilog Module Name
                        SyncPulse.v
mkSyncPulse             SyncHandshake.v
mkSyncPulseFromCC
mkSyncPulseToCC
mkSyncHandshake
mkSyncHandshakeFromCC
mkSyncHandshakeToCC

C.8.6 Word Synchronizers

Description

Word synchronizers are used to provide word synchronization across clock domains. The crossings
are handshaked, such that a second write cannot occur until the ﬁrst is acknowledged (that the data
has been received, but the value may not have been read) by the destination side. The destination
read is registered.

Interfaces and Methods

                        c 2008 Bluespec, Inc. All rights reserved     325


Reference Guide                                              Bluespec SystemVerilog

Word synchronizers use the common Reg interface (redescribed below), but there are a few subtle
diﬀerences which the designer should be aware. First, the _read and _write methods are in diﬀerent
clock domains and, second, the _write method has an implicit “ready” condition which means that
some synchronization modules cannot be written every clock cycle. Both of these conditions are
handled automatically by the Bluespec compiler relieving the designer of these tedious checks.

Name         Type                       Reg Interface  Name   Arguments
_write       Action  Method                            x1           Description
_read        a_type
                       Description                           Data to be written

                       Writes a value x1
                       Returns the value of the reg-
                       ister

       interface Reg #(a_type);
              method Action _write(a_type x1);
              method a_type _read();

       endinterface: Reg

Modules

The mkSyncReg, mkSyncRegToCC and mkSyncRegFromCC modules provide word synchronization across
clock domains.

Figure 16: Register Synchronization Module (see Figure 15 for the pulse synchronizer with hand-
shake)

  mkSyncReg          Provides word synchronization across clock domains. The in and out
326                  clocks, along with the input reset, are explicitly provided. The default
                     clock and reset are ignored.
                     module mkSyncReg #( a_type initValue,

                                                    Clock sClkIn, Reset sRstIn,
                                                    Clock dClkIn )
                                                 ( Reg #(a_type) )
                         provisos (Bits#(a_type, sa) ) ;

                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkSyncRegFromCC         Provides word synchronization from the current clock domain. The
                        input clock and reset are the current clock and reset.

                        module mkSyncRegFromCC #( a_type initValue,
                                                                 Clock dClkIn )

                                                              ( Reg #(a_type) )
                            provisos (Bits#(a_type, sa)) ;

mkSyncRegToCC           Provides word synchronization to the current clock domain. The out-
                        put clock is the current clock. The current reset is ignored.

                        module mkSyncRegToCC #( a_type initValue,
                                                              Clock sClkIn, Reset sRstIn )

                                                          ( Reg #(a_type) )
                            provisos (Bits#(a_type, sa)) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name           Verilog Module Name
                          SyncRegister.v
mkSyncReg
mkSyncRegFromCC
mkSyncRegToCC

C.8.7 FIFO Synchronizers

Description

The FIFO synchronizers use FIFOs to synchronize data being sent across clock domains. Additional
FIFO synchronizers, SyncFIFOLevel and SyncFIFOCount can be found in the FIFOLevel package
(Section C.1.4).

Interfaces and Methods

The sync FIFO interface deﬁnes an interface similar to the FIFOF interface, except it does not have
a clear method.

                        c 2008 Bluespec, Inc. All rights reserved  327


Reference Guide                                                Bluespec SystemVerilog

                            SyncFIFOIfc Interface

                    Method                                     Arguments

     Name  Type     Description                      Name      Description
     enq   Action
     deq   Action   Adds an entry to the FIFO sendData Data to be added
                    Removes the ﬁrst entry from
                    the FIFO

     first a_type   Returns the ﬁrst entry
     notFull Bool
                    Returns True if there is space

                    and you can enq into the
                    FIFO

     notEmpty Bool  Returns True if there are el-

                    ements in the FIFO and you

                    can deq from the FIFO

       interface SyncFIFOIfc #(type a_type) ;
            method Action enq ( a_type sendData ) ;
            method Action deq () ;
            method a_type first () ;
            method Bool notFull () ;
            method Bool notEmpty () ;

       endinterface

Modules

                    Figure 17: Synchronization FIFOs

The mkSyncFIFO, mkSyncFIFOFromCC and mkSyncFIFOToCC modules provide FIFOs for sending data
across clock domains. Data items enqueued on the source side will arrive at the destination side and
remain there until they are dequeued. The depth of the FIFO is speciﬁed by the depth parameter.

328                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkSyncFIFO              Provides a FIFO for sending data across clock domains. The enq
                        method is in the source (sClkIn) domain, while the deq and first
                        methods are in the destination (dClkIn) domain. The in and out
                        clocks, along with the input reset, are explicitly provided. The default
                        clock and reset are ignored.

                        module mkSyncFIFO #( Integer depth,
                                                         Clock sClkIn, Reset sRstIn,
                                                         Clock dClkIn )

                                                      ( SyncFIFOIfc #(a_type) )
                            provisos (Bits#(a_type, sa));

mkSyncFIFOFromCC        Provides a FIFO to send data from the current clock domain into a
                        second clock domain. The input clock and reset are the current clock
                        and reset.

                        module mkSyncFIFOFromCC #( Integer depth,
                                                                  Clock dClkIn )

                                                               ( SyncFIFOIfc #(a_type) )
                            provisos (Bits#(a_type, sa));

mkSyncFIFOToCC          Provides a FIFO to send data from a second clock domain into the
                        current clock domain. The output clock is the current clock. The
                        current reset is ignored.

                        module mkSyncFIFOToCC #( Integer depth,
                                                               Clock sClkIn, Reset sRstIn )

                                                            ( SyncFIFOIfc #(a_type) )
                            provisos (Bits#(a_type, sa));

The sync FIFOFull modules are a variation of the Sync FIFO which allow the empty and full signals
to be registered. Registering the signals can give better synthesis results, since a comparator is
removed from the empty or full path. However, there is an additional cycle of latency before the
empty or full signal is visible.

mkSyncFIFOFull          Provides a registered FIFO for sending data across clock domains. The
                        in and out clocks, along with the input reset, are explicitly provided.
                        The default clock and reset are ignored.

                        module mkSyncFIFOFull #( Integer depth,
                                                               Bool regEmpty,
                                                               Bool regFull,
                                                               Clock sClkIn, Reset sRstIn,
                                                               Clock dClkIn )

                                                            ( SyncFIFOIfc #(a_type) )
                            provisos (Bits#(a_type, sa));

                        c 2008 Bluespec, Inc. All rights reserved  329


Reference Guide                                                  Bluespec SystemVerilog

mkSyncFIFOFromCCFull Provides a registered FIFO to send data from the current clock domain
                                  into a second clock domain. The input clock and reset are the current
                                  clock and reset.

                                  module mkSyncFIFOFromCCFull #( Integer depth,
                                                                                   Bool regEmpty,
                                                                                   Bool regFull,
                                                                                   Clock dClkIn )

                                                                                ( SyncFIFOIfc #(a_type) )
                                       provisos (Bits#(a_type, sa));

mkSyncFIFOToCCFull    Provides a registered FIFO to send data from a second clock domain
                      into the current clock domain. The output clock is the current clock.
                      The current reset is ignored.

                      module mkSyncFIFOToCCFull #( Integer depth,
                                                                    Bool regEmpty,
                                                                    Bool regFull,
                                                                    Clock sClkIn, Reset sRstIn )

                                                                ( SyncFIFOIfc #(a_type) )
                          provisos (Bits#(a_type, sa));

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name          Verilog Module Name
                         SyncFIFO.v
mkSyncFIFO
mkSyncFIFOFromCC
mkSyncFIFOFromCC
mkSyncFIFOFull
mkSyncFIFOFromCCFull
mkSyncFIFOToCCFull

C.8.8 Asynchronous RAMs

Description

An asynchronous RAM provides a domain crossing by having its read and write methods in separate
clock domains.

Interfaces and Methods

330                   c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                                DualPortRamIfc Interface

                        Method                                         Arguments
                                                                              Description
Name       Type         Description  Name
write      Action                                                  Address of datatype addr_t
                        Writes data to a an ad- wr_addr
read       data_d       dress in a RAM                             Data of datatype data_t
                                                                   Address to be read from
                                                              din
                        Reads the data from the rd_addr
                        RAM

interface DualPortRamIfc #(type addr_t, type data_t);

method Action           write( addr_t wr_addr, data_t din );

method data_t           read ( addr_t rd_addr);

endinterface: DualPortRamIfc

                                Figure 18: Ansynchronous RAM

mkDualRam               Provides an asynchronous RAM for when the read and the write meth-
                        ods are in separate clock domains. The write method is clocked by the
                        default clock, the read method is not clocked.

                        module mkDualRam( DualPortRamIfc #(addr_t, data_t) )
                            provisos ( Bits#(addr_t, sa),
                                              Bits#(data_t, da) ) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name                      Verilog Module Name
mkDualRam                            DualPortRam.v

C.8.9 Null Crossing Primitives

Description
In these primitives, no synchronization is actually done. It is up to the designer to verify that it is
safe for the signal to be used in the other domain. The mkNullCrossingWire is a wire synchronizer.
The older mkNullCrossing primitive is deprecated.

                        c 2008 Bluespec, Inc. All rights reserved                              331


Reference Guide                                                Bluespec SystemVerilog

                    Figure 19: Wire synchronizer

Modules

The mkNullCrossingWire module, shown in Figure 19, uses the ReadOnly interface which is deﬁned
in the Prelude library B.4.7.

mkNullCrossingWire  Deﬁnes a synchronizer that contains only a wire. It is left up to the
                    designer to ensure the clock crossing is safe.

                    module mkNullCrossingWire #( Clock dClk, a_type dataIn )
                                                              ( ReadOnly#(a_type) )

                        provisos (Bits#(a_type, sa)) ;

Example: instantiating a null synchronizer

    // domain2sig is domain1sig synchronized to clk0 with just a wire.
    ReadOnly#(Bit#(2)) domain2sig &lt;- mkNullCrossingWire (clk0, domain1sig);

Note: no synchronization is actually done. This is purely a way to tell BSC that it is safe to use the
signal in the other domain. It is the responsibility of the designer to verify that this is correct.

There are some restrictions on the use of a mkNullCrossingWire. The expression used as the data
argument must not have an implicit condition, and there cannot be another rule which is required
to schedule before any method called in the expression.

mkNullCrossingWires may not be used in sequence to pass a signal across multiple clock boundaries
without synchronization. Once a signal has been crossed from one domain to a second domain
without synchronization, it cannot be subsequently passed unsynchronized to a third domain (or
back to the ﬁrst domain).

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name     Verilog Module Name
mkNullCrossingWire  BypassWire.v

C.8.10 Specialized Crossing Primitives

Description
The mkSyncRegToSlow and mkSyncRegToFast are specialized crossing primitives which can be used
to transport data when clock edges are aligned, between the domains. The divided clocks and the

332                 c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

appropriate interface needed for the module would typically be generated using the mkClockDivider
module (Section C.8.3).

The crossing primitive is implemented via a single register, clocked by the slower (divided) clock. For
a fast to slow crossing, the register is only writable when the clockReady bit of the divider interface
is asserted. This is an implicit condition of the write method module which prevents erroneous
writes. For a slow to fast crossing both the read and write methods are always available.

Modules

                        Figure 20: Fast to Slow Crossing

mkSyncRegToSlow         Provides a register to transport data when the clock edges are aligned
                        between domains. This module moves data from a fast to a slow
                        domain. The register is only writable when the clockReady bit of the
                        divider is asserted.

                        module mkSyncRegToSlow #( a_type initValue,
                                                                 ClockDividerIfc divider,
                                                                 Reset slowRstIn )

                                                              ( Reg #(a_type) )
                            provisos (Bits#(a_type, sa)) ;

                        Figure 21: Slow to Fast Crossing

                        c 2008 Bluespec, Inc. All rights reserved  333


Reference Guide                                              Bluespec SystemVerilog

mkSyncRegToFast   Provides a register to transport data when the clock edges are aligned
                  between domains. This module moves data from a slow to a fast
                  domain. The read and write methods are always available.

                  module mkSyncRegToFast #( a_type initValue,
                                                           ClockDividerIfc divider,
                                                           Reset slowRstIn )

                                                        ( Reg #(a_type) )
                      provisos (Bits#(a_type, sa)) ;

The mkSyncFIFOToSlow and mkSyncFIFOToFast modules are specialized crossing primitives which
can be used to transport data when clock edges are aligned, between a fast clock domain and a slower
clock domain. The derived clock and the ClkNextRdy signal would typically be generated using the
mkClockDivider module. The synchronous FIFOs are clocked by the slower (divided) clock. The
SyncFIFOIfc is detailed in Section C.8.7.

                  Figure 22: Aligned clocks with FIFO - to slower domain

mkSyncFIFOToSlow  Provides a FIFO with speciﬁed depth to transport data from a fast
                  clock domain to a slower clock domain when clock edges are aligned.
                  The crossing primitive is implemented via a FIFO with the speci-
                  ﬁed depth clocked by dClkIn. The FIFO is enqueued only when the
                  syncBit is asserted and the FIFO is not full.

                  module mkSyncFIFOToSlow #( Integer depth,
                                                            ClockDividerIfc divider,
                                                            Reset slowRstIn )

                                                         ( SyncFIFOIfc #(a_type) )
                      provisos (Bits#(a_type, sa)) ;

334               c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                    Reference Guide

                  Figure 23: Aligned clocks with FIFO - to faster domain

mkSyncFIFOToFast        Provides a FIFO with speciﬁed depth to transport data from a slower
                        clock domain to a faster clock domain when clock edges are aligned.
                        The crossing primitive is implemented via a FIFO with the speciﬁed
                        depth clocked by sClkIn (the source clock is the slower clock). The
                        FIFO is dequeued only when the syncBit is asserted and the FIFO is
                        not empty.

                        module mkSyncFIFOToFast #( Integer depth,
                                                                  ClockDividerIfc divider,
                                                                  Reset slowRstIn )

                                                               ( SyncFIFOIfc #(a_type) )
                            provisos (Bits#(a_type, sa)) ;

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name         Verilog Module Name

mkSyncRegToSlow         RegA.v
mkSyncRegToFast
mkSyncFIFOToSlow        FIFO2.v
mkSyncFIFOToFast        SizedFIFO.v

C.8.11 Reset Synchronization and Generation

Description

This section describes the interfaces and modules used to synchronize reset signals from one clock
domain to another and to create reset signals. Reset generation converts a Boolean type to a Reset
type, where the reset is associated with the default or clocked_by clock domain.

Interfaces and Methods

The MakeResetIfc interface is provided by the reset generators mkReset and mkResetSync.

                        c 2008 Bluespec, Inc. All rights reserved         335


Reference Guide           Type                                                       Bluespec SystemVerilog

       Name               Action    MakeResetIfc Interface
       assertReset        Bool                Method
       isAsserted         Reset
       new_rst                              Description
                                            Method used to assert the reset
                                            Indicates whether the reset is asserted
                                            Generated output reset

     interface MakeResetIfc;
         method Action assertReset();
         method Bool isAsserted();
         interface Reset new_rst;

     endinterface

The interface MuxRstIfc is provided by the mkResetMux module.

                                    MuxRstIfc Interface

                            Method                               Arguments
                                                                       Description
     Name           Type          Description            Name
     select                                                    Value determines which
                    Action        Method used to select ab     input reset to select
     reset_out      Reset         the reset based on the
                                  Boolean value ab
                                  Generated output reset

       interface MuxRstIfc;
            method Action select ( Bool ab );
            interface Reset reset_out;

       endinterface

Modules

Reset Synchronization To synchronize resets from one clock domain to another, both syn-
chronous and asynchronous modules are provided. The stages argument is the number of full clock
cycles the output reset is held for after the input reset is deasserted. This is shown as the number of
ﬂops in ﬁgures 24 and 25. Specifying a 0 for the stages argument results in the creation of a simple
wire between sRst and dRstOut.

                            Figure 24: Module for asynchronous resets

336                         c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkAsyncReset            Provides synchronization of a source reset (sRst) to the destination
                        domain. The output reset occurs immediately once the source reset is
                        asserted.

                        module mkAsyncReset #( Integer stages,
                                                            Reset sRst,
                                                            Clock dClkIn )

                                                         ( Reset ) ;

mkAsyncResetFromCR      Provides synchronization of the current reset to the destination do-
                        main. There is no source reset sRst argument because it is taken
                        from the current reset. The output reset occurs immediately once the
                        current reset is asserted.

                        module mkAsyncResetFromCR #( Integer stages,
                                                                      Clock dClkIn )

                                                                  ( Reset ) ;

The less common mkSyncReset modules are provided for convenience, but these modules require
that sRst be held during a positive edge of dClkIn for the reset assertion to be detected. Both
mkSyncReset and mkSyncResetFromCR use the model in ﬁgure 25.

                        Figure 25: Module for synchronous resets

mkSyncReset             Provides synchronization of a source reset (sRst) to the destination
                        domain. The reset is asserted at the next rising edge of the clock.

                        module mkSyncReset #( Integer stages
                                                          Reset sRst,
                                                          Clock dClkIn )

                                                       ( Reset ) ;

                        c 2008 Bluespec, Inc. All rights reserved  337


Reference Guide                                               Bluespec SystemVerilog

mkSyncResetFromCR  Provides synchronization of the current reset to the destination do-
                   main. The reset is asserted at the next rising edge of the clock.

                   module mkSyncResetFromCR #( Integer stages
                                                               Clock dClkIn )

                                                            ( Reset ) ;

Example: instantiating a reset synchronizer

    // 2 is the number of stages
    Reset rstn2 &lt;- mkAsyncResetFromCR (2, clk0);
    // if stages = 0, the default reset is used directly
    Reset rstn0 &lt;- mkAsyncResetFromCR (0, clk0);

Reset Generation Two modules are provided for reset generation, mkReset and mkResetSync,
where each module has one parameter, stages. The stages parameter is the number of full clock
cycles the output reset is held after the inRst, as seen in ﬁgure 26, is deasserted. Specifying a 0
for the stages parameter results in the creation of a simple wire between the input register and
the output reset. That is, the reset is asserted immediately and not held after the input reset is
deasserted. It becomes the designer’s responsibility to ensure that the input reset is asserted for
suﬃcient time to allow the design to reset properly. The reset is controlled using the assertReset
method of the MakeResetIfc interface.

The diﬀerence between mkReset and mkResetSync is that for the former, the assertion of reset
is immediate, while the later asserts reset at the next rising edge of the clock. Note that use of
mkResetSync is less common, since the reset requires clock edges to take eﬀect; failure to assert
reset for a clock edge will result in a reset not being seen at the output reset.

                   Figure 26: Module for generating resets

338                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkReset                 Provides conversion of a Boolean type to a Reset type, where the reset
                        is associated with dClkIn. This module uses the model in ﬁgure 26.
                        startInRst indicates the reset value of the register. If startInRst
                        is True, the reset value of the register is 0, which means the output
                        reset will be asserted whenever the currentReset (sRst) is asserted.
                        rst_out will remain asserted for the number of clock cycles given
                        by the stages parameter after sRst is deasserted. If startInRst is
                        False, the output reset will not be asserted when sRst is asserted,
                        but only when the assert_reset method is invoked. At the start of
                        simulation rst_out will only be asserted if startinRst is True and
                        sRst is initially asserted.

                        module mkReset #( Integer stages,
                                                    Bool startInRst,
                                                    Clock dClkIn )

                                                 ( MakeResetIfc ) ;

mkResetSync             Provides conversion of a Boolean type to a Reset type, where the reset
                        is associated with dClkIn and the assertion of reset is at the next
                        rising edge of the clock. This module uses the model in ﬁgure 26.
                        startInRst indicates the reset value of the register. If startInRst
                        is True, the reset value of the register is 0, which means the output
                        reset will be asserted whenever the currentReset (sRst) is asserted.
                        rst_out will remain asserted for the number of clock cycles given
                        by the stages parameter after sRst is deasserted. If startInRst is
                        False, the output reset will not be asserted when sRst is asserted,
                        but only when the assert_reset method is invoked. At the start of
                        simulation rst_out will only be asserted if startinRst is True and
                        sRst is initially asserted.

                        module mkResetSync #( Integer stages,
                                                          Bool startInRst,
                                                          Clock dClkIn )

                                                       ( MakeResetIfc ) ;

A reset multiplexor mkResetMux, as seen in ﬁgure 27, creates one reset signal by selecting between
two existing reset signals.

                        Figure 27: Reset Multiplexor

                        c 2008 Bluespec, Inc. All rights reserved  339


Reference Guide                                             Bluespec SystemVerilog

mkResetMux       Multiplexor which selects between two input resets, aRst and bRst,
                 to create a single output reset rst_out. The reset is selected through
                 a Boolean value provided to the select method where True selects
                 aRst.

                 module mkResetMux #( Reset aRst, Reset bRst )
                                               ( MuxRstIfc rst_out ) ;

For testbenches, in which an absolute clock is being created, it is helpful to generate a reset for
that clock. The module mkInitialReset is available for this purpose. It generates a reset which is
asserted at the start of simulation. The reset is asserted for the number of cycles speciﬁed by the
parameter cycles, counting the start of time as 1 cycle. Therefore, a cycles value of 1 will cause
the reset to turn oﬀ at the ﬁrst clock tick. This module is not synthesizable.

mkInitialReset   Generates a reset for cycles cycles, where the cycles parameter must
                 be greater than zero. The clocked_by clause indicates the clock the
                 reset is associated with. This module is not synthesizable.

                 module mkInitialReset #( Integer cycles )
                                                     ( Reset ) ;

Example:

      Clock c &lt;- mkAbsoluteClock (10, 5);
      // a reset associated with clock c:
      Reset r &lt;- mkInitialReset (2, clocked_by c);

When two reset signals need to be combined so that some logic can be reset when either input reset
is asserted, the mkResetEither module can be used.

                 Figure 28: Reset Either

mkResetEither    Generates a reset which is asserted whenever either input reset is as-
                 serted.

                 module mkResetEither ( Reset aRst,
                                                     Reset bRst)

                                                  ( Reset out_ifc );

Example:
      Reset r &lt;- mkResetEither(rst1, rst2);

340              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

mkResetInverter         Generates an inverted Reset.

                        module mkResetInverter#(Reset in)
                                                            (Reset);

Verilog Modules

The BSV modules correspond to the following Verilog modules, which are found in the Bluespec
Verilog library, $BLUESPECDIR/Verilog/.

BSV Module Name         Verilog Module Name  Comments

mkASyncReset            SyncReset0.v         when stages==0
mkASyncResetFromCR      SyncResetA.v
mkSyncReset             SyncReset0.v         when stages==0
mkSyncResetFromCR       SyncReset.v
mkReset                 MakeReset0.v         when stages==0
                        MakeResetA.v         instantiates SyncResetA
mkResetSync             MakeReset0.v         when stages==0
                        MakeReset.v          instantiates SyncReset
mkResetMux              ResetMux.v
mkResetEither           ResetEither.v
mkResetInverter         ResetInverter.v

C.9 Special Collections

C.9.1 ModuleCollect

Package

import ModuleCollect :: * ;

Description

The ModuleCollect package provides the capability of adding additional items, such as conﬁguration
bus connections, to a design in such a way that it does not change the structure of the design. This
section provides a brief overview of the package. For more description of its usage, see the CBus
package (C.9.2), which utilizes ModuleCollect. There is also a detailed example and more complete
discussion of the CBus package in the conﬁgbus tutorial in the BSV/tutorials directory.

An ordinary Bluespec module, when instantiated, adds its own state elements and rules to the grow-
ing accumulation of state elements and rules deﬁned in the design. In some designs, for example a
conﬁguration bus, additional items, such as the logic for the bus address decoding must be accumu-
lated as well. While there is a need to add these items, it is also desirable to keep these additional
design details separate from the main design, keeping the natural structure of the design intact.

The ModuleCollect mechanism allows the designer to hide the details of the additional interfaces. A
module which is going to be synthesized must contain only rules and state elements, as the compiler
does not know how to handle the additional items. Therefore, the collection must be brought into
the open, or exposed, before the module can be synthesized. The ModuleCollect package provides
the mechanisms to allow these additional items to be collected, processed and exposed.

Types and Type Classes

                        c 2008 Bluespec, Inc. All rights reserved     341


Reference Guide                                                          Bluespec SystemVerilog

The ModuleCollect type is a variation on Module that allows additional items, other than states and
rules, to be collected while elaborating the module structure. A module deﬁning the accumulation
of a special collection will have the type of ModuleCollect which is deﬁned as follows:

    struct ModuleCollect#(a_type, ifc)
              · · · abstract · · ·

where a_type deﬁnes the type of the items being collected. The collection is kept as a List, therfore
each item in the collection must have the same type. The collection is associated with ifc, the
device module interface.

Your new type of module is a ModuleCollect deﬁned to collect a speciﬁc type. It is often convenient
to give a name to your new type of module using the typedef keyword.

For example:

       typedef ModuleCollect#(element_type, ifc_device)
                    MyModuleType#(type ifc_device)

speciﬁes a type named MyModuleType.

An ordinary module, one not collecting anything other than rules and state elements has the type
Module. When no type is explicitly given, the compiler ﬁxes it to Module when the module is
synthesized. But for a module accumulating a collection, the type must be explicitly given, and it is
supplied in square brackets immediately after the keyword module. Because in our example above,
the new type alias only takes one argument, the interface, we can use it here without arguments:

      module [MyModuleType] mkSubDesign#(x,y) (IfcType) ;

Since only modules of type Module can be synthesized the collection be exposed before synthesis,
by applying the function exposeCollection. The module type of the function exposeCollection
is Module, so once the collection has been exposed the design is ready for synthesis.

Interfaces

The IWithCollection interface couples the normal module interface (the device interface) with
the collection of collected items (the collection interface). This is the interface provided by the
exposeCollection function. It separates the collection list and the device module interface, to allow
the module to be synthesized.

    interface IWithCollection #(type collection_type, type item_type);
         interface item_type device();
         interface List#(collection_type) collection();

    endinterface: IWithCollection

Modules and Functions

In the course of evaluating a module body during its instantiation, an item may be added to the
current collection by using the function addToCollection.

addToCollection Adds an item to the collection.

                           function ModuleCollect#(a_type, ifc)
                                          addToCollection(a_type item);

342              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                     Reference Guide

Once a set of items has been collected, those items must be exposed before synthesis. The exposeCollection
module constructor is used to bring the collection out into the open. The exposeCollection
module takes as an argument a ModuleCollect module (m) with interface ifc, and provides an
IWithCollection interface.

 exposeCollection Expose the collection to allow the module to be synthesized.

               module exposeCollection#(ModuleCollect#(a_type, ifc) m)
                                                     (IWithCollection#(a_type, ifc));

Finally, the ModuleCollect package provides a function, mapCollection, to apply a function to
each item in the current collection.

mapCollection  Apply a function to each item added to the collection within the second
               argument.

               function ModuleCollect#(a_type, ifc)
                   mapCollection(function a_type x1(a_type x1),
                                         ModuleCollect#(a_type, ifc) x2);

Example - Assertion Wires

// This example shows excerpts of a design which places various
// test conditions (Boolean expressions) at random places in a design,
// and lights an LED (setting an external wire to 1), if the condition
// is ever satisfied.

import ModuleCollect::*;
import List::*;
import Vector::*;
import Assert::*;

// The desired interface at the top level is:
interface AssertionWires#(type n);

    method Bit#(n) wires;
    method Action clear;
endinterface

// The &quot;wires&quot; method tells which conditions have been set, and the
// &quot;clear&quot; method resets them all to 0.
// The items in our extra collection will be interfaces of the
// following type:

interface AssertionWire;   //Indicates which wire is to be set if
    method Integer index;  // fail method ever returns true.
    method Bool fail;
    method Action clear;

endinterface

// We next define the &quot;AssertModule&quot; type. This is to behave like an
// ordinary module providing an interface of type &quot;i&quot;, except that it
// also can collect items of type &quot;AssertionWire&quot;:

                           c 2008 Bluespec, Inc. All rights reserved                   343


Reference Guide                                             Bluespec SystemVerilog

typedef ModuleCollect#(AssertionWire, i) AssertModule#(type i);

typedef Tuple2#(AssertionWires#(n), i) AssertIfc#(type i, type n);

...

// The next definition shows how items are added to the collection.
// This is the module which will be instantiated at various places in
// the design, to test various conditions. It takes one static
// parameter, &quot;ix&quot;, to specify which wire is to carry this condition,
// and one dynamic parameter (one varying at run-time) &quot;c&quot;, giving the
// value of the condition itself.

interface AssertionReg;
    method Action set;
    method Action clear;

endinterface

module [AssertModule] mkAssertionReg#(Integer ix)(AssertionReg);

    Reg#(Bool) cond &lt;- mkReg(False);

    // an item is defined and added to the collection
    let item = (interface AssertionWire;

                          method index;
                               return (ix);

                          endmethod
                          method fail;

                               return(cond);
                          endmethod
                          method Action clear;

                                 cond &lt;= False;
                          endmethod
                       endinterface);
    addToCollection(item);
    ...
endmodule

// the collection must be exposed before synthesis
module [Module] exposeAssertionWires#(AssertModule#(i) mkI)(AssertIfc#(i, n));

    IWithCollection#(AssertionWire, i) ecs &lt;- exposeCollection(mkI);

    ...(c_ifc is created from the list ecs.collection)

    // deliver the array of values in the registers
    let dut_ifc = ecs.device;

    // return the values in the collection, and the ifc of the device
    return(tuple2(c_ifc, dut_ifc));
endmodule

344              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

C.9.2 CBus

Package

import CBus :: * ;

Description

The CBus package provides the interface, types and modules to implement a conﬁguration bus
capability providing access to the control and status registers in a given module hierarchy. This
package utilizes the ModuleCollect package and functionality, as described in section C.9.1. The
ModuleCollect package allows items in addition to usual state elements and rules to be accumulated.
This is required to collect up the interfaces of the control status registers included in a module and
to add the associated logic and ports required to allow them to be accessed via a conﬁguration bus.

This package is provided as both a compiled library package and as BSV source code to facilitate
customization. The source code ﬁle can be found in the $BLUESPECDIR/BSVSource directory. To
customize a package, copy the ﬁle into a local directory and then include the local directory in the
path when compiling. This is done by specifying the path with the -p option as described in the
BSV Users Guide.

For a more complete discussion of the CBus package, consult the conﬁgbus tutorial in the BSV/tutorials
directory.

Types and Type Classes

The type CBusItem deﬁnes the type of item to be collected by ModuleCollect. The items to be
collected are the same as the ifc which we will later expose, so we use a type alias:

typedef CBus#(size_address, size_data)
            CBusItem #(type size_address, type size_data);

The type ModWithCBus deﬁnes the type of module which is collecting CBusItems. An ordinary
module, one not collecting anything other than state elements and rules, has the type Module. Since
CBusItems are being collected, a module type ModWithCBus is deﬁned. When the module type is
not Module, the type must be speciﬁed in square brackets immediately after the module keyword in
the module deﬁnition.

typedef ModuleCollect#(CBusItem#(size_address, size_data), item)
            ModWithCBus#(type size_address, type size_data, type item);

Interface and Methods

The CBus interface provides read and write methods to access control status registers. It is poly-
morphic in terms of the size of the address bus (size_address) and size of the data bus (size_data).

                        CBus Interface

Name   Description
write
read   Writes the data value to the register if and only if the value of
       addr matches the address of the register.

       Returns the value of the associated register if and only if addr
       matches the register address. In all other cases the read method
       returns an Invalid value.

                        c 2008 Bluespec, Inc. All rights reserved         345


Reference Guide                                             Bluespec SystemVerilog

interface CBus#(type size_address, type size_data);
    method Action write(Bit#(size_address) addr, Bit#(size_data) data);
    (* always_ready *)
    method ActionValue#(Bit#(size_data)) read(Bit#(size_address) addr);

endinterface

The IWithCBus interface combines the CBus interface with a normal module interface. It is deﬁned as
a structured interface with two sub-interfaces: cbus_ifc (the associated conﬁguration bus interface)
and device_ifc (the associated device interface). It is polymorphic in terms of the type of the
conﬁguation bus interface and the type of the device interface.

interface IWithCBus#(type cbus_IFC, type device_IFC);
    interface cbus_IFC cbus_ifc;
    interface device_IFC device_ifc;

endinterface

Modules

The collectCBusIFC module takes as an argument a module with an IWithCBus interface, adds the
associated CBus interface to the current collection (using addToCollection from the ModuleCollect
package), and returns a module with the normal interface. Note that collectCBusIFC is of module
type ModWithCBus.

collectCBusIFC Adds the CBus to the collection and returns a module with just the device
                         interface.

                         module [ModWithCBus#(size_address, size_data)]
                                      collectCBusIFC#(Module#(IWithCBus#(
                                                               CBus#(size_address,size_data),i)) m)(i);

The exposeCBusIFC module is used to create an IWithCBus interface given a module with a normal
interface and an associated collection of CBusItems. This module takes as an argument a module
of type ModWithCBus and provides an interface of type IWithCBus. The exposeCBusIFC module
exposes the collected CBusItems, processes them, and provides a new combined interface. This
module is synthesizable, because it is of type Module.

exposeCBusIFC    A module wrapper that takes a module with a normal interface, processes the
                 collected CBusItems and provides an IWithCBus interface.

                 module [Module] exposeCBusIFC#(ModWithCBus#(
                                    size_address, size_data, item) sm)
                                    (IWithCBus#(CBus#(size_address, size_data), item));

The CBus package provides a set of module primitives each of which adds a CBus interface to the
collection and provides a normal Reg interface from the local block point of view. These modules are
used in designs where a normal register would be used, and can be read and written to as registers
from within the design.

346              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkCBRegR   A wrapper to provide a read only CBus interface to the collection and a normal
           Reg interface to the local block.

           module [ModWithCBus#(size_address, size_data)]
                      mkCBRegR#(CRAddr#(size_address2) addr, r x)
                                     (Reg#(r))

               provisos (Bits#(r, sr), Add#(k, sr, size_data),
                               Add#(ignore, size_address2, size_address));

mkCBRegRW  A wrapper to provide a read/write CBus interface to the collection and a
           normal Reg interface to the local block.

           module [ModWithCBus#(size_address, size_data)]
                      mkCBRegRW#(CRAddr#(size_address2) addr, r x)
                                     (Reg#(r))

               provisos (Bits#(r, sr), Add#(k, sr, size_data),
                               Add#(ignore, size_address2, size_address));

mkCBRegW   A wrapper to provide a write only CBus interface to the collection and a
           normal Reg interface to the local block.

           module [ModWithCBus#(size_address, size_data)]
                      mkCBRegW#(CRAddr#(size_address2) addr, r x)
                                     (Reg#(r))

               provisos (Bits#(r, sr), Add#(k, sr, size_data),
                               Add#(ignore, size_address2, size_address));

mkCBRegRC  A wrapper to provide a read/clear CBus interface to the collection and a
           normal Reg interface to the local block. This register can read from the conﬁg
           bus but the write is clear mode; for each write bit a 1 means clear, while a 0
           means don’t clear.

           module [ModWithCBus#(size_address, size_data)]
                      mkCBRegRC#(CRAddr#(size_address2) addr, r x)
                                     (Reg#(r))

               provisos (Bits#(r, sr), Add#(k, sr, size_data),
                               Add#(ignore, size_address2, size_address));

The mkCBRegFile module wrapper adds a CBus interface to the collection and provides a RegFile
interface to the design. This module is used in designs as a normal RegFile would be used.

                        c 2008 Bluespec, Inc. All rights reserved  347


Reference Guide                                                   Bluespec SystemVerilog

mkCBRegFile      A wrapper to provide a normal RegFile interface and automatically add the
                 CBus interface to the collection.

                 module [ModWithCBus#(size_address, size_data)]
                            mkCBRegFile#(Bit#(size_address) reg_addr,
                                                Bit#(size_address) size)
                                                (RegFile#(Bit#(size_address), r))

                     provisos (Bits#(r, sr), Add#(k, sr, size_data));

Example

Provided here is a simple example of a CBus implementation. The example is comprised of three
packages: CfgDefines, Block, and Tb. The CfgDefines package contains the deﬁnition for the
conﬁguration bus, Block is the design block, and Tb is the testbench which executes the block.

The Block package contains the local design. As seen in Figure 29, the conﬁguration bus registers
look like a single ﬁeld from the CBus (cfgResetAddr, cfgStateAddr, cfgStatusAddr), while each
ﬁeld (reset, init, cnt, etc.) in the conﬁguration bus registers looks like a regular register from
from the local block point of view.

                 Figure 29: CBus Registers used in Block example

import CBus::*;  // this is a Bluespec library

import CfgDefines::*; // user defines - address,registers, etc

interface Block;
    // TODO: normally this block would have at least a few methods
    // Cbus interface is hidden, but it is there

endinterface

// In order to access the CBus at this parent, we need to expose the bus.
// Only modules of type [Module] can be synthesized.
module [Module] mkBlock(IWithCBus#(DCBus, Block));

    let ifc &lt;- exposeCBusIFC( mkBlockInternal );
    return ifc;
endmodule

// Within this module the CBus looks like normal Registers.
// This module can’t be synthesized directly.

348              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

// How these registers are combined into CBus registers is
// defined in the CfgDefines package.

module [DModWithCBus] mkBlockInternal( Block );

// all registers are read/write from the local block point of view

// config register interface types can be

// mkCBRegR -&gt; read only from config bus

// mkCBRegRW -&gt; read/write from config bus

// mkCBRegW -&gt; write only from config bus

// mkCBRegRC -&gt; read from config bus, write is clear mode

//                      i.e. for each bit a 1 means clear, 0 means don’t clear

// reset bit is write only from config bus

// we presume that you use this bit to fire some local rules, etc

Reg#(TCfgReset) reg_reset_reset &lt;- mkCBRegW(cfg_reset_reset, 0 /* init val */);

Reg#(TCfgInit)          reg_setup_init  &lt;- mkCBRegRW(cfg_setup_init,  0 /* init val */);
Reg#(TCfgTz)            reg_setup_tz    &lt;- mkCBRegRW(cfg_setup_tz,    0 /* init val */);
Reg#(TCfgCnt)           reg_setup_cnt   &lt;- mkCBRegRW(cfg_setup_cnt,   1 /* init val */);

Reg#(TCfgOnes) reg_status_ones &lt;- mkCBRegRC(cfg_status_ones, 0 /* init val */);
Reg#(TCfgError) reg_status_error &lt;- mkCBRegRC(cfg_status_error, 0 /* init val */);

// USER: you know have registers, so do whatever it is you do with registers :)
// for instance
rule bumpCounter ( reg_setup_cnt != unpack(’1) );

    reg_setup_cnt &lt;= reg_setup_cnt + 1;
endrule

    rule watch4ones ( reg_setup_cnt == unpack(’1) );
         reg_status_ones &lt;= 1;

    endrule
endmodule

The CfgDefines package contains the user deﬁnes describing how the local registers are combined
into the conﬁguration bus.

package CfgDefines;
import CBus::*;

////////////////////////////////////////////////////////////////////////////////
/// basic defines
////////////////////////////////////////////////////////////////////////////////
// width of the address bus, it’s easiest to use only the width of the bits needed
// but you may have other reasons for passing more bits around (even if some address
// bits are always 0)
typedef 2 DCBusAddrWidth; // roof( log2( number_of_config_registers ) )

// the data bus width is probably defined in your spec
typedef 32 DCBusDataWidth; // how wide is the data bus

////////////////////////////////////////////////////////////////////////////////

// Define the CBus

////////////////////////////////////////////////////////////////////////////////

typedef CBus#( DCBusAddrWidth,DCBusDataWidth)           DCBus;

                        c 2008 Bluespec, Inc. All rights reserved               349


Reference Guide                                                   Bluespec SystemVerilog

typedef CRAddr#(DCBusAddrWidth,DCBusDataWidth)   DCAddr;

typedef ModWithCBus#(DCBusAddrWidth, DCBusDataWidth, i) DModWithCBus#(type i);

////////////////////////////////////////////////////////////////////////////////

/// Configuration Register Types

////////////////////////////////////////////////////////////////////////////////

// these are configuration register from your design. The basic

// idea is that you want to define types for each individual field

// and later on we specify which address and what offset bits these

// go to. This means that config register address fields can

// actually be split across modules if need be.

//

typedef bit      TCfgReset;

typedef Bit#(4) TCfgInit;
typedef Bit#(6) TCfgTz;
typedef UInt#(8) TCfgCnt;

typedef bit      TCfgOnes;
typedef bit      TCfgError;

////////////////////////////////////////////////////////////////////////////////
/// configuration bus addresses
////////////////////////////////////////////////////////////////////////////////
Bit#(DCBusAddrWidth) cfgResetAddr = 0; //
Bit#(DCBusAddrWidth) cfgStateAddr = 1; //
Bit#(DCBusAddrWidth) cfgStatusAddr = 2; // maybe you really want this to be 0,4,8 ???

////////////////////////////////////////////////////////////////////////////////

/// Configuration Register Locations

////////////////////////////////////////////////////////////////////////////////

// DCAddr is a structure with two fields

//   DCBusAddrWidth a ; // this is the address

//                     // this does a pure comparison

//   Bit#(n)           o ; // this is the offset that this register

//                     // starts reading and writting at

DCAddr cfg_reset_reset = DCAddr {a: cfgResetAddr, o: 0}; // bits 0:0

DCAddr cfg_setup_init  = DCAddr {a: cfgStateAddr, o: 0}; // bits 0:0
DCAddr cfg_setup_tz    = DCAddr {a: cfgStateAddr, o: 4}; // bits 9:4
DCAddr cfg_setup_cnt   = DCAddr {a: cfgStateAddr, o: 16}; // bits 24:16

DCAddr cfg_status_ones = DCAddr {a: cfgStatusAddr, o: 0}; // bits 0:0
DCAddr cfg_status_error = DCAddr {a: cfgStatusAddr, o: 0}; // bits 1:1

////////////////////////////////////////////////////////////////////////////////
///
////////////////////////////////////////////////////////////////////////////////
endpackage

The Tb package executes the block.

import CBus::*;        // bluespec library

350                    c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                Reference Guide

import CfgDefines::*; // address defines, etc

import Block::*;        // test block with cfg bus

import StmtFSM::*; // just for creating a test sequence

(* synthesize *)
module mkTb ();

    // In order to access this cfg bus we need to use IWithCBus type
    IWithCBus#(DCBus,Block) dut &lt;- mkBlock;

Stmt test =
seq

    // write the bits need to the proper address
    // generally this comes from software or some other packing scheme
    // you can, of course, create functions to pack up several fields
    // and drive that to bits of the correct width
    // For that matter, you could have your own shadow config registers
    // up here in the testbench to do the packing and unpacking for you
    dut.cbus_ifc.write( cfgResetAddr, unpack(’1) );

// put some ones in the status bits
dut.cbus_ifc.write( cfgStateAddr, unpack(’1) );

// show that only the valid bits get written
$display(&quot;TOP: state = %x at &quot;, dut.cbus_ifc.read( cfgStateAddr ), $time);

// clear out the bits
dut.cbus_ifc.write( cfgStateAddr, 0 );

// but the ’ones’ bit was set when it saw all ones on the count
// so read it to see that...
$display(&quot;TOP: status = %x at &quot;, dut.cbus_ifc.read( cfgStatusAddr ), $time);

// now clear it
dut.cbus_ifc.write( cfgStatusAddr, 1 );

// see that it’s clear
$display(&quot;TOP: status = %x at &quot;, dut.cbus_ifc.read( cfgStatusAddr ), $time);

         // and if we had other interface methods, that where not part of CBUS
         // we would access them via dut.device_ifc
    endseq;
    mkAutoFSM( test );
endmodule

C.10 AzureIP Libraries

This section describes the Bluespec AzureIP library components. These components can be used
to build complex, fully synthesizable designs. Each component is provided in one or more BSV
packages, deﬁning the interfaces and data structures used to communicate to other components.

These library components are provided as BSV source code to facilitate customization. Users can
easily understand and then extend the IP to implement additional features as required for their
applications. The source code ﬁles can be found in the $BLUESPECDIR/BSVSource directory. To

                        c 2008 Bluespec, Inc. All rights reserved               351


Reference Guide                                             Bluespec SystemVerilog

modify the ﬁles, copy the ﬁles into a local directory and use the -p compile option, as described in
the BSV Users Guide, to include the local directory in your path.

C.10.1 TLM

Description

The TLM package includes deﬁnitions of interfaces, data structures, and module constructors which
allow users to create and modify bus-based designs in a manner that is independent of any one
speciﬁc bus protocol. Bus operations are deﬁned in terms of generic bus payload data structures.
Other protocol speciﬁc packages include transactor modules that convert a stream of TLM bus
operations into corresponding operations in a speciﬁc bus protocol. Designs created using the TLM
package are thus more portable (because that they allow the core design to be easily applied to
multiple bus protocols). In addition, since the speciﬁc signalling details of each bus protocol are
encapsulated in pre-designed transactors, users are not required to learn, re-implement, and re-verify
existing standard protocols.

Packages

The elements of the TLM library are deﬁned within TLM package.

To include the package in your design, use the import syntax.

import TLM :: * ;

Data Structures

The two basic data structures deﬁned in the TLM package are TLMRequest and TLMResponse. By
using these types in a design, the underlying bus protocol can be changed without having to modify
the interactions with the TLM objects.

TLMRequest A TLM request contains either control information and data, or data alone. A
TLMRequest is tagged as either a RequestDescriptor or RequestData. A RequestDescriptor
contains control information and data while a RequestData contains only data.

typedef union tagged {RequestDescriptor#(‘TLM_TYPES) Descriptor;
                                  RequestData#(‘TLM_TYPES) Data;

                                 } TLMRequest#(‘TLM_TYPE_PRMS) deriving(Eq, Bits, Bounded);

RequestDescriptor The table below describes the components of a RequestDescriptor and the
valid values for each of its members.

352              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                  Reference Guide

   Member Name                              RequestDescriptor           Valid Values
                              DataType
command
mode                    TLMCommand                     READ, WRITE, UNKNOWN
addr                    TLMMode                        REGULAR, DEBUG, CONTROL
data                    TLMAddr#(‘TLM_TYPES)           Bit#(addr_size)
burst_length            TLMData#(‘TLM_TYPES)           Bit#(data_size)
byte_enable             TLMUint#(‘TLM_TYPES)           UInt#(uint_size)
burst_mode              TLMByteEn#(‘TLM_TYPES)         Bit#(TDiv#(data_size, 8))
burst_size              TLMBurstMode                   INCR, CNST, WRAP, UNKNOWN
prty                    TLMBurstSize#(‘TLM_TYPES)      Bit#(TLog#(TDiv#(data_size, 8)))
thread_id               TLMUInt#(‘TLM_TYPES)           UInt#(uint_size)
transaction_id          TLMId#(‘TLM_TYPES)             Bit#(id_size)
export_id               TLMId#(‘TLM_TYPES)             Bit#(id_size)
custom                  TLMId#(‘TLM_TYPES)             Bit#(id_size)
                        TLMCustom#(‘TLM_TYPES)         cstm_type

typedef struct {TLMCommand                      command;

                TLMMode                         mode;

                TLMAddr#(‘TLM_TYPES)            addr;

                TLMData#(‘TLM_TYPES)            data;

                TLMUInt#(‘TLM_TYPES)            burst_length;

                TLMByteEn#(‘TLM_TYPES) byte_enable;

                TLMBurstMode                    burst_mode;

                TLMBurstSize#(‘TLM_TYPES) burst_size;

                TLMUInt#(‘TLM_TYPES)            prty;

                TLMId#(‘TLM_TYPES)              thread_id;

                TLMId#(‘TLM_TYPES)              transaction_id;

                TLMId#(‘TLM_TYPES)              export_id;

                TLMCustom#(‘TLM_TYPES) custom;

                } RequestDescriptor#(‘TLM_TYPE_PRMS) deriving (Eq, Bits, Bounded);

RequestData The table below describes the components of a RequestData and the valid values
for its members.

   Member Name                                 RequestData              Valid Values
                              DataType
data
transaction_id          TLMData#(‘TLM_TYPES)           Bit#(data_size)
custom                  TLMId#(‘TLM_TYPES)             Bit#(id_size)
                        TLMCustom#(‘TLM_TYPES)         cstm_type

typedef struct {TLMData#(‘TLM_TYPES) data;
                         TLMId#(‘TLM_TYPES) transaction_id;
                         TLMCustom#(‘TLM_TYPES) custom;

                       } RequestData#(‘TLM_TYPE_PRMS) deriving (Eq, Bits, Bounded);

TLMResponse The table below describes the components of a TLMResponse and the valid values
for its members.

                         c 2008 Bluespec, Inc. All rights reserved                    353


Reference Guide                                             Bluespec SystemVerilog

                                       TLMResponse

   Member Name              DataType                            Valid Values

command          TLMCommand                      READ, WRITE, UNKNOWN
data
status           TLMData#(‘TLM_TYPES)            Bit#(data_size)
prty             TLMStatus                       SUCCESS, ERROR, NO RESPONSE
thread_id
transaction_id   TLMUInt#(‘TLM_TYPES)            UInt#(uint_size)
export_id
custom           TLMId#(‘TLM_TYPES)              Bit#(id_size)

                 TLMId#(‘TLM_TYPES)              Bit#(id_size)

                 TLMId#(‘TLM_TYPES)              Bit#(id_size)

                 TLMCustom#(‘TLM_TYPES)          cstm_type

typedef struct {TLMCommand            command;

                 TLMData#(‘TLM_TYPES) data;

                 TLMStatus            status;

                 TLMUInt#(‘TLM_TYPES) prty;

                 TLMId#(‘TLM_TYPES) thread_id;

                 TLMId#(‘TLM_TYPES) transaction_id;

                 TLMId#(‘TLM_TYPES) export_id;

                 TLMCustom#(‘TLM_TYPES) custom;

                 } TLMResponse#(‘TLM_TYPE_PRMS) deriving (Eq, Bits, Bounded);

Conﬁgurable Parameters

In the above BSV code deﬁnitions the compiler macros ‘TLM_TYPE_PRMS and ‘TLM_TYPES are used in
the typedef statements. A ’define statement is a preprocessor construct used to place prepackaged
text values into a ﬁle, as described in Section 2.7.1. In this case, the macros contain parameters
to be used in the data deﬁnitions. Placing the parameters in a separate ﬁle allows them to be
easily modiﬁed for diﬀerent protocol requirements. For convenience, we have predeﬁned a few useful
deﬁnitions for use in the TLM package.

The TLM_TYPE_PRMS macro contains type deﬁnition parameters which are used in the interface
deﬁnitions or as arguments to TLM types and interfaces.

The TLM_TYPES macro is used when providing the interface or using the data type. TLM_TYPES is
still polymorphic.

The macro TLM_STD_TYPES provides speciﬁc values for the polymorphic values deﬁned above. The
values deﬁned in TLM_STD_TYPES are common values. The user can change any of the values or
deﬁne other corresponding macros (with diﬀerent values) as appropriate for a given design.

The macros are found in the ﬁle TLM.defines. A sample of the contents of the ﬁle are displayed
below.

‘define TLM_TYPE_PRMS numeric type id_size, numeric type addr_size, \
                                  numeric type data_size, numeric type uint_size, type cstm_type

‘define TLM_TYPES id_size, addr_size, data_size, uint_size, cstm_type
‘define TLM_STD_TYPES 4, 32, 32, 10, Bit#(0)

Interfaces

The TLM interfaces deﬁne how TLM blocks interconnect and communicate. The TLM package
includes two basic interfaces: The TLMSendIFC interface and the TLMRecvIFC interface. These inter-
faces use basic Get and Put subinterfaces as the requests and responses, as described in Section C.6.1.
The TLMSendIFC interface generates (Get) requests and receives (Put) responses. The TLMRecvIFC
interface receives (Put) requests and generates (Get) responses. Additional TLM interfaces are built
up from these basic blocks.

354              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

TLMSendIFC The TLMSendIFC interface transmits the requests and receives the responses.

                        TLMSendIFC Interface

Name  Type                            Description
tx
rx    Get#(TLMRequest#(‘TLM_TYPES))   Transmits a request through the Get interface

      Put#(TLMResponse#(‘TLM_TYPES))  Receives a response through the Put interface

interface TLMSendIFC#(‘TLM_TYPE_PRMS);
    interface Get#(TLMRequest#(‘TLM_TYPES)) tx;
    interface Put#(TLMResponse#(‘TLM_TYPES)) rx;

endinterface

TLMRecvIFC The TLMRecvIFC interface receives the requests and transmits the responses.

Name  Type              TLMRecvIFC Interface
tx                                         Description
rx
      Get#(TLMResponse#(‘TLM_TYPES))  Transmits the response through the Get interface
      Put#(TLMRequest#(‘TLM_TYPES))   Receives the request through the Put interface

interface TLMRecvIFC#(‘TLM_TYPE_PRMS);
    interface Get#(TLMResponse#(‘TLM_TYPES)) tx;
    interface Put#(TLMRequest#(‘TLM_TYPES)) rx;

endinterface

As illustrated in Figure 30, a TLMSendIFC is connectable to a TLMRecvIFC, just as a Get is connectable
to a Put. A transmitted request (tx) from a TLMSendIFC is received (rx) by the TLMRecvIFC and
visa versa.

            Figure 30: Connecting TLM Send And Receive Interfaces

instance Connectable#(TLMSendIFC#(‘TLM_TYPES), TLMRecvIFC#(‘TLM_TYPES));

A module with a TLMSendIFC interface creates a stream of requests. A module with a TLMRecvIFC
interface receives the requests and transmits responses. Some bus protocols have separate channels
for read and write operations. In these cases it is useful to have interfaces which bundle together
two sends or two receives. The TLMReadWriteSendIFC interface includes two send interfaces while
the TLMReadWriteRecvIFC interface bundles two receives.

                        c 2008 Bluespec, Inc. All rights reserved                       355


Reference Guide                                             Bluespec SystemVerilog

TLMReadWriteSendIFC The TLMReadWriteSendIFC interface is composed of two TLMSendIFC
subinterfaces, one for a read channel and one for a write channel.

      interface TLMReadWriteSendIFC#(‘TLM_TYPE_PRMS);
           interface TLMSendIFC#(‘TLM_TYPES) read;
           interface TLMSendIFC#(‘TLM_TYPES) write;

      endinterface

TLMReadWriteRecvIFC The TLMReadWriteRecvIFC interface is composed of two TLMRecvIFC
subinterfaces, one for a read channnel and one for a write channel.

      interface TLMReadWriteRecvIFC#(‘TLM_TYPE_PRMS);
           interface TLMRecvIFC#(‘TLM_TYPES) read;
           interface TLMRecvIFC#(‘TLM_TYPES) write;

      endinterface

As illustreated in Figure 31, the TLMReadWriteSendIFC and TLMReadWriteRecvIFC interfaces are
connectable as well.

                 Figure 31: TLM Read/Write Interfaces

instance Connectable#(TLMReadWriteSendIFC#(‘TLM_TYPES), TLMReadWriteRecvIFC#(‘TLM_TYPES));

TLMTransformIFC The TLMTransformIFC provides a single TLMRecvIFC interface and a sin-
gle TLMSendIFC interface. This interface is useful in modules which convert one stream of TLM
operations into another. It is the interface provided by mkTLMReducer module for instance.

      interface TLMTransformIFC#(‘TLM_TYPE_PRMS);
           interface TLMRecvIFC#(‘TLM_TYPES) in;
           interface TLMSendIFC#(‘TLM_TYPES) out;

      endinterface

Modules

The TLM package includes modules for creating and modifying TLM objects: mkTLMRandomizer,
mkTLMSource, and mkTLMReducer. Two TLM RAM modules are also provided: mkTLMRam which
provides a single read/write port and mkTLMReadWriteRam which provides two ports, a separate one
for reads and a separate one for writes.

356              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

                        Figure 32: TLMTransformIFC Interface

mkTLMRandomizer         Creates a stream of random TLM operations. The argument m_command is a Maybe
                        type which determines if the TLMRequests will be reads, writes, or both. A value
                        of Valid READ will generate only reads, a value of Valid WRITE will generate only
                        writes, and an Invalid value will generate both reads and writes. The Randomize
                        interface is deﬁned in the Randomizable package.

                        module mkTLMRandomizer#(Maybe#(TLMCommand) m_command)
                                                            (Randomize#(TLMRequest#(‘TLM_TYPES)))

                            provisos(Bits#(RequestDescriptor#(‘TLM_TYPES), s0),
                                           Bounded#(RequestDescriptor#(‘TLM_TYPES)),
                                           Bits#(RequestData#(‘TLM_TYPES), s1),
                                           Bounded#(RequestData#(‘TLM_TYPES)));

mkTLMSource             Creates a wrapper around the mkTLMRandomize module. The provided inter-
                        face is now a TLMSendIFC interface which both sends TLMRequests and re-
                        ceives TLMResponses. The argument m_command has the same meaning as in
                        mkTLMRandomizer. The verbose argument controls whether or not $display out-
                        puts are provide when sending and receiving TLM objects.

                        module mkTLMSource#(Maybe#(TLMCommand) m_command, Bool verbose)
                                                      (TLMSendIFC#(‘TLM_STD_TYPES));

mkTLMReducer            Converts a stream of (arbitrary) TLM operations into a stream with only single
                        reads and single writes.

                        module mkTLMReducer (TLMTransformIFC#(‘TLM_TYPES))
                            provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                           Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                           Bits#(RequestDescriptor#(‘TLM_TYPES), s2));

                        c 2008 Bluespec, Inc. All rights reserved  357


Reference Guide                                               Bluespec SystemVerilog

                   Figure 33: TLMRAM

mkTLMRam           Creates a TLM RAM with a single port for read and write operations. Provides the
                   TLMRecvIFC interface. The verbose argument controls whether or not $display
                   output is provided when performing a memory operation. The id argument pro-
                   vides an identiﬁer for the instantiation which is used in the $display output if the
                   verbose ﬂag is asserted.

                   module mkTLMRam#(parameter Bit#(4) id, Bool verbose)
                                            (TLMRecvIFC#(‘TLM_TYPES))

                       provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                      Bits#(TLMResponse#(‘TLM_TYPES), s1));

                   Figure 34: TLMReadWriteRAM

mkTLMReadWriteRam  Creates a RAM with separate ports for read and write operations. Provides the
                   TLMReadWriteRecvIFC interface. The verbose argument controls whether or not
                   $display output is provided when performing a memory operation. The id ar-
                   gument provides an identiﬁer for the instantiation which is used in the $display
                   output if the verbose ﬂag is asserted.

                   module mkTLMReadWriteRam#(parameter Bit#(4) id, Bool verbose)
                                                          (TLMReadWriteRecvIFC#(‘TLM_TYPES))

                       provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                      Bits#(TLMResponse#(‘TLM_TYPES), s1));

The mkTLMCBusAdapter module creates an adapter which allows the CBus (Section C.9.2) to be
accessed via a TLM interface.

358                c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkTLMCBusAdapter Takes a TLMCBus interface as an argument. Provides the TLMRecvIFC interface.

                             module mkTLMCBusAdapter#(TLMCBus#(‘TLM_TYPES, caddr_size) cfg)
                                                                    (TLMRecvIFC#(‘TLM_TYPES))

                                  provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                    Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                    Add#(ignore, caddr_size, addr_size));

mkTLMCBusAdapterToReadWrite  Takes a TLMCBus interface as an argument. Provides the
                             TLMReadWriteRecvIFC interface. This conﬁguration provides separate
                             ports for read and write operations.

                             module mkTLMCBusAdapterToReadWrite#
                                                         (TLMCBus#(‘TLM_TYPES, caddr_size) cfg)
                                                         (TLMReadWriteRecvIFC#(‘TLM_TYPES))

                                 provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                   Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                   Add#(ignore, caddr_size, addr_size));

Functions

createBasicRequestDescriptor Returns a generic TLM request with default values.

                                               function RequestDescriptor#(‘TLM_TYPES)
                                                             createBasicRequestDescriptor()

                                                    provisos(Bits#(RequestDescriptor#(‘TLM_TYPES), s0));

createBasicTLMResponse Returns a generic TLM response with default values.

                                      function TLMResponse#(‘TLM_TYPES) createBasicTLMResponse()
                                           provisos(Bits#(TLMResponse#(‘TLM_TYPES), s0));

C.10.2 AXI

Description

The AXI library includes interface, transactor, module and function deﬁnitions to implement the
Advanced eXtensible Interface (AXI) protocol with Bluespec SystemVerilog. The BSV AXI library
groups the AXI data and protocols into reusable, parameterized interfaces, which interact with TLM
interfaces. An AXI bus is implemented using AXI transactors to connect TLM interfaces on one
side with AXI interfaces on the other side.

The AXI library supports the following AXI Bus protocol features:

                        c 2008 Bluespec, Inc. All rights reserved  359


Reference Guide                                             Bluespec SystemVerilog

    • Basic and Burst Transfers
    • Aligned and Unaligned Transfers

The AXI library does not support the following AXI Bus protocol features:

    • Exclusive/Locked Access
    • Low Power Interface
    • Cache Transaction Attributes

The basic structure of an AXI write bus is show in ﬁgure 35. The structure of a read bus is similar.
(Note that the nature of the AXI protocol is such that the read and write buses operate totally
independently of each other).

                                         Figure 35: AXI Write Bus Example

The corresponding BSV AXI implementation is shown in ﬁgure 36. TLM Write requests are received
via the TLMRecvIFC interfaces of the master transactors. The request is then transmitted via the
AxiWrMaster interface out onto the AXI bus and on to the appropriate slave transactor. The slave
transactor receives the request via the AxiWrSlave interface, translates the request back into a
stream of TLM objects, and then transmits those objects via the TLMSendIFC interface. The TLM
response from the write operation follows the same path in reverse.

          Figure 36: BSV AXI Write Bus Implementation Using TLM Transactors

Packages         c 2008 Bluespec, Inc. All rights reserved
360


Bluespec SystemVerilog                                             Reference Guide

The transactors, interfaces, data structures, modules, and functions for implementing the AXI bus
are deﬁned in the AXI package.

To include a package in your design, use the import syntax.

import Axi :: * ;

Data Structures

Inside the transactor modules, the AXI data is organized into the following data structures: the
address data is deﬁned by AxiAddrCmd, the read response is deﬁned by AxiRdResp, the write data
is deﬁned by AxiWrData and the write response is deﬁned by AxiWrResp.

AxiAddrCmd The AXI Address Bus is deﬁned by a structure, AxiAddrCmd, the components of
which are described in the following table.

                                          AxiAddrCmd

 Member Name                    DataType                           Valid Values

id                 AxiId#(‘TLM_TYPES)     Bit#(id_size)
len                AxiLen                 Bit#(4)
size               AxiSize                Bit#(3)
burst              AxiBurst               FIXED, INCR, WRAP
lock               AxiLock                NORMAL, EXCLUSIVE, LOCKED
cache              AxiCache
prot               AxiProt                Bit#(4)
addr               AxiAddr#(‘TLM_TYPES)   Bit#(3)
                                          Bit#(addr_size)

typedef struct {

              AxiId#(‘TLM_TYPES) id;

              AxiLen    len;

              AxiSize   size;

              AxiBurst  burst;

              AxiLock   lock;

              AxiCache  cache;

              AxiProt   prot;

              AxiAddr#(‘TLM_TYPES) addr;

              } AxiAddrCmd#(‘TLM_TYPE_PRMS) deriving(Bits,Eq);

AxiRdResp The AXI Read Bus is deﬁned by the AxiRdResp structure, the components of which
are described in the following table.

                                          AxiRdResp

 Member Name                    DataType                           Valid Values

id                 AxiId#(‘TLM_TYPES)     Bit#(id_size)
data               AxiData#(‘TLM_TYPES)   Bit#(data_size)
resp               AxiResp                OKAY, EXOKAY, SLVERR, DECERR
last               Bool                   True, False

                        c 2008 Bluespec, Inc. All rights reserved                361


Reference Guide                                                      Bluespec SystemVerilog

typedef struct {

                 AxiId#(‘TLM_TYPES) id;

                 AxiData#(‘TLM_TYPES) data;

                 AxiResp                 resp;

                 Bool                    last;

                 } AxiRdResp#(‘TLM_TYPE_PRMS) deriving(Bits,Eq);

The AXI Write Bus is deﬁned by two structures, AxiWrData and AxiWrResp.

AxiWrData The components of AxiWrData are described in the following table.

                                          AxiWrData

 Member Name              DataType                                   Valid Values

id                AxiId#(‘TLM_TYPES)            Bit#(id_size)
data
strb              AxiData#(‘TLM_TYPES)          Bit#(data_size)
last
                  AxiByteEn#(‘TLM_TYPES)        Bit#(TDiv#(data_size, 8))
                  Bool                          True, False

typedef struct {

                 AxiId#(‘TLM_TYPES) id;

                 AxiData#(‘TLM_TYPES) data;

                 AxiByteEn#(‘TLM_TYPES) strb;

                 Bool                    last;

                 } AxiWrData#(‘TLM_TYPE_PRMS) deriving(Bits,Eq);

AxiWrResp The components of AxiWrResp are described in the following table.

                                          AxiWrResp

 Member Name                   DataType                              Valid Values
id                AxiId#(‘TLM_TYPES)
resp              AxiResp                       Bit#(id_size)
                                                OKAY, EXOKAY, SLVERR, DECERR

typedef struct {

                 AxiId#(‘TLM_TYPES) id;

                 AxiResp                 resp;

                 } AxiWrResp#(‘TLM_TYPE_PRMS) deriving(Bits,Eq);

Bus Interfaces

This section describes the AXI bus master and slave interfaces used by the AXI transactor modules.
Since the AXI protocol supports read and write operations on separate buses, two ﬂavors of each
interface exist, one for reads and one for writes.

AxiRdMaster The AxiRdMaster interface issues AXI read requests and receives AXI read re-
sponses.

interface AxiRdMaster#(‘TLM_TYPE_PRMS);
    // Address Outputs
    method AxiId#(‘TLM_TYPES) arID;

362                       c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

method AxiAddr#(‘TLM_TYPES) arADDR;

method AxiLen              arLEN;

method AxiSize             arSIZE;

method AxiBurst            arBURST;

method AxiLock             arLOCK;

method AxiCache            arCACHE;

method AxiProt             arPROT;

method Bool                arVALID;

// Address Inputs
method Action arREADY(Bool value);

// Response Outputs           rREADY;
method Bool

// Response Inputs

method Action rID (AxiId#(‘TLM_TYPES) value);

method Action rDATA (AxiData#(‘TLM_TYPES) value);

method Action rRESP (AxiResp             value);

method Action rLAST (Bool                value);

method Action rVALID(Bool                value);

endinterface

AxiWrMaster The AxiWrMaster interface issues AXI write requests and receives AXI write re-
sponses.

interface AxiWrMaster#(‘TLM_TYPE_PRMS);

// Address Outputs

method AxiId#(‘TLM_TYPES) awID;

method AxiAddr#(‘TLM_TYPES) awADDR;

method AxiLen              awLEN;

method AxiSize             awSIZE;

method AxiBurst            awBURST;

method AxiLock             awLOCK;

method AxiCache            awCACHE;

method AxiProt             awPROT;

method Bool                awVALID;

// Address Inputs
method Action awREADY(Bool value);

// Data Outputs

method AxiId#(‘TLM_TYPES) wID;

method AxiData#(‘TLM_TYPES) wDATA;

method AxiByteEn#(‘TLM_TYPES) wSTRB;

method Bool                   wLAST;

method Bool                   wVALID;

// Data Inputs
method Action wREADY(Bool value);

// Response Outputs           bREADY;
method Bool

                        c 2008 Bluespec, Inc. All rights reserved  363


Reference Guide                                                       Bluespec SystemVerilog

     // Response Inputs

     method Action bID (AxiId#(‘TLM_TYPES) value);

     method Action bRESP (AxiResp         value);

     method Action bVALID(Bool            value);

endinterface

AxiRdSlave The AxiRdSlave interface receives AXI read requests and returns AXI read re-
sponses.

interface AxiRdSlave#(‘TLM_TYPE_PRMS);

     // Address Inputs

     method Action arID (AxiId#(‘TLM_TYPES) value);

     method Action arADDR (AxiAddr#(‘TLM_TYPES) value);

     method Action arLEN (AxiLen          value);

     method Action arSIZE (AxiSize        value);

     method Action arBURST(AxiBurst       value);

     method Action arLOCK (AxiLock        value);

     method Action arCACHE(AxiCache       value);

     method Action arPROT (AxiProt        value);

     method Action arVALID(Bool           value);

     // Address Outputs
     method Bool arREADY;

     // Response Inputs
     method Action rREADY(Bool value);

     // Response Outputs

     method AxiId#(‘TLM_TYPES) rID;

     method AxiData#(‘TLM_TYPES) rDATA;

     method AxiResp              rRESP;

     method Bool                 rLAST;

     method Bool                 rVALID;

endinterface

AxiWrSlave The AxiWrSlave interface receives AXI write requests and returns AXI write re-
sponses.

interface AxiWrSlave#(‘TLM_TYPE_PRMS);

     // Address Inputs

     method Action awID (AxiId#(‘TLM_TYPES) value);

     method Action awADDR (AxiAddr#(‘TLM_TYPES) value);

     method Action awLEN (AxiLen          value);

     method Action awSIZE (AxiSize        value);

     method Action awBURST(AxiBurst       value);

     method Action awLOCK (AxiLock        value);

     method Action awCACHE(AxiCache       value);

     method Action awPROT (AxiProt        value);

     method Action awVALID(Bool           value);

     // Address Outputs

364                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

method Bool awREADY;

// Data Inputs

method Action wID (AxiId#(‘TLM_TYPES)          value);

method Action wDATA (AxiData#(‘TLM_TYPES) value);

method Action wSTRB (AxiByteEn#(‘TLM_TYPES) value);

method Action wLAST (Bool                      value);

method Action wVALID(Bool                      value);

// Data Ouptuts
method Bool wREADY;

// Response Inputs
method Action bREADY(Bool value);

// Response Outputs

method AxiId#(‘TLM_TYPES) bID;

method AxiResp             bRESP;

method Bool                bVALID;

endinterface

The AxiRdMaster and AxiRdSlave interfaces as well as the AxiWrMaster and AxiWrSlave interfaces
are connectable.

instance Connectable#(AxiRdMaster#(‘TLM_TYPES), AxiRdSlave#(‘TLM_TYPES));
instance Connectable#(AxiWrMaster#(‘TLM_TYPES), AxiWrSlave#(‘TLM_TYPES));

Fabric Interfaces

When used in the context of a bus or switch, AXI transactor modules must communicate with address
decoding logic. As with the BSV implementation of the AHB bus, bus fabric interfaces are provided
to support this communication. Unlike the AHB protocol however, with the AXI bus protocol no
explicit communication between the arbiter and the master transactor modules is required. Thus
the AxiRdFabricMaster and AxiWrFabricMaster interfaces are simply wrappers around the bus
interfaces themselves.

interface AxiRdFabricMaster#(‘TLM_TYPE_PRMS);
    interface AxiRdMaster#(‘TLM_TYPES) bus;

endinterface

interface AxiWrFabricMaster#(‘TLM_TYPE_PRMS);
    interface AxiWrMaster#(‘TLM_TYPES) bus;

endinterface

The AxiRdFabricSlave and AxiWrFabricSlave interfaces each provide an addrMatch method which
given an AXI address returns an Boolean value indicating whether the given address maps to the
associated slave. By polling this method for each slave on the bus, the decoding logic can determine
the appropriate destination for each bus transaction.

interface AxiRdFabricSlave#(‘TLM_TYPE_PRMS);
    interface AxiRdSlave#(‘TLM_TYPES) bus;
    method Bool addrMatch(AxiAddr#(‘TLM_TYPES) value);

endinterface

                        c 2008 Bluespec, Inc. All rights reserved          365


Reference Guide                                             Bluespec SystemVerilog

interface AxiWrFabricSlave#(‘TLM_TYPE_PRMS);
    interface AxiWrSlave#(‘TLM_TYPES) bus;
    method Bool addrMatch(AxiAddr#(‘TLM_TYPES) value);

endinterface

Transactor Interfaces

Each AXI transactor module provides AXI and TLM interfaces to implement a translation between
a stream of TLM operations and the AXI bus protocol. Each transactor has two subinterfaces:
a subinterface for the connection with the AXI bus and a subinterface to send and receive TLM
objects. The AXI library package includes two master transactor interfaces and two slave trans-
actor interfaces; The AXIRdMasterXActor and AXIWrMasterXActor interfaces for masters and the
AXIRdSlaveXActor and AXIWrSlaveXActor interfaces for slaves. Since the AXI protocol supports
read and write transaction on separate buses, two transactor implementations are required for mas-
ters and two implementations for slaves. The AXI subinterface deﬁnitions can be found in section
C.10.2. The TLM interfaces are described in Section C.10.1.

AxiRdMasterXActorIFC The AxiRdMasterXActorIFC has two subinterfaces: an AxiRdFabricMaster
subinterface and a TLMRecvIFC subinterface. The associated transactor converts TLM read requests
into the AXI protocol, and converts the AXI response back into TLM.

interface AxiRdMasterXActorIFC#(‘TLM_TYPE_PRMS);

     interface TLMRecvIFC#(‘TLM_TYPES)  tlm;

     interface AxiRdFabricMaster#(‘TLM_TYPES) fabric;

endinterface

AxiWrMasterXActorIFC The AxiWrMasterXActorIFC has two subinterfaces: an AxiWrFabricMaster
subinterface and a TLMRecvIFC subinterface. The associated transactor converts TLM write requests
into the AXI protocol, and converts the AXI response back into TLM.

interface AxiWrMasterXActorIFC#(‘TLM_TYPE_PRMS);

     interface TLMRecvIFC#(‘TLM_TYPES)  tlm;

     interface AxiWrFabricMaster#(‘TLM_TYPES) fabric;

endinterface

              Figure 37: AXIMasterXActor Interfaces (Read and Write Versions)

366              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

AxiRdSlaveXActorIFC The AxiRdSlaveXActorIFC has two subinterfaces: an AxiRdFabricSlave
subinterface and a TLMSendIFC subinterface. The associated transactor converts an AXI read request
into TLM and the TLM response back into the AXI protocol.

interface AxiRdSlaveXActorIFC#(‘TLM_TYPE_PRMS);

interface TLMSendIFC#(‘TLM_TYPES)  tlm;

interface AxiRdFabricSlave#(‘TLM_TYPES) fabric;

endinterface

AxiWrSlaveXActorIFC The AxiWrSlaveXActorIFC has two subinterfaces: an AxiWrFabricSlave
subinterface and a TLMSendIFC subinterface. The associated transactor converts an AXI write re-
quest into TLM and the TLM response back into the AXI protocol.

interface AxiWrSlaveXActorIFC#(‘TLM_TYPE_PRMS);

interface TLMSendIFC#(‘TLM_TYPES)  tlm;

interface AxiWrFabricSlave#(‘TLM_TYPES) fabric;

endinterface

                      Figure 38: AXISlaveXActor Interfaces (Read and Write Versions)

Modules
The following constructors are used to create AXI transactor modules. Versions with associated syn-
thesis boundaries are also available. These versions are called mkAxiRdMasterStd, mkAxiWrMasterStd,
mkAxiRdSlaveStd, and mkAxiWrSlaveStd. The speciﬁc TLM parameter values for these synthesized
versions are as speciﬁed by the preprocessor macro TLM_STD_TYPES (see section C.10.1).

mkAxiRdMaster           Creates an AXI master read transactor module.             Provides an
                        AxiRdMasterXActorIFC interface.

                        module mkAxiRdMaster (AxiRdMasterXActorIFC#(‘TLM_TYPES))
                            provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                           Bits#(TLMResponse#(‘TLM_TYPES), s1));

                        c 2008 Bluespec, Inc. All rights reserved                 367


Reference Guide                                             Bluespec SystemVerilog

mkAxiWrMaster    Creates an AXI master write transactor module.            Provides an
                 AxiWrMasterXActorIFC interface.

                 module mkAxiWrMaster (AxiWrMasterXActorIFC#(‘TLM_TYPES))
                     provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                    Bits#(TLMResponse#(‘TLM_TYPES), s1));

mkAxiRdSlave     Creates an AXI slave read transactor module. Provides an AxiRdSlaveXActorIFC
                 interface.

                 module mkAxiRdSlave#(function Bool
                                                  addr_match(AxiAddr#(‘TLM_TYPES) addr))
                                                  (AxiRdSlaveXActorIFC#(‘TLM_TYPES))

                     provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                    Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                    Bits#(RequestDescriptor#(‘TLM_TYPES), s2));

mkAxiWrSlave     Creates an AXI slave write transactor module. Provides an AxiWrSlaveXActorIFC
                 interface.

                 module mkAxiWrSlave#(function Bool
                                                  addr_match(AxiAddr#(‘TLM_TYPES) addr))
                                                  (AxiWrSlaveXActorIFC#(‘TLM_TYPES))

                     provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                    Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                    Bits#(RequestDescriptor#(‘TLM_TYPES), s2));

The following two module constructors are each used to create an AXI bus fabric. mkAxiRdBus is
used to create a read bus while mkAxiWrBus is used to create a write bus.

mkAxiRdBus       Given a vector of AxiRdFabricMaster interfaces and a vector of AxiRdFabricSlave
                 interfaces, mkAxiRdBus creates an AXI read bus.

                 module mkAxiRdBus#(Vector#(master_count,
                                                           AxiRdFabricMaster#(‘TLM_TYPES)) masters,

                                               Vector#(slave_count,
                                                           AxiRdFabricSlave#(‘TLM_TYPES))slaves) (Empty);

368              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkAxiWrBus              Given a vector of AxiWrFabricMaster interfaces and a vector of AxiWrFabricSlave
                        interfaces, mkAxiWrBus creates an AXI write bus.

                        module mkAxiWrBus#(Vector#(master_count,
                                                                  AxiWrMaster#(‘TLM_TYPES)) masters,

                                                      Vector#(slave_count,
                                                                  AxiWrSlave#(‘TLM_TYPES)) slaves) (Empty);

The following module is used to add probe signals for each of the AXI bus signals. This facilitates
debugging and waveform viewing of the created bus fabric.

mkAxiMonitor            Adds a probe module for each of the AXI bus signals. The include_pc value
                        indicates whether or not the monitor module should include an instantiation of an
                        AXI protocol checker module (available from ARM). If the protocol checker is not
                        available, the value of include_pc should be set to False.

                        module mkAxiMonitor#(Bool include_pc,
                                                         AxiWrMaster#(‘TLM_TYPES) master_wr,
                                                         AxiWrSlave#(‘TLM_TYPES) slave_wr,
                                                         AxiRdMaster#(‘TLM_TYPES) master_rd,
                                                         AxiRdSlave#(‘TLM_TYPES) slave_rd)
                                                         (AxiMonitor#(‘TLM_TYPES));

C.10.3 AHB

Description
The AHB library includes interface, transactor, module and function deﬁnitions to implement the
AHB protocol with Bluespec SystemVerilog. The BSV AHB library groups the AHB data and
protocols into reusable, parameterized interfaces, which interact with TLM interfaces. An AHB bus
is implemented using AHB transactors - interfaces which connect TLM interfaces on one side with
AHB interfaces on the other side.
The AHB library supports the following AHB Bus protocol features:

    • Basic and Burst Transfers
    • Locked Transfers

The AHB library does not support the following AHB Bus protocol features:

    • Early Burst Termination
    • Split Transfers
    • Retry Transfers

                        c 2008 Bluespec, Inc. All rights reserved  369


Reference Guide                                                       Bluespec SystemVerilog

                           Figure 39: AHB Bus Example

Packages
The transactors, interfaces, data structures, and modules for the AHB bus are deﬁned within the
AHB package.
To include a package in your design, use the import syntax.

import AHB :: * ;

Data Structures
Inside the transactor modules, the AHB data is organized into the following data structures: the
address and control information is deﬁned by AHBCntrl, the write data is deﬁned by AHBData.
These two structures are bundled into an AHBRequest. Finally, the response data is deﬁned by
AHBResponse.

AHBRequest An AHB request is deﬁned by the AHBRequest structure as described below.

                                         AHBRequest

     Member                DataType                                   Valid Values
cntrl
data              AHBCntrl#(‘TLM_TYPES)  see above

                  AHBData                Bit#(data_size)

typedef struct {

                 AHBCntrl#(‘TLM_TYPES) cntrl;

                 AHBData#(‘TLM_TYPES)    data;

                 } AHBRequest#(‘TLM_TYPE_PRMS) ‘dv;

AHBCntrl The control ﬁelds in an AHBRequest are described by the AHBCntrl structure, the
components of which are deﬁned in the following table.

370                        c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

     Member                    DataType  AHBCntrl
command           AHBWrite                                               Valid Values
size              AHBSize
                                               READ, WRITE
burst             AHBBurst                     BITS8, BITS16, BITS32, BITS64, BITS128,
                                               BITS256, BITS512, BITS1024
transfer          AHBTransfer                  SINGLE, INCR, WRAP4, INCR4, WRAP8, INCR8,
prot              AHBProt                      WRAP16, INCR16
addr              AHBAddr#(‘TLM_TYPES)         IDLE, BUSY, NONSEQ, SEQ
                                               Bit#(4)
                                               Bit#(addr_size)

typedef struct {

             AHBWrite                    command;

             AHBSize                     size;

             AHBBurst                    burst;

             AHBTransfer                 transfer;

             AHBProt                     prot;

             AHBAddr#(‘TLM_TYPES) addr;

             } AHBCntrl#(‘TLM_TYPE_PRMS) ‘dv;

AHBResponse An AHBResponse consists of a status ﬁelds and data (when responding to a read
request). The components of the structure are described in the following table.

     Member                    DataType  AHBResponse
status            AHBResp                                                   Valid Values
data              AHBData
                                                 OKAY, ERROR, RETRY, SPLIT
                                                 Bit#(data_size)

typedef struct {

             AHBResp                     status;

             AHBData#(‘TLM_TYPES) data;

             } AHBResponse#(‘TLM_TYPE_PRMS) ‘dv;

Bus Interfaces

The two basic bus interfaces included in the AHB library are the AHBMaster interface and the
AHBSlave interface.

AHBMaster The AHBMaster interface issues AHB requests and receives AHB responses.

interface AHBMaster#(‘TLM_TYPE_PRMS);

// Outputs

method AHBAddr#(‘TLM_TYPES) hADDR;

method AHBData#(‘TLM_TYPES) hWDATA;

method AHBWrite           hWRITE;

method AHBTransfer        hTRANS;

method AHBBurst           hBURST;

method AHBSize            hSIZE;

method AHBProt            hPROT;

                        c 2008 Bluespec, Inc. All rights reserved                         371


Reference Guide                                                     Bluespec SystemVerilog

                     Figure 40: AHB Master Interface

    // Inputs        hRDATA(AHBData#(‘TLM_TYPES) data);
    method Action
    method Action    hREADY(Bool                        value);
    method Action
endinterface         hRESP (AHBResp                     response);

AHBSlave The AHBSlave interface receives AHB requests and returns AHB responses.

                     Figure 41: AHB Slave Interface

interface AHBSlave#(‘TLM_TYPE_PRMS);

     // Inputs

     method Action   hADDR (AHBAddr#(‘TLM_TYPES) addr);

     method Action   hWDATA(AHBData#(‘TLM_TYPES) data);

     method Action   hWRITE(AHBWrite                    value);

     method Action   hTRANS(AHBTransfer                 value);

     method Action   hBURST(AHBBurst                    value);

     method Action   hSIZE (AHBSize                     value);

     method Action   hPROT (AHBProt                     value);

     // Outputs

     method AHBData#(‘TLM_TYPES) hRDATA;

     method Bool     hREADY;

     method AHBResp  hRESP;

endinterface

The AHBMaster and AHBSlave interfaces are connectable.

instance Connectable#(AHBMaster#(‘TLM_TYPES), AHBSlave#(‘TLM_TYPES));

Fabric Interfaces

When used in the context of a bus or switch, AHB Master and Slave modules must communicate
with the arbiter and with address decoding logic. Two additional interfaces are provided to support
this communication.

372                  c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

AHBMasterArbiter The AHBMasterArbiter interface connects the master module with the bus
arbiter. Through this interface, the master can request control of the bus and determine when
control has been granted.

interface AHBMasterArbiter;

method Bool             hBUSREQ();

method Bool             hLOCK ();

method Action           hGRANT (Bool value);

endinterface

AHBSlaveSelector The AHBSlaveSelector interface provides an addrMatch method which given
an AHB address returns an Boolean value indicating whether the given address maps to the associ-
ated slave. By polling this method for each slave on the bus, the decoding logic can determine the
appropriate destination for each bus transaction. The AHBSlaveSelector interface also provides a
select method by which the decoding logic can indicate which slave is the selected destination.

interface AHBSlaveSelector#(‘TLM_TYPE_PRMS);

method Bool addrMatch(AHBAddr#(‘TLM_TYPES) value);

method Action select (Bool                          value);

endinterface

AHBFabricMaster The AHBFabricMaster interface bundles two sub-interfaces, an AHBMaster
interface and an AHBMasterArbiter interface. It is this interface that is provided as an argument
when constructing an AHB bus and as the bus side interface of an AHB master transactor module.

interface AHBFabricMaster#(‘TLM_TYPE_PRMS);

interface AHBMaster#(‘TLM_TYPES) bus;

interface AHBMasterArbiter          arbiter;

endinterface

AHBFabricSlave The AHBFabricSlave interface bundles two sub-interfaces, an AHBSlave inter-
face and an AHBSlaveSelector interface. It is this interface that is provided as an argument when
constructing an AHB bus and as the bus side interface of an AHB slave transactor module

interface AHBFabricSlave#(‘TLM_TYPE_PRMS);

interface AHBSlave#(‘TLM_TYPES)               bus;

interface AHBSlaveSelector#(‘TLM_TYPES) selector;

endinterface

Transactor Interfaces

An AHB transactor module provides AHB and TLM interfaces to implement a translation between
a stream of TLM operations and the AHB bus protocol. Each transactor has two subinterfaces:
a subinterface for the connection with the AHB bus and a subinterface to send and receive TLM
objects.

The AHB library package includes two transactor interfaces; The AHBMasterXActor interface for
the master and AHBSlaveXActor interface for the slave. The AHB protocol doesn’t separate read
and write transactions, so there is a single transactor implementation for masters and a single
implementation for slaves.

                        c 2008 Bluespec, Inc. All rights reserved  373


Reference Guide                                             Bluespec SystemVerilog

                 Figure 42: AHBMasterXActor Interface

AHBMasterXActorIFC The AHBMasterXActorIFC has two subinterfaces: an AHBFabricMaster
subinterface and a TLMRecvIFC subinterface. The TLM interface is described in Section C.10.1. The
transactor converts TLM requests into the AHB protocol, and converts the AHB response back into
TLM.

interface AHBMasterXActorIFC#(‘TLM_TYPE_PRMS)

     interface TLMRecvIFC#(‘TLM_TYPES)  tlm;

     interface AHBFabricMaster#(‘TLM_TYPES) fabric;

endinterface

                 Figure 43: AHBSlaveXActor Interface

AHBSlaveXActorIFC The AHBSlaveXActorIFC has two subinterfaces: AHBFabricSlave subin-
terface and a TLMSendIFC subinterface. The TLM interface is described in Section C.10.1. The
transactor converts an AHB request into TLM and the TLM response back into the AHB protocol.

interface AHBSlaveXActorIFC#(‘TLM_TYPE_PRMS);

     interface TLMSendIFC#(‘TLM_TYPES)  tlm;

     interface AHBFabricSlave#(‘TLM_TYPES) fabric;

endinterface

Modules

The following constructors are used to create AHB transactor modules. Versions with associated syn-
thesis boundaries are also available. These versions are called mkAHBMasterStd, and mkAHBSlaveStd.
The speciﬁc TLM parameter values for these synthesized versions are as speciﬁed by the preprocessor
macro TLM_STD_TYPES (see section C.10.1).

374              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                                 Reference Guide

mkAHBMaster             Creates an AHB Master transactor module. Provides a AHBMasterXActorIFC in-
                        terface.

                        module mkAHBMaster (AHBMasterXActorIFC#(‘TLM_TYPES))
                            provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                           Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                           Bits#(RequestDescriptor#(‘TLM_TYPES), s2));

mkAHBSlave              Creates an AHB Slave transactor module. Provides an AHBSlaveXActorIFC inter-
                        face.

                        module mkAHBSlave#(function Bool addr_match(AHBAddr#(‘TLM_TYPES)addr))
                                                      (AHBSlaveXActorIFC#(‘TLM_TYPES))

                            provisos(Bits#(TLMRequest#(‘TLM_TYPES), s0),
                                           Bits#(TLMResponse#(‘TLM_TYPES), s1),
                                           Bits#(RequestDescriptor#(‘TLM_TYPES), s2));

The following module constructor is used to create an AHB bus fabric.

mkAHBBus                Given a vector of AHBFabricMaster interfaces and a vector of AHBFabricSlave
                        interfaces, mkAHBBus creates an AHB bus fabric.

                        module mkAHBBus#(Vector#(master_count,
                                                               AHBFabricMaster#(‘TLM_TYPES)) masters,

                                                  Vector#(slave_count,
                                                               AHBFabricSlave#(‘TLM_TYPES)) slaves) (Empty);

The following module is used to add probe signals for each of the AHB bus signals. This facilitates
debugging and waveform viewing of the created bus fabric.

mkAHBMonitor            Adds a probe module for each of the AHB bus signals. The include_pc value
                        indicates whether or not the monitor module should include an instantiation of an
                        AHB protocol checker module (available from ARM). If the protocol checker is not
                        available, the value of include_pc should be set to False.

                        module mkAHBMonitor#(Bool include_pc,
                                                         AHBMaster#(‘TLM_TYPES) master,
                                                         AHBSlave#(‘TLM_TYPES) slave)

                                                       (AHBMonitor#(‘TLM_TYPES));

                        c 2008 Bluespec, Inc. All rights reserved      375


Index

!= (Eq class method), 146                         $stime, 92
&lt;&lt; (Bitwise class method), 150                    $stop, 92
&gt;&gt; (Bitwise class method), 150                    $swrite, 91
| (BitReduction class method), 151                $swriteAV, 91
| (Bitwise class method), 150                     $swriteb, 91
π (Real constant), 239                            $swritebAV, 91
&amp;&amp; (Bool operator), 156                           $swriteh, 91
(..) (exporting member names), 18                 $swritehAV, 91
* (Arith class method), 147                       $swriteo, 91
** (Arith class method), 147                      $swriteoAV, 91
*/ (close nested comment), 13                     $test$plusargs, 93
+ (String concatenation operator), 157            $time, 92
+ (Arith class method), 147                       $ungetc, 91
- (Arith class method), 147                       $write, 87
., see structs, member selection                  $writeb, 87
/ (Arith class div method), 147                   $writeh, 87
/* (open block comment), 13                       $writeo, 87
// (one-line comment), 13                         %(Arith class mod method), 147
&lt; (Ord class method), 149                         &amp; (BitReduction class method), 151
&lt;= (Reg assignment), 54                           &amp; (Bitwise class method), 150
&lt;= (Ord class method), 149                        _read (PulseWire interface method), 169
== (Eq class method), 146                         _read (Reg interface method), 85, 165
&gt; (Ord class method), 149                         _write (Reg interface method), 85, 165
&gt;= (Ord class method), 149                        {} (Bit concatenation operator), 154
? (don’t-care expression), 15, 63                 {} (concatenation of bit arrays), 65
[] (bit/part select from bit array), 65           $ (character in identiﬁers), 13
$bitstoreal (Real system function), 93, 157       _ (character in identiﬁers), 13
$display, 87                                      ‘, see compiler directives
$displayb, 87                                     ^~ (BitReduction class method), 151
$displayh, 87                                     ^ (BitReduction class method), 151
$displayo, 87                                     ^ (Bitwise class method), 150
$dumpoff, 92                                      ^&amp; (BitReduction class method), 151
$dumpon, 92                                       ˆ˜ (Bitwise class method), 150
$dumpvars, 92                                     ~^ (BitReduction class method), 151
$fclose, 89                                       ˜ (Bitwise class method), 150
$fdisplay, 90                                     ~| (BitReduction class method), 151
$fdisplayb, 90                                    ˜ˆ (Bitwise class method), 150
$fdisplayh, 90
$fdisplayo, 90                                    abs (function), 171
$fflush, 92                                       abs (Arith class method), 147
$fgetc, 91                                        acosh (Real function), 240
$finish, 92                                       Action (type), 161
$fopen, 89                                        actions
$fwrite, 90
$fwriteb, 90                                            Action (type), 66
$fwriteh, 90                                            action (keyword), 67
$fwriteo, 90                                            combining, 67
$realtobits (Real system function), 93, 157       ActionValue (type), 68, 161
$sformat, 91                                      Add (type provisos), 22, 163
$sformatAV, 91                                    addRules (Rules function), 162

                                             376


Bluespec SystemVerilog                                             Reference Guide

addToCollection (ModuleCollect function),        clock family=, 108
            342                                  clock preﬁx, 106
                                                 clocked by=, 109
AHB, 369                                         conﬂict free, 103
AHB (package), 370                               default clock gate=, 107
AHBAddr (data type), 370                         default clock osc=, 107
AHBBurst (data type), 370                        default reset=, 107
AHBData (data type), 370                         defualt gate inhigh=, 107
AHBMasterXActor (transactor), 373                defualt gate unused=, 107
AHBMasterXActorIFC (interface), 374              descending urgency, 100
AHBProt (data type), 370                         doc=, 110
AHBResponse (data type), 370                     enable=, 95
AHBSlaveXActor (transactor), 374                 execution order, 102
AHBSlaveXActorIFC (interface), 374               ﬁre when enabled, 98
AHBTransfer (data type), 370                     gate=, 108
AHBWrite (data type), 370                        gate default clock, 107
all (List function), 229                         gate inhigh, 108
all (Vector function), 208                       gate input clocks=, 107
always_enabled (attribute), 96                   gate preﬁx, 106
always_ready (attribute), 96                     gate unused, 108
ancestor(BVI import statement), 133              mutually exclusive, 103
and (List function), 230                         no implicit conditions, 99
any (List function), 229                         noinline, 94
any (Vector function), 208                       nosplit, 104
AOF (clock ancestor attribute), 108              osc=, 108
append (List function), 223                      port=, 96, 110
append (Vector function), 200                    preempts, 104
application                                      preﬁx=, 96
                                                 ready=, 95
      of functions to arguments, 70              reset=, 108
      of methods to arguments, 70                reset by=, 110
Arbiter (package), 273                           reset preﬁx, 106
Arith (type class), 21, 147                      result=, 96
      UInt, Int type instances, 84               split, 104
arrays                                           synthesize, 94
      update, 53                           attributes, 93
arrayToVector (Vector function), 222       await (StmtFSM function), 254
asIfc (interface pseudo-function), 86      AXI (package), 360
asinh (Real function), 240                 AxiAddrAxiAddr (data type), 361
asReg (Reg function), 85, 165              AxiAddrCmd (data structure), 361
Assert (package), 287                      AxiBurst (data type), 361
AssertFifoTest_IFC (interface), 297        AxiByteEn (data type), 362
AssertQuiescentTest_IFC (interface), 296   AxiCache (data type), 361
AssertSampleTest_IFC (interface), 295      AxiData (data type), 361, 362
AssertStartStopTest_IFC (interface), 296   AxiId (data type), 361, 362
AssertStartTest_IFC (interface), 295       AxiLen (data type), 361
AssertTest_IFC (interface), 295            AxiLock (data type), 361
AssertTransitionTest_IFC (interface), 296  AxiProtAxiProt (data type), 361
assignment statements                      AxiRdMaster (interface), 362
      pattern matching in, 82              AxiRdMasterXActorIFC (interface), 366
atan2 (Real function), 241                 AxiRdResp (data structure), 361
atanh (Real function), 240                 AxiRdSlave (interface), 364
attribute                                  AxiRdSlaveXActorIFC (interface), 367
      always enabled, 96                   AxiResp (data type), 361, 362
      always ready, 96
      clock ancestors=, 108

                        c 2008 Bluespec, Inc. All rights reserved                 377


Reference Guide                                             Bluespec SystemVerilog

AxiSize (data type), 361                     bsv_assert_one_hot (module), 304
AxiWrData (data structure), 362              bsv_assert_proposition (module), 304
AxiWrMaster (interface), 362                 bsv_assert_quiescent_state (module), 304
AxiWrMasterXActorIFC (interface), 366        bsv_assert_range (module), 304
AxiWrResp (data structure), 362              bsv_assert_time (module), 305
AxiWrSlave (interface), 364                  bsv_assert_transition (module), 305
AxiWrSlaveXActorIFC (interface), 367         bsv_assert_unchange (module), 305
                                             bsv_assert_width (module), 305
begin (keyword), 57, 66                      bsv_assert_win_change (module), 306
begin-end expression blocks, 66              bsv_assert_win_unchange (module), 306
begin-end statement blocks, 57               bsv_assert_window (module), 306
Bit (type), 83, 154                          bsv_assert_zero_one_hot (module), 306
bit (type), 83, 154                          BVI import (keyword)
bitconcat (Bit concatenation operator), 154
BitExtend (type class), 21, 153                    in interfacing to Verilog, 123
                                             BypassWire (interface), 168
      UInt, Int type instances, 84
BitReduction (type class), 21, 151           C (scheduling annotations), 45
                                             case (keyword), 58, 79, 80
      UInt, Int type instances, 84           case expression, 80
Bits (type class), 21, 118, 145              case statements

      deriving, 119                                ordinary, 58
      representation of data types, 119            pattern matching, 79
      UInt, Int type instances, 84           CBus (interface), 345
Bitwise (type class), 21, 150                CBus (package), 345
      UInt, Int type instances, 84           ceil (Real function), 241
Bool (type), 156                             CF (scheduling annotations), 45
Bounded (type class), 21, 150                CGetPut (package), 267
      deriving, 120                          clear (FIFOF interface method), 86
      UInt, Int type instances, 84           clear (FIFO interface method), 86
BRAM (interface type), 196                   Client (interface), 265
BRAM (package, 196                           ClientServer (package), 265
BRAMFIFO (package), 197                      Clock (type), 160, 308
BRAMRequest (type), 196                      clock_ancestors= (attribute), 108
bsv_assert_always (module), 299              clock_family= (attribute), 108
bsv_assert_always_on_edge (module), 299      clock_prefix= (attribute), 106
bsv_assert_change (module), 299              ClockDividerIfc (interface), 316
bsv_assert_cycle_sequence (module), 299      clocked_by=(attribute), 109
bsv_assert_decrement (module), 300           clockOf (function), 309
bsv_assert_delta (module), 300               Clocks (package), 308
bsv_assert_even_parity (module), 300         cmplx (complex function), 243
bsv_assert_fifo_index (module), 300          cmplxMap (complex function), 244
bsv_assert_frame (module), 300               cmplxSwap (complex function), 244
bsv_assert_handshake (module), 301           cmplxWrite (complex function), 244
bsv_assert_implication (module), 301         collectCBusIFC (module), 346
bsv_assert_increment (module), 301           comment
bsv_assert_never (module), 301                     block, 13
bsv_assert_never_unknown (module), 302             one-line, 13
bsv_assert_never_unknown_async (module),     compiler directives, 15
                                             compilerVersion, 174
            302                              CompletionBuffer (interface), 277
bsv_assert_next (module), 302                CompletionBuffer (package), 277
bsv_assert_no_overflow (module), 302         Complex (package), 243
bsv_assert_no_transition (module), 303       compose (function), 172
bsv_assert_no_underflow (module), 303        composeM (function), 172
bsv_assert_odd_parity (module), 303
bsv_assert_one_cold (module), 303

378              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

concat (List function), 224                     drop (List function), 226
concat (Vector function), 201                   drop (Vector function), 204
conditional expressions, 64                     dropWhile (List function), 226
                                                dropWhileRev (List function), 226
      pattern matching in, 81                   DualPortRamIfc (interface), 330
conditional statements, 58                      DWire (interface), 168
ConfigReg (package,interface), 193              dynamicAssert, 288
conflict_free (attribute), 103
Connectable (class), 264                        elem (List function), 229
Connectable (package), 264                      elem (Vector function), 207
Cons (List constructor), 223                    ‘else (compiler directive), 17
cons (List function), 223                       else (keyword), 58
cons (Vector function), 200                     ‘elsif (compiler directive), 17
constFn (function), 172                         Empty (interface), 27
context, see provisos                           emptyRules (Rules variable), 162
context too weak (overloading resolution), 115  enable= (attribute), 95
continuousAssert, 288                           end (keyword), 57, 66
Control (interface), 272                        ‘endif (compiler directive), 17
cos (Real function), 240                        endpackage (keyword), 18
cosh (Real function), 240                       enq (FIFOF interface method), 86
countElem (Vector function), 208                enq (FIFO interface method), 86
countIf (Vector function), 208                  enum, 47
countOnes (function), 173                       enumerations, 47
countOnesAlt (bit-vector function), 210         epsilon (ﬁxed-point function), 246
countZerosLSB (function), 173                   Eq (type class), 21, 146
countZerosMSB (function), 173
                                                      deriving, 120
date, 175                                             UInt, Int type instances, 84
decodeReal (Real function), 242                 error (compilation message), 171
default (keyword), 58, 79                       execution_order (attribute), 102
default_clock(BVI import statement), 128        exp_e (Arith class method), 147
default_clock_gate= (attribute), 107            export (keyword), 18
default_clock_osc= (attribute), 107             export, identiﬁers from a package, 18
default_gate_inhigh (attribute), 107            exposeCBusIFC (module), 346
default_gate_unused (attribute), 107            exposeCollection (ModuleCollect function),
default_reset(BVI import statement), 131
default_reset= (attribute), 107                             343
‘define (compiler directive), 16                exposeCurrentClock (function), 309
delay (StmtFSM function), 254                   exposeCurrentReset (function), 309
deq (FIFOF interface method), 86                extend (BitExtend class method), 153
deq (FIFO interface method), 86
deriving                                        False (Bool constant), 156
                                                FIFO (package), 179
      Bits, 119                                 FIFO (interface type), 86
      Bounded, 120                              FIFOCountIfc (interface), 187
      Eq, 120                                   FIFOF (package), 179
      brief description, 23                     FIFOF (interface type), 86
      for isomorphic types, 121                 fifofToFifo (function), 183
descending_urgency (attribute), 100             FIFOLevel (package), 186
dbgProbe (module), 285                          FIFOLevelIfc (interface), 186
Div (type provisos), 22, 163                    fifoToGet (GetPut function), 263
div (Integer function), 155                     fifoToPut (GetPut function), 263
doc= (attribute), 110                           File (type), 89
documentation attributes, 110                   select (filter function), 226
don’t-care expression, see ?                    findElem (Vector function), 208
DReg (package,interface), 194                   findIndex (Vector function), 208

                        c 2008 Bluespec, Inc. All rights reserved  379


Reference Guide                                             Bluespec SystemVerilog

ﬁnite state machines, 83                      grammar, 12
fire_when_enabled (attribute), 98             Gray (package), 276
first (FIFOF interface method), 86            GrayCounter (package), 275
first (FIFO interface method), 86             grayDecode (function), 276
FixedPoint (package), 245                     grayDecr (function), 277
flip (function), 172                          grayEncode (function), 276
floor (Real function), 242                    grayIncr (function), 277
Fmt (type), 157                               grayIncrDecr (function), 276
fold (List function), 234
fold (Vector function), 215                   head (List function), 225
foldl (List function), 234                    head (Vector function), 203
foldl (Vector function), 214                  higher order functions, 121
foldl1 (List function), 234
foldl1 (Vector function), 214                 id (function), 172
foldr (List function), 233                    Identiﬁer (grammar terminal), 13
foldr (Vector function), 214                  identiﬁer (grammar terminal), 13
foldr1 (List function), 234                   identiﬁers, 13
foldr1 (Vector function), 214
fromInt (ﬁxed-point function), 247                  case sensitivity, 13
fromInteger (Literal class method), 146             export from a package, 18
fromInteger (converting unsized integer lit-        import into a package, 19
                                                    qualiﬁed, 19
            erals to speciﬁc types), 14             static scoping, 19
fromMaybe (Maybe function), 158                     with $ as ﬁrst letter, 13
fromReal (RealLiteral class method), 147      if (keyword), 58
fromUInt (ﬁxed-point function), 247                 in method implicit conditions, 32
FShow (data type), 283                        if statements, 58
FShow (package), 283                                pattern matching in, 81
fshow (function), 285                         if-else statements, 58
FSMs, 83                                      ‘ifdef (compiler directive), 17
function calls, 70                            ‘ifndef (compiler directive), 17
function deﬁnitions, 60                       implicit conditions, 32
fxptGetFrac (ﬁxed-point function), 246              on interface methods, 32
fxptGetInt (ﬁxed-point function), 246         import (keyword), 18
fxptMult (ﬁxed-point function), 247           import, identiﬁers into a package, 19
fxptSignExtend (ﬁxed-point function), 248     import BDPI (keyword), 136
fxptTruncate (ﬁxed-point function), 248       ‘include (compiler directive), 15
fxptWrite (ﬁxed-point function), 248          inﬁx operators
fxptZeroExtend (ﬁxed-point function), 248           associativity, 64
                                                    precedence, 64
gate= (attribute), 108                              predeﬁned, 64
gate_default_clock (attribute), 107           init (List function), 225
gate_inhigh (attribute), 108                  init (Vector function), 203
gate_input_clocks= (attribute), 107           Inout (type), 161
gate_prefix= (attribute), 106                 inout(BVI import statement), 135
gate_unused (attribute), 108                  input_clock(BVI import statement), 127
GatedClockIfc (interface), 311                input_reset(BVI import statement), 130
genC, 174                                     instance (of overloading group), 114
generated clock port renaming, 106            instance (of type class), 114
genVector (Vector function), 200              Int (type), 84, 155
genVerilog, 174                               int (type), 84, 155
genWith (Vector function), 200                Integer (type), 84, 155
genWithM (Vector function), 220               Integer literals, 13
Get (interface), 260                          interface
GetPut (package), 260                               expression, 74

380              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

      instantiation, 29                     mapCollection (ModuleCollect function), 343
interface (keyword)                         mapM (Monad function on List), 238
                                            mapM (Monad function on Vector), 219
      in interface declarations, 25         mapM_ (List function), 238
      in interface expressions, 74          mapM_ (Vector function), 219
interfaces, 25                              mapPairs (List function), 235
      deﬁnition of, 23                      mapPairs (Vector function), 215
Invalid                                     match (keyword), 82
      tagged union member ofMaybe type, 51  Max (type provisos), 22, 163
Invalid (type constructor), 158             max (function), 171
invert (Bitwise class method), 150          maxBound (Bounded class method), 150
isAncestor (function), 309                  Maybe (type), 51, 158
isInfinite (Real function), 242             message (compilation message), 171
isNegativeZero (Real function), 242         meta notation, see grammar
isNull (List function), 229                 method(BVI import statement), 125
isValid (Maybe function), 158               method calls, 70
IWithCBus (interface), 345                  methods

joinActions (List function), 234                  of an interface, 25
joinActions (Vector function), 215                pattern matching in, 82
joinRules (List function), 235              min (function), 171
joinRules (Vector function), 215            minBound (Bounded class method), 150
                                            mkAbsoluteClock (module), 313
last (List function), 225                   mkAbsoluteClockFull (module), 313
last (Vector function), 203                 mkAHBMaster (module), 374
length (List function), 229                 mkAHBSlave (module), 374
let, 54                                     mkArbiter (module), 274
LevelFIFO, see FIFOLevel                    mkAsyncReset (module), 336
LFSR (package), 269                         mkAsyncResetFromCR (module), 336
‘line (compiler directive), 15              mkAutoFSM, 254
List (type), 223                            mkAxiRdMaster (module), 367
ListN (type), 222                           mkAxiRdSlave (module), 368
Literal (type class), 21, 146               mkAxiWrMaster (module), 367
                                            mkAxiWrSlave (module), 368
      UInt, Int type instances, 84          mkBRAM (module), 196
Literals                                    mkBypassWire (module), 168
                                            mkCBRegFile (module), 347
      Integer, 13                           mkCBRegR (module), 346
      real, 14                              mkCBRegRC (module), 347
      String, 14                            mkCBRegRW (module), 347
Log (type provisos), 22, 163                mkCBRegW (module), 347
log (Arith class method), 147               mkCClientServer (function), 268
log10 (Arith class method), 147             mkCGetPut (function), 268
log2 (Arith class method), 147              mkClientCServer (function), 268
logb (Arith class method), 147              mkClock (module), 311
loop statements                             mkClockDivider (module), 316
      statically unrolled, 59               mkClockDividerOffset (module), 316
      temporal, in FSMs, 251                mkClockInverter (module), 316
                                            mkClockMux (module), 314
macro invocation (compiler directive), 17   mkClockSelect (module), 315
MakeClockIfc (interface), 310               mkCompletionBuffer (module), 278
MakeResetIfc (interface), 335               mkConfigReg (module), 193
map (List function), 231                    mkConfigRegA (module), 193
map (Vector function), 212                  mkConfigRegU (module), 193
mapAccumL (List function), 237              mkConstrainedRandomizer (module), 272
mapAccumL (Vector function), 218
mapAccumR (List function), 237
mapAccumR (Vector function), 218

                        c 2008 Bluespec, Inc. All rights reserved  381


Reference Guide                                             Bluespec SystemVerilog

mkDepthParamFIFO (module), 182             mkResetMux (module), 339
mkDepthParamFIFOF (module), 182            mkResetSync (module), 338
mkDReg (module), 194                       mkRevertingVirtualReg (module), 195
mkDRegA (module), 194                      mkRWire (RWire module), 167
mkDRegU (module), 194                      mkSizedBRAMFIFO (module), 198
mkDualRam (module), 330                    mkSizedBRAMFIFOF (module), 198
mkDWire (module), 168                      mkSizedFIFO (module), 182
mkFeedLFSR(module), 269                    mkSizedFIFO (FIFO function), 86
mkFIFO (module), 181                       mkSizedFIFOF (module), 182
mkFIFO (FIFO function), 86                 mkSizedFIFOF (FIFOF function), 86
mkFIFO1 (module), 181                      mkStickyArbiter (module), 274
mkFIFOCount (module), 190                  mkSyncBit (module), 319
mkFIFOF (module), 181                      mkSyncBit05 (module), 321
mkFIFOF (FIFOF function), 86               mkSyncBit05FromCC (module), 322
mkFIFOF1 (module), 181                     mkSyncBit05ToCC (module), 322
mkFIFOLevel (module), 189                  mkSyncBit1 (module), 321
mkFSM, 254                                 mkSyncBit15 (module), 320
mkFSMServer, 258                           mkSyncBit15FromCC (module), 320
mkFSMWithPred, 254                         mkSyncBit15ToCC (module), 320
mkGatedClock (module), 312                 mkSyncBit1FromCC (module), 321
mkGatedClockDivider (module), 316          mkSyncBit1ToCC (module), 321
mkGateClockFromCC (module), 312            mkSyncBitFromCC (module), 319
mkGatedClockInverter (module), 316         mkSyncBitToCC (module), 320
mkGDepthParamFIFOF (module), 182           mkSyncBRAM (module), 196
mkGenericRandomizer (module), 272          mkSyncBRAMFIFO (module), 198
mkGetCPut (function), 268                  mkSyncBRAMFIFOFromCC (module), 198
mkGFIFOCount (module), 190                 mkSyncBRAMFIFOToCC (module), 198
mkGFIFOF (module), 181                     mkSyncBRAMLoadEither (module), 197
mkGFIFOF1 (module), 182                    mkSyncFIFO (module), 328
mkGFIFOLevel (module), 190                 mkSyncFIFOCount (module), 191
mkGLFIFOF (module), 182                    mkSyncFIFOFromCC (module), 329
mkGPFIFO (GetPut module), 262              mkSyncFIFOFromCCFull (module), 330
mkGPFIFO1 (GetPut module), 262             mkSyncFIFOFull (module), 329
mkGPSizedFIFO (GetPut module), 262         mkSyncFIFOLevel (module), 190
mkGrayCounter (module), 275                mkSyncFIFOToCC (module), 329
mkGSizedFIFOF (module), 182                mkSyncFIFOToCCFull (module), 330
mkInitialReset (module), 338               mkSyncFIFOToFast (module), 332
mkLFIFO (module), 182                      mkSyncFIFOToSlow (module), 332
mkLFIFOF (module), 182                     mkSyncHandshake (module), 324
mkNullCrossingWire (module), 332           mkSyncHandshakeFromCC (module), 324
mkOnce, 254                                mkSyncHandshakeToCC (module), 325
mkPulseWire (module), 169                  mkSyncPulse (module), 323
mkPulseWireOR (module), 169                mkSyncPulseFromCC (module), 324
mkReg (Reg function), 85, 165              mkSyncPulseToCC (module), 324
mkRegA (Reg function), 165                 mkSyncReg (module), 326
mkRegFile (RegFile module), 176            mkSyncRegFromCC (module), 326
mkRegFileFull (RegFile module), 176        mkSyncRegToCC (module), 327
mkRegFileFullFile (RegFileLoad function),  mkSyncRegToFast (module), 332
                                           mkSyncReset (module), 336
            177                            mkSyncResetFromCR (module), 336
mkRegFileLoad (RegFileLoad function), 177  mkSyncRegToSlow (module), 332
mkRegU (Reg function), 85, 165             mkTLMRam (module), 356
mkReset (module), 338                      mkTLMRandomizer (module), 356
mkResetEither (module), 340                mkTLMReadWriteRam (module), 356
mkResetInverter (module), 340

382              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

mkTLMReducer (module), 356                 output_clock(BVI import statement), 130
mkTLMSource (module), 356                  output_reset(BVI import statement), 133
mkTriState, 292                            overloading groups, see type classes
mkUGDepthParamFIFOF (module), 182          overloading, of types, 114
mkUGFIFOF (module), 181                    OVLAssertions (package), 294
mkUGFIFOF1 (module), 181
mkUGLFIFOF (module), 182                   pack (Bits type class overloaded function),
mkUGSizedFIFOF (module), 182                           118, 145
mkUngatedClock (module), 312
mkUngatedClockMux (module), 315            package, 18
mkUngatedClockSelect (module), 315         package (keyword), 18
mkUniqueWrappers (UniqueWrappers module),  parameter, 28
                                           parameter(BVI import statement), 125
            280                            parity (function), 173
mkWire (module), 167                       path(BVI import statement), 135
mkZBus (function), 294                     pattern matching, 77
mkZBusBuffer (function), 293
mod (Integer function), 155                      error, 80
module                                           in assignment statements, 82
                                                 in case expressions, 80
      deﬁnition of, 27                           in case statements, 79
      instantiation, 29                          in conditional expressions, 81
ModuleCollect (package), 341                     in if statements, 81
ModuleCollect (type), 342                        in methods, 82
modules                                          in rules, 81
      deﬁnition of, 23                     patterns, 77
      module (keyword), 28                 peekGet (GetPut function), 263
msb (function), 173                        pi (Real constant), 239
Mul (type provisos), 22, 163               polymorphism, 20
mutually_exclusive (attribute), 103        port(BVI import statement), 126
MuxClockIfc (interface), 314               port= (attribute), 96, 110
MuxRstIfc (interface), 335                 pow (Real function), 241
                                           preempts (attribute), 104
Nat (type), 154                            prefix= (attribute), 96
negate (Arith class method), 147           Prelude, see Standard Prelude
newVector (Vector function), 200           Probe (package), 288
Nil (List constructor), 223                provisos, 114, 163
nil (Vector function), 200                       brief description, 21
no_implicit_conditions (attribute), 99     PulseWire (interface), 169
noAction (empty action), 67, 161           Put (interface), 260
noClock (function), 310
noinline (attribute), 94                   quot (Integer function), 155
noReset (function), 310
nosplit (attribute), 104                   Randomizable (package), 271
not (Bool function), 156                   Randomize (interface), 271
                                           ReadOnly (interface), 170
OInt (package), 249                        readReg (Reg function), 165
OInt (type), 249                           readVReg (Vector function), 210
oneHotSelect (List function), 225          ready= (attribute), 95
operators                                  Real (package), 239
                                           Real (type), 156
      inﬁx, 64                             real (type), 156
      preﬁx, 64                            Real literals, 14
or (List function), 230                    RealLiteral (type class), 147
Ord (type class), 21, 114, 149             records, see struct
      UInt, Int type instances, 84         reduceAnd (BitReduction class method), 151
osc= (attribute), 108                      reduceNand (BitReduction class method), 151

                        c 2008 Bluespec, Inc. All rights reserved  383


Reference Guide                                             Bluespec SystemVerilog

reduceNor (BitReduction class method), 151   same_family(BVI import statement), 133
reduceOr (BitReduction class method), 151    sameFamily (function), 309
reduceXnor (BitReduction class method), 151  SAR (scheduling annotations), 45
reduceXor (BitReduction class method), 151   SB (scheduling annotations), 45
Reg (interface), 326                         SBR (scheduling annotations), 45
Reg (type), 85, 165                          scanl (List function), 237
RegFile (interface type), 176                scanl (Vector function), 217
RegFileLoad (package), 177                   scanr (List function), 236
register assignment, 54                      scanr (Vector function), 216
                                             schedule(BVI import statement), 133
      array element, 55                      scheduling annotations, 45
      partial, 55                            select (List function), 224
register writes, 54                          select (Vector function), 202
rem (Integer function), 155                  SelectClockIfc (interface), 314
replicate (List function), 223               send (PulseWire interface method), 169
replicate (Vector function), 200             Server (interface), 266
replicateM (List function), 239              shiftInAt0 (Vector function), 206
replicateM (Vector function), 220            shiftInAtN (Vector function), 206
RequestData (data structure), 352, 353       signedMul (function), 171
RequestDescriptor (data structure), 352      signExtend (BitExtend class method), 153
Reserved (type), 290                         signum (Arith class method), 147
Reset (type), 160, 308                       sin (Real function), 239
clear, 250                                   sinh (Real function), 240
reset= (attribute), 108                      size types, 20
reset_by=(attribute), 110
reset_prefix= (attribute), 106                     type classes for constraints, 22
‘resetall (compiler directive), 17           SizeOf (pseudo-function on types), 119, 164
resetOf (function), 310                      split (Bit function), 83, 154
result= (attribute), 96                      split (attribute), 104
reverse (List function), 228                 splitReal (Real function), 242
reverse (Vector function), 206               sqrt (Real function), 241
reverseBits (function), 173                  sscanl (List function), 237
RevertingVirtualReg (package), 195           sscanl (Vector function), 217
rJoin (Rules operator), 162                  sscanr (List function), 236
rJoinConflictFree (Rules operator), 162      sscanr (Vector function), 217
rJoinDescendingUrgency (Rules operator),     Standard Prelude, 19, 67, 83, 84, 115, 145
                                             start, 250
            162                              staticAssert, 287
rJoinExecutionOrder (Rules operator), 162    StmtFSM (package), 250
rJoinMutuallyExclusive (Rules operator),     strConcat (String concatenation operator),

            162                                          157
rJoinPreempts (Rules operator), 162          String (type), 84, 157
rotate (List function), 228                  String literals, 14
rotate (Vector function), 205                struct
rotateBitsBy (bit-vector function), 210
rotateBy (Vector function), 206                    type deﬁnition, 49
rotateR (List function), 228                 ’struct’,49
rotateR (Vector function), 206               structs
round (Real function), 241
rules, 35                                          member selection, 72
                                                   update, 53
      expression, 75                         sub (RegFile interface method), 176
      pattern matching in, 81                subinterfaces
Rules (type), 75, 162                              declaration of, 27
RWire, 167                                         deﬁnition of, 34
                                             SyncBitIfc (interface), 318
SA (scheduling annotations), 45              SyncFIFOCountIfc (interface), 189

384              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

SyncFIFOIfc (interface), 327                        member selection using dot notation, 73
SyncFIFOLevelIfc (interface), 188                   type deﬁnition, 49
SyncPulseIfc (interface), 323                       update, 53
synthesize                                    tail (List function), 225
                                              tail (Vector function), 203
      modules, 38                             take (List function), 225
synthesize (attribute), 94                    take (Vector function), 203
system functions, 87                          takeAt (Vector function), 204
                                              takeWhile (List function), 226
      $bitstoreal, 93                         takeWhileRev (List function), 226
      $realtobits, 93                         tan (Real function), 240
      $stime, 92                              tanh (Real function), 240
      $test$plusargs, 93                      TDiv (type functions), 164
      $time, 92                               TExp (type functions), 164
system tasks, 87                              TLM (package), 352
      $display, 87                            TLM.defines, 354
      $displayb, 87                           TLM_STD_TYPES, 354
      $displayh, 87                           TLM_TYPE, 354
      $displayo, 87                           TLM_TYPE_PRMS, 354
      $dumpoff, 92                            TLMReadWriteRecvIFC (interface), 356
      $dumpon, 92                             TLMReadWriteSendIFC (interface), 356
      $dumpvars, 92                           TLMRecvIFC (interface), 354
      $fclose, 89                             TLMRequest (data structure), 352
      $fdisplay, 90                           TLMResponse (data structure), 353
      $fdisplayb, 90                          TLMSendIFC (interface), 354
      $fdisplayh, 90                          TLMTransformIFC (interface), 356
      $fdisplayo, 90                          TLog (type functions), 164
      $fflush, 92                             TMul (type functions), 164
      $fgetc, 91                              toGet (function), 260
      $finish, 92                             toList (Vector function), 222
      $fopen, 89                              toPut (function), 260
      $fwrite, 90                             toVector (Vector function), 222
      $fwriteb, 90                            Transactors, 366
      $fwriteh, 90                            transpose (List function), 228
      $fwriteo, 90                            transpose (Vector function), 206
      $sformat, 91                            transposeLN (Vector function), 207
      $sformatAV, 91                          TriState (interface), 291
      $stop, 92                               TriState (package), 291
      $swrite, 91                             True (Bool constant), 156
      $swriteAV, 91                           trunc (Real function), 241
      $swriteb, 91                            truncate (BitExtend class method), 153
      $swritebAV, 91                          truncateLSB (function), 173
      $swriteh, 91                            TSub (type functions), 164
      $swritehAV, 91                          tuples
      $swriteo, 91                                  expressions, 84, 159
      $swriteoAV, 91                                patterns, 85
      $ungetc, 91                                   selecting components, 84, 160
      $write, 87                                    type deﬁnition, 84, 158
      $writeb, 87                             type assertions
      $writeh, 87                                   static, 71
      $writeo, 87                             type classes, 114, 145
                                              type declaration, 20
TAdd (type functions), 164                    type variables, 20
’tagged’,see union                            typedef (keyword), 46
tagged union

      member selection, see pattern matching

                        c 2008 Bluespec, Inc. All rights reserved  385


Reference Guide                                             Bluespec SystemVerilog

types, 20                                          zeroExtend (BitExtend class method), 153
      parameterized, 20                            zip (List function), 230
      polymorphic, 20                              zip (Vector function), 210
                                                   zip3 (List function), 231
UInt (type), 84, 154                               zip3 (Vector function), 210
‘undef (compiler directive), 17                    zip4 (List function), 231
underscore, see                                    zip4 (Vector function), 211
’union’,49                                         zipAny (Vector function), 211
union tagged                                       zipWith (List function), 232
                                                   zipWith (Vector function), 212
      type deﬁnition, 49                           zipWith3 (List function), 232
unpack (converting sized integer literals to spe-  zipWith3 (Vector function), 213
                                                   zipWith3M (List function), 238
            ciﬁc types), 14                        zipWith3M (Vector function), 219
unpack (Bits type class overloaded function),      zipWith4 (List function), 232
                                                   zipWithAny (Vector function), 212
            118, 145                               zipWithAny3 (Vector function), 213
unsignedMul (function), 172                        zipWithM (List function), 238
unzip (List function), 231                         zipWithM (Vector function), 219
unzip (Vector function), 211
upd (RegFile interface method), 176
update (List function), 224
update (Vector function), 202
upto (List function), 223

Valid
      tagged union member ofMaybe type, 51

Valid (type constructor), 158
valueOf (pseudo-function of size types), 22,

            164
valueof (pseudo-function of size types), 164
variable assignment, 52
variable declaration, 52
variable initialization, 52
variables, 52
Vector, 199
vectorToArray (Vector function), 222
void (type, in tagged unions), 49

warning (compilation message), 171
wget (RWire interface method), 167
when (function), 174
while (function), 174
Wire (interface), 167
Wrapper (interface type), 280
writeReg (Reg function), 165
writeVReg (Vector function), 210
wset (RWire interface method), 167

Xilinx
      BRAM (package), 196
      BRAMFIFO (package), 197
      GrayCounter (package), 274

ZBus (package), 292
ZBusBusIFC (interface), 293
ZBusClientIFC (interface), 293
ZBusDualIFC (interface), 292

386              c 2008 Bluespec, Inc. All rights reserved


Function and Module by Package

AHB                                           mkGatedClockDivider, 316
      mkAHBBus, 375                           mkGatedClockFromCC, 312
      mkAHBMaster, 374                        mkGatedClockInverter, 316
      mkAHBMonitor, 375                       mkInitialReset, 338
      mkAHBSlave, 374                         mkNullCrossingWire, 332
                                              mkReset, 338
AXI                                           mkResetEither, 340
      mkAxiMonitor, 369                       mkResetInverter, 340
      mkAxiRdBus, 368                         mkResetMux, 339
      mkAxiRdMaster, 367                      mkResetSync, 338
      mkAxiRdSlave, 368                       mkSyncBit, 319
      mkAxiWrBus, 368                         mkSyncBit05, 321
      mkAxiWrMaster, 367                      mkSyncBit05FromCC, 322
      mkAxiWrSlave, 368                       mkSyncBit05ToCC, 322
                                              mkSyncBit1, 321
BRAM                                          mkSyncBit15, 320
      mkBRAM, 196                             mkSyncBit15FromCC, 320
      mkSyncBRAM, 196                         mkSyncBit15ToCC, 320
      mkSyncBRAMLoadEither, 197               mkSyncBit1FromCC, 321
                                              mkSyncBit1ToCC, 321
BRAMFIFO                                      mkSyncBitFromCC, 319
      mkSizedBRAMFIFO, 198                    mkSyncBitToCC, 320
      mkSizedBRAMFIFOF, 198                   mkSyncFIFO, 328
      mkSyncBRAMFIFO, 198                     mkSyncFIFOFromCC, 329
      mkSyncBRAMFIFOFromCC, 198               mkSyncFIFOFromCCFull, 330
      mkSyncBRAMFIFOToCC, 198                 mkSyncFIFOFull, 329
                                              mkSyncFIFOToCC, 329
CBus                                          mkSyncFIFOToCCFull, 330
      collectCBusIFC, 346                     mkSyncFIFOToFast, 332
      exposeCBusIFC, 346                      mkSyncFIFOToSlow, 332
      mkCBRegFile, 347                        mkSyncHandshake, 324
      mkCBRegR, 346                           mkSyncHandshakeFromCC, 324
      mkCBRegRC, 347                          mkSyncHandshakeToCC, 325
      mkCBRegRW, 347                          mkSyncPulse, 323
      mkCBRegW, 347                           mkSyncPulseFromCC, 324
                                              mkSyncPulseToCC, 324
Clocks                                        mkSyncReg, 326
      clockOf, 309                            mkSyncRegFromCC, 326
      exposeCurrentClock, 309                 mkSyncRegToCC, 327
      exposeCurrentReset, 309                 mkSyncRegToFast, 332
      isAncestor, 309                         mkSyncRegToSlow, 332
      mkAbsoluteClock, 313                    mkSyncReset, 336
      mkAbsoluteClockFull, 313                mkSyncResetFromCR, 336
      mkAsyncReset, 336                       mkUngatedClock, 312
      mkAsyncResetFromCR, 336                 mkUngatedClockMux, 315
      mkClock, 311                            mkUngatedClockSelect, 315
      mkClockDivider, 316                     noClock, 310
      mkClockDividerOﬀset, 316                noReset, 310
      mkClockInverter, 316                    resetOf, 310
      mkClockMux, 314                         sameFamily, 309
      mkClockSelect, 315
      mkDualRam, 330             387
      mkGatedClock, 312


Reference Guide                                             Bluespec SystemVerilog

FIFO                            concat, 224
      ﬁfofToFifo, 183           cons, 223
      mkDepthParamFIFO, 182     drop, 226
      mkFIFO, 181               dropWhile, 226
      mkFIFO1, 181              dropWhileRev, 226
      mkLFIFO, 182              elem, 229
      mkSizedFIFO, 182          ﬁlter, 226
                                fold, 234
FIFOF                           foldl, 234
      mkDepthParamFIFOF, 182    foldl1, 234
      mkFIFOF, 181              foldr, 233
      mkFIFOF1, 181             foldr1, 234
      mkGDepthParamFIFOF, 182   head, 225
      mkGFIFOF, 181             init, 225
      mkGFIFOF1, 182            isNull, 229
      mkGLFIFOF, 182            joinActions, 234
      mkGSizedFIFOF, 182        joinRules, 235
      mkLFIFOF, 182             last, 225
      mkSizedFIFOF, 182         length, 229
      mkUGDepthParamFIFOF, 182  map, 231
      mkUGFIFO1, 181            mapAccumL, 237
      mkUGFIFOF, 181            mapAccumR, 237
      mkUGLFIFOF, 182           mapM, 238
      mkUGSizedFIFOF, 182       mapM_, 238
                                mapPairs, 235
FIFOLevel                       oneHotSelect, 225
      mkFIFOCount, 190          or, 230
      mkFIFOLevel, 189          replicate, 223
      mkGFIFOCount, 190         replicateM, 239
      mkGFIFOLevel, 190         reverse, 228
      mkSyncFIFOCount, 191      rotate, 228
      mkSyncFIFOLevel, 190      rotateR, 228
                                scanl, 237
GetPut                          scanr, 236
      ﬁfoToGet, 263             select, 224
      ﬁfoToPut, 263             sscanl, 237
      mkGPFIFO, 262             sscanr, 236
      mkGPFIFO1, 262            tail, 225
      mkGPSizedFIFO, 262        take, 225
      peekGet, 263              takeWhile, 226
      toGet, 260                takeWhileRev, 226
      toPut, 260                transpose, 228
                                unzip, 231
Gray                            update, 224
      grayDecode, 276           upto, 223
      grayDecr, 277             zip, 230
      grayEncode, 276           zip3, 231
      grayIncr, 277             zip4, 231
      grayIncrDecr, 276         zipWith, 232
                                zipWith3, 232
GrayCounter                     zipWith3M, 238
      mkGrayCounter, 275        zipWith4, 232
                                zipWithM, 238
List
      all, 229
      and, 230
      any, 229
      append, 223

388              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                             Reference Guide

OVLAssertions                              ˆ, 150, 151
      bsv assert always, 299               ˆ˜, 150, 151
      bsv assert always on edge, 299       ˜, 150, 151
      bsv assert change, 299               ˜|, 151
      bsv assert cycle sequence, 299       ˜ˆ, 150, 151
      bsv assert decrement, 300            abs, 147, 171
      bsv assert delta, 300                addRules, 162
      bsv assert even parity, 300          asReg, 165
      bsv assert ﬁfo index, 300            compilerVersion, 174
      bsv assert frame, 300                compose, 172
      bsv assert handshake, 301            composeM, 172
      bsv assert implication, 301          constFn, 172
      bsv assert increment, 301            countOnes, 173
      bsv assert never, 301                countZerosLSB, 173
      bsv assert never unknown, 302        countZerosMSB, 173
      bsv assert never unknown async, 302  date, 175
      bsv assert next, 302                 div, 155
      bsv assert no overﬂow, 302           exp, 147
      bsv assert no transition, 303        extend, 153
      bsv assert no underﬂow, 303          ﬂip, 172
      bsv assert odd parity, 303           fromInteger, 146
      bsv assert one cold, 303             fromMaybe, 158
      bsv assert one hot, 304              fromReal, 147
      bsv assert proposition, 304          genC, 174
      bsv assert quiescent state, 304      genVerilog, 174
      bsv assert range, 304                id, 172
      bsv assert time, 305                 invert, 150
      bsv assert transition, 305           isValid, 158
      bsv assert unchange, 305             log, 147
      bsv assert width, 305                log10, 147
      bsv assert win change, 306           log2, 147
      bsv assert win unchange, 306         logb, 147
      bsv assert window, 306               max, 171
      bsv assert zero one hot, 306         maxBound, 150
                                           min, 171
Prelude                                    minBound, 150
      !=, 146                              mkBypassWire, 168
      &lt;&lt;, 150                              mkDWire, 168
      &gt;&gt;, 150                              mkPulseWire, 169
      |, 150, 151                          mkPulseWireOR, 169
      *, 147                               mkReg, 165
      **, 147                              mkRegA, 165
      +, 147, 157                          mkRegU, 165
      -, 147                               mkRWire, 167
      /, 147                               mkWire, 167
      &lt;, 149                               mod, 155
      &lt;=, 149                              msb, 173
      ==, 146                              negate, 147
      &gt;, 149                               not, 156
      &gt;=, 149                              pack, 145
      $bitstoreal, 157                     parity, 173
      $realtobits, 157                     quot, 155
      %, 147                               readReg, 165
      &amp;, 150, 151                          reduceAnd, 151

                        c 2008 Bluespec, Inc. All rights reserved  389


Reference Guide                                             Bluespec SystemVerilog

      reduceNand, 151                    tanh, 240
      reduceNor, 151                     trunc, 241
      reduceOr, 151
      reduceXNor, 151              StmtFSM
      reduceXor, 151                     await, 254
      rem, 155                           callServer, 258
      reverseBits, 173                   delay, 254
      rJoin, 162                         mkAutoFSM, 254
      rJoinConﬂictFree, 162              mkFSM, 254
      rJoinDescendingUrgency, 162        mkFSMServer, 258
      rJoinExecutionOrder, 162           mkFSMwithPred, 254
      rJoinMutuallyExclusive, 162        mkOnce, 254
      rJoinPreempts, 162
      signedMul, 171               TLM
      signExtend, 153                    mkTLMRam, 356
      signum, 147                        mkTLMRandomizer, 356
      SizeOf, 164                        mkTLMReadWriteRam, 356
      split, 154                         mkTLMReducer, 356
      strConcat, 157                     mkTLMSource, 356
      TAdd, 164
      TDiv, 164                    Vector, 222
      TExp, 164                          all, 208
      TLog, 164                          any, 208
      TMul, 164                          append, 200
      truncate, 153                      arrayToVector, 222
      truncateLSB, 173                   concat, 201
      TSub, 164                          cons, 200
      unpack, 145                        countElem, 208
      unsignedMul, 172                   countIf, 208
      valueOf, 164                       countOnesAlt, 210
      when, 174                          drop, 204
      while, 174                         elem, 207
      writeReg, 165                      ﬁndElem, 208
      zeroExtend, 153                    ﬁndIndex, 208
                                         fold, 215
Real                                     foldl, 214
      acosh, 240                         foldl1, 214
      asinh, 240                         foldr, 214
      atan2, 241                         foldr1, 214
      atanh, 240                         genVector, 200
      ceil, 241                          genWith, 200
      cos, 240                           genWithM, 220
      cosh, 240                          head, 203
      decodeReal, 242                    init, 203
      ﬂoor, 242                          joinActions, 215
      isInﬁnite, 242                     joinRules, 215
      isNegativeZero, 242                last, 203
      pow, 241                           map, 212
      round, 241                         mapAccumL, 218
      sin, 239                           mapAccumR, 218
      sinh, 240                          mapM, 219
      splitReal, 242                    mapM_, 219
      sqrt, 241                          mapPairs, 215
      tan, 240                           newVector, 200
                                         nil, 200

390              c 2008 Bluespec, Inc. All rights reserved


Bluespec SystemVerilog                                               Reference Guide

      readVReg, 210
      replicate, 200
      replicateM, 220
      reverse, 206
      rotate, 205
      rotateBitsBy, 210
      rotateBy, 206
      rotateR, 206
      scanl, 217
      scanr, 216
      select, 202
      shiftInAt0, 206
      shiftInAtN, 206
      sscanl, 217
      sscanr, 217
      tail, 203
      take, 203
      takeAt, 204
      toList, 222
      transpose, 206
      transposeLN, 207
      unzip, 211
      update, 202
      vectorToArray, 222
      writeVReg, 210
      zip, 210
      zip3, 210
      zip4, 211
      zipAny, 211
      zipWith, 212
      zipWith3, 213
      zipWith3M, 219
      zipWithAny, 212
      zipWithAny3, 213
      zipWithM, 219

                          c 2008 Bluespec, Inc. All rights reserved  391


Packages provided as BSV source code

AHB, 369
AHBBus, 369
AHBDeﬁnes, 369
AHBMaster, 369
AHBMonitor, 369
AHBPC, 369
AHBSlave, 369
Arbiter, 273
AXI, 359
AxiDeﬁnes, 359
AxiMaster, 359
AxiMonitor, 359
AxiPC, 359
AxiRam, 359
AxiRdBus, 359
AxiSlave, 359
AxiWrBus, 359
BRAMFIFO, 197
CBus, 345
FShow, 283
Gray, 276
GrayCounter, 274
Randomizable, 271
TLM, 352
TLMCBusAdapter, 352
TLMDeﬁnes, 352
TLMRam, 352
TLMReadWriteRam, 352
TLMReduce, 352
TLMUtils, 352

                                                               392
</Text>
        </Document>
        <Document ID="E7F7659E-3663-4DCA-B04F-CAD3A610E424">
            <Title>TLA+ / PlusCal</Title>
        </Document>
        <Document ID="E9819D59-9CC1-4FB5-8CE8-113BFBF40C10">
            <Title>Bluespec SystemVerilog Reference Card</Title>
            <Text>Bluespec SystemVerilog Reference Card                                                 Interface Declaration                            Action Method Definition

                            Revision: 11/07                      interface ifc_name;                                    method Action method_name ({parameter})
                                                                    method declarations                                    [if (method_predicate)];
bold       as is                                                    subinterface declarations                                        method body statements
italic
{ }        user identifier being declared                        endinterface[:ifc_name]                                endmethod [:method_name]
[ ]        repeated                                              interface ifc_name #({type Type_name});
           optional                                                                                                                ActionValue Method Definition
                                                                    method declarations
                        Capitalization                              subinterface declarations                           method ActionValue method_name({parameter})
                                                                 endinterface[:ifc_name]                                   [if (method_predicate)];
Foo: Type names, Typeclass names, Interface names, Enum labels,  example:                                                            method body statements
Tagged union labels, Package names                                                                                                   return statement
foo: bit[..], int, module names, instance names, all variables,       interface MyIfc#(t) ;
all type variables, rule names                                              method Action tick() ;                      endmethod [:method_name]
                                                                            interface FIFO#(t) inbuffer ;
                            Package                                                                                           Variable Declaration and Initialization
                                                                      endinterface:MyIfc
package Package_name ;                                                                                                  Type {variable_name [= expression ]};
    typedef statements                                                                 Method Declaration               example:
    import statements
    interface declarations                                       method Type method_name [(Type argument)] ;                 Integer x = 16, y = 32;
    module declarations                                                                                                      int a[20], b[40];
                                                                                        Module Definition                    Int#(5) xs[2][4] = {{1,2,3,4},
endpackage [: Package_name]
                                                                 module module_name [# ({parameter})]                                                            {5,6,7,8}};
                      Import Statement                                ({Ifc_type ifc_name*})[provisos] ;
                                                                              module instantiations                                       Variable Assignment
import Package_name :: * ;                                                    variable declaration and initializations
                                                                              rules                                     variable_name = expression ;
Bit#(n)    Predefined Data Types                                              interface/method definitions              example:

Int#(n)    // signed                                             endmodule [:module_name]                                   x = 23 ;
                                                                 * ifc_name optional if only one ifc                        b = foo.bar(x);
Uint#(n)   // unsigned
                                                                                      Module Instantiation                       ActionValue Assignment Statement
Integer    // static elaboration only
                                                                 Ifc_type ifc_name &lt;­ module_name({parameter});         Special &lt;­ notation used to perform the action and return the
Bool                                                             Ifc_type ifc_name &lt;­ module_name([{parameter,}         value
                                                                                                                        type identifier &lt;­ expression ;
String                                                                 clocked_by clock_name,                           identifier &lt;­ expression ;
                                                                       reset_by reset_name]);
Action                                                           example:                                                  Implicit Type Declaration and Initialization
                                                                       Reg#(Time32) state &lt;­ mkReg(0);
ActionValue#(t)                                                                                                         let identifier = expression ;
                                                                                                Rules
Rules                                                                                                                               if expression is actionvalue method
                                                                 rule rule_name [rule_predicate] ;
Tuple2#(t1, t2) ... Tuple7#(t1,..., t7)                             action statements                                   let identifier &lt;­ expression ;
                                                                                                                        example:
int        // Int#(32)                                           endrule[: rule_name]
                                                                 rules [: rules_name]                                       let n = valueof(Buffsize);
Nat        // Bit#(32)                                                                                                      let z &lt;­ rndm.get;
                                                                    rule
Maybe#(t)                                                           variable declaration or variable assignment                        Register Read and Write
                                                                 endrules[: rules_name]
Type_name        Type Definition                                                                                        register_name &lt;= expression ;
                                                                                            Action Block                example:
Type_name#(type_variable)            // polymorphic type
                                                                 action [: action_name] ;                                    state &lt;= state + 1 ; // same as: state._write (state.read() + 1)
                        Type Synonym                                  action statements
                                                                                                                                               Enumeration
typedef type Type_name[#({type type_var})];                      endaction [:action_name]
                                                                                                                        typedef enum {{Elements}} Type_name
example:                                                                            Value Method Definition                  [deriving (Typeclass)];
typedef Bit#(8) Byte;
typedef Tuple3#(a, a, a) Triple#(type a);                        method Type method_name ({parameter})                  example:
                                                                    [if (method_predicate)];                               typedef enum {Red, White, Blue} Color
                                                                              method body statements                                     deriving (Eq, Bits);
                                                                              return statement

                                                                 endmethod [:method_name]


                             Structure                                                      Attributes                                     importBVI Statements

             (struct value contains member1 and member2, etc.)  (* {attribute [= expression ]}*)                      parameter parameter_name = expression ;
typedef struct {Type member1;...;Type memberN}                                                                        port port_name = expression ;
                                                                                 Module Attributes (top­level only)   default_clock clock_name
    Type_name [#{[numeric] type type_variable}]
                          [deriving (Typeclass)];               synthesize                                                  [(port_name, port_name)][= expression];
                                                                RST_N = “string”                                      input_clock clock_name [(port_name,
example:                                                        CLK = “string”
    typedef struct {Int x; Int y;} Coord                        always_ready [= “interface_method”]                         port_name)] = expression;
             deriving (Eq, Bits);                               always_enabled [= “interface_method”]                 output_clock clock_name
                                                                descending urgency = “{rule_names}”
Declaration and initialization of a structure variable          preempts = “{rule_names, (list_rule_names)]}”               (port_name [,port_name]);
Type variable_name = Type{member:expression}                    doc = “string“                                        no_reset;
                                                                                                                      default_reset clock_name ([port_name])
    Coord c1 = Coord{x:1, y:foo};                                                          Method Attributes
Update of a structure variable                                                                                              [= expression];
                                                                always_ready [= “interface_method”]                   input_reset clock_name
    c1.x = c1.x + 5 ;                                           always_enabled [= “interface_method”]
Structure member selection                                      ready = “string”                                            ([port_name]) = expression;
                                                                enable = “string”                                     output_reset clock_name ( port_name );
     xposition = c1.x ;                                         result = “string”                                     ancestor ( clock1, clock2 );
                                                                prefix = “string”                                     same_family ( clock1, clock2 );
                            Tagged Union                        port = “string”                                       method [output_port] method_name

                 (union value contains member1 or member2)                                Interface Attributes              ({input_ports}) [enable enable_port]
typedef union tagged {type Member1; ... ;                                                                                   [ready ready_port][clocked_by
                                                                always_ready [= “interface_method”]                   clock_name] [reset_by clock_name];
     type MemberN;} Type_name [#...[numeric]                    always_enabled [= “interface_method”]                 schedule ({method_name}) operator
     type type_variable];                                                                                                   ({method_name});
example:                                                                        Function Attributes (top­level only)
     typedef union tagged { void Invalid;                                                                                          operators are CF, SB, SBR, and C
                                                                noinline                                              path (port_name1, port_name2) ;
                                int Valid; } MaybeInt;
                                                                                             Rule Attributes                              Defined Interfaces
Declaration and initialization of a tagged union
                                                                fire_when_enabled                                                                      Reg
Type variable_name = Member expression ;                        no_implicit_conditions
     MaybeInt x = tagged Valid 5 ;                              descending_urgency = “{rule_names}”                   interface Reg #(type a_type);
                                                                preempts “{rule_names, [(list_rule_names)]}”              method Action _write(a_type x1);
                       Pattern Matching                                                                                   method a_type _read();
                                                                $display   System Tasks and Functions
                              Tagged Union                      $write                                                endinterface: Reg
                                                                $fopen                       $finish
tagged Member [ pattern ]                                       $fdisplay                    $stop                                                 PulseWire
                                                                $fwrite                      $dumpon
                                 Structure                      $fgetc                       $dumpoff                 interface PulseWire;
                                                                $fflush                      $dumpvars                         method Action send();
tagged Type [ member:pattern ]                                  $fclose                      $test$plusargs                    method Bool _read();
                                                                $ungetc                      $time
                                   Tuple                                                     $stime                   endinterface

tagged {pattern, pattern}                                                           Importing C Functions                                             Wire

                     Pattern Matching Examples                  import “BDPI” [c_function_name =] function            typedef Reg#(a_type) Wire#(type a_type);

Pattern matching in a case statement                               Return_type function_name [{argument}])                                Defined Modules
     case (f(a)) matches                                           [provisos] ;
          tagged Valid .x : return x;                                                                                                                  Reg
          tagged Invalid : return 0;                                             Importing Verilog Modules
     endcase                                                                                                          module mkReg#(a_type resetval)
                                                                import “BVI” [verilog_module_name] =                  (Reg#(a_type));
Pattern matching in an if statement                                module [[Type]] module_name [# ({parameter})]      module mkRegU(Reg#(a_type));
     if (x matches tagged Valid .n &amp;&amp;&amp; n &gt; 5...)                   ({Ifc_type ifc_name}) [provisos] ;                 module mkRegA#(a_type
                                                                             module statements                        resetval)(Reg#(a_type));
            Pattern Matching Assignment Statement                            importBVI statements
                                                                                                                                                      Wire
match pattern = expression ;                                    endmodule [: module_name]
example:                                                                                                              module mkWire(Wire#(a_type));

     Tuple2#(Bits(32) x, Bool y) a_tuple;                                                                                                        BypassWire
     match {.a, .b} = a_tuple ;
                                                                                                                      module mkBypassWire(Wire#(a_type));
                      Function Definition
                                                                                                                                                     DWire
function type function_name ([{arguments}])
     [provisos];                                                                                                      module mkDWire#(a_type defaultval)
             function body statements                                                                                              (Wire#(a_type));
             return statement
                                                                                                                                                   PulseWire
endfunction [: function_name]
                                                                                                                      module mkPulseWire(PulseWire);


                        Library Packages                                                   BSV Example

                  FIFOFs (import FIFOF::*; )                     package Counter ;

                          see LRM for additional FIFOs           interface Counter#(type count_t);
                                                                        method count_t read();
Interface                                                               method Action load(count_t newval);
                                                                        method Action increment();
interface FIFOF #(type a_type);                                         method Action decrement();
       method Action enq(a_type x1);
       method Action deq();                                      endinterface
       method a_type first();
       method Bool notFull();                                    module mkCounter(Counter#(count_t))
       method Bool notEmpty();                                                 provisos(Arith#(count_t), Bits#(count_t,
       method Action clear();
                                                                 count_t_sz));
endinterface: FIFOF                                                     Reg#(count_t) value &lt;­ mkReg(0);

Modules                                                                 PulseWire increment_called &lt;­ mkPulseWire();
                                                                        PulseWire decrement_called &lt;­ mkPulseWire();
module mkFIFOF# (FIFO#(a_type)) ;
module mkFIFOF1#(FIFO#(a_type));                                        rule do_increment(increment_called &amp;&amp; !
module mkSizedFIFOF#(Integer n)(FIFO#(a_type)) ;                 decrement_called);
module mkLFIFOF#(FIFO#(a_type));
                                                                               value &lt;= value + 1;
                  Get/Put (import GetPut::*;)                           endrule
Interfaces                                                              rule do_decrement(!increment_called &amp;&amp;
                                                                 decrement_called);
interface Get#(type a_type);
       method ActionValue#(a_type) get();                                      value &lt;= value ­ 1;
                                                                        endrule
endinterface: Get
interface Put#(type a_type);                                            method count_t read();
                                                                               return value;
       method Action put(a_type x1);
endinterface: Put                                                       endmethod
                                                                        method Action load(count_t newval);
Type
                                                                               value &lt;= newval;
typedef Tuple2#( Get#(a_type), Put#(a_type) )                           endmethod
                              GetPut#(type a_type);                     method Action increment();

Connectable (import Connectable::*;)                                           increment_called.send();
Typeclass                                                               endmethod
                                                                        method Action decrement();
      typeclass Connectable#(type a , type b) ;
                                                                               decrement_called.send();
Module                                                                  endmethod
                                                                 endmodule
      mkConnection#(a x1, b x2) ;                                endpackage: Counter

          Client/Server (import ClientServer::*;)
Interfaces

      interface Client#(type req_type, type
      resp_type);

             interface Get#(req_type) request;
             interface Put#(resp_type) response;
      endinterface: Client
      interface Server#(type req_type, type
      resp_type);
             interface Put#(req_type) request;
             interface Get#(resp_type) response;
      endinterface: Server

Type

      typedef Tuple2#(Client#(req_type, resp_type),
      Server#(req_type,resp_type))

                  ClientServer#(type req_type, type resp_type);
</Text>
        </Document>
        <Document ID="E9DFC673-0455-4AE5-B50C-F041A71FD055">
            <Title>Pipelines</Title>
            <Text>Pipelines are just computations spread across time

a@1 = f(b@0);
c@2 = g(a@1);
d@3 = h(c@2);

etc</Text>
        </Document>
        <Document ID="EB3C32F0-B7B8-4E76-BB78-CCE91748C73E">
            <Title>Imperative, Functional, Temporal</Title>
            <Text>### Imperative vs. Functional vs. Temporal

If we are going to declare “temporal” programming to be something distinct from imperative and functional programming, we need some sort of orthogonal-ish classification to distinguish between them.

 - Imperative - State changes incrementally
 - Functional - State does not change
 - Temporal - State changes atomically

This is not a great classification, but it’s a start.
</Text>
        </Document>
        <Document ID="EF27D140-3AAF-4E62-B3C8-14C007DB793E">
            <Title>Why not resurrect synchronous programming?</Title>
        </Document>
        <Document ID="F2D19D6E-FC52-4558-8A05-C1103208396C">
            <Title>Changing Mental Models of Computation</Title>
            <Text>If it sounds like temporal programming should by definition be “easy”, I can assure you that it is not. A seasoned C programmer might be able to comprehend isolated snippets of Verilog, but going from there to understanding something like a DDR memory controller is a _huge_ mental leap.

This is part of why you hear FPGA &amp; ASIC developers say “Writing code in Verilog is _not_ like writing Quicksort - everything happens at once!” - true, but missing the point slightly. Quicksort makes intuitive sense in the imperative and functional paradigms, but attempting to write Quicksort in Verilog will quickly prove futile - while you may be able to produce something Quicksort-esque the result will almost certainly not be usable in actual hardware, as actual hardware has no notion of “recursion”.

Similarly, while you could write a memory controller in an imperative language that “bit-bangs” the control signals to a DDR chip, your implementation will be fundamentally and radically limited by the host processor - generating and responding to dozens of control signals and data wires within a handful of nanoseconds just isn’t something modern CPUs are designed for.

This isn’t to say that temporal ideas aren’t useful in imperative or functional languages, or vice versa - for example, having a mechanism to coordinate atomic state changes across objects can be hugely useful in implementing simulations. Similarly, being able to model a Verilog module’s sub-circuits as collections of pure functions can greatly improve the maintainability of the codebase.







### Branch Vs. Mux

Let’s look at two trivial C examples:

int result;
if (rand() &gt; 0) {
  result = expensive_computation_a(input);
}
else {
  result = expensive_computation_b(input);
}

int result = rand() &gt; 0 ? expensive_computation_a(input) : expensive_computation_b(input);


A software programmer looks at these examples and sees branching control flow - first we generate a random number, then we evaluate either computation A or B but never both. 

A hardware programmer sees a mux - first we evaluate _both_ computation A and B, and _then_ we look at the result of rand() to see which one to assign to “result”. To a hardware programmer the “expensive_computation” functions are _things_ - the circuit doing the computation occupies physical space on the chip, so if we want to do both A and B then we need room on the chip for both of them even if we only rarely use one.


“Phi” functions




A software developer who tries to read a large chunk of Verilog for the first time is in for a very, very steep learning curve - and it's not a syntax issue. Verilog _looks_ superficially like C but it doesn't _run_ like C, and the explanation that's often given to new devs is something along the lines of &quot;Hardware just doesn't work like that&quot;. Which is true, but it's missing the point - The learning curve isn't caused by the language, it's caused by thinking about the problem using the wrong programming paradigm.</Text>
        </Document>
        <Document ID="F2D2F625-535C-4D03-926A-12619309FCF1">
            <Title>Old Draft Stuff</Title>
        </Document>
        <Document ID="F8DE5DBA-DEB1-40C5-8F27-7DCB5C043ADF">
            <Title>Intro</Title>
            <Text>## #############################################################################
## Previous Work &amp; Prior Art

This list is not at all comprehensive, and I keep finding new variations on these ideas as I stumble across new keywords to plug into Google Scholar. If you know of a project or language that seems to be related to temporal programming, email me and I'll add them to this list.

Github search counts
   - Lustre 58 repos (but there are other overloads)
   - Esterel 4 repos
   - Signal - too overloaded
   - Blech - 8 from 2 users
   - Quartz - too overloaded
   - Statecharts - 53
   - SyncCharts - 0
   - JavaScript - 349576

</Text>
        </Document>
        <Document ID="F9972C18-850D-4A3B-B9A8-76C0CA3B2A41">
            <Title>Translating Temporal C to Verilog</Title>
            <Text>## Translating C to Verilog?

If you’re a veteran C programmer, I can virtually guarantee that you will not be able to write functional Verilog systems of any significant size until you sit down and internalize some temporal programming concepts.

Translating a C program into Verilog will almost never work, for the same reason that you can’t translate a chocolate chip cookie recipe into a chocolate chip cookie factory - the former is a set of instructions that a complex actor can perform to produce cookies in series, the latter is a collection of machines and conveyor belts that produce cookies in parallel.

It’s not impossible, however - it just requires that the C program be written in a more temporal style, one that will probably feel cumbersome and alien to procedural programmers at first.

In order to “write” a cookie factory in C, we need to describe our cookie recipe differently. In our factory, all the machines are running all the time.

We can imagine an initial version of our cookie factory that just replicates the steps in the recipe using a sequence of robots, each performing one step of the recipe. Robot A puts butter and sugar in a bowl and hands it off to robot B. Robot B creams the butter and sugar together and passes the bowl to robot C, etcetera etcetera.

This will work to a degree, but it doesn’t scale up well. 

 Instead of “cream together the butter and sugar”, we need to define a butter pipeline and a sugar pipeline 

We need to define a “cookie pipeline”.

For our butter pipeline, we want to turn on the pipe when we have bowls to fill, fill all the bowls with the right amount of butter as fast as possible, and then turn off the pipe. Same for sugar.




Right now our cookie factory is set up specifically for chocolate chip cookies, but as responsible factory owners we probably want to be able to produce other types of cookies as well. It would be nice if we could generalize our cookie factory to be able to handle oatmeal raisin cookies, snickerdoodles, and white chocolate macadamia nut cookies (one of my favorites).



Our fully-automated cookie factory consists of:

Various tubes or conveyors containing raw ingredients
Dispensing mechanisms that can place measured amounts of those ingredients into mixing containers



Some signals in our factory are “fast” - our dough dispenser might need a “dispense” signal that lasts exactly 0.3 seconds in order for our cookies to all be the same size.

Some signals are “slow” - cookies need to be removed from the oven when they’re done, but a few seconds delay isn’t disastrous.

Some signals only change infrequently, if ever - we might make chocolate chip cookies for a week, then oatmeal cookies for a week, then back to chocolate chip.


As you might have realized by now, while the “pipeline” is relatively simple, all the “control” logic is a pain to wire up and has to change every time we want to use a new recipe. It would make more sense if we could wire up all the “slow” control signals to a central computer and leave the machines on the factory floor solely responsible for the heavy lifting (and mixing, and baking) that needs to be parallelized.

And so in practice that’s what most factories/circuits/etcetera do - they define a “factory” full of machines and the connections to those machines, provide a way for an external “controller” to change the settings on the machines and start/stop them remotely, and provide feedback to the controller on the current state of each machine.




This analogy may sound ridiculous, but it’s actually not that far off conceptually from how real hardware works for things like AI accelerator chips.




Having sketched out our cookie factory, let’s try describing it using temporal programming style.

If the oven is on and the timer has beeped,
Turn the oven off


Even though these steps are written as a numbered list, they do _not_ 
Each of these steps is an _atomic_ action. We can’t say “stir for 5 minutes”, we have to say “if the ingredients are in the mixer and the timer is at 0, start the mixer. If the mixer is running and the timer reads 300 seconds, turn the mixer off and signal the next machine”.
Every action has to “flip a switch”



### If we want a language that is “parallel by default”, then lexical ordering _can’t_ be the sole arbiter of execution order.
</Text>
        </Document>
        <Document ID="FB6531A9-3DD9-4FC6-81B6-BC93E7248848">
            <Title>What do you mean, &quot;reboot&quot;?</Title>
            <Text>The ideas of synchronous programming are sound and made sense at the time, and the languages that grew from the initial research (Esterel, Lustre, Signal) are totally reasonable and not too painful to understand.

However, if you look at their uptake in the software industry they didn’t really catch on. Github contains a total of 4 repos that are tagged with “Esterel”, two of which are forks of the Columbia Esterel Compiler. StateCharts has 57 tagged repos, most related to the “XState” Javascript state machine library.

[defunct site list]

“When X happens, do Y”.

I think part of the reason that SP didn't become more popular is that the initial research focused too tightly on _how_ to do SP (in the form of new languages with new and somewhat unfamiliar semantics), at the expense of defining clearly _what_ synchronous programming is. That in turn created the impression that SP is something you can only do in synchronous programming languages, which is not at all correct - you can apply the “synchronous abstraction” to code written in any language, much as you can do functional programming in any language - it might be limited and awkward, but it doesn’t require completely replacing your current dev environment. If you've ever written a state machine or dealt with any sort of atomic transactions, then you've already done some form of synchronous programming even if you didn't know the name for it at the time.</Text>
        </Document>
        <Document ID="FC1AED8B-D2DD-4868-9724-3C23A70F1416">
            <Title>What defines a programming paradigm?</Title>
            <Text>## What defines a programming paradigm?

### It should provide a concise but abstract conceptual model

A good programming paradigm should be explainable in a few sentences and should provide an answer to the general question of “What is programming?” without referring to concrete details like language, syntax, or implementation.

For imperative programs, that would be Turing machines. For functional programming, lambda calculus. For temporal programming, recurrence relations

### It should be practical and useful

A good programming paradigm should be demonstrable using the tools we already have, even if those tools aren’t yet

### It should extend our ability to think about programming

If it’s worth calling a paradigm, it should be profound enough that it gives us new ways to think about and solve programming problems. It should add “new tools to the toolbox” that don’t exist in other paradigms.

    x' = f(x)

“Structural” and “Procedural” programming extended imperative programming by providing ways to simplify programs by clarifying control flow and allowing programs to be split into collections of sub-procedures. “Object-Oriented” programming extended that further by describing programs as collections of “things” that can perform “actions” at a higher level of abstraction.

Functional programming gave us an alternate definition of programming, one based on applying and composing functions (link to wikipedia) 

Temporal programming can be seen as a sort of “imperative programming rotated 90 degrees through time” - instead of modeling a program as a blob of data we call “state” that is incrementally modified by a sequence of actions over time, temporal programs consist of sequences of “states” placed at discrete points in time, each computed from the previous state in a single atomic action.

Pure temporal programs transform old states into new states using pure functions.

</Text>
        </Document>
        <Document ID="FF544CEA-60D9-49C4-A020-E33DC1509A6E">
            <Title>Temporal Programming Languages</Title>
        </Document>
    </Documents>
</SearchIndexes>
